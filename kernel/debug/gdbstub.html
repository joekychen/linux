<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › debug › gdbstub.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>gdbstub.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Kernel Debug Core</span>
<span class="cm"> *</span>
<span class="cm"> * Maintainer: Jason Wessel &lt;jason.wessel@windriver.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2000-2001 VERITAS Software Corporation.</span>
<span class="cm"> * Copyright (C) 2002-2004 Timesys Corporation</span>
<span class="cm"> * Copyright (C) 2003-2004 Amit S. Kale &lt;amitkale@linsyssoft.com&gt;</span>
<span class="cm"> * Copyright (C) 2004 Pavel Machek &lt;pavel@ucw.cz&gt;</span>
<span class="cm"> * Copyright (C) 2004-2006 Tom Rini &lt;trini@kernel.crashing.org&gt;</span>
<span class="cm"> * Copyright (C) 2004-2006 LinSysSoft Technologies Pvt. Ltd.</span>
<span class="cm"> * Copyright (C) 2005-2009 Wind River Systems, Inc.</span>
<span class="cm"> * Copyright (C) 2007 MontaVista Software, Inc.</span>
<span class="cm"> * Copyright (C) 2008 Red Hat, Inc., Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Contributors at various stages not listed above:</span>
<span class="cm"> *  Jason Wessel ( jason.wessel@windriver.com )</span>
<span class="cm"> *  George Anzinger &lt;george@mvista.com&gt;</span>
<span class="cm"> *  Anurekh Saxena (anurekh.saxena@timesys.com)</span>
<span class="cm"> *  Lake Stevens Instrument Division (Glenn Engel)</span>
<span class="cm"> *  Jim Kingdon, Cygnus Support.</span>
<span class="cm"> *</span>
<span class="cm"> * Original KGDB stub: David Grothe &lt;dave@gcom.com&gt;,</span>
<span class="cm"> * Tigran Aivazian &lt;tigran@sco.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is licensed under the terms of the GNU General Public License</span>
<span class="cm"> * version 2. This program is licensed &quot;as is&quot; without any warranty of any</span>
<span class="cm"> * kind, whether express or implied.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/kgdb.h&gt;</span>
<span class="cp">#include &lt;linux/kdb.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &quot;debug_core.h&quot;</span>

<span class="cp">#define KGDB_MAX_THREAD_QUERY 17</span>

<span class="cm">/* Our I/O buffers. */</span>
<span class="k">static</span> <span class="kt">char</span>			<span class="n">remcom_in_buffer</span><span class="p">[</span><span class="n">BUFMAX</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">char</span>			<span class="n">remcom_out_buffer</span><span class="p">[</span><span class="n">BUFMAX</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">gdbstub_use_prev_in_buf</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">gdbstub_prev_in_buf_pos</span><span class="p">;</span>

<span class="cm">/* Storage for the registers, in GDB format. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">gdb_regs</span><span class="p">[(</span><span class="n">NUMREGBYTES</span> <span class="o">+</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)];</span>

<span class="cm">/*</span>
<span class="cm"> * GDB remote protocol parser:</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_KGDB_KDB</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gdbstub_read_wait</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">gdbstub_use_prev_in_buf</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gdbstub_prev_in_buf_pos</span> <span class="o">&lt;</span> <span class="n">gdbstub_use_prev_in_buf</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">remcom_in_buffer</span><span class="p">[</span><span class="n">gdbstub_prev_in_buf_pos</span><span class="o">++</span><span class="p">];</span>
		<span class="k">else</span>
			<span class="n">gdbstub_use_prev_in_buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* poll any additional I/O interfaces that are defined */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">kdb_poll_funcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">kdb_poll_funcs</span><span class="p">[</span><span class="n">i</span><span class="p">]();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gdbstub_read_wait</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">read_char</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NO_POLL_CHAR</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">read_char</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cm">/* scan for the sequence $&lt;data&gt;#&lt;checksum&gt; */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_packet</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">checksum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">xmitcsum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Spin and wait around for the start character, ignore all</span>
<span class="cm">		 * other characters:</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">ch</span> <span class="o">=</span> <span class="p">(</span><span class="n">gdbstub_read_wait</span><span class="p">()))</span> <span class="o">!=</span> <span class="sc">&#39;$&#39;</span><span class="p">)</span>
			<span class="cm">/* nothing */</span><span class="p">;</span>

		<span class="n">kgdb_connected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">xmitcsum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * now, read until a # or end of buffer is found:</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">BUFMAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ch</span> <span class="o">=</span> <span class="n">gdbstub_read_wait</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;#&#39;</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">checksum</span> <span class="o">=</span> <span class="n">checksum</span> <span class="o">+</span> <span class="n">ch</span><span class="p">;</span>
			<span class="n">buffer</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;#&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xmitcsum</span> <span class="o">=</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="n">gdbstub_read_wait</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">xmitcsum</span> <span class="o">+=</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="n">gdbstub_read_wait</span><span class="p">());</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">checksum</span> <span class="o">!=</span> <span class="n">xmitcsum</span><span class="p">)</span>
				<span class="cm">/* failed checksum */</span>
				<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">write_char</span><span class="p">(</span><span class="sc">&#39;-&#39;</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="cm">/* successful transfer */</span>
				<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">write_char</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">)</span>
				<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">buffer</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">checksum</span> <span class="o">!=</span> <span class="n">xmitcsum</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send the packet in buffer.</span>
<span class="cm"> * Check for gdb connection if asked for.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_packet</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">checksum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * $&lt;packet info&gt;#&lt;checksum&gt;.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">write_char</span><span class="p">(</span><span class="sc">&#39;$&#39;</span><span class="p">);</span>
		<span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">((</span><span class="n">ch</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">count</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">write_char</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
			<span class="n">checksum</span> <span class="o">+=</span> <span class="n">ch</span><span class="p">;</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">write_char</span><span class="p">(</span><span class="sc">&#39;#&#39;</span><span class="p">);</span>
		<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">write_char</span><span class="p">(</span><span class="n">hex_asc_hi</span><span class="p">(</span><span class="n">checksum</span><span class="p">));</span>
		<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">write_char</span><span class="p">(</span><span class="n">hex_asc_lo</span><span class="p">(</span><span class="n">checksum</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">)</span>
			<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">();</span>

		<span class="cm">/* Now see what we get in reply. */</span>
		<span class="n">ch</span> <span class="o">=</span> <span class="n">gdbstub_read_wait</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
			<span class="n">ch</span> <span class="o">=</span> <span class="n">gdbstub_read_wait</span><span class="p">();</span>

		<span class="cm">/* If we get an ACK, we are done. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we get the start of another packet, this means</span>
<span class="cm">		 * that GDB is attempting to reconnect.  We will NAK</span>
<span class="cm">		 * the packet being sent, and stop trying to send this</span>
<span class="cm">		 * packet.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;$&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">write_char</span><span class="p">(</span><span class="sc">&#39;-&#39;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">)</span>
				<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">gdbmsgbuf</span><span class="p">[</span><span class="n">BUFMAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">gdbstub_msg_write</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">bufptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wcount</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="cm">/* &#39;O&#39;utput */</span>
	<span class="n">gdbmsgbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;O&#39;</span><span class="p">;</span>

	<span class="cm">/* Fill and send buffers... */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bufptr</span> <span class="o">=</span> <span class="n">gdbmsgbuf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Calculate how many this time */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">BUFMAX</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
			<span class="n">wcount</span> <span class="o">=</span> <span class="p">(</span><span class="n">BUFMAX</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">wcount</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="cm">/* Pack in hex chars */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wcount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">bufptr</span> <span class="o">=</span> <span class="n">hex_byte_pack</span><span class="p">(</span><span class="n">bufptr</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="o">*</span><span class="n">bufptr</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

		<span class="cm">/* Move up */</span>
		<span class="n">s</span> <span class="o">+=</span> <span class="n">wcount</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">wcount</span><span class="p">;</span>

		<span class="cm">/* Write packet */</span>
		<span class="n">put_packet</span><span class="p">(</span><span class="n">gdbmsgbuf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert the memory pointed to by mem into hex, placing result in</span>
<span class="cm"> * buf.  Return a pointer to the last char put in buf (null). May</span>
<span class="cm"> * return an error.</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">kgdb_mem2hex</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We use the upper half of buf as an intermediate buffer for the</span>
<span class="cm">	 * raw memory copy.  Hex conversion will work against this one.</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">probe_kernel_read</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">hex_byte_pack</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">tmp</span><span class="o">++</span><span class="p">;</span>
		<span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert the hex array pointed to by buf into binary to be placed in</span>
<span class="cm"> * mem.  Return a pointer to the character AFTER the last byte</span>
<span class="cm"> * written.  May return an error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kgdb_hex2mem</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp_raw</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp_hex</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We use the upper half of buf as an intermediate buffer for the</span>
<span class="cm">	 * raw memory that is converted from hex.</span>
<span class="cm">	 */</span>
	<span class="n">tmp_raw</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">tmp_hex</span> <span class="o">=</span> <span class="n">tmp_raw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tmp_hex</span> <span class="o">&gt;=</span> <span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp_raw</span><span class="o">--</span><span class="p">;</span>
		<span class="o">*</span><span class="n">tmp_raw</span> <span class="o">=</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="o">*</span><span class="n">tmp_hex</span><span class="o">--</span><span class="p">);</span>
		<span class="o">*</span><span class="n">tmp_raw</span> <span class="o">|=</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="o">*</span><span class="n">tmp_hex</span><span class="o">--</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">probe_kernel_write</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">tmp_raw</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * While we find nice hex chars, build a long_val.</span>
<span class="cm"> * Return number of chars processed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kgdb_hex2long</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">long_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">hex_val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">negate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">long_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">**</span><span class="n">ptr</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">negate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">**</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hex_val</span> <span class="o">=</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="o">**</span><span class="n">ptr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hex_val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="o">*</span><span class="n">long_val</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">long_val</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">hex_val</span><span class="p">;</span>
		<span class="n">num</span><span class="o">++</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">negate</span><span class="p">)</span>
		<span class="o">*</span><span class="n">long_val</span> <span class="o">=</span> <span class="o">-*</span><span class="n">long_val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy the binary array pointed to by buf into mem.  Fix $, #, and</span>
<span class="cm"> * 0x7d escaped with 0x7d. Return -EFAULT on failure or 0 on success.</span>
<span class="cm"> * The input buf is overwitten with the result to write to mem.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kgdb_ebin2mem</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x7d</span><span class="p">)</span>
			<span class="n">c</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">^</span> <span class="mh">0x20</span><span class="p">;</span>
		<span class="n">size</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">probe_kernel_write</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if DBG_MAX_REG_NUM &gt; 0</span>
<span class="kt">void</span> <span class="nf">pt_regs_to_gdb_regs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">gdb_regs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">gdb_regs</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DBG_MAX_REG_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_get_reg</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="n">idx</span> <span class="o">+=</span> <span class="n">dbg_reg_def</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">gdb_regs_to_pt_regs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">gdb_regs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">gdb_regs</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DBG_MAX_REG_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_set_reg</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="n">idx</span> <span class="o">+=</span> <span class="n">dbg_reg_def</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* DBG_MAX_REG_NUM &gt; 0 */</span><span class="cp"></span>

<span class="cm">/* Write memory due to an &#39;M&#39; or &#39;X&#39; packet. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_mem_msg</span><span class="p">(</span><span class="kt">int</span> <span class="n">binary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kgdb_hex2long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span> <span class="o">&amp;&amp;</span>
	    <span class="n">kgdb_hex2long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">binary</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">kgdb_ebin2mem</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">kgdb_hex2mem</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CACHE_FLUSH_IS_SAFE</span><span class="p">)</span>
			<span class="n">flush_icache_range</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">length</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">error_packet</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">pkt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
	<span class="n">pkt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;E&#39;</span><span class="p">;</span>
	<span class="n">pkt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">hex_asc</span><span class="p">[(</span><span class="n">error</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)];</span>
	<span class="n">pkt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">hex_asc</span><span class="p">[(</span><span class="n">error</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)];</span>
	<span class="n">pkt</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Thread ID accessors. We represent a flat TID space to GDB, where</span>
<span class="cm"> * the per CPU idle threads (which under Linux all have PID 0) are</span>
<span class="cm"> * remapped to negative TIDs.</span>
<span class="cm"> */</span>

<span class="cp">#define BUF_THREAD_ID_SIZE	8</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">pack_threadid</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">pkt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">limit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lzero</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">limit</span> <span class="o">=</span> <span class="n">id</span> <span class="o">+</span> <span class="p">(</span><span class="n">BUF_THREAD_ID_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lzero</span> <span class="o">||</span> <span class="o">*</span><span class="n">id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pkt</span> <span class="o">=</span> <span class="n">hex_byte_pack</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>
			<span class="n">lzero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">id</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lzero</span><span class="p">)</span>
		<span class="n">pkt</span> <span class="o">=</span> <span class="n">hex_byte_pack</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pkt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">int_to_threadref</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">getthread</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Non-positive TIDs are remapped to the cpu shadow information</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">tid</span> <span class="o">=</span> <span class="o">-</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kgdb_active</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">tid</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">NR_CPUS</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kgdb_info</span><span class="p">[</span><span class="o">-</span><span class="n">tid</span> <span class="o">-</span> <span class="mi">2</span><span class="p">].</span><span class="n">task</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">kgdb_info</span><span class="p">[</span><span class="o">-</span><span class="n">tid</span> <span class="o">-</span> <span class="mi">2</span><span class="p">].</span><span class="n">task</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">idle_task</span><span class="p">(</span><span class="o">-</span><span class="n">tid</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;KGDB: Internal thread select error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * find_task_by_pid_ns() does not take the tasklist lock anymore</span>
<span class="cm">	 * but is nicely RCU locked - hence is a pretty resilient</span>
<span class="cm">	 * thing to use:</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">find_task_by_pid_ns</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_pid_ns</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Remap normal tasks to their real PID,</span>
<span class="cm"> * CPU shadow threads are mapped to -CPU - 2</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">shadow_pid</span><span class="p">(</span><span class="kt">int</span> <span class="n">realpid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">realpid</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">realpid</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">raw_smp_processor_id</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * All the functions that start with gdb_cmd are the various</span>
<span class="cm"> * operations to implement the handlers for the gdbserial protocol</span>
<span class="cm"> * where KGDB is communicating with an external debugger</span>
<span class="cm"> */</span>

<span class="cm">/* Handle the &#39;?&#39; status packets */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdb_cmd_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We know that this packet is only sent</span>
<span class="cm">	 * during initial connect.  So to be safe,</span>
<span class="cm">	 * we clear out our breakpoints now in case</span>
<span class="cm">	 * GDB is reconnecting.</span>
<span class="cm">	 */</span>
	<span class="n">dbg_remove_all_break</span><span class="p">();</span>

	<span class="n">remcom_out_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;S&#39;</span><span class="p">;</span>
	<span class="n">hex_byte_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">remcom_out_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">signo</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdb_get_regs_helper</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">local_debuggerinfo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="kr">thread</span> <span class="o">=</span> <span class="n">kgdb_usethread</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="kr">thread</span><span class="p">)</span> <span class="p">{</span>
		<span class="kr">thread</span> <span class="o">=</span> <span class="n">kgdb_info</span><span class="p">[</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">].</span><span class="n">task</span><span class="p">;</span>
		<span class="n">local_debuggerinfo</span> <span class="o">=</span> <span class="n">kgdb_info</span><span class="p">[</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">].</span><span class="n">debuggerinfo</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">local_debuggerinfo</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Try to find the task on some other</span>
<span class="cm">			 * or possibly this node if we do not</span>
<span class="cm">			 * find the matching task then we try</span>
<span class="cm">			 * to approximate the results.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="kr">thread</span> <span class="o">==</span> <span class="n">kgdb_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">task</span><span class="p">)</span>
				<span class="n">local_debuggerinfo</span> <span class="o">=</span> <span class="n">kgdb_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">debuggerinfo</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * All threads that don&#39;t have debuggerinfo should be</span>
<span class="cm">	 * in schedule() sleeping, since all other CPUs</span>
<span class="cm">	 * are in kgdb_wait, and thus have debuggerinfo.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">local_debuggerinfo</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pt_regs_to_gdb_regs</span><span class="p">(</span><span class="n">gdb_regs</span><span class="p">,</span> <span class="n">local_debuggerinfo</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Pull stuff saved during switch_to; nothing</span>
<span class="cm">		 * else is accessible (or even particularly</span>
<span class="cm">		 * relevant).</span>
<span class="cm">		 *</span>
<span class="cm">		 * This should be enough for a stack trace.</span>
<span class="cm">		 */</span>
		<span class="n">sleeping_thread_to_gdb_regs</span><span class="p">(</span><span class="n">gdb_regs</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Handle the &#39;g&#39; get registers request */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdb_cmd_getregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gdb_get_regs_helper</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
	<span class="n">kgdb_mem2hex</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">gdb_regs</span><span class="p">,</span> <span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="n">NUMREGBYTES</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Handle the &#39;G&#39; set registers request */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdb_cmd_setregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kgdb_hex2mem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">gdb_regs</span><span class="p">,</span> <span class="n">NUMREGBYTES</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kgdb_usethread</span> <span class="o">&amp;&amp;</span> <span class="n">kgdb_usethread</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">gdb_regs_to_pt_regs</span><span class="p">(</span><span class="n">gdb_regs</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">linux_regs</span><span class="p">);</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Handle the &#39;m&#39; memory read bytes */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdb_cmd_memread</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kgdb_hex2long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span> <span class="o">&amp;&amp;</span>
					<span class="n">kgdb_hex2long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">kgdb_mem2hex</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Handle the &#39;M&#39; memory write bytes */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdb_cmd_memwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">write_mem_msg</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if DBG_MAX_REG_NUM &gt; 0</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">gdb_hex_reg_helper</span><span class="p">(</span><span class="kt">int</span> <span class="n">regnum</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">regnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">dbg_reg_def</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">kgdb_mem2hex</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">gdb_regs</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span>
			    <span class="n">dbg_reg_def</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Handle the &#39;p&#39; individual regster get */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdb_cmd_reg_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">regnum</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">kgdb_hex2long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regnum</span> <span class="o">&gt;=</span> <span class="n">DBG_MAX_REG_NUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">gdb_get_regs_helper</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
	<span class="n">gdb_hex_reg_helper</span><span class="p">(</span><span class="n">regnum</span><span class="p">,</span> <span class="n">remcom_out_buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Handle the &#39;P&#39; individual regster set */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdb_cmd_reg_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">regnum</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">kgdb_hex2long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">regnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">!=</span> <span class="sc">&#39;=&#39;</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="o">!</span><span class="n">kgdb_usethread</span> <span class="o">||</span> <span class="n">kgdb_usethread</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">dbg_get_reg</span><span class="p">(</span><span class="n">regnum</span><span class="p">,</span> <span class="n">gdb_regs</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">linux_regs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">gdb_regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">gdb_regs</span><span class="p">));</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">gdb_regs</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hex_to_bin</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">kgdb_hex2mem</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">gdb_regs</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">dbg_set_reg</span><span class="p">(</span><span class="n">regnum</span><span class="p">,</span> <span class="n">gdb_regs</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">linux_regs</span><span class="p">);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* DBG_MAX_REG_NUM &gt; 0 */</span><span class="cp"></span>

<span class="cm">/* Handle the &#39;X&#39; memory binary write bytes */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdb_cmd_binwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">write_mem_msg</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Handle the &#39;D&#39; or &#39;k&#39;, detach or kill packets */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdb_cmd_detachkill</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* The detach case */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;D&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">dbg_remove_all_break</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">strcpy</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>
			<span class="n">kgdb_connected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">put_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Assume the kill case, with no exit code checking,</span>
<span class="cm">		 * trying to force detach the debugger:</span>
<span class="cm">		 */</span>
		<span class="n">dbg_remove_all_break</span><span class="p">();</span>
		<span class="n">kgdb_connected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Handle the &#39;R&#39; reboot packets */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gdb_cmd_reboot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* For now, only honor R0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">,</span> <span class="s">&quot;R0&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;Executing emergency reboot</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>
		<span class="n">put_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Execution should not return from</span>
<span class="cm">		 * machine_emergency_restart()</span>
<span class="cm">		 */</span>
		<span class="n">machine_emergency_restart</span><span class="p">();</span>
		<span class="n">kgdb_connected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Handle the &#39;q&#39; query packets */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdb_cmd_query</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">g</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">thref</span><span class="p">[</span><span class="n">BUF_THREAD_ID_SIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">finished</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;s&#39;</span>:
	<span class="k">case</span> <span class="sc">&#39;f&#39;</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">remcom_in_buffer</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;ThreadInfo&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">remcom_out_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;m&#39;</span><span class="p">;</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">remcom_out_buffer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;f&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Each cpu is a shadow thread */</span>
			<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ks</span><span class="o">-&gt;</span><span class="n">thr_query</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">int_to_threadref</span><span class="p">(</span><span class="n">thref</span><span class="p">,</span> <span class="o">-</span><span class="n">cpu</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
				<span class="n">ptr</span> <span class="o">=</span> <span class="n">pack_threadid</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">thref</span><span class="p">);</span>
				<span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;,&#39;</span><span class="p">;</span>
				<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">do_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">thr_query</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">int_to_threadref</span><span class="p">(</span><span class="n">thref</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
				<span class="n">ptr</span> <span class="o">=</span> <span class="n">pack_threadid</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">thref</span><span class="p">);</span>
				<span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;,&#39;</span><span class="p">;</span>
				<span class="n">ks</span><span class="o">-&gt;</span><span class="n">thr_query</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">thr_query</span> <span class="o">%</span> <span class="n">KGDB_MAX_THREAD_QUERY</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">finished</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

		<span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">ptr</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="sc">&#39;C&#39;</span>:
		<span class="cm">/* Current thread id */</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="s">&quot;QC&quot;</span><span class="p">);</span>
		<span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span> <span class="o">=</span> <span class="n">shadow_pid</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">int_to_threadref</span><span class="p">(</span><span class="n">thref</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span><span class="p">);</span>
		<span class="n">pack_threadid</span><span class="p">(</span><span class="n">remcom_out_buffer</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">thref</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="sc">&#39;T&#39;</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">remcom_in_buffer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;ThreadExtraInfo,&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">remcom_in_buffer</span> <span class="o">+</span> <span class="mi">17</span><span class="p">;</span>
		<span class="n">kgdb_hex2long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">getthread</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">linux_regs</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kgdb_mem2hex</span><span class="p">(</span><span class="n">getthread</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">linux_regs</span><span class="p">,</span>
					<span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span>
					<span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">static</span> <span class="kt">char</span> <span class="n">tmpstr</span><span class="p">[</span><span class="mi">23</span> <span class="o">+</span> <span class="n">BUF_THREAD_ID_SIZE</span><span class="p">];</span>

			<span class="n">sprintf</span><span class="p">(</span><span class="n">tmpstr</span><span class="p">,</span> <span class="s">&quot;shadowCPU%d&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="o">-</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span> <span class="o">-</span> <span class="mi">2</span><span class="p">));</span>
			<span class="n">kgdb_mem2hex</span><span class="p">(</span><span class="n">tmpstr</span><span class="p">,</span> <span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">tmpstr</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_KGDB_KDB</span>
	<span class="k">case</span> <span class="sc">&#39;R&#39;</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">,</span> <span class="s">&quot;qRcmd,&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">remcom_in_buffer</span> <span class="o">+</span> <span class="mi">6</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">strcpy</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="s">&quot;E01&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">kgdb_hex2mem</span><span class="p">(</span><span class="n">remcom_in_buffer</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span>
				     <span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">remcom_out_buffer</span><span class="p">[</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">kdb_parse</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">);</span>
			<span class="n">strcpy</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Handle the &#39;H&#39; task query packets */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdb_cmd_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;g&#39;</span>:
		<span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="n">kgdb_hex2long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span><span class="p">);</span>
		<span class="kr">thread</span> <span class="o">=</span> <span class="n">getthread</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">linux_regs</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="kr">thread</span> <span class="o">&amp;&amp;</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kgdb_usethread</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">;</span>
		<span class="n">ks</span><span class="o">-&gt;</span><span class="n">kgdb_usethreadid</span> <span class="o">=</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span><span class="p">;</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="sc">&#39;c&#39;</span>:
		<span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="n">kgdb_hex2long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kgdb_contthread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kr">thread</span> <span class="o">=</span> <span class="n">getthread</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">linux_regs</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="kr">thread</span> <span class="o">&amp;&amp;</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">kgdb_contthread</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Handle the &#39;T&#39; thread query packets */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdb_cmd_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>

	<span class="n">kgdb_hex2long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span><span class="p">);</span>
	<span class="kr">thread</span> <span class="o">=</span> <span class="n">getthread</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">linux_regs</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">threadid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="kr">thread</span><span class="p">)</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Handle the &#39;z&#39; or &#39;Z&#39; breakpoint remove or set packets */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gdb_cmd_break</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Since GDB-5.3, it&#39;s been drafted that &#39;0&#39; is a software</span>
<span class="cm">	 * breakpoint, &#39;1&#39; is a hardware breakpoint, so let&#39;s do that.</span>
<span class="cm">	 */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">bpt_type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_kgdb_ops</span><span class="p">.</span><span class="n">set_hw_breakpoint</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">bpt_type</span> <span class="o">&gt;=</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Unsupported */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bpt_type</span> <span class="o">&gt;</span> <span class="sc">&#39;4&#39;</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bpt_type</span> <span class="o">!=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">bpt_type</span> <span class="o">!=</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span>
			<span class="cm">/* Unsupported. */</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Test if this is a hardware breakpoint, and</span>
<span class="cm">	 * if we support it:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bpt_type</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">arch_kgdb_ops</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KGDB_HW_BREAKPOINT</span><span class="p">))</span>
		<span class="cm">/* Unsupported. */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kgdb_hex2long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">&#39;,&#39;</span> <span class="o">||</span>
		<span class="o">!</span><span class="n">kgdb_hex2long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;Z&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">bpt_type</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">dbg_set_sw_break</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;z&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">bpt_type</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">dbg_remove_sw_break</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;Z&#39;</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">arch_kgdb_ops</span><span class="p">.</span><span class="n">set_hw_breakpoint</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">length</span><span class="p">,</span> <span class="o">*</span><span class="n">bpt_type</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;z&#39;</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">arch_kgdb_ops</span><span class="p">.</span><span class="n">remove_hw_breakpoint</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">length</span><span class="p">,</span> <span class="o">*</span><span class="n">bpt_type</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Handle the &#39;C&#39; signal / exception passing packets */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gdb_cmd_exception_pass</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* C09 == pass exception</span>
<span class="cm">	 * C15 == detach kgdb, pass exception</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">ks</span><span class="o">-&gt;</span><span class="n">pass_exception</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;c&#39;</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;5&#39;</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">ks</span><span class="o">-&gt;</span><span class="n">pass_exception</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;D&#39;</span><span class="p">;</span>
		<span class="n">dbg_remove_all_break</span><span class="p">();</span>
		<span class="n">kgdb_connected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">gdbstub_msg_write</span><span class="p">(</span><span class="s">&quot;KGDB only knows signal 9 (pass)&quot;</span>
			<span class="s">&quot; and 15 (pass and disconnect)</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;Executing a continue without signal passing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;c&#39;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Indicate fall through */</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function performs all gdbserial command procesing</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gdb_serial_stub</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* Initialize comm buffer and globals. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">));</span>
	<span class="n">kgdb_usethread</span> <span class="o">=</span> <span class="n">kgdb_info</span><span class="p">[</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">].</span><span class="n">task</span><span class="p">;</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">kgdb_usethreadid</span> <span class="o">=</span> <span class="n">shadow_pid</span><span class="p">(</span><span class="n">kgdb_info</span><span class="p">[</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">].</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">ks</span><span class="o">-&gt;</span><span class="n">pass_exception</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kgdb_connected</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">thref</span><span class="p">[</span><span class="n">BUF_THREAD_ID_SIZE</span><span class="p">];</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

		<span class="cm">/* Reply to host that an exception has occurred */</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">remcom_out_buffer</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;T&#39;</span><span class="p">;</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">hex_byte_pack</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">signo</span><span class="p">);</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">strcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="s">&quot;thread:&quot;</span><span class="p">));</span>
		<span class="n">int_to_threadref</span><span class="p">(</span><span class="n">thref</span><span class="p">,</span> <span class="n">shadow_pid</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">));</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">pack_threadid</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">thref</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;;&#39;</span><span class="p">;</span>
		<span class="n">put_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Clear the out buffer. */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">));</span>

		<span class="n">get_packet</span><span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;?&#39;</span>: <span class="cm">/* gdbserial status */</span>
			<span class="n">gdb_cmd_status</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;g&#39;</span>: <span class="cm">/* return the value of the CPU registers */</span>
			<span class="n">gdb_cmd_getregs</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;G&#39;</span>: <span class="cm">/* set the value of the CPU registers - return OK */</span>
			<span class="n">gdb_cmd_setregs</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;m&#39;</span>: <span class="cm">/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */</span>
			<span class="n">gdb_cmd_memread</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;M&#39;</span>: <span class="cm">/* MAA..AA,LLLL: Write LLLL bytes at address AA..AA */</span>
			<span class="n">gdb_cmd_memwrite</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#if DBG_MAX_REG_NUM &gt; 0</span>
		<span class="k">case</span> <span class="sc">&#39;p&#39;</span>: <span class="cm">/* pXX Return gdb register XX (in hex) */</span>
			<span class="n">gdb_cmd_reg_get</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;P&#39;</span>: <span class="cm">/* PXX=aaaa Set gdb register XX to aaaa (in hex) */</span>
			<span class="n">gdb_cmd_reg_set</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* DBG_MAX_REG_NUM &gt; 0 */</span><span class="cp"></span>
		<span class="k">case</span> <span class="sc">&#39;X&#39;</span>: <span class="cm">/* XAA..AA,LLLL: Write LLLL bytes at address AA..AA */</span>
			<span class="n">gdb_cmd_binwrite</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* kill or detach. KGDB should treat this like a</span>
<span class="cm">			 * continue.</span>
<span class="cm">			 */</span>
		<span class="k">case</span> <span class="sc">&#39;D&#39;</span>: <span class="cm">/* Debugger detach */</span>
		<span class="k">case</span> <span class="sc">&#39;k&#39;</span>: <span class="cm">/* Debugger detach via kill */</span>
			<span class="n">gdb_cmd_detachkill</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">default_handle</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;R&#39;</span>: <span class="cm">/* Reboot */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">gdb_cmd_reboot</span><span class="p">(</span><span class="n">ks</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">default_handle</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;q&#39;</span>: <span class="cm">/* query command */</span>
			<span class="n">gdb_cmd_query</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;H&#39;</span>: <span class="cm">/* task related */</span>
			<span class="n">gdb_cmd_task</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;T&#39;</span>: <span class="cm">/* Query thread status */</span>
			<span class="n">gdb_cmd_thread</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;z&#39;</span>: <span class="cm">/* Break point remove */</span>
		<span class="k">case</span> <span class="sc">&#39;Z&#39;</span>: <span class="cm">/* Break point set */</span>
			<span class="n">gdb_cmd_break</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_KGDB_KDB</span>
		<span class="k">case</span> <span class="sc">&#39;3&#39;</span>: <span class="cm">/* Escape into back into kdb */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">gdb_cmd_detachkill</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">DBG_PASS_EVENT</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="k">case</span> <span class="sc">&#39;C&#39;</span>: <span class="cm">/* Exception passing */</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">gdb_cmd_exception_pass</span><span class="p">(</span><span class="n">ks</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">default_handle</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* Fall through on tmp &lt; 0 */</span>
		<span class="k">case</span> <span class="sc">&#39;c&#39;</span>: <span class="cm">/* Continue packet */</span>
		<span class="k">case</span> <span class="sc">&#39;s&#39;</span>: <span class="cm">/* Single step packet */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kgdb_contthread</span> <span class="o">&amp;&amp;</span> <span class="n">kgdb_contthread</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Can&#39;t switch threads in kgdb */</span>
				<span class="n">error_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dbg_activate_sw_breakpoints</span><span class="p">();</span>
			<span class="cm">/* Fall through to default processing */</span>
		<span class="nl">default:</span>
<span class="nl">default_handle:</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">kgdb_arch_handle_exception</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">ex_vector</span><span class="p">,</span>
						<span class="n">ks</span><span class="o">-&gt;</span><span class="n">signo</span><span class="p">,</span>
						<span class="n">ks</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">,</span>
						<span class="n">remcom_in_buffer</span><span class="p">,</span>
						<span class="n">remcom_out_buffer</span><span class="p">,</span>
						<span class="n">ks</span><span class="o">-&gt;</span><span class="n">linux_regs</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Leave cmd processing on error, detach,</span>
<span class="cm">			 * kill, continue, or single step.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;D&#39;</span> <span class="o">||</span>
			    <span class="n">remcom_in_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;k&#39;</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">kgdb_exit</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span>

		<span class="cm">/* reply to the request */</span>
		<span class="n">put_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">kgdb_exit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">pass_exception</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">gdbstub_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">kgdb_state</span> <span class="o">*</span><span class="n">ks</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;e&#39;</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">kgdb_arch_handle_exception</span><span class="p">(</span><span class="n">ks</span><span class="o">-&gt;</span><span class="n">ex_vector</span><span class="p">,</span>
						   <span class="n">ks</span><span class="o">-&gt;</span><span class="n">signo</span><span class="p">,</span>
						   <span class="n">ks</span><span class="o">-&gt;</span><span class="n">err_code</span><span class="p">,</span>
						   <span class="n">remcom_in_buffer</span><span class="p">,</span>
						   <span class="n">remcom_out_buffer</span><span class="p">,</span>
						   <span class="n">ks</span><span class="o">-&gt;</span><span class="n">linux_regs</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">case</span> <span class="sc">&#39;s&#39;</span>:
	<span class="k">case</span> <span class="sc">&#39;c&#39;</span>:
		<span class="n">strcpy</span><span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="sc">&#39;$&#39;</span>:
		<span class="n">strcpy</span><span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">gdbstub_use_prev_in_buf</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">remcom_in_buffer</span><span class="p">);</span>
		<span class="n">gdbstub_prev_in_buf_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">write_char</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">);</span>
	<span class="n">put_packet</span><span class="p">(</span><span class="n">remcom_out_buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * gdbstub_exit - Send an exit message to GDB</span>
<span class="cm"> * @status: The exit code to report.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">gdbstub_exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">checksum</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">loop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kgdb_connected</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">kgdb_connected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_io_ops</span> <span class="o">||</span> <span class="n">dbg_kdb_mode</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;W&#39;</span><span class="p">;</span>
	<span class="n">buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">hex_asc_hi</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
	<span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">hex_asc_lo</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>

	<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">write_char</span><span class="p">(</span><span class="sc">&#39;$&#39;</span><span class="p">);</span>
	<span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">loop</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ch</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">loop</span><span class="p">];</span>
		<span class="n">checksum</span> <span class="o">+=</span> <span class="n">ch</span><span class="p">;</span>
		<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">write_char</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">write_char</span><span class="p">(</span><span class="sc">&#39;#&#39;</span><span class="p">);</span>
	<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">write_char</span><span class="p">(</span><span class="n">hex_asc_hi</span><span class="p">(</span><span class="n">checksum</span><span class="p">));</span>
	<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">write_char</span><span class="p">(</span><span class="n">hex_asc_lo</span><span class="p">(</span><span class="n">checksum</span><span class="p">));</span>

	<span class="cm">/* make sure the output is flushed, lest the bootloader clobber it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">)</span>
		<span class="n">dbg_io_ops</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">();</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
