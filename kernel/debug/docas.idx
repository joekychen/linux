d | kdb |  | 11 items |  | Linus Torvalds | torvalds@linux-foundation.org | 1333585568 |  | 
f | debug_core.c | s | 23K | 863 | Linus Torvalds | torvalds@linux-foundation.org | 1333585568 |  | 
f | Makefile | g | 122B |  | Jason Wessel | jason.wessel@windriver.com | 1274407460 |  | kdb: core for kgdb back end (1 of 2)  This patch contains only the kdb core.  Because the change set was large, it was split.  The next patch in the series includes the instrumentation into the core kernel which are mainly helper functions for kdb.  This work is directly derived from kdb v4.4 found at:  ftp://oss.sgi.com/projects/kdb/download/v4.4/  The kdb internals have been re-organized to make them mostly platform independent and to connect everything to the debug core which is used by gdbstub (which has long been known as kgdb).  The original version of kdb was 58,000 lines worth of changes to support x86.  From that implementation only the kdb shell, and basic commands for memory access, runcontrol, lsmod, and dmesg where carried forward.  This is a generic implementation which aims to cover all the current architectures using the kgdb core: ppc, arm, x86, mips, sparc, sh and blackfin.  More archictectures can be added by implementing the architecture specific kgdb functions.  [mort@sgi.com: Compile fix with hugepages enabled] [mort@sgi.com: Clean breakpoint code renaming kdba_ -> kdb_] [mort@sgi.com: fix new line after printing registers] [mort@sgi.com: Remove the concept of global vs. local breakpoints] [mort@sgi.com: Rework kdb_si_swapinfo to use more generic name] [mort@sgi.com: fix the information dump macros, remove 'arch' from the names] [sfr@canb.auug.org.au: include fixup to include linux/slab.h]  CC: linux-arch@vger.kernel.org Signed-off-by: Jason Wessel <jason.wessel@windriver.com> Signed-off-by: Martin Hicks <mort@sgi.com>
f | debug_core.h | s | 2.3K | 70 | Jason Wessel | jason.wessel@windriver.com | 1287779653 |  | debug_core: refactor locking for master/slave cpus  For quite some time there have been problems with memory barriers and various races with NMI on multi processor systems using the kernel debugger.  The algorithm for entering the kernel debug core and resuming kernel execution was racy and had several known edge case problems with attempting to debug something on a heavily loaded system using breakpoints that are hit repeatedly and quickly.  The prior "locking" design entry worked as follows:    * The atomic counter kgdb_active was used with atomic exchange in     order to elect a master cpu out of all the cpus that may have     taken a debug exception.   * The master cpu increments all elements of passive_cpu_wait[].   * The master cpu issues the round up cpus message.   * Each "slave cpu" that enters the debug core increments its own     element in cpu_in_kgdb[].   * Each "slave cpu" spins on passive_cpu_wait[] until it becomes 0.   * The master cpu debugs the system.  The new scheme removes the two arrays of atomic counters and replaces them with 2 single counters.  One counter is used to count the number of cpus waiting to become a master cpu (because one or more hit an exception). The second counter is use to indicate how many cpus have entered as slave cpus.  The new entry logic works as follows:    * One or more cpus enters via kgdb_handle_exception() and increments     the masters_in_kgdb. Each cpu attempts to get the spin lock called     dbg_master_lock.   * The master cpu sets kgdb_active to the current cpu.   * The master cpu takes the spinlock dbg_slave_lock.   * The master cpu asks to round up all the other cpus.   * Each slave cpu that is not already in kgdb_handle_exception()     will enter and increment slaves_in_kgdb.  Each slave will now spin     try_locking on dbg_slave_lock.   * The master cpu waits for the sum of masters_in_kgdb and slaves_in_kgdb     to be equal to the sum of the online cpus.   * The master cpu debugs the system.  In the new design the kgdb_active can only be changed while holding dbg_master_lock.  Stress testing has not turned up any further entry/exit races that existed in the prior locking design.  The prior locking design suffered from atomic variables not being truly atomic (in the capacity as used by kgdb) along with memory barrier races.  Signed-off-by: Jason Wessel <jason.wessel@windriver.com> Acked-by: Dongdong Deng <dongdong.deng@windriver.com>
f | gdbstub.c | s | 25K | 1000 | Jason Wessel | jason.wessel@windriver.com | 1332446835 |  | kgdb,debug-core,gdbstub: Hook the reboot notifier for debugger detach  The gdbstub and kdb should get detached if the system is rebooting. Calling gdbstub_exit() will set the proper debug core state and send a message to any debugger that is connected to correctly detach.  An attached debugger will receive the exit code from include/linux/reboot.h based on SYS_HALT, SYS_REBOOT, etc...  Reported-by: Jan Kiszka <jan.kiszka@siemens.com> Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
