<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › rtmutex.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>rtmutex.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * RT-Mutexes: simple blocking mutual exclusion locks with PI support</span>
<span class="cm"> *</span>
<span class="cm"> * started by Ingo Molnar and Thomas Gleixner.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2004-2006 Red Hat, Inc., Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="cm"> *  Copyright (C) 2005-2006 Timesys Corp., Thomas Gleixner &lt;tglx@timesys.com&gt;</span>
<span class="cm"> *  Copyright (C) 2005 Kihon Technologies Inc., Steven Rostedt</span>
<span class="cm"> *  Copyright (C) 2006 Esben Nielsen</span>
<span class="cm"> *</span>
<span class="cm"> *  See Documentation/rt-mutex-design.txt for details.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>

<span class="cp">#include &quot;rtmutex_common.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * lock-&gt;owner state tracking:</span>
<span class="cm"> *</span>
<span class="cm"> * lock-&gt;owner holds the task_struct pointer of the owner. Bit 0</span>
<span class="cm"> * is used to keep track of the &quot;lock has waiters&quot; state.</span>
<span class="cm"> *</span>
<span class="cm"> * owner	bit0</span>
<span class="cm"> * NULL		0	lock is free (fast acquire possible)</span>
<span class="cm"> * NULL		1	lock is free and has waiters and the top waiter</span>
<span class="cm"> *				is going to take the lock*</span>
<span class="cm"> * taskpointer	0	lock is held (fast release possible)</span>
<span class="cm"> * taskpointer	1	lock is held and has waiters**</span>
<span class="cm"> *</span>
<span class="cm"> * The fast atomic compare exchange based acquire and release is only</span>
<span class="cm"> * possible when bit 0 of lock-&gt;owner is 0.</span>
<span class="cm"> *</span>
<span class="cm"> * (*) It also can be a transitional state when grabbing the lock</span>
<span class="cm"> * with -&gt;wait_lock is held. To prevent any fast path cmpxchg to the lock,</span>
<span class="cm"> * we need to set the bit0 before looking at the lock, and the owner may be</span>
<span class="cm"> * NULL in this small time, hence this can be a transitional state.</span>
<span class="cm"> *</span>
<span class="cm"> * (**) There is a small time when bit 0 is set but there are no</span>
<span class="cm"> * waiters. This can happen when grabbing the lock in the slow path.</span>
<span class="cm"> * To prevent a cmpxchg of the owner releasing the lock, we need to</span>
<span class="cm"> * set this bit before looking at the lock.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rt_mutex_set_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">owner</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt_mutex_has_waiters</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">RT_MUTEX_HAS_WAITERS</span><span class="p">;</span>

	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">)</span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_rt_mutex_waiters</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RT_MUTEX_HAS_WAITERS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_rt_mutex_waiters</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_mutex_has_waiters</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span>
		<span class="n">clear_rt_mutex_waiters</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We can speed up the acquire/release, if the architecture</span>
<span class="cm"> * supports cmpxchg and if there&#39;s no debugging state to be set up</span>
<span class="cm"> */</span>
<span class="cp">#if defined(__HAVE_ARCH_CMPXCHG) &amp;&amp; !defined(CONFIG_DEBUG_RT_MUTEXES)</span>
<span class="cp"># define rt_mutex_cmpxchg(l,c,n)	(cmpxchg(&amp;l-&gt;owner, c, n) == c)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mark_rt_mutex_waiters</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">owner</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">owner</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cmpxchg</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">owner</span> <span class="o">|</span> <span class="n">RT_MUTEX_HAS_WAITERS</span><span class="p">)</span> <span class="o">!=</span> <span class="n">owner</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp"># define rt_mutex_cmpxchg(l,c,n)	(0)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mark_rt_mutex_waiters</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">|</span> <span class="n">RT_MUTEX_HAS_WAITERS</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate task priority from the waiter list priority</span>
<span class="cm"> *</span>
<span class="cm"> * Return task-&gt;normal_prio when the waiter list is empty or when</span>
<span class="cm"> * the waiter is not allowed to do priority boosting</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">rt_mutex_getprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">task_has_pi_waiters</span><span class="p">(</span><span class="n">task</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">normal_prio</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">task_top_pi_waiter</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pi_list_entry</span><span class="p">.</span><span class="n">prio</span><span class="p">,</span>
		   <span class="n">task</span><span class="o">-&gt;</span><span class="n">normal_prio</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Adjust the priority of a task, after its pi_waiters got modified.</span>
<span class="cm"> *</span>
<span class="cm"> * This can be both boosting and unboosting. task-&gt;pi_lock must be held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__rt_mutex_adjust_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">prio</span> <span class="o">=</span> <span class="n">rt_mutex_getprio</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">!=</span> <span class="n">prio</span><span class="p">)</span>
		<span class="n">rt_mutex_setprio</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">prio</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Adjust task priority (undo boosting). Called from the exit path of</span>
<span class="cm"> * rt_mutex_slowunlock() and rt_mutex_slowlock().</span>
<span class="cm"> *</span>
<span class="cm"> * (Note: We do this outside of the protection of lock-&gt;wait_lock to</span>
<span class="cm"> * allow the lock to be taken while or before we readjust the priority</span>
<span class="cm"> * of task. We do not use the spin_xx_mutex() variants here as we are</span>
<span class="cm"> * outside of the debug path.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rt_mutex_adjust_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__rt_mutex_adjust_prio</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Max number of times we&#39;ll walk the boosting chain:</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">max_lock_depth</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Adjust the priority chain. Also used for deadlock detection.</span>
<span class="cm"> * Decreases task&#39;s usage by one - may thus free the task.</span>
<span class="cm"> * Returns 0 or -EDEADLK.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rt_mutex_adjust_prio_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">deadlock_detect</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">orig_lock</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">orig_waiter</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">top_task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">waiter</span><span class="p">,</span> <span class="o">*</span><span class="n">top_waiter</span> <span class="o">=</span> <span class="n">orig_waiter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">detect_deadlock</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">detect_deadlock</span> <span class="o">=</span> <span class="n">debug_rt_mutex_detect_deadlock</span><span class="p">(</span><span class="n">orig_waiter</span><span class="p">,</span>
							 <span class="n">deadlock_detect</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The (de)boosting is a step by step approach with a lot of</span>
<span class="cm">	 * pitfalls. We want this to be preemptible and we want hold a</span>
<span class="cm">	 * maximum of two locks per step. So we have to check</span>
<span class="cm">	 * carefully whether things change under us.</span>
<span class="cm">	 */</span>
 <span class="nl">again:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="n">max_lock_depth</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="kt">int</span> <span class="n">prev_max</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Print this only once. If the admin changes the limit,</span>
<span class="cm">		 * print a new message when reaching the limit again.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_max</span> <span class="o">!=</span> <span class="n">max_lock_depth</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prev_max</span> <span class="o">=</span> <span class="n">max_lock_depth</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Maximum lock depth %d reached &quot;</span>
			       <span class="s">&quot;task: %s (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">max_lock_depth</span><span class="p">,</span>
			       <span class="n">top_task</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">top_task</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">deadlock_detect</span> <span class="o">?</span> <span class="o">-</span><span class="n">EDEADLK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">retry:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Task can not go away as we did a get_task() before !</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">waiter</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_blocked_on</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check whether the end of the boosting chain has been</span>
<span class="cm">	 * reached or the state of the chain has changed while we</span>
<span class="cm">	 * dropped the locks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">waiter</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock_pi</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check the orig_waiter state. After we dropped the locks,</span>
<span class="cm">	 * the previous owner of the lock might have released the lock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">orig_waiter</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rt_mutex_owner</span><span class="p">(</span><span class="n">orig_lock</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock_pi</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Drop out, when the task has no waiters. Note,</span>
<span class="cm">	 * top_waiter can be NULL, when we are in the deboosting</span>
<span class="cm">	 * mode!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">top_waiter</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">task_has_pi_waiters</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">||</span>
			   <span class="n">top_waiter</span> <span class="o">!=</span> <span class="n">task_top_pi_waiter</span><span class="p">(</span><span class="n">task</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out_unlock_pi</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When deadlock detection is off then we check, if further</span>
<span class="cm">	 * priority adjustment is necessary.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">detect_deadlock</span> <span class="o">&amp;&amp;</span> <span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list_entry</span><span class="p">.</span><span class="n">prio</span> <span class="o">==</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock_pi</span><span class="p">;</span>

	<span class="n">lock</span> <span class="o">=</span> <span class="n">waiter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">raw_spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Deadlock detection */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lock</span> <span class="o">==</span> <span class="n">orig_lock</span> <span class="o">||</span> <span class="n">rt_mutex_owner</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="o">==</span> <span class="n">top_task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debug_rt_mutex_deadlock</span><span class="p">(</span><span class="n">deadlock_detect</span><span class="p">,</span> <span class="n">orig_waiter</span><span class="p">,</span> <span class="n">lock</span><span class="p">);</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">deadlock_detect</span> <span class="o">?</span> <span class="o">-</span><span class="n">EDEADLK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock_pi</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">top_waiter</span> <span class="o">=</span> <span class="n">rt_mutex_top_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Requeue the waiter */</span>
	<span class="n">plist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_list</span><span class="p">);</span>
	<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list_entry</span><span class="p">.</span><span class="n">prio</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
	<span class="n">plist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_list</span><span class="p">);</span>

	<span class="cm">/* Release the task */</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_mutex_owner</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the requeue above changed the top waiter, then we need</span>
<span class="cm">		 * to wake the new top waiter up to try to get the lock.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">top_waiter</span> <span class="o">!=</span> <span class="n">rt_mutex_top_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span>
			<span class="n">wake_up_process</span><span class="p">(</span><span class="n">rt_mutex_top_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_put_task</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="cm">/* Grab the next task */</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">rt_mutex_owner</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">waiter</span> <span class="o">==</span> <span class="n">rt_mutex_top_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Boost the owner */</span>
		<span class="n">plist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">top_waiter</span><span class="o">-&gt;</span><span class="n">pi_list_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_waiters</span><span class="p">);</span>
		<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">pi_list_entry</span><span class="p">.</span><span class="n">prio</span> <span class="o">=</span> <span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list_entry</span><span class="p">.</span><span class="n">prio</span><span class="p">;</span>
		<span class="n">plist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">pi_list_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_waiters</span><span class="p">);</span>
		<span class="n">__rt_mutex_adjust_prio</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">top_waiter</span> <span class="o">==</span> <span class="n">waiter</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Deboost the owner */</span>
		<span class="n">plist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">pi_list_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_waiters</span><span class="p">);</span>
		<span class="n">waiter</span> <span class="o">=</span> <span class="n">rt_mutex_top_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">pi_list_entry</span><span class="p">.</span><span class="n">prio</span> <span class="o">=</span> <span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list_entry</span><span class="p">.</span><span class="n">prio</span><span class="p">;</span>
		<span class="n">plist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">pi_list_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_waiters</span><span class="p">);</span>
		<span class="n">__rt_mutex_adjust_prio</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">top_waiter</span> <span class="o">=</span> <span class="n">rt_mutex_top_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">detect_deadlock</span> <span class="o">&amp;&amp;</span> <span class="n">waiter</span> <span class="o">!=</span> <span class="n">top_waiter</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put_task</span><span class="p">;</span>

	<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

 <span class="nl">out_unlock_pi:</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
 <span class="nl">out_put_task:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try to take an rt-mutex</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with lock-&gt;wait_lock held.</span>
<span class="cm"> *</span>
<span class="cm"> * @lock:   the lock to be acquired.</span>
<span class="cm"> * @task:   the task which wants to acquire the lock</span>
<span class="cm"> * @waiter: the waiter that is queued to the lock&#39;s wait list. (could be NULL)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_to_take_rt_mutex</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">waiter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We have to be careful here if the atomic speedups are</span>
<span class="cm">	 * enabled, such that, when</span>
<span class="cm">	 *  - no other waiter is on the lock</span>
<span class="cm">	 *  - the lock has been released since we did the cmpxchg</span>
<span class="cm">	 * the lock can be released or taken while we are doing the</span>
<span class="cm">	 * checks and marking the lock with RT_MUTEX_HAS_WAITERS.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The atomic acquire/release aware variant of</span>
<span class="cm">	 * mark_rt_mutex_waiters uses a cmpxchg loop. After setting</span>
<span class="cm">	 * the WAITERS bit, the atomic release / acquire can not</span>
<span class="cm">	 * happen anymore and lock-&gt;wait_lock protects us from the</span>
<span class="cm">	 * non-atomic case.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note, that this might set lock-&gt;owner =</span>
<span class="cm">	 * RT_MUTEX_HAS_WAITERS in the case the lock is not contended</span>
<span class="cm">	 * any more. This is fixed up when we take the ownership.</span>
<span class="cm">	 * This is the transitional state explained at the top of this file.</span>
<span class="cm">	 */</span>
	<span class="n">mark_rt_mutex_waiters</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt_mutex_owner</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It will get the lock because of one of these conditions:</span>
<span class="cm">	 * 1) there is no waiter</span>
<span class="cm">	 * 2) higher priority than waiters</span>
<span class="cm">	 * 3) it is top waiter</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt_mutex_has_waiters</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&gt;=</span> <span class="n">rt_mutex_top_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">list_entry</span><span class="p">.</span><span class="n">prio</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">waiter</span> <span class="o">||</span> <span class="n">waiter</span> <span class="o">!=</span> <span class="n">rt_mutex_top_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">waiter</span> <span class="o">||</span> <span class="n">rt_mutex_has_waiters</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">top</span><span class="p">;</span>

		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* remove the queued waiter. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waiter</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">plist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_list</span><span class="p">);</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_blocked_on</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We have to enqueue the top waiter(if it exists) into</span>
<span class="cm">		 * task-&gt;pi_waiters list.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt_mutex_has_waiters</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">top</span> <span class="o">=</span> <span class="n">rt_mutex_top_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">top</span><span class="o">-&gt;</span><span class="n">pi_list_entry</span><span class="p">.</span><span class="n">prio</span> <span class="o">=</span> <span class="n">top</span><span class="o">-&gt;</span><span class="n">list_entry</span><span class="p">.</span><span class="n">prio</span><span class="p">;</span>
			<span class="n">plist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">top</span><span class="o">-&gt;</span><span class="n">pi_list_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_waiters</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* We got the lock. */</span>
	<span class="n">debug_rt_mutex_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">rt_mutex_set_owner</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>

	<span class="n">rt_mutex_deadlock_account_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Task blocks on lock.</span>
<span class="cm"> *</span>
<span class="cm"> * Prepare waiter and propagate pi chain</span>
<span class="cm"> *</span>
<span class="cm"> * This must be called with lock-&gt;wait_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">task_blocks_on_rt_mutex</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">waiter</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">detect_deadlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">owner</span> <span class="o">=</span> <span class="n">rt_mutex_owner</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">top_waiter</span> <span class="o">=</span> <span class="n">waiter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chain_walk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__rt_mutex_adjust_prio</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>
	<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="n">lock</span><span class="p">;</span>
	<span class="n">plist_node_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list_entry</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">);</span>
	<span class="n">plist_node_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">pi_list_entry</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">);</span>

	<span class="cm">/* Get the top priority waiter on the lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt_mutex_has_waiters</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span>
		<span class="n">top_waiter</span> <span class="o">=</span> <span class="n">rt_mutex_top_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">plist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_list</span><span class="p">);</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_blocked_on</span> <span class="o">=</span> <span class="n">waiter</span><span class="p">;</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">owner</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">waiter</span> <span class="o">==</span> <span class="n">rt_mutex_top_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">plist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">top_waiter</span><span class="o">-&gt;</span><span class="n">pi_list_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pi_waiters</span><span class="p">);</span>
		<span class="n">plist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">pi_list_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pi_waiters</span><span class="p">);</span>

		<span class="n">__rt_mutex_adjust_prio</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pi_blocked_on</span><span class="p">)</span>
			<span class="n">chain_walk</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">debug_rt_mutex_detect_deadlock</span><span class="p">(</span><span class="n">waiter</span><span class="p">,</span> <span class="n">detect_deadlock</span><span class="p">))</span>
		<span class="n">chain_walk</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chain_walk</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The owner can&#39;t disappear while holding a lock,</span>
<span class="cm">	 * so the owner struct is protected by wait_lock.</span>
<span class="cm">	 * Gets dropped in rt_mutex_adjust_prio_chain()!</span>
<span class="cm">	 */</span>
	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">rt_mutex_adjust_prio_chain</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="n">detect_deadlock</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">waiter</span><span class="p">,</span>
					 <span class="n">task</span><span class="p">);</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wake up the next waiter on the lock.</span>
<span class="cm"> *</span>
<span class="cm"> * Remove the top waiter from the current tasks waiter list and wake it up.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with lock-&gt;wait_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wakeup_next_waiter</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">waiter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">waiter</span> <span class="o">=</span> <span class="n">rt_mutex_top_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove it from current-&gt;pi_waiters. We do not adjust a</span>
<span class="cm">	 * possible priority boost right now. We execute wakeup in the</span>
<span class="cm">	 * boosted mode and go back to normal after releasing</span>
<span class="cm">	 * lock-&gt;wait_lock.</span>
<span class="cm">	 */</span>
	<span class="n">plist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">pi_list_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pi_waiters</span><span class="p">);</span>

	<span class="n">rt_mutex_set_owner</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a waiter from a lock and give up</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with lock-&gt;wait_lock held and</span>
<span class="cm"> * have just failed to try_to_take_rt_mutex().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_waiter</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">waiter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="p">(</span><span class="n">waiter</span> <span class="o">==</span> <span class="n">rt_mutex_top_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">owner</span> <span class="o">=</span> <span class="n">rt_mutex_owner</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chain_walk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">plist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_list</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">pi_blocked_on</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">owner</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">plist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">pi_list_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pi_waiters</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rt_mutex_has_waiters</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

			<span class="n">next</span> <span class="o">=</span> <span class="n">rt_mutex_top_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">plist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">pi_list_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pi_waiters</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">__rt_mutex_adjust_prio</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pi_blocked_on</span><span class="p">)</span>
			<span class="n">chain_walk</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">plist_node_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">pi_list_entry</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chain_walk</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* gets dropped in rt_mutex_adjust_prio_chain()! */</span>
	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>

	<span class="n">rt_mutex_adjust_prio_chain</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Recheck the pi chain, in case we got a priority setting</span>
<span class="cm"> *</span>
<span class="cm"> * Called from sched_setscheduler</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rt_mutex_adjust_pi</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">waiter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">waiter</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_blocked_on</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">waiter</span> <span class="o">||</span> <span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list_entry</span><span class="p">.</span><span class="n">prio</span> <span class="o">==</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* gets dropped in rt_mutex_adjust_prio_chain()! */</span>
	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">rt_mutex_adjust_prio_chain</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __rt_mutex_slowlock() - Perform the wait-wake-try-to-take loop</span>
<span class="cm"> * @lock:		 the rt_mutex to take</span>
<span class="cm"> * @state:		 the state the task should block in (TASK_INTERRUPTIBLE</span>
<span class="cm"> * 			 or TASK_UNINTERRUPTIBLE)</span>
<span class="cm"> * @timeout:		 the pre-initialized and started timer, or NULL for none</span>
<span class="cm"> * @waiter:		 the pre-initialized rt_mutex_waiter</span>
<span class="cm"> *</span>
<span class="cm"> * lock-&gt;wait_lock must be held by the caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__sched</span>
<span class="nf">__rt_mutex_slowlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="o">*</span><span class="n">timeout</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">waiter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/* Try to acquire the lock: */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">try_to_take_rt_mutex</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">waiter</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * TASK_INTERRUPTIBLE checks for signals and</span>
<span class="cm">		 * timeout. Ignored otherwise.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Signal pending? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timeout</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>

		<span class="n">debug_rt_mutex_print_deadlock</span><span class="p">(</span><span class="n">waiter</span><span class="p">);</span>

		<span class="n">schedule_rt_mutex</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Slow path lock function:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__sched</span>
<span class="nf">rt_mutex_slowlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="o">*</span><span class="n">timeout</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">detect_deadlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="n">waiter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">debug_rt_mutex_init_waiter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="p">);</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>

	<span class="cm">/* Try to acquire the lock again: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">try_to_take_rt_mutex</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_current_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>

	<span class="cm">/* Setup the timer, when timeout != NULL */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hrtimer_start_expires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timeout</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hrtimer_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timeout</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">))</span>
			<span class="n">timeout</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">task_blocks_on_rt_mutex</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">waiter</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">detect_deadlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__rt_mutex_slowlock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">waiter</span><span class="p">);</span>

	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="n">remove_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">waiter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * try_to_take_rt_mutex() sets the waiter bit</span>
<span class="cm">	 * unconditionally. We might have to fix that up.</span>
<span class="cm">	 */</span>
	<span class="n">fixup_rt_mutex_waiters</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>

	<span class="cm">/* Remove pending timer: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">timeout</span><span class="p">))</span>
		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timeout</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">debug_rt_mutex_free_waiter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Slow path try-lock function:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">rt_mutex_slowtrylock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rt_mutex_owner</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="o">!=</span> <span class="n">current</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">try_to_take_rt_mutex</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * try_to_take_rt_mutex() sets the lock waiters</span>
<span class="cm">		 * bit unconditionally. Clean this up.</span>
<span class="cm">		 */</span>
		<span class="n">fixup_rt_mutex_waiters</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Slow path to release a rt-mutex:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__sched</span>
<span class="nf">rt_mutex_slowunlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>

	<span class="n">debug_rt_mutex_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">rt_mutex_deadlock_account_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_mutex_has_waiters</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lock</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wakeup_next_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>

	<span class="cm">/* Undo pi boosting if necessary: */</span>
	<span class="n">rt_mutex_adjust_prio</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * debug aware fast / slowpath lock,trylock,unlock</span>
<span class="cm"> *</span>
<span class="cm"> * The atomic acquire/release ops are compiled away, when either the</span>
<span class="cm"> * architecture does not support cmpxchg or when debugging is enabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">rt_mutex_fastlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">detect_deadlock</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">slowfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="o">*</span><span class="n">timeout</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">detect_deadlock</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">detect_deadlock</span> <span class="o">&amp;&amp;</span> <span class="n">likely</span><span class="p">(</span><span class="n">rt_mutex_cmpxchg</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">current</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rt_mutex_deadlock_account_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="n">slowfn</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">detect_deadlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">rt_mutex_timed_fastlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="o">*</span><span class="n">timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="n">detect_deadlock</span><span class="p">,</span>
			<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">slowfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="o">*</span><span class="n">timeout</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">detect_deadlock</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">detect_deadlock</span> <span class="o">&amp;&amp;</span> <span class="n">likely</span><span class="p">(</span><span class="n">rt_mutex_cmpxchg</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">current</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rt_mutex_deadlock_account_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="n">slowfn</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">detect_deadlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">rt_mutex_fasttrylock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">slowfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rt_mutex_cmpxchg</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">current</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rt_mutex_deadlock_account_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">slowfn</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">rt_mutex_fastunlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
		    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">slowfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rt_mutex_cmpxchg</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)))</span>
		<span class="n">rt_mutex_deadlock_account_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">slowfn</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rt_mutex_lock - lock a rt_mutex</span>
<span class="cm"> *</span>
<span class="cm"> * @lock: the rt_mutex to be locked</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__sched</span> <span class="nf">rt_mutex_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">rt_mutex_fastlock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rt_mutex_slowlock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt_mutex_lock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rt_mutex_lock_interruptible - lock a rt_mutex interruptible</span>
<span class="cm"> *</span>
<span class="cm"> * @lock: 		the rt_mutex to be locked</span>
<span class="cm"> * @detect_deadlock:	deadlock detection on/off</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  0 		on success</span>
<span class="cm"> * -EINTR 	when interrupted by a signal</span>
<span class="cm"> * -EDEADLK	when the lock would deadlock (when deadlock detection is on)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__sched</span> <span class="nf">rt_mutex_lock_interruptible</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
						 <span class="kt">int</span> <span class="n">detect_deadlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">rt_mutex_fastlock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">,</span>
				 <span class="n">detect_deadlock</span><span class="p">,</span> <span class="n">rt_mutex_slowlock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt_mutex_lock_interruptible</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rt_mutex_timed_lock - lock a rt_mutex interruptible</span>
<span class="cm"> *			the timeout structure is provided</span>
<span class="cm"> *			by the caller</span>
<span class="cm"> *</span>
<span class="cm"> * @lock: 		the rt_mutex to be locked</span>
<span class="cm"> * @timeout:		timeout structure or NULL (no timeout)</span>
<span class="cm"> * @detect_deadlock:	deadlock detection on/off</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  0 		on success</span>
<span class="cm"> * -EINTR 	when interrupted by a signal</span>
<span class="cm"> * -ETIMEDOUT	when the timeout expired</span>
<span class="cm"> * -EDEADLK	when the lock would deadlock (when deadlock detection is on)</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">rt_mutex_timed_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="o">*</span><span class="n">timeout</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">detect_deadlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">rt_mutex_timed_fastlock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span>
				       <span class="n">detect_deadlock</span><span class="p">,</span> <span class="n">rt_mutex_slowlock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt_mutex_timed_lock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rt_mutex_trylock - try to lock a rt_mutex</span>
<span class="cm"> *</span>
<span class="cm"> * @lock:	the rt_mutex to be locked</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 on success and 0 on contention</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__sched</span> <span class="nf">rt_mutex_trylock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rt_mutex_fasttrylock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">rt_mutex_slowtrylock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt_mutex_trylock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rt_mutex_unlock - unlock a rt_mutex</span>
<span class="cm"> *</span>
<span class="cm"> * @lock: the rt_mutex to be unlocked</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__sched</span> <span class="nf">rt_mutex_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rt_mutex_fastunlock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">rt_mutex_slowunlock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt_mutex_unlock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rt_mutex_destroy - mark a mutex unusable</span>
<span class="cm"> * @lock: the mutex to be destroyed</span>
<span class="cm"> *</span>
<span class="cm"> * This function marks the mutex uninitialized, and any subsequent</span>
<span class="cm"> * use of the mutex is forbidden. The mutex must not be locked when</span>
<span class="cm"> * this function is called.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rt_mutex_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">rt_mutex_is_locked</span><span class="p">(</span><span class="n">lock</span><span class="p">));</span>
<span class="cp">#ifdef CONFIG_DEBUG_RT_MUTEXES</span>
	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rt_mutex_destroy</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __rt_mutex_init - initialize the rt lock</span>
<span class="cm"> *</span>
<span class="cm"> * @lock: the rt lock to be initialized</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize the rt lock to unlocked state.</span>
<span class="cm"> *</span>
<span class="cm"> * Initializing of a locked rt lock is not allowed</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__rt_mutex_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>
	<span class="n">plist_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_list</span><span class="p">);</span>

	<span class="n">debug_rt_mutex_init</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__rt_mutex_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rt_mutex_init_proxy_locked - initialize and lock a rt_mutex on behalf of a</span>
<span class="cm"> *				proxy owner</span>
<span class="cm"> *</span>
<span class="cm"> * @lock: 	the rt_mutex to be locked</span>
<span class="cm"> * @proxy_owner:the task to set as owner</span>
<span class="cm"> *</span>
<span class="cm"> * No locking. Caller has to do serializing itself</span>
<span class="cm"> * Special API call for PI-futex support</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rt_mutex_init_proxy_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">proxy_owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__rt_mutex_init</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">debug_rt_mutex_proxy_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">proxy_owner</span><span class="p">);</span>
	<span class="n">rt_mutex_set_owner</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">proxy_owner</span><span class="p">);</span>
	<span class="n">rt_mutex_deadlock_account_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">proxy_owner</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rt_mutex_proxy_unlock - release a lock on behalf of owner</span>
<span class="cm"> *</span>
<span class="cm"> * @lock: 	the rt_mutex to be locked</span>
<span class="cm"> *</span>
<span class="cm"> * No locking. Caller has to do serializing itself</span>
<span class="cm"> * Special API call for PI-futex support</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rt_mutex_proxy_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">proxy_owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_rt_mutex_proxy_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">rt_mutex_set_owner</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">rt_mutex_deadlock_account_unlock</span><span class="p">(</span><span class="n">proxy_owner</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rt_mutex_start_proxy_lock() - Start lock acquisition for another task</span>
<span class="cm"> * @lock:		the rt_mutex to take</span>
<span class="cm"> * @waiter:		the pre-initialized rt_mutex_waiter</span>
<span class="cm"> * @task:		the task to prepare</span>
<span class="cm"> * @detect_deadlock:	perform deadlock detection (1) or not (0)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  0 - task blocked on lock</span>
<span class="cm"> *  1 - acquired the lock for task, caller should wake it up</span>
<span class="cm"> * &lt;0 - error</span>
<span class="cm"> *</span>
<span class="cm"> * Special API call for FUTEX_REQUEUE_PI support.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">rt_mutex_start_proxy_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">waiter</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">detect_deadlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">try_to_take_rt_mutex</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">task_blocks_on_rt_mutex</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">waiter</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">detect_deadlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rt_mutex_owner</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Reset the return value. We might have</span>
<span class="cm">		 * returned with -EDEADLK and the owner</span>
<span class="cm">		 * released the lock while we were walking the</span>
<span class="cm">		 * pi chain.  Let the waiter sort it out.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="n">remove_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">waiter</span><span class="p">);</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>

	<span class="n">debug_rt_mutex_print_deadlock</span><span class="p">(</span><span class="n">waiter</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rt_mutex_next_owner - return the next owner of the lock</span>
<span class="cm"> *</span>
<span class="cm"> * @lock: the rt lock query</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the next owner of the lock or NULL</span>
<span class="cm"> *</span>
<span class="cm"> * Caller has to serialize against other accessors to the lock</span>
<span class="cm"> * itself.</span>
<span class="cm"> *</span>
<span class="cm"> * Special API call for PI-futex support</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">rt_mutex_next_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_mutex_has_waiters</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rt_mutex_top_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rt_mutex_finish_proxy_lock() - Complete lock acquisition</span>
<span class="cm"> * @lock:		the rt_mutex we were woken on</span>
<span class="cm"> * @to:			the timeout, null if none. hrtimer should already have</span>
<span class="cm"> * 			been started.</span>
<span class="cm"> * @waiter:		the pre-initialized rt_mutex_waiter</span>
<span class="cm"> * @detect_deadlock:	perform deadlock detection (1) or not (0)</span>
<span class="cm"> *</span>
<span class="cm"> * Complete the lock acquisition started our behalf by another thread.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  0 - success</span>
<span class="cm"> * &lt;0 - error, one of -EINTR, -ETIMEDOUT, or -EDEADLK</span>
<span class="cm"> *</span>
<span class="cm"> * Special API call for PI-futex requeue support</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">rt_mutex_finish_proxy_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">waiter</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">detect_deadlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>

	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__rt_mutex_slowlock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">waiter</span><span class="p">);</span>

	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="n">remove_waiter</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">waiter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * try_to_take_rt_mutex() sets the waiter bit unconditionally. We might</span>
<span class="cm">	 * have to fix that up.</span>
<span class="cm">	 */</span>
	<span class="n">fixup_rt_mutex_waiters</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">wait_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
