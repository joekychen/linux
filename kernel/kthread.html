<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › kthread.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>kthread.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Kernel thread helper functions.</span>
<span class="cm"> *   Copyright (C) 2004 IBM Corporation, Rusty Russell.</span>
<span class="cm"> *</span>
<span class="cm"> * Creation is done via kthreadd, so that we get a clean environment</span>
<span class="cm"> * even if we&#39;re invoked from userspace (think modprobe, hotplug cpu,</span>
<span class="cm"> * etc.).</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/cpuset.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;trace/events/sched.h&gt;</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">kthread_create_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">kthread_create_list</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">kthreadd_task</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">kthread_create_info</span>
<span class="p">{</span>
	<span class="cm">/* Information passed to kthread() from kthreadd. */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">threadfn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="cm">/* Result passed back to kthread_create() from kthreadd. */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kthread</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">should_stop</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">exited</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define to_kthread(tsk)	\</span>
<span class="cp">	container_of((tsk)-&gt;vfork_done, struct kthread, exited)</span>

<span class="cm">/**</span>
<span class="cm"> * kthread_should_stop - should this kthread return now?</span>
<span class="cm"> *</span>
<span class="cm"> * When someone calls kthread_stop() on your kthread, it will be woken</span>
<span class="cm"> * and this will return true.  You should then return, and your return</span>
<span class="cm"> * value will be passed through to kthread_stop().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kthread_should_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">to_kthread</span><span class="p">(</span><span class="n">current</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">should_stop</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kthread_freezable_should_stop - should this freezable kthread return now?</span>
<span class="cm"> * @was_frozen: optional out parameter, indicates whether %current was frozen</span>
<span class="cm"> *</span>
<span class="cm"> * kthread_should_stop() for freezable kthreads, which will enter</span>
<span class="cm"> * refrigerator if necessary.  This function is safe from kthread_stop() /</span>
<span class="cm"> * freezer deadlock and freezable kthreads should use this function instead</span>
<span class="cm"> * of calling try_to_freeze() directly.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">kthread_freezable_should_stop</span><span class="p">(</span><span class="n">bool</span> <span class="o">*</span><span class="n">was_frozen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">frozen</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">freezing</span><span class="p">(</span><span class="n">current</span><span class="p">)))</span>
		<span class="n">frozen</span> <span class="o">=</span> <span class="n">__refrigerator</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">was_frozen</span><span class="p">)</span>
		<span class="o">*</span><span class="n">was_frozen</span> <span class="o">=</span> <span class="n">frozen</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">kthread_should_stop</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kthread_freezable_should_stop</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kthread_data - return data value specified on kthread creation</span>
<span class="cm"> * @task: kthread task in question</span>
<span class="cm"> *</span>
<span class="cm"> * Return the data value specified when kthread @task was created.</span>
<span class="cm"> * The caller is responsible for ensuring the validity of @task when</span>
<span class="cm"> * calling this function.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">kthread_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">to_kthread</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kthread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Copy data: it&#39;s on kthread&#39;s stack */</span>
	<span class="k">struct</span> <span class="n">kthread_create_info</span> <span class="o">*</span><span class="n">create</span> <span class="o">=</span> <span class="n">_create</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">threadfn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="o">=</span> <span class="n">create</span><span class="o">-&gt;</span><span class="n">threadfn</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">create</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kthread</span> <span class="n">self</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">self</span><span class="p">.</span><span class="n">should_stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="p">.</span><span class="n">exited</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">vfork_done</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">self</span><span class="p">.</span><span class="n">exited</span><span class="p">;</span>

	<span class="cm">/* OK, tell user we&#39;re spawned, wait for stop or wakeup */</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">create</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">create</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
	<span class="n">schedule</span><span class="p">();</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">should_stop</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">threadfn</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

	<span class="cm">/* we can&#39;t just return, we must preserve &quot;self&quot; on stack */</span>
	<span class="n">do_exit</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* called from do_fork() to get node information for about to be created task */</span>
<span class="kt">int</span> <span class="nf">tsk_fork_get_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span> <span class="o">==</span> <span class="n">kthreadd_task</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pref_node_fork</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">numa_node_id</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">create_kthread</span><span class="p">(</span><span class="k">struct</span> <span class="n">kthread_create_info</span> <span class="o">*</span><span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">pref_node_fork</span> <span class="o">=</span> <span class="n">create</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* We want our own signal handler (we take no signals by default). */</span>
	<span class="n">pid</span> <span class="o">=</span> <span class="n">kernel_thread</span><span class="p">(</span><span class="n">kthread</span><span class="p">,</span> <span class="n">create</span><span class="p">,</span> <span class="n">CLONE_FS</span> <span class="o">|</span> <span class="n">CLONE_FILES</span> <span class="o">|</span> <span class="n">SIGCHLD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">create</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">create</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kthread_create_on_node - create a kthread.</span>
<span class="cm"> * @threadfn: the function to run until signal_pending(current).</span>
<span class="cm"> * @data: data ptr for @threadfn.</span>
<span class="cm"> * @node: memory node number.</span>
<span class="cm"> * @namefmt: printf-style name for the thread.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: This helper function creates and names a kernel</span>
<span class="cm"> * thread.  The thread will be stopped: use wake_up_process() to start</span>
<span class="cm"> * it.  See also kthread_run().</span>
<span class="cm"> *</span>
<span class="cm"> * If thread is going to be bound on a particular cpu, give its node</span>
<span class="cm"> * in @node, to get NUMA affinity for kthread stack, or else give -1.</span>
<span class="cm"> * When woken, the thread will run @threadfn() with @data as its</span>
<span class="cm"> * argument. @threadfn() can either call do_exit() directly if it is a</span>
<span class="cm"> * standalone thread for which no one will call kthread_stop(), or</span>
<span class="cm"> * return when &#39;kthread_should_stop()&#39; is true (which means</span>
<span class="cm"> * kthread_stop() has been called).  The return value should be zero</span>
<span class="cm"> * or a negative error number; it will be passed to kthread_stop().</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a task_struct or ERR_PTR(-ENOMEM).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">kthread_create_on_node</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">threadfn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
					   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">node</span><span class="p">,</span>
					   <span class="k">const</span> <span class="kt">char</span> <span class="n">namefmt</span><span class="p">[],</span>
					   <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kthread_create_info</span> <span class="n">create</span><span class="p">;</span>

	<span class="n">create</span><span class="p">.</span><span class="n">threadfn</span> <span class="o">=</span> <span class="n">threadfn</span><span class="p">;</span>
	<span class="n">create</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">create</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">create</span><span class="p">.</span><span class="n">done</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kthread_create_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">create</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kthread_create_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kthread_create_lock</span><span class="p">);</span>

	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">kthreadd_task</span><span class="p">);</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">create</span><span class="p">.</span><span class="n">done</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">create</span><span class="p">.</span><span class="n">result</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="n">param</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>
		<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>

		<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">namefmt</span><span class="p">);</span>
		<span class="n">vsnprintf</span><span class="p">(</span><span class="n">create</span><span class="p">.</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">create</span><span class="p">.</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">),</span>
			  <span class="n">namefmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
		<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * root may have changed our (kthreadd&#39;s) priority or CPU mask.</span>
<span class="cm">		 * The kernel thread should not inherit these properties.</span>
<span class="cm">		 */</span>
		<span class="n">sched_setscheduler_nocheck</span><span class="p">(</span><span class="n">create</span><span class="p">.</span><span class="n">result</span><span class="p">,</span> <span class="n">SCHED_NORMAL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>
		<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">create</span><span class="p">.</span><span class="n">result</span><span class="p">,</span> <span class="n">cpu_all_mask</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">create</span><span class="p">.</span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kthread_create_on_node</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kthread_bind - bind a just-created kthread to a cpu.</span>
<span class="cm"> * @p: thread created by kthread_create().</span>
<span class="cm"> * @cpu: cpu (might not be online, must be possible) for @k to run on.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: This function is equivalent to set_cpus_allowed(),</span>
<span class="cm"> * except that @cpu doesn&#39;t need to be online, and the thread must be</span>
<span class="cm"> * stopped (i.e., just returned from kthread_create()).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kthread_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Must have done schedule() in kthread() before we set_task_cpu */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait_task_inactive</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* It&#39;s safe because the task is inactive. */</span>
	<span class="n">do_set_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_THREAD_BOUND</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kthread_bind</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kthread_stop - stop a thread created by kthread_create().</span>
<span class="cm"> * @k: thread created by kthread_create().</span>
<span class="cm"> *</span>
<span class="cm"> * Sets kthread_should_stop() for @k to return true, wakes it, and</span>
<span class="cm"> * waits for it to exit. This can also be called after kthread_create()</span>
<span class="cm"> * instead of calling wake_up_process(): the thread will exit without</span>
<span class="cm"> * calling threadfn().</span>
<span class="cm"> *</span>
<span class="cm"> * If threadfn() may call do_exit() itself, the caller must ensure</span>
<span class="cm"> * task_struct can&#39;t go away.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result of threadfn(), or %-EINTR if wake_up_process()</span>
<span class="cm"> * was never called.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kthread_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kthread</span> <span class="o">*</span><span class="n">kthread</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">trace_sched_kthread_stop</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>

	<span class="n">kthread</span> <span class="o">=</span> <span class="n">to_kthread</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
	<span class="n">barrier</span><span class="p">();</span> <span class="cm">/* it might have exited */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">vfork_done</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kthread</span><span class="o">-&gt;</span><span class="n">should_stop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kthread</span><span class="o">-&gt;</span><span class="n">exited</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">exit_code</span><span class="p">;</span>

	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
	<span class="n">trace_sched_kthread_stop_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kthread_stop</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kthreadd</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="cm">/* Setup a clean context for our children to inherit. */</span>
	<span class="n">set_task_comm</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="s">&quot;kthreadd&quot;</span><span class="p">);</span>
	<span class="n">ignore_signals</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">cpu_all_mask</span><span class="p">);</span>
	<span class="n">set_mems_allowed</span><span class="p">(</span><span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">]);</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_NOFREEZE</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kthread_create_list</span><span class="p">))</span>
			<span class="n">schedule</span><span class="p">();</span>
		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kthread_create_lock</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kthread_create_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">kthread_create_info</span> <span class="o">*</span><span class="n">create</span><span class="p">;</span>

			<span class="n">create</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">kthread_create_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">kthread_create_info</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">create</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kthread_create_lock</span><span class="p">);</span>

			<span class="n">create_kthread</span><span class="p">(</span><span class="n">create</span><span class="p">);</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kthread_create_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kthread_create_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__init_kthread_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">kthread_worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">lockdep_set_class_and_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
	<span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__init_kthread_worker</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kthread_worker_fn - kthread function to process kthread_worker</span>
<span class="cm"> * @worker_ptr: pointer to initialized kthread_worker</span>
<span class="cm"> *</span>
<span class="cm"> * This function can be used as @threadfn to kthread_create() or</span>
<span class="cm"> * kthread_run() with @worker_ptr argument pointing to an initialized</span>
<span class="cm"> * kthread_worker.  The started kthread will process work_list until</span>
<span class="cm"> * the it is stopped with kthread_stop().  A kthread can also call</span>
<span class="cm"> * this function directly after extra initialization.</span>
<span class="cm"> *</span>
<span class="cm"> * Different kthreads can be used for the same kthread_worker as long</span>
<span class="cm"> * as there&#39;s only one kthread attached to it at any given time.  A</span>
<span class="cm"> * kthread_worker without an attached kthread simply collects queued</span>
<span class="cm"> * kthread_works.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kthread_worker_fn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">worker_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kthread_worker</span> <span class="o">*</span><span class="n">worker</span> <span class="o">=</span> <span class="n">worker_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kthread_work</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
	<span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
<span class="nl">repeat:</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>	<span class="cm">/* mb paired w/ kthread_stop */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">work</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">work</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kthread_work</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
		<span class="n">work</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
		<span class="n">smp_wmb</span><span class="p">();</span>	<span class="cm">/* wmb worker-b0 paired with flush-b1 */</span>
		<span class="n">work</span><span class="o">-&gt;</span><span class="n">done_seq</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">queue_seq</span><span class="p">;</span>
		<span class="n">smp_mb</span><span class="p">();</span>	<span class="cm">/* mb worker-b1 paired with flush-b0 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">flushing</span><span class="p">))</span>
			<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">freezing</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="n">schedule</span><span class="p">();</span>

	<span class="n">try_to_freeze</span><span class="p">();</span>
	<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kthread_worker_fn</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * queue_kthread_work - queue a kthread_work</span>
<span class="cm"> * @worker: target kthread_worker</span>
<span class="cm"> * @work: kthread_work to queue</span>
<span class="cm"> *</span>
<span class="cm"> * Queue @work to work processor @task for async execution.  @task</span>
<span class="cm"> * must have been created with kthread_worker_create().  Returns %true</span>
<span class="cm"> * if @work was successfully queued, %false if it was already pending.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">queue_kthread_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">kthread_worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">kthread_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
		<span class="n">work</span><span class="o">-&gt;</span><span class="n">queue_seq</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">))</span>
			<span class="n">wake_up_process</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">queue_kthread_work</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * flush_kthread_work - flush a kthread_work</span>
<span class="cm"> * @work: work to flush</span>
<span class="cm"> *</span>
<span class="cm"> * If @work is queued or executing, wait for it to finish execution.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">flush_kthread_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">kthread_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">queue_seq</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">flushing</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * mb flush-b0 paired with worker-b1, to make sure either</span>
<span class="cm">	 * worker sees the above increment or we see done_seq update.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb__after_atomic_inc</span><span class="p">();</span>

	<span class="cm">/* A - B &lt;= 0 tests whether B is in front of A regardless of overflow */</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">,</span> <span class="n">seq</span> <span class="o">-</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">done_seq</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">flushing</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * rmb flush-b1 paired with worker-b0, to make sure our caller</span>
<span class="cm">	 * sees every change made by work-&gt;func().</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb__after_atomic_dec</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">flush_kthread_work</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">kthread_flush_work</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kthread_work</span>	<span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">done</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kthread_flush_work_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">kthread_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kthread_flush_work</span> <span class="o">*</span><span class="n">fwork</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kthread_flush_work</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fwork</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * flush_kthread_worker - flush all current works on a kthread_worker</span>
<span class="cm"> * @worker: worker to flush</span>
<span class="cm"> *</span>
<span class="cm"> * Wait until all currently executing or pending works on @worker are</span>
<span class="cm"> * finished.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">flush_kthread_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">kthread_worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kthread_flush_work</span> <span class="n">fwork</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">KTHREAD_WORK_INIT</span><span class="p">(</span><span class="n">fwork</span><span class="p">.</span><span class="n">work</span><span class="p">,</span> <span class="n">kthread_flush_work_fn</span><span class="p">),</span>
		<span class="n">COMPLETION_INITIALIZER_ONSTACK</span><span class="p">(</span><span class="n">fwork</span><span class="p">.</span><span class="n">done</span><span class="p">),</span>
	<span class="p">};</span>

	<span class="n">queue_kthread_work</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fwork</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fwork</span><span class="p">.</span><span class="n">done</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">flush_kthread_worker</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
