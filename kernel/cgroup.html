<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › cgroup.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>cgroup.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Generic process-grouping system.</span>
<span class="cm"> *</span>
<span class="cm"> *  Based originally on the cpuset system, extracted by Paul Menage</span>
<span class="cm"> *  Copyright (C) 2006 Google, Inc</span>
<span class="cm"> *</span>
<span class="cm"> *  Notifications support</span>
<span class="cm"> *  Copyright (C) 2009 Nokia Corporation</span>
<span class="cm"> *  Author: Kirill A. Shutemov</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright notices from the original cpuset code:</span>
<span class="cm"> *  --------------------------------------------------</span>
<span class="cm"> *  Copyright (C) 2003 BULL SA.</span>
<span class="cm"> *  Copyright (C) 2004-2006 Silicon Graphics, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> *  Portions derived from Patrick Mochel&#39;s sysfs code.</span>
<span class="cm"> *  sysfs is Copyright (c) 2001-3 Patrick Mochel</span>
<span class="cm"> *</span>
<span class="cm"> *  2003-10-10 Written by Simon Derr.</span>
<span class="cm"> *  2003-10-22 Updates by Stephen Hemminger.</span>
<span class="cm"> *  2004 May-July Rework by Paul Jackson.</span>
<span class="cm"> *  ---------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> *  This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> *  License.  See the file COPYING in the main directory of the Linux</span>
<span class="cm"> *  distribution for more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/cgroup.h&gt;</span>
<span class="cp">#include &lt;linux/cred.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/init_task.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/magic.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/sort.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/delayacct.h&gt;</span>
<span class="cp">#include &lt;linux/cgroupstats.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/pid_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt; </span><span class="cm">/* TODO: replace with more sophisticated array */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/eventfd.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/flex_array.h&gt; </span><span class="cm">/* used in cgroup_attach_proc */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cm">/* css deactivation bias, makes css-&gt;refcnt negative to deny new trygets */</span>
<span class="cp">#define CSS_DEACT_BIAS		INT_MIN</span>

<span class="cm">/*</span>
<span class="cm"> * cgroup_mutex is the master lock.  Any modification to cgroup or its</span>
<span class="cm"> * hierarchy must be performed while holding it.</span>
<span class="cm"> *</span>
<span class="cm"> * cgroup_root_mutex nests inside cgroup_mutex and should be held to modify</span>
<span class="cm"> * cgroupfs_root of any cgroup hierarchy - subsys list, flags,</span>
<span class="cm"> * release_agent_path and so on.  Modifying requires both cgroup_mutex and</span>
<span class="cm"> * cgroup_root_mutex.  Readers can acquire either of the two.  This is to</span>
<span class="cm"> * break the following locking order cycle.</span>
<span class="cm"> *</span>
<span class="cm"> *  A. cgroup_mutex -&gt; cred_guard_mutex -&gt; s_type-&gt;i_mutex_key -&gt; namespace_sem</span>
<span class="cm"> *  B. namespace_sem -&gt; cgroup_mutex</span>
<span class="cm"> *</span>
<span class="cm"> * B happens only through cgroup_show_options() and using cgroup_root_mutex</span>
<span class="cm"> * breaks it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">cgroup_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">cgroup_root_mutex</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Generate an array of cgroup subsystem pointers. At boot time, this is</span>
<span class="cm"> * populated up to CGROUP_BUILTIN_SUBSYS_COUNT, and modular subsystems are</span>
<span class="cm"> * registered after that. The mutable section of this array is protected by</span>
<span class="cm"> * cgroup_mutex.</span>
<span class="cm"> */</span>
<span class="cp">#define SUBSYS(_x) &amp;_x ## _subsys,</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">subsys</span><span class="p">[</span><span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#include &lt;linux/cgroup_subsys.h&gt;</span>
<span class="p">};</span>

<span class="cp">#define MAX_CGROUP_ROOT_NAMELEN 64</span>

<span class="cm">/*</span>
<span class="cm"> * A cgroupfs_root represents the root of a cgroup hierarchy,</span>
<span class="cm"> * and may be associated with a superblock to form an active</span>
<span class="cm"> * hierarchy</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The bitmask of subsystems intended to be attached to this</span>
<span class="cm">	 * hierarchy</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">subsys_bits</span><span class="p">;</span>

	<span class="cm">/* Unique id for this hierarchy. */</span>
	<span class="kt">int</span> <span class="n">hierarchy_id</span><span class="p">;</span>

	<span class="cm">/* The bitmask of subsystems currently attached to this hierarchy */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">actual_subsys_bits</span><span class="p">;</span>

	<span class="cm">/* A list running through the attached subsystems */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">subsys_list</span><span class="p">;</span>

	<span class="cm">/* The root cgroup for this hierarchy */</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="n">top_cgroup</span><span class="p">;</span>

	<span class="cm">/* Tracks how many cgroups are currently defined in hierarchy.*/</span>
	<span class="kt">int</span> <span class="n">number_of_cgroups</span><span class="p">;</span>

	<span class="cm">/* A list running through the active hierarchies */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">root_list</span><span class="p">;</span>

	<span class="cm">/* All cgroups on this root, cgroup_mutex protected */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">allcg_list</span><span class="p">;</span>

	<span class="cm">/* Hierarchy-specific flags */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* The path to use for release notifications. */</span>
	<span class="kt">char</span> <span class="n">release_agent_path</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>

	<span class="cm">/* The name for this hierarchy - may be empty */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">MAX_CGROUP_ROOT_NAMELEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The &quot;rootnode&quot; hierarchy is the &quot;dummy hierarchy&quot;, reserved for the</span>
<span class="cm"> * subsystems that are otherwise unattached - it never has more than a</span>
<span class="cm"> * single cgroup, and all tasks are part of that cgroup.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="n">rootnode</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * cgroupfs file entry, pointed to from leaf dentry-&gt;d_fsdata.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cfent</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span>			<span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cftype</span>			<span class="o">*</span><span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * CSS ID -- ID per subsys&#39;s Cgroup Subsys State(CSS). used only when</span>
<span class="cm"> * cgroup_subsys-&gt;use_id != 0.</span>
<span class="cm"> */</span>
<span class="cp">#define CSS_ID_MAX	(65535)</span>
<span class="k">struct</span> <span class="n">css_id</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The css to which this ID points. This pointer is set to valid value</span>
<span class="cm">	 * after cgroup is populated. If cgroup is removed, this will be NULL.</span>
<span class="cm">	 * This pointer is expected to be RCU-safe because destroy()</span>
<span class="cm">	 * is called after synchronize_rcu(). But for safe use, css_is_removed()</span>
<span class="cm">	 * css_tryget() should be used for avoiding race.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">css</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * ID of this css.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">id</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Depth in hierarchy which this ID belongs to.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">depth</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * ID is freed by RCU. (and lookup routine is RCU safe.)</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu_head</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Hierarchy of CSS ID belongs to.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* Array of Length (depth+1) */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * cgroup_event represents events which userspace want to receive.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cgroup_event</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Cgroup which the event belongs to.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Control file which the event associated.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * eventfd to signal userspace about the event.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">eventfd_ctx</span> <span class="o">*</span><span class="n">eventfd</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Each of these stored in a list by the cgroup.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * All fields below needed to unregister event when</span>
<span class="cm">	 * userspace closes eventfd.</span>
<span class="cm">	 */</span>
	<span class="n">poll_table</span> <span class="n">pt</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wqh</span><span class="p">;</span>
	<span class="n">wait_queue_t</span> <span class="n">wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">remove</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The list of hierarchy roots */</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">roots</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">root_count</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_IDA</span><span class="p">(</span><span class="n">hierarchy_ida</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">next_hierarchy_id</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">hierarchy_id_lock</span><span class="p">);</span>

<span class="cm">/* dummytop is a shorthand for the dummy hierarchy&#39;s top cgroup */</span>
<span class="cp">#define dummytop (&amp;rootnode.top_cgroup)</span>

<span class="cm">/* This flag indicates whether tasks in the fork and exit paths should</span>
<span class="cm"> * check for fork/exit handlers to call. This avoids us having to do</span>
<span class="cm"> * extra work in the fork/exit path if none of the subsystems need to</span>
<span class="cm"> * be called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">need_forkexit_callback</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PROVE_LOCKING</span>
<span class="kt">int</span> <span class="nf">cgroup_lock_is_held</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* #ifdef CONFIG_PROVE_LOCKING */</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">cgroup_lock_is_held</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* #else #ifdef CONFIG_PROVE_LOCKING */</span><span class="cp"></span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cgroup_lock_is_held</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">css_unbias_refcnt</span><span class="p">(</span><span class="kt">int</span> <span class="n">refcnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">refcnt</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">refcnt</span> <span class="o">:</span> <span class="n">refcnt</span> <span class="o">-</span> <span class="n">CSS_DEACT_BIAS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* the current nr of refs, always &gt;= 0 whether @css is deactivated or not */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">css_refcnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">css_unbias_refcnt</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* convenient tests for these bits */</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cgroup_is_removed</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">CGRP_REMOVED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* bits in struct cgroupfs_root flags field */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">ROOT_NOPREFIX</span><span class="p">,</span> <span class="cm">/* mounted subsystems have no named prefix */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_is_releasable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">bits</span> <span class="o">=</span>
		<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CGRP_RELEASABLE</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CGRP_NOTIFY_ON_RELEASE</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">bits</span><span class="p">)</span> <span class="o">==</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">notify_on_release</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">CGRP_NOTIFY_ON_RELEASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">clone_children</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">CGRP_CLONE_CHILDREN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * for_each_subsys() allows you to iterate on each subsystem attached to</span>
<span class="cm"> * an active hierarchy</span>
<span class="cm"> */</span>
<span class="cp">#define for_each_subsys(_root, _ss) \</span>
<span class="cp">list_for_each_entry(_ss, &amp;_root-&gt;subsys_list, sibling)</span>

<span class="cm">/* for_each_active_root() allows you to iterate across the active hierarchies */</span>
<span class="cp">#define for_each_active_root(_root) \</span>
<span class="cp">list_for_each_entry(_root, &amp;roots, root_list)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="nf">__d_cgrp</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfent</span> <span class="o">*</span><span class="nf">__d_cfe</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="nf">__d_cft</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__d_cfe</span><span class="p">(</span><span class="n">dentry</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* the list of cgroups eligible for automatic release. Protected by</span>
<span class="cm"> * release_list_lock */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">release_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_RAW_SPINLOCK</span><span class="p">(</span><span class="n">release_list_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">cgroup_release_agent</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">release_agent_work</span><span class="p">,</span> <span class="n">cgroup_release_agent</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">check_for_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">);</span>

<span class="cm">/* Link structure for associating css_set objects with cgroups */</span>
<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * List running through cg_cgroup_links associated with a</span>
<span class="cm">	 * cgroup, anchored on cgroup-&gt;css_sets</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cgrp_link_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * List running through cg_cgroup_links pointing at a</span>
<span class="cm">	 * single css_set object, anchored on css_set-&gt;cg_links</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cg_link_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">cg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The default css_set - used by init and its children prior to any</span>
<span class="cm"> * hierarchies being mounted. It contains a pointer to the root state</span>
<span class="cm"> * for each subsystem. Also used to anchor the list of css_sets. Not</span>
<span class="cm"> * reference-counted, to improve performance when child cgroups</span>
<span class="cm"> * haven&#39;t been created.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">css_set</span> <span class="n">init_css_set</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="n">init_css_set_link</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">cgroup_init_idr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">);</span>

<span class="cm">/* css_set_lock protects the list of css_set objects, and the</span>
<span class="cm"> * chain of tasks off each css_set.  Nests outside task-&gt;alloc_lock</span>
<span class="cm"> * due to cgroup_iter_start() */</span>
<span class="k">static</span> <span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">css_set_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">css_set_count</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * hash table for cgroup groups. This improves the performance to find</span>
<span class="cm"> * an existing css_set. This hash doesn&#39;t (currently) take into</span>
<span class="cm"> * account cgroups in empty hierarchies.</span>
<span class="cm"> */</span>
<span class="cp">#define CSS_SET_HASH_BITS	7</span>
<span class="cp">#define CSS_SET_TABLE_SIZE	(1 &lt;&lt; CSS_SET_HASH_BITS)</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">css_set_table</span><span class="p">[</span><span class="n">CSS_SET_TABLE_SIZE</span><span class="p">];</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="nf">css_set_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">tmp</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">css</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">^</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">hash_long</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">CSS_SET_HASH_BITS</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">css_set_table</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* We don&#39;t maintain the lists running through each css_set to its</span>
<span class="cm"> * task until after the first call to cgroup_iter_start(). This</span>
<span class="cm"> * reduces the fork()/exit() overhead for people who have cgroups</span>
<span class="cm"> * compiled into their kernel but not actually in use */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">use_task_css_set_links</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__put_css_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">cg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">taskexit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">saved_link</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ensure that the refcount doesn&#39;t hit zero while any readers</span>
<span class="cm">	 * can see it. Similar to atomic_dec_and_lock(), but for an</span>
<span class="cm">	 * rwlock</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This css_set is dead. unlink it and release cgroup refcounts */</span>
	<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
	<span class="n">css_set_count</span><span class="o">--</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">saved_link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">cg_links</span><span class="p">,</span>
				 <span class="n">cg_link_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">cg_link_list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">cgrp_link_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">notify_on_release</span><span class="p">(</span><span class="n">cgrp</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">taskexit</span><span class="p">)</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">CGRP_RELEASABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">check_for_release</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="n">rcu_head</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * refcounted get/put for css_set objects</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">get_css_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">cg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_css_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">cg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__put_css_set</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_css_set_taskexit</span><span class="p">(</span><span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">cg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__put_css_set</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * compare_css_sets - helper function for find_existing_css_set().</span>
<span class="cm"> * @cg: candidate css_set being tested</span>
<span class="cm"> * @old_cg: existing css_set for a task</span>
<span class="cm"> * @new_cgrp: cgroup that&#39;s being entered by the task</span>
<span class="cm"> * @template: desired set of css pointers in css_set (pre-calculated)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if &quot;cg&quot; matches &quot;old_cg&quot; except for the hierarchy</span>
<span class="cm"> * which &quot;new_cgrp&quot; belongs to, for which it should match &quot;new_cgrp&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">compare_css_sets</span><span class="p">(</span><span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">cg</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">old_cg</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">new_cgrp</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">template</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">l1</span><span class="p">,</span> <span class="o">*</span><span class="n">l2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">cg</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Not all subsystems matched */</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compare cgroup pointers in order to distinguish between</span>
<span class="cm">	 * different cgroups in heirarchies with no subsystems. We</span>
<span class="cm">	 * could get by with just this check alone (and skip the</span>
<span class="cm">	 * memcmp above) but on most setups the memcmp check will</span>
<span class="cm">	 * avoid the need for this more expensive check on almost all</span>
<span class="cm">	 * candidates.</span>
<span class="cm">	 */</span>

	<span class="n">l1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">cg_links</span><span class="p">;</span>
	<span class="n">l2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">old_cg</span><span class="o">-&gt;</span><span class="n">cg_links</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">cgl1</span><span class="p">,</span> <span class="o">*</span><span class="n">cgl2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cg1</span><span class="p">,</span> <span class="o">*</span><span class="n">cg2</span><span class="p">;</span>

		<span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="cm">/* See if we reached the end - both lists are equal length. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l1</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">cg_links</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">l2</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">old_cg</span><span class="o">-&gt;</span><span class="n">cg_links</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">l2</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">old_cg</span><span class="o">-&gt;</span><span class="n">cg_links</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Locate the cgroups associated with these links. */</span>
		<span class="n">cgl1</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cg_cgroup_link</span><span class="p">,</span> <span class="n">cg_link_list</span><span class="p">);</span>
		<span class="n">cgl2</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cg_cgroup_link</span><span class="p">,</span> <span class="n">cg_link_list</span><span class="p">);</span>
		<span class="n">cg1</span> <span class="o">=</span> <span class="n">cgl1</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="p">;</span>
		<span class="n">cg2</span> <span class="o">=</span> <span class="n">cgl2</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="p">;</span>
		<span class="cm">/* Hierarchies should be linked in the same order. */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cg1</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">!=</span> <span class="n">cg2</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If this hierarchy is the hierarchy of the cgroup</span>
<span class="cm">		 * that&#39;s changing, then we need to check that this</span>
<span class="cm">		 * css_set points to the new cgroup; if it&#39;s any other</span>
<span class="cm">		 * hierarchy, then this css_set should point to the</span>
<span class="cm">		 * same cgroup as the old css_set.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cg1</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">==</span> <span class="n">new_cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cg1</span> <span class="o">!=</span> <span class="n">new_cgrp</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cg1</span> <span class="o">!=</span> <span class="n">cg2</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find_existing_css_set() is a helper for</span>
<span class="cm"> * find_css_set(), and checks to see whether an existing</span>
<span class="cm"> * css_set is suitable.</span>
<span class="cm"> *</span>
<span class="cm"> * oldcg: the cgroup group that we&#39;re using before the cgroup</span>
<span class="cm"> * transition</span>
<span class="cm"> *</span>
<span class="cm"> * cgrp: the cgroup that we&#39;re moving into</span>
<span class="cm"> *</span>
<span class="cm"> * template: location in which to build the desired set of subsystem</span>
<span class="cm"> * state objects for the new cgroup group</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="nf">find_existing_css_set</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">oldcg</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">template</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hhead</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">cg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Build the set of subsystem state objects that we want to see in the</span>
<span class="cm">	 * new css_set. while subsystems can change globally, the entries here</span>
<span class="cm">	 * won&#39;t change, so no need for locking.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">subsys_bits</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Subsystem is in this hierarchy. So we want</span>
<span class="cm">			 * the subsystem state from the new</span>
<span class="cm">			 * cgroup */</span>
			<span class="n">template</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Subsystem is not in this hierarchy, so we</span>
<span class="cm">			 * don&#39;t want to change the subsystem state */</span>
			<span class="n">template</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldcg</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">hhead</span> <span class="o">=</span> <span class="n">css_set_hash</span><span class="p">(</span><span class="n">template</span><span class="p">);</span>
	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">hhead</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">compare_css_sets</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="n">oldcg</span><span class="p">,</span> <span class="n">cgrp</span><span class="p">,</span> <span class="n">template</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* This css_set matches what we need */</span>
		<span class="k">return</span> <span class="n">cg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* No existing cgroup group matched */</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_cg_links</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">saved_link</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">saved_link</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">cgrp_link_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">cgrp_link_list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * allocate_cg_links() allocates &quot;count&quot; cg_cgroup_link structures</span>
<span class="cm"> * and chains them on tmp through their cgrp_link_list fields. Returns 0 on</span>
<span class="cm"> * success or a negative error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">allocate_cg_links</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">link</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">link</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_cg_links</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">cgrp_link_list</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * link_css_set - a helper function to link a css_set to a cgroup</span>
<span class="cm"> * @tmp_cg_links: cg_cgroup_link objects allocated by allocate_cg_links()</span>
<span class="cm"> * @cg: the css_set to be linked</span>
<span class="cm"> * @cgrp: the destination cgroup</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">link_css_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp_cg_links</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">cg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">tmp_cg_links</span><span class="p">));</span>
	<span class="n">link</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">tmp_cg_links</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cg_cgroup_link</span><span class="p">,</span>
				<span class="n">cgrp_link_list</span><span class="p">);</span>
	<span class="n">link</span><span class="o">-&gt;</span><span class="n">cg</span> <span class="o">=</span> <span class="n">cg</span><span class="p">;</span>
	<span class="n">link</span><span class="o">-&gt;</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">cgrp</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">cgrp_link_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">css_sets</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Always add links to the tail of the list so that the list</span>
<span class="cm">	 * is sorted by order of hierarchy creation</span>
<span class="cm">	 */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">cg_link_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">cg_links</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find_css_set() takes an existing cgroup group and a</span>
<span class="cm"> * cgroup object, and returns a css_set object that&#39;s</span>
<span class="cm"> * equivalent to the old group, but with the given cgroup</span>
<span class="cm"> * substituted into the appropriate hierarchy. Must be called with</span>
<span class="cm"> * cgroup_mutex held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="nf">find_css_set</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">oldcg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">template</span><span class="p">[</span><span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tmp_cg_links</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hhead</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>

	<span class="cm">/* First see if we already have a cgroup group that matches</span>
<span class="cm">	 * the desired set */</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">find_existing_css_set</span><span class="p">(</span><span class="n">oldcg</span><span class="p">,</span> <span class="n">cgrp</span><span class="p">,</span> <span class="n">template</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="n">get_css_set</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Allocate all the cg_cgroup_link objects that we&#39;ll need */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">allocate_cg_links</span><span class="p">(</span><span class="n">root_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_cg_links</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">cg_links</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">);</span>
	<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>

	<span class="cm">/* Copy the set of subsystem state objects generated in</span>
<span class="cm">	 * find_existing_css_set() */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">));</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="cm">/* Add reference counts and links from the new css_set. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldcg</span><span class="o">-&gt;</span><span class="n">cg_links</span><span class="p">,</span> <span class="n">cg_link_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">==</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">)</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">cgrp</span><span class="p">;</span>
		<span class="n">link_css_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_cg_links</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_cg_links</span><span class="p">));</span>

	<span class="n">css_set_count</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Add this cgroup group to the hash table */</span>
	<span class="n">hhead</span> <span class="o">=</span> <span class="n">css_set_hash</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="n">hhead</span><span class="p">);</span>

	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the cgroup for &quot;task&quot; from the given hierarchy. Must be</span>
<span class="cm"> * called with cgroup_mutex held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="nf">task_cgroup_from_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">css</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">));</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * No need to lock the task - since we hold cgroup_mutex the</span>
<span class="cm">	 * task can&#39;t change groups, so the only thing that can happen</span>
<span class="cm">	 * is that it exits and its css is set back to init_css_set.</span>
<span class="cm">	 */</span>
	<span class="n">css</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">cgroups</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">css</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">init_css_set</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">top_cgroup</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">cg_links</span><span class="p">,</span> <span class="n">cg_link_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">==</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">res</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * There is one global cgroup mutex. We also require taking</span>
<span class="cm"> * task_lock() when dereferencing a task&#39;s cgroup subsys pointers.</span>
<span class="cm"> * See &quot;The task_lock() exception&quot;, at the end of this comment.</span>
<span class="cm"> *</span>
<span class="cm"> * A task must hold cgroup_mutex to modify cgroups.</span>
<span class="cm"> *</span>
<span class="cm"> * Any task can increment and decrement the count field without lock.</span>
<span class="cm"> * So in general, code holding cgroup_mutex can&#39;t rely on the count</span>
<span class="cm"> * field not changing.  However, if the count goes to zero, then only</span>
<span class="cm"> * cgroup_attach_task() can increment it again.  Because a count of zero</span>
<span class="cm"> * means that no tasks are currently attached, therefore there is no</span>
<span class="cm"> * way a task attached to that cgroup can fork (the other way to</span>
<span class="cm"> * increment the count).  So code holding cgroup_mutex can safely</span>
<span class="cm"> * assume that if the count is zero, it will stay zero. Similarly, if</span>
<span class="cm"> * a task holds cgroup_mutex on a cgroup with zero count, it</span>
<span class="cm"> * knows that the cgroup won&#39;t be removed, as cgroup_rmdir()</span>
<span class="cm"> * needs that mutex.</span>
<span class="cm"> *</span>
<span class="cm"> * The fork and exit callbacks cgroup_fork() and cgroup_exit(), don&#39;t</span>
<span class="cm"> * (usually) take cgroup_mutex.  These are the two most performance</span>
<span class="cm"> * critical pieces of code here.  The exception occurs on cgroup_exit(),</span>
<span class="cm"> * when a task in a notify_on_release cgroup exits.  Then cgroup_mutex</span>
<span class="cm"> * is taken, and if the cgroup count is zero, a usermode call made</span>
<span class="cm"> * to the release agent with the name of the cgroup (path relative to</span>
<span class="cm"> * the root of cgroup file system) as the argument.</span>
<span class="cm"> *</span>
<span class="cm"> * A cgroup can only be deleted if both its &#39;count&#39; of using tasks</span>
<span class="cm"> * is zero, and its list of &#39;children&#39; cgroups is empty.  Since all</span>
<span class="cm"> * tasks in the system use _some_ cgroup, and since there is always at</span>
<span class="cm"> * least one task in the system (init, pid == 1), therefore, top_cgroup</span>
<span class="cm"> * always has either children cgroups and/or using tasks.  So we don&#39;t</span>
<span class="cm"> * need a special hack to ensure that top_cgroup cannot be deleted.</span>
<span class="cm"> *</span>
<span class="cm"> *	The task_lock() exception</span>
<span class="cm"> *</span>
<span class="cm"> * The need for this exception arises from the action of</span>
<span class="cm"> * cgroup_attach_task(), which overwrites one tasks cgroup pointer with</span>
<span class="cm"> * another.  It does so using cgroup_mutex, however there are</span>
<span class="cm"> * several performance critical places that need to reference</span>
<span class="cm"> * task-&gt;cgroup without the expense of grabbing a system global</span>
<span class="cm"> * mutex.  Therefore except as noted below, when dereferencing or, as</span>
<span class="cm"> * in cgroup_attach_task(), modifying a task&#39;ss cgroup pointer we use</span>
<span class="cm"> * task_lock(), which acts on a spinlock (task-&gt;alloc_lock) already in</span>
<span class="cm"> * the task_struct routinely used for such matters.</span>
<span class="cm"> *</span>
<span class="cm"> * P.S.  One more locking exception.  RCU is used to guard the</span>
<span class="cm"> * update of a tasks cgroup pointer by cgroup_attach_task()</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_lock - lock out any changes to cgroup structures</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cgroup_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cgroup_lock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_unlock - release lock on cgroup changes</span>
<span class="cm"> *</span>
<span class="cm"> * Undo the lock taken in a previous cgroup_lock() call.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cgroup_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cgroup_unlock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * A couple of forward declarations required, due to cyclic reference loop:</span>
<span class="cm"> * cgroup_mkdir -&gt; cgroup_create -&gt; cgroup_populate_dir -&gt;</span>
<span class="cm"> * cgroup_add_file -&gt; cgroup_create_file -&gt; cgroup_dir_inode_operations</span>
<span class="cm"> * -&gt; cgroup_mkdir.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">cgroup_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">cgroup_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cgroup_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">unused_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cgroup_populate_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">cgroup_dir_inode_operations</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_cgroupstats_operations</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="n">cgroup_backing_dev_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;cgroup&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">capabilities</span>	<span class="o">=</span> <span class="n">BDI_CAP_NO_ACCT_AND_WRITEBACK</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">alloc_css_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">child</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">cgroup_new_inode</span><span class="p">(</span><span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">get_next_ino</span><span class="p">();</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">current_fsuid</span><span class="p">();</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">current_fsgid</span><span class="p">();</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cgroup_backing_dev_info</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Call subsys&#39;s pre_destroy handler.</span>
<span class="cm"> * This is called before css refcnt check.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_call_pre_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">pre_destroy</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">pre_destroy</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* -&gt;pre_destroy() failure is being deprecated */</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">__DEPRECATED_clear_css_refs</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_diput</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* is dentry a directory ? if so, kfree() associated cgroup */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cgroup_is_removed</span><span class="p">(</span><span class="n">cgrp</span><span class="p">)));</span>
		<span class="cm">/* It&#39;s possible for external users to be holding css</span>
<span class="cm">		 * reference counts on a cgroup; css_put() needs to</span>
<span class="cm">		 * be able to access the cgroup after decrementing</span>
<span class="cm">		 * the reference count in order to know if it needs to</span>
<span class="cm">		 * queue the cgroup to be handled by the release</span>
<span class="cm">		 * agent */</span>
		<span class="n">synchronize_rcu</span><span class="p">();</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Release the subsystem state objects.</span>
<span class="cm">		 */</span>
		<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>

		<span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">number_of_cgroups</span><span class="o">--</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We want to drop the active superblock reference from the</span>
<span class="cm">		 * cgroup creation after all the dentry refs are gone -</span>
<span class="cm">		 * kill_sb gets mighty unhappy otherwise.  Mark</span>
<span class="cm">		 * dentry-&gt;d_fsdata with cgroup_diput() to tell</span>
<span class="cm">		 * cgroup_d_release() to call deactivate_super().</span>
<span class="cm">		 */</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span> <span class="o">=</span> <span class="n">cgroup_diput</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * if we&#39;re getting rid of the cgroup, refcount should ensure</span>
<span class="cm">		 * that there are no pidlists left.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">pidlists</span><span class="p">));</span>

		<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">rcu_head</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cfent</span> <span class="o">*</span><span class="n">cfe</span> <span class="o">=</span> <span class="n">__d_cfe</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>

		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfe</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			  <span class="n">cgrp</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">top_cgroup</span><span class="p">,</span>
			  <span class="s">&quot;cfe still linked for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfe</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">cfe</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_delete</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_d_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* did cgroup_diput() tell me to deactivate super? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span> <span class="o">==</span> <span class="n">cgroup_diput</span><span class="p">)</span>
		<span class="n">deactivate_super</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">);</span>

	<span class="n">d_delete</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="n">simple_rmdir</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_rm_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfent</span> <span class="o">*</span><span class="n">cfe</span><span class="p">;</span>

	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cfe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">cfe</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cft</span> <span class="o">&amp;&amp;</span> <span class="n">cfe</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">cft</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">dget</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
		<span class="n">d_delete</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
		<span class="n">simple_unlink</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfe</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_clear_directory</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">__d_cgrp</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">))</span>
		<span class="n">cgroup_rm_file</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE : the dentry must have been dget()&#39;ed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_d_remove_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">cgroup_clear_directory</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">,</span> <span class="n">DENTRY_D_LOCK_NESTED</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">remove_dir</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A queue for waiters to do rmdir() cgroup. A tasks will sleep when</span>
<span class="cm"> * cgroup-&gt;count == 0 &amp;&amp; list_empty(&amp;cgroup-&gt;children) &amp;&amp; subsys has some</span>
<span class="cm"> * reference to css-&gt;refcnt. In general, this refcnt is expected to goes down</span>
<span class="cm"> * to zero, soon.</span>
<span class="cm"> *</span>
<span class="cm"> * CGRP_WAIT_ON_RMDIR flag is set under cgroup&#39;s inode-&gt;i_mutex;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">cgroup_rmdir_waitq</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_wakeup_rmdir_waiter</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">CGRP_WAIT_ON_RMDIR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)))</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_rmdir_waitq</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cgroup_exclude_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">css_get</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cgroup_release_and_wakeup_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cgroup_wakeup_rmdir_waiter</span><span class="p">(</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">cgroup</span><span class="p">);</span>
	<span class="n">css_put</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Call with cgroup_mutex held. Drops reference counts on modules, including</span>
<span class="cm"> * any duplicate ones that parse_cgroupfs_options took. If this function</span>
<span class="cm"> * returns an error, no reference counts are touched.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rebind_subsystems</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">final_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">added_bits</span><span class="p">,</span> <span class="n">removed_bits</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">top_cgroup</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_root_mutex</span><span class="p">));</span>

	<span class="n">removed_bits</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">actual_subsys_bits</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">final_bits</span><span class="p">;</span>
	<span class="n">added_bits</span> <span class="o">=</span> <span class="n">final_bits</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">actual_subsys_bits</span><span class="p">;</span>
	<span class="cm">/* Check that any added subsystems are currently free */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bit</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span> <span class="o">=</span> <span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bit</span> <span class="o">&amp;</span> <span class="n">added_bits</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Nobody should tell us to do a subsys that doesn&#39;t exist:</span>
<span class="cm">		 * parse_cgroupfs_options should catch that case and refcounts</span>
<span class="cm">		 * ensure that subsystems won&#39;t disappear once selected.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ss</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">rootnode</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Subsystem isn&#39;t free */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Currently we don&#39;t handle adding/removing subsystems when</span>
<span class="cm">	 * any child cgroups exist. This is theoretically supportable</span>
<span class="cm">	 * but involves complex error handling, so it&#39;s being left until</span>
<span class="cm">	 * later */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">number_of_cgroups</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* Process each subsystem */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span> <span class="o">=</span> <span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bit</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&amp;</span> <span class="n">added_bits</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We&#39;re binding this subsystem to this hierarchy */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ss</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dummytop</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dummytop</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cgroup</span> <span class="o">!=</span> <span class="n">dummytop</span><span class="p">);</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">hierarchy_mutex</span><span class="p">);</span>
			<span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dummytop</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cgroup</span> <span class="o">=</span> <span class="n">cgrp</span><span class="p">;</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">subsys_list</span><span class="p">);</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">)</span>
				<span class="n">ss</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">hierarchy_mutex</span><span class="p">);</span>
			<span class="cm">/* refcount was already taken, and we&#39;re keeping it */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&amp;</span> <span class="n">removed_bits</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We&#39;re removing this subsystem */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ss</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dummytop</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cgroup</span> <span class="o">!=</span> <span class="n">cgrp</span><span class="p">);</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">hierarchy_mutex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">)</span>
				<span class="n">ss</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">(</span><span class="n">dummytop</span><span class="p">);</span>
			<span class="n">dummytop</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cgroup</span> <span class="o">=</span> <span class="n">dummytop</span><span class="p">;</span>
			<span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rootnode</span><span class="p">;</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rootnode</span><span class="p">.</span><span class="n">subsys_list</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">hierarchy_mutex</span><span class="p">);</span>
			<span class="cm">/* subsystem is now free - drop reference on module */</span>
			<span class="n">module_put</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&amp;</span> <span class="n">final_bits</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Subsystem state should already exist */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ss</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="cm">/*</span>
<span class="cm">			 * a refcount was taken, but we already had one, so</span>
<span class="cm">			 * drop the extra reference.</span>
<span class="cm">			 */</span>
			<span class="n">module_put</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_MODULE_UNLOAD</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">module</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">module_refcount</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">));</span>
<span class="cp">#endif</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Subsystem state shouldn&#39;t exist */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">subsys_bits</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">actual_subsys_bits</span> <span class="o">=</span> <span class="n">final_bits</span><span class="p">;</span>
	<span class="n">synchronize_rcu</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_show_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_root_mutex</span><span class="p">);</span>
	<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,%s&quot;</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ROOT_NOPREFIX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,noprefix&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">release_agent_path</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,release_agent=%s&quot;</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">release_agent_path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clone_children</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">top_cgroup</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,clone_children&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,name=%s&quot;</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_root_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cgroup_sb_opts</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">subsys_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">release_agent</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">clone_children</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="cm">/* User explicitly requested empty subsystem */</span>
	<span class="n">bool</span> <span class="n">none</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">new_root</span><span class="p">;</span>

<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Convert a hierarchy specifier into a bitmask of subsystems and flags. Call</span>
<span class="cm"> * with cgroup_mutex held to protect the subsys[] array. This function takes</span>
<span class="cm"> * refcounts on subsystems to be used, unless it returns error, in which case</span>
<span class="cm"> * no refcounts are taken.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_cgroupfs_options</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_sb_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">token</span><span class="p">,</span> <span class="o">*</span><span class="n">o</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">all_ss</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">one_ss</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">module_pin_failed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">));</span>

<span class="cp">#ifdef CONFIG_CPUSETS</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">cpuset_subsys_id</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">));</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">token</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">token</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="s">&quot;none&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Explicitly have no subsystems */</span>
			<span class="n">opts</span><span class="o">-&gt;</span><span class="n">none</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="s">&quot;all&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Mutually exclusive option &#39;all&#39; + subsystem name */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">one_ss</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">all_ss</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="s">&quot;noprefix&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">ROOT_NOPREFIX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="s">&quot;clone_children&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">opts</span><span class="o">-&gt;</span><span class="n">clone_children</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="s">&quot;release_agent=&quot;</span><span class="p">,</span> <span class="mi">14</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Specifying two release agents is forbidden */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">release_agent</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">opts</span><span class="o">-&gt;</span><span class="n">release_agent</span> <span class="o">=</span>
				<span class="n">kstrndup</span><span class="p">(</span><span class="n">token</span> <span class="o">+</span> <span class="mi">14</span><span class="p">,</span> <span class="n">PATH_MAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">release_agent</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="s">&quot;name=&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">token</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
			<span class="cm">/* Can&#39;t specify an empty name */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="cm">/* Must match [\w.-]+ */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">isalnum</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Specifying two names is forbidden */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">opts</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">kstrndup</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
					      <span class="n">MAX_CGROUP_ROOT_NAMELEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					      <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span> <span class="o">=</span> <span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* Mutually exclusive option &#39;all&#39; + subsystem name */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">all_ss</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">subsys_bits</span><span class="p">);</span>
			<span class="n">one_ss</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the &#39;all&#39; option was specified select all the subsystems,</span>
<span class="cm">	 * otherwise if &#39;none&#39;, &#39;name=&#39; and a subsystem name options</span>
<span class="cm">	 * were not specified, let&#39;s default to &#39;all&#39;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">all_ss</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">one_ss</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">none</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span> <span class="o">=</span> <span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">subsys_bits</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Consistency checks */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Option noprefix was introduced just for backward compatibility</span>
<span class="cm">	 * with the old cpuset, so we allow noprefix only if mounting just</span>
<span class="cm">	 * the cpuset subsystem.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ROOT_NOPREFIX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">subsys_bits</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>


	<span class="cm">/* Can&#39;t specify &quot;none&quot; and some subsystems */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">subsys_bits</span> <span class="o">&amp;&amp;</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">none</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We either have to specify by name or by subsystems. (So all</span>
<span class="cm">	 * empty hierarchies must have a name).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">subsys_bits</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Grab references on all the modules we&#39;ll need, so the subsystems</span>
<span class="cm">	 * don&#39;t dance around before rebind_subsystems attaches them. This may</span>
<span class="cm">	 * take duplicate reference counts on a subsystem that&#39;s already used,</span>
<span class="cm">	 * but rebind_subsystems handles this case.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">CGROUP_BUILTIN_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bit</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bit</span> <span class="o">&amp;</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">subsys_bits</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">module_pin_failed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">module_pin_failed</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * oops, one of the modules was going away. this means that we</span>
<span class="cm">		 * raced with a module_delete call, and to the user this is</span>
<span class="cm">		 * essentially a &quot;subsystem doesn&#39;t exist&quot; case.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">CGROUP_BUILTIN_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* drop refcounts only on the ones we took */</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bit</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bit</span> <span class="o">&amp;</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">subsys_bits</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">module_put</span><span class="p">(</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">drop_parsed_module_refcounts</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">subsys_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">CGROUP_BUILTIN_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bit</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bit</span> <span class="o">&amp;</span> <span class="n">subsys_bits</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_remount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">top_cgroup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_sb_opts</span> <span class="n">opts</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_root_mutex</span><span class="p">);</span>

	<span class="cm">/* See what subsystems are wanted */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">parse_cgroupfs_options</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/* See feature-removal-schedule.txt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">subsys_bits</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">actual_subsys_bits</span> <span class="o">||</span> <span class="n">opts</span><span class="p">.</span><span class="n">release_agent</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;cgroup: option changes via remount are deprecated (pid=%d comm=%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">task_tgid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t allow flags or name to change at remount */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">flags</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">drop_parsed_module_refcounts</span><span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">subsys_bits</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rebind_subsystems</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">opts</span><span class="p">.</span><span class="n">subsys_bits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drop_parsed_module_refcounts</span><span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">subsys_bits</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* clear out any existing files and repopulate subsystem files */</span>
	<span class="n">cgroup_clear_directory</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">cgroup_populate_dir</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">release_agent</span><span class="p">)</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">release_agent_path</span><span class="p">,</span> <span class="n">opts</span><span class="p">.</span><span class="n">release_agent</span><span class="p">);</span>
 <span class="nl">out_unlock:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">release_agent</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_root_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">cgroup_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">statfs</span> <span class="o">=</span> <span class="n">simple_statfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">drop_inode</span> <span class="o">=</span> <span class="n">generic_delete_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_options</span> <span class="o">=</span> <span class="n">cgroup_show_options</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remount_fs</span> <span class="o">=</span> <span class="n">cgroup_remount</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_cgroup_housekeeping</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">css_sets</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">release_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">pidlists</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">pidlist_mutex</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">event_list_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_cgroup_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">top_cgroup</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">subsys_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">allcg_list</span><span class="p">);</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">number_of_cgroups</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">top_cgroup</span> <span class="o">=</span> <span class="n">cgrp</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">allcg_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">allcg_list</span><span class="p">);</span>
	<span class="n">init_cgroup_housekeeping</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">init_root_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ida_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hierarchy_ida</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hierarchy_id_lock</span><span class="p">);</span>
		<span class="cm">/* Try to allocate the next unused ID */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ida_get_new_above</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hierarchy_ida</span><span class="p">,</span> <span class="n">next_hierarchy_id</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">hierarchy_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="cm">/* Try again starting from 0 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ida_get_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hierarchy_ida</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">hierarchy_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">next_hierarchy_id</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">hierarchy_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Can only get here if the 31-bit IDR is full ... */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hierarchy_id_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_test_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_sb_opts</span> <span class="o">*</span><span class="n">opts</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="cm">/* If we asked for a name then it must match */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we asked for subsystems (or explicitly for no</span>
<span class="cm">	 * subsystems) then they must match</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">subsys_bits</span> <span class="o">||</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">none</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">subsys_bits</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">subsys_bits</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="nf">cgroup_root_from_opts</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_sb_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">subsys_bits</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">none</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">root</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init_root_id</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">init_cgroup_root</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

	<span class="n">root</span><span class="o">-&gt;</span><span class="n">subsys_bits</span> <span class="o">=</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">subsys_bits</span><span class="p">;</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">release_agent</span><span class="p">)</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">release_agent_path</span><span class="p">,</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">release_agent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">clone_children</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CGRP_CLONE_CHILDREN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">top_cgroup</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_drop_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">hierarchy_id</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hierarchy_id_lock</span><span class="p">);</span>
	<span class="n">ida_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hierarchy_ida</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">hierarchy_id</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hierarchy_id_lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_set_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_sb_opts</span> <span class="o">*</span><span class="n">opts</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* If we don&#39;t have a new root, we can&#39;t set up a new sb */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">new_root</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">subsys_bits</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">none</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">set_anon_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">new_root</span><span class="p">;</span>
	<span class="n">opts</span><span class="o">-&gt;</span><span class="n">new_root</span><span class="o">-&gt;</span><span class="n">sb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_magic</span> <span class="o">=</span> <span class="n">CGROUP_SUPER_MAGIC</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cgroup_ops</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_get_rootdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">cgroup_dops</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">d_iput</span> <span class="o">=</span> <span class="n">cgroup_diput</span><span class="p">,</span>
		<span class="p">.</span><span class="n">d_delete</span> <span class="o">=</span> <span class="n">cgroup_delete</span><span class="p">,</span>
		<span class="p">.</span><span class="n">d_release</span> <span class="o">=</span> <span class="n">cgroup_d_release</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span>
		<span class="n">cgroup_new_inode</span><span class="p">(</span><span class="n">S_IFDIR</span> <span class="o">|</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IXUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">simple_dir_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cgroup_dir_inode_operations</span><span class="p">;</span>
	<span class="cm">/* directories start off with i_nlink == 2 (for &quot;.&quot; entry) */</span>
	<span class="n">inc_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">=</span> <span class="n">d_make_root</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="cm">/* for everything else we want -&gt;d_op set */</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_d_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cgroup_dops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">cgroup_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">unused_dev_name</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_sb_opts</span> <span class="n">opts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">new_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="cm">/* First find the desired set of subsystems */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">parse_cgroupfs_options</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate a new cgroup root. We may not need it if we&#39;re</span>
<span class="cm">	 * reusing an existing hierarchy.</span>
<span class="cm">	 */</span>
	<span class="n">new_root</span> <span class="o">=</span> <span class="n">cgroup_root_from_opts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_root</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_root</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">drop_modules</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">opts</span><span class="p">.</span><span class="n">new_root</span> <span class="o">=</span> <span class="n">new_root</span><span class="p">;</span>

	<span class="cm">/* Locate an existing or new sb for this hierarchy */</span>
	<span class="n">sb</span> <span class="o">=</span> <span class="n">sget</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">cgroup_test_super</span><span class="p">,</span> <span class="n">cgroup_set_super</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">cgroup_drop_root</span><span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">new_root</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">drop_modules</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">opts</span><span class="p">.</span><span class="n">new_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We used the new root structure, so this is a new hierarchy */</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tmp_cg_links</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">root_cgrp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">top_cgroup</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">existing_root</span><span class="p">;</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">cgroup_get_rootdir</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">drop_new_super</span><span class="p">;</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_root_mutex</span><span class="p">);</span>

		<span class="cm">/* Check for name clashes with existing mounts */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
			<span class="n">for_each_active_root</span><span class="p">(</span><span class="n">existing_root</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">existing_root</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">unlock_drop</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re accessing css_set_count without locking</span>
<span class="cm">		 * css_set_lock here, but that&#39;s OK - it can only be</span>
<span class="cm">		 * increased by someone holding cgroup_lock, and</span>
<span class="cm">		 * that&#39;s us. The worst that can happen is that we</span>
<span class="cm">		 * have some link structures left over</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">allocate_cg_links</span><span class="p">(</span><span class="n">css_set_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_cg_links</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock_drop</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">rebind_subsystems</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">subsys_bits</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_cg_links</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_cg_links</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">unlock_drop</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * There must be no failure case after here, since rebinding</span>
<span class="cm">		 * takes care of subsystems&#39; refcounts, which are explicitly</span>
<span class="cm">		 * dropped in the failure exit path.</span>
<span class="cm">		 */</span>

		<span class="cm">/* EBUSY should be the only error here */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">roots</span><span class="p">);</span>
		<span class="n">root_count</span><span class="o">++</span><span class="p">;</span>

		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="o">-&gt;</span><span class="n">d_fsdata</span> <span class="o">=</span> <span class="n">root_cgrp</span><span class="p">;</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">top_cgroup</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">;</span>

		<span class="cm">/* Link the top cgroup in this hierarchy into all</span>
<span class="cm">		 * the css_set objects */</span>
		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CSS_SET_TABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hhead</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">css_set_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">cg</span><span class="p">;</span>

			<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">hhead</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span>
				<span class="n">link_css_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_cg_links</span><span class="p">,</span> <span class="n">cg</span><span class="p">,</span> <span class="n">root_cgrp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>

		<span class="n">free_cg_links</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_cg_links</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_cgrp</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_cgrp</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">number_of_cgroups</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">cred</span> <span class="o">=</span> <span class="n">override_creds</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_cred</span><span class="p">);</span>
		<span class="n">cgroup_populate_dir</span><span class="p">(</span><span class="n">root_cgrp</span><span class="p">);</span>
		<span class="n">revert_creds</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_root_mutex</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We re-used an existing hierarchy - the new root (if</span>
<span class="cm">		 * any) is not needed</span>
<span class="cm">		 */</span>
		<span class="n">cgroup_drop_root</span><span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">new_root</span><span class="p">);</span>
		<span class="cm">/* no subsys rebinding, so refcounts don&#39;t change */</span>
		<span class="n">drop_parsed_module_refcounts</span><span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">subsys_bits</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">release_agent</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dget</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">);</span>

 <span class="nl">unlock_drop:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_root_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
 <span class="nl">drop_new_super:</span>
	<span class="n">deactivate_locked_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
 <span class="nl">drop_modules:</span>
	<span class="n">drop_parsed_module_refcounts</span><span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">subsys_bits</span><span class="p">);</span>
 <span class="nl">out_err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">release_agent</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_kill_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">top_cgroup</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">saved_link</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">number_of_cgroups</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">));</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_root_mutex</span><span class="p">);</span>

	<span class="cm">/* Rebind all subsystems back to the default hierarchy */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">rebind_subsystems</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* Shouldn&#39;t be able to fail ... */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Release all the links from css_sets to this hierarchy&#39;s</span>
<span class="cm">	 * root cgroup</span>
<span class="cm">	 */</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">saved_link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">css_sets</span><span class="p">,</span>
				 <span class="n">cgrp_link_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">cg_link_list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">cgrp_link_list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_list</span><span class="p">);</span>
		<span class="n">root_count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_root_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>

	<span class="n">kill_litter_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">cgroup_drop_root</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">cgroup_fs_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;cgroup&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mount</span> <span class="o">=</span> <span class="n">cgroup_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kill_sb</span> <span class="o">=</span> <span class="n">cgroup_kill_sb</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">cgroup_kobj</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_path - generate the path of a cgroup</span>
<span class="cm"> * @cgrp: the cgroup in question</span>
<span class="cm"> * @buf: the buffer to write the path into</span>
<span class="cm"> * @buflen: the length of the buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Called with cgroup_mutex held or else with an RCU-protected cgroup</span>
<span class="cm"> * reference.  Writes path of cgroup into buf.  Returns 0 on success,</span>
<span class="cm"> * -errno on error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cgroup_path</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span>
						      <span class="n">cgroup_lock_is_held</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span> <span class="o">||</span> <span class="n">cgrp</span> <span class="o">==</span> <span class="n">dummytop</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Inactive subsystems have no dentry for their root</span>
<span class="cm">		 * cgroup</span>
<span class="cm">		 */</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">buflen</span><span class="p">;</span>

	<span class="o">*--</span><span class="n">start</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">start</span> <span class="o">-=</span> <span class="n">len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">buf</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">cgrp</span> <span class="o">=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgrp</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">dentry</span> <span class="o">=</span> <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span>
					       <span class="n">cgroup_lock_is_held</span><span class="p">());</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">buf</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>
		<span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">buflen</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cgroup_path</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Control Group taskset</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">task_and_cgroup</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup</span>		<span class="o">*</span><span class="n">cgrp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">css_set</span>		<span class="o">*</span><span class="n">cg</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_and_cgroup</span>	<span class="n">single</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flex_array</span>	<span class="o">*</span><span class="n">tc_array</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">tc_array_len</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup</span>		<span class="o">*</span><span class="n">cur_cgrp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_taskset_first - reset taskset and return the first task</span>
<span class="cm"> * @tset: taskset of interest</span>
<span class="cm"> *</span>
<span class="cm"> * @tset iteration is initialized and the first task is returned.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">cgroup_taskset_first</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tset</span><span class="o">-&gt;</span><span class="n">tc_array</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tset</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">cgroup_taskset_next</span><span class="p">(</span><span class="n">tset</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tset</span><span class="o">-&gt;</span><span class="n">cur_cgrp</span> <span class="o">=</span> <span class="n">tset</span><span class="o">-&gt;</span><span class="n">single</span><span class="p">.</span><span class="n">cgrp</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">tset</span><span class="o">-&gt;</span><span class="n">single</span><span class="p">.</span><span class="n">task</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cgroup_taskset_first</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_taskset_next - iterate to the next task in taskset</span>
<span class="cm"> * @tset: taskset of interest</span>
<span class="cm"> *</span>
<span class="cm"> * Return the next task in @tset.  Iteration must have been initialized</span>
<span class="cm"> * with cgroup_taskset_first().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">cgroup_taskset_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_and_cgroup</span> <span class="o">*</span><span class="n">tc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tset</span><span class="o">-&gt;</span><span class="n">tc_array</span> <span class="o">||</span> <span class="n">tset</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">tset</span><span class="o">-&gt;</span><span class="n">tc_array_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">tc</span> <span class="o">=</span> <span class="n">flex_array_get</span><span class="p">(</span><span class="n">tset</span><span class="o">-&gt;</span><span class="n">tc_array</span><span class="p">,</span> <span class="n">tset</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">++</span><span class="p">);</span>
	<span class="n">tset</span><span class="o">-&gt;</span><span class="n">cur_cgrp</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cgroup_taskset_next</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_taskset_cur_cgroup - return the matching cgroup for the current task</span>
<span class="cm"> * @tset: taskset of interest</span>
<span class="cm"> *</span>
<span class="cm"> * Return the cgroup for the current (last returned) task of @tset.  This</span>
<span class="cm"> * function must be preceded by either cgroup_taskset_first() or</span>
<span class="cm"> * cgroup_taskset_next().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="nf">cgroup_taskset_cur_cgroup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tset</span><span class="o">-&gt;</span><span class="n">cur_cgrp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cgroup_taskset_cur_cgroup</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_taskset_size - return the number of tasks in taskset</span>
<span class="cm"> * @tset: taskset of interest</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cgroup_taskset_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tset</span><span class="o">-&gt;</span><span class="n">tc_array</span> <span class="o">?</span> <span class="n">tset</span><span class="o">-&gt;</span><span class="n">tc_array_len</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cgroup_taskset_size</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * cgroup_task_migrate - move a task from one cgroup to another.</span>
<span class="cm"> *</span>
<span class="cm"> * &#39;guarantee&#39; is set if the caller promises that a new css_set for the task</span>
<span class="cm"> * will already exist. If not set, this function might sleep, and can fail with</span>
<span class="cm"> * -ENOMEM. Must be called with cgroup_mutex and threadgroup locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_task_migrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">oldcgrp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">newcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">oldcg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are synchronized through threadgroup_lock() against PF_EXITING</span>
<span class="cm">	 * setting such that we can&#39;t race against cgroup_exit() changing the</span>
<span class="cm">	 * css_set to init_css_set and dropping the old one.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">);</span>
	<span class="n">oldcg</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cgroups</span><span class="p">;</span>

	<span class="n">task_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cgroups</span><span class="p">,</span> <span class="n">newcg</span><span class="p">);</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="cm">/* Update the css_set linked lists if we&#39;re using them */</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cg_list</span><span class="p">))</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cg_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newcg</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We just gained a reference on oldcg by taking it from the task. As</span>
<span class="cm">	 * trading it for newcg is protected by cgroup_mutex, we&#39;re safe to drop</span>
<span class="cm">	 * it here; it will be freed under RCU.</span>
<span class="cm">	 */</span>
	<span class="n">put_css_set</span><span class="p">(</span><span class="n">oldcg</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">CGRP_RELEASABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldcgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_attach_task - attach task &#39;tsk&#39; to cgroup &#39;cgrp&#39;</span>
<span class="cm"> * @cgrp: the cgroup the task is attaching to</span>
<span class="cm"> * @tsk: the task to be attached</span>
<span class="cm"> *</span>
<span class="cm"> * Call with cgroup_mutex and threadgroup locked. May take task_lock of</span>
<span class="cm"> * @tsk during call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cgroup_attach_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="o">*</span><span class="n">failed_ss</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">oldcgrp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="n">tset</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">newcg</span><span class="p">;</span>

	<span class="cm">/* @tsk either already exited or can&#39;t exit until the end */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="cm">/* Nothing to do if the task is already in that cgroup */</span>
	<span class="n">oldcgrp</span> <span class="o">=</span> <span class="n">task_cgroup_from_root</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cgrp</span> <span class="o">==</span> <span class="n">oldcgrp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tset</span><span class="p">.</span><span class="n">single</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">tsk</span><span class="p">;</span>
	<span class="n">tset</span><span class="p">.</span><span class="n">single</span><span class="p">.</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">oldcgrp</span><span class="p">;</span>

	<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">can_attach</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">can_attach</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Remember on which subsystem the can_attach()</span>
<span class="cm">				 * failed, so that we only call cancel_attach()</span>
<span class="cm">				 * against the subsystems whose can_attach()</span>
<span class="cm">				 * succeeded. (See below)</span>
<span class="cm">				 */</span>
				<span class="n">failed_ss</span> <span class="o">=</span> <span class="n">ss</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">newcg</span> <span class="o">=</span> <span class="n">find_css_set</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cgroups</span><span class="p">,</span> <span class="n">cgrp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newcg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cgroup_task_migrate</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">oldcgrp</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="n">newcg</span><span class="p">);</span>

	<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">)</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">synchronize_rcu</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * wake up rmdir() waiter. the rmdir should fail since the cgroup</span>
<span class="cm">	 * is no longer empty.</span>
<span class="cm">	 */</span>
	<span class="n">cgroup_wakeup_rmdir_waiter</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss</span> <span class="o">==</span> <span class="n">failed_ss</span><span class="p">)</span>
				<span class="cm">/*</span>
<span class="cm">				 * This subsystem was the one that failed the</span>
<span class="cm">				 * can_attach() check earlier, so we don&#39;t need</span>
<span class="cm">				 * to call cancel_attach() against it or any</span>
<span class="cm">				 * remaining subsystems.</span>
<span class="cm">				 */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">cancel_attach</span><span class="p">)</span>
				<span class="n">ss</span><span class="o">-&gt;</span><span class="n">cancel_attach</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tset</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_attach_task_all - attach task &#39;tsk&#39; to all cgroups of task &#39;from&#39;</span>
<span class="cm"> * @from: attach to all cgroups of a given task</span>
<span class="cm"> * @tsk: the task to be attached</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cgroup_attach_task_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cgroup_lock</span><span class="p">();</span>
	<span class="n">for_each_active_root</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">from_cg</span> <span class="o">=</span> <span class="n">task_cgroup_from_root</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">cgroup_attach_task</span><span class="p">(</span><span class="n">from_cg</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cgroup_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cgroup_attach_task_all</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_attach_proc - attach all threads in a threadgroup to a cgroup</span>
<span class="cm"> * @cgrp: the cgroup to attach to</span>
<span class="cm"> * @leader: the threadgroup leader task_struct of the group to be attached</span>
<span class="cm"> *</span>
<span class="cm"> * Call holding cgroup_mutex and the group_rwsem of the leader. Will take</span>
<span class="cm"> * task_lock of each thread in leader&#39;s threadgroup individually in turn.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_attach_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">leader</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">group_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="o">*</span><span class="n">failed_ss</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* guaranteed to be initialized later, but the compiler needs this */</span>
	<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="cm">/* threadgroup list cursor and array */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_and_cgroup</span> <span class="o">*</span><span class="n">tc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flex_array</span> <span class="o">*</span><span class="n">group</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="n">tset</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * step 0: in order to do expensive, possibly blocking operations for</span>
<span class="cm">	 * every thread, we cannot iterate the thread group list, since it needs</span>
<span class="cm">	 * rcu or tasklist locked. instead, build an array of all threads in the</span>
<span class="cm">	 * group - group_rwsem prevents new threads from appearing, and if</span>
<span class="cm">	 * threads exit, this will just be an over-estimate.</span>
<span class="cm">	 */</span>
	<span class="n">group_size</span> <span class="o">=</span> <span class="n">get_nr_threads</span><span class="p">(</span><span class="n">leader</span><span class="p">);</span>
	<span class="cm">/* flex_array supports very large thread-groups better than kmalloc. */</span>
	<span class="n">group</span> <span class="o">=</span> <span class="n">flex_array_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tc</span><span class="p">),</span> <span class="n">group_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="cm">/* pre-allocate to guarantee space while iterating in rcu read-side. */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">flex_array_prealloc</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">group_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_group_list</span><span class="p">;</span>

	<span class="n">tsk</span> <span class="o">=</span> <span class="n">leader</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Prevent freeing of tasks while we take a snapshot. Tasks that are</span>
<span class="cm">	 * already PF_EXITING could be freed from underneath us unless we</span>
<span class="cm">	 * take an rcu_read_lock.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_and_cgroup</span> <span class="n">ent</span><span class="p">;</span>

		<span class="cm">/* @tsk either already exited or can&#39;t exit until the end */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* as per above, nr_threads may decrease, but not increase. */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">group_size</span><span class="p">);</span>
		<span class="n">ent</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">tsk</span><span class="p">;</span>
		<span class="n">ent</span><span class="p">.</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">task_cgroup_from_root</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="cm">/* nothing to do if this task is already in the cgroup */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ent</span><span class="p">.</span><span class="n">cgrp</span> <span class="o">==</span> <span class="n">cgrp</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * saying GFP_ATOMIC has no effect here because we did prealloc</span>
<span class="cm">		 * earlier, but it&#39;s good form to communicate our expectations.</span>
<span class="cm">		 */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">flex_array_put</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">leader</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="cm">/* remember the number of threads in the array for later. */</span>
	<span class="n">group_size</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">tset</span><span class="p">.</span><span class="n">tc_array</span> <span class="o">=</span> <span class="n">group</span><span class="p">;</span>
	<span class="n">tset</span><span class="p">.</span><span class="n">tc_array_len</span> <span class="o">=</span> <span class="n">group_size</span><span class="p">;</span>

	<span class="cm">/* methods shouldn&#39;t be called if no task is actually migrating */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group_size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_group_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * step 1: check that we can legitimately attach to the cgroup.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">can_attach</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">can_attach</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">failed_ss</span> <span class="o">=</span> <span class="n">ss</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_cancel_attach</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * step 2: make sure css_sets exist for all threads to be migrated.</span>
<span class="cm">	 * we use find_css_set, which allocates a new one if necessary.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">group_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tc</span> <span class="o">=</span> <span class="n">flex_array_get</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">tc</span><span class="o">-&gt;</span><span class="n">cg</span> <span class="o">=</span> <span class="n">find_css_set</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">cgroups</span><span class="p">,</span> <span class="n">cgrp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">cg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_put_css_set_refs</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * step 3: now that we&#39;re guaranteed success wrt the css_sets,</span>
<span class="cm">	 * proceed to move all tasks to the new cgroup.  There are no</span>
<span class="cm">	 * failure cases after here, so this is the commit point.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">group_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tc</span> <span class="o">=</span> <span class="n">flex_array_get</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">cgroup_task_migrate</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">cg</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* nothing is sensitive to fork() after this point. */</span>

	<span class="cm">/*</span>
<span class="cm">	 * step 4: do subsystem attach callbacks.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">)</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * step 5: success! and cleanup</span>
<span class="cm">	 */</span>
	<span class="n">synchronize_rcu</span><span class="p">();</span>
	<span class="n">cgroup_wakeup_rmdir_waiter</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_put_css_set_refs:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">group_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tc</span> <span class="o">=</span> <span class="n">flex_array_get</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">cg</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">put_css_set</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">cg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out_cancel_attach:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss</span> <span class="o">==</span> <span class="n">failed_ss</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">cancel_attach</span><span class="p">)</span>
				<span class="n">ss</span><span class="o">-&gt;</span><span class="n">cancel_attach</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tset</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out_free_group_list:</span>
	<span class="n">flex_array_free</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the task_struct of the task to attach by vpid and pass it along to the</span>
<span class="cm"> * function to attach either it or all tasks in its threadgroup. Will lock</span>
<span class="cm"> * cgroup_mutex and threadgroup; may take task_lock of task.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">attach_task_by_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">u64</span> <span class="n">pid</span><span class="p">,</span> <span class="n">bool</span> <span class="n">threadgroup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">(),</span> <span class="o">*</span><span class="n">tcred</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgroup_lock_live_group</span><span class="p">(</span><span class="n">cgrp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

<span class="nl">retry_find_task:</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tsk</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="n">ret</span><span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock_cgroup</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * even if we&#39;re attaching all tasks in the thread group, we</span>
<span class="cm">		 * only need to check permissions on one of them.</span>
<span class="cm">		 */</span>
		<span class="n">tcred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">GLOBAL_ROOT_UID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">suid</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock_cgroup</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">threadgroup</span><span class="p">)</span>
		<span class="n">tsk</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Workqueue threads may acquire PF_THREAD_BOUND and become</span>
<span class="cm">	 * trapped in a cpuset, or RT worker may be born in a cgroup</span>
<span class="cm">	 * with no rt_runtime allocated.  Just say no.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span> <span class="o">==</span> <span class="n">kthreadd_task</span> <span class="o">||</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_THREAD_BOUND</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">out_unlock_cgroup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">threadgroup_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">threadgroup</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">thread_group_leader</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * a race with de_thread from another thread&#39;s exec()</span>
<span class="cm">			 * may strip us of our leadership, if this happens,</span>
<span class="cm">			 * there is no choice but to throw this task away and</span>
<span class="cm">			 * try again; this is</span>
<span class="cm">			 * &quot;double-double-toil-and-trouble-check locking&quot;.</span>
<span class="cm">			 */</span>
			<span class="n">threadgroup_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
			<span class="n">put_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry_find_task</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cgroup_attach_proc</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cgroup_attach_task</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
	<span class="n">threadgroup_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="nl">out_unlock_cgroup:</span>
	<span class="n">cgroup_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_tasks_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="n">u64</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">attach_task_by_pid</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_procs_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="n">u64</span> <span class="n">tgid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">attach_task_by_pid</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">tgid</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_lock_live_group - take cgroup_mutex and check that cgrp is alive.</span>
<span class="cm"> * @cgrp: the cgroup to be checked for liveness</span>
<span class="cm"> *</span>
<span class="cm"> * On success, returns true; the lock should be later released with</span>
<span class="cm"> * cgroup_unlock(). On failure returns false with no lock held.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">cgroup_lock_live_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cgroup_is_removed</span><span class="p">(</span><span class="n">cgrp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cgroup_lock_live_group</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_release_agent_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">release_agent_path</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">PATH_MAX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">PATH_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgroup_lock_live_group</span><span class="p">(</span><span class="n">cgrp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_root_mutex</span><span class="p">);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">release_agent_path</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_root_mutex</span><span class="p">);</span>
	<span class="n">cgroup_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_release_agent_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgroup_lock_live_group</span><span class="p">(</span><span class="n">cgrp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">release_agent_path</span><span class="p">);</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
	<span class="n">cgroup_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* A buffer size big enough for numbers or short strings */</span>
<span class="cp">#define CGROUP_LOCAL_BUFFER_SIZE 64</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cgroup_write_X64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">userbuf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">unused_ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">CGROUP_LOCAL_BUFFER_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nbytes</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">userbuf</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">buffer</span><span class="p">[</span><span class="n">nbytes</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="cm">/* nul-terminate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">write_u64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">val</span> <span class="o">=</span> <span class="n">simple_strtoull</span><span class="p">(</span><span class="n">strstrip</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">write_u64</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">cft</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">s64</span> <span class="n">val</span> <span class="o">=</span> <span class="n">simple_strtoll</span><span class="p">(</span><span class="n">strstrip</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">write_s64</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">cft</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">nbytes</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cgroup_write_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">userbuf</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">unused_ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">local_buffer</span><span class="p">[</span><span class="n">CGROUP_LOCAL_BUFFER_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">max_bytes</span> <span class="o">=</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">max_write_len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">local_buffer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_bytes</span><span class="p">)</span>
		<span class="n">max_bytes</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">local_buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">&gt;=</span> <span class="n">max_bytes</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
	<span class="cm">/* Allocate a dynamic buffer if we need one */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">local_buffer</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">nbytes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">&amp;&amp;</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">userbuf</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">buffer</span><span class="p">[</span><span class="n">nbytes</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="cm">/* nul-terminate */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">write_string</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">cft</span><span class="p">,</span> <span class="n">strstrip</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">nbytes</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">!=</span> <span class="n">local_buffer</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cgroup_file_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
						<span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span> <span class="o">=</span> <span class="n">__d_cft</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">__d_cgrp</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cgroup_is_removed</span><span class="p">(</span><span class="n">cgrp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">cft</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">write_u64</span> <span class="o">||</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">write_s64</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cgroup_write_X64</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">cft</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">write_string</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cgroup_write_string</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">cft</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">trigger</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">trigger</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">nbytes</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cgroup_read_u64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span>
			       <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="n">CGROUP_LOCAL_BUFFER_SIZE</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">val</span> <span class="o">=</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">read_u64</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">cft</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">val</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cgroup_read_s64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span>
			       <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="n">CGROUP_LOCAL_BUFFER_SIZE</span><span class="p">];</span>
	<span class="n">s64</span> <span class="n">val</span> <span class="o">=</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">read_s64</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">cft</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">val</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cgroup_file_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span> <span class="o">=</span> <span class="n">__d_cft</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">__d_cgrp</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cgroup_is_removed</span><span class="p">(</span><span class="n">cgrp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">cft</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">read_u64</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cgroup_read_u64</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">cft</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">read_s64</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cgroup_read_s64</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">cft</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * seqfile ops/methods for returning structured data. Currently just</span>
<span class="cm"> * supports string-&gt;u64 maps, but can be extended in future.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">cgroup_seqfile_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgroup</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_map_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_map_cb</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">u64</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="s">&quot;%s %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_seqfile_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_seqfile_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">cft</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">read_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup_map_cb</span> <span class="n">cb</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">fill</span> <span class="o">=</span> <span class="n">cgroup_map_add</span><span class="p">,</span>
			<span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span>
		<span class="p">};</span>
		<span class="k">return</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">read_map</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">cgroup</span><span class="p">,</span> <span class="n">cft</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">read_seq_string</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">cgroup</span><span class="p">,</span> <span class="n">cft</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_seqfile_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">single_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">cgroup_seqfile_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">cgroup_file_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">cgroup_seqfile_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_file_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">generic_file_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">cft</span> <span class="o">=</span> <span class="n">__d_cft</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">read_map</span> <span class="o">||</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">read_seq_string</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup_seqfile_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span>
			<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">),</span> <span class="n">GFP_USER</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">cft</span> <span class="o">=</span> <span class="n">cft</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">cgroup</span> <span class="o">=</span> <span class="n">__d_cgrp</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">);</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cgroup_seqfile_operations</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">cgroup_seqfile_show</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_file_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span> <span class="o">=</span> <span class="n">__d_cft</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cgroup_rename - Only allow simple rename of directories in place.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTDIR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_dir</span> <span class="o">!=</span> <span class="n">new_dir</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">simple_rename</span><span class="p">(</span><span class="n">old_dir</span><span class="p">,</span> <span class="n">old_dentry</span><span class="p">,</span> <span class="n">new_dir</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">cgroup_file_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">cgroup_file_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">cgroup_file_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">cgroup_file_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">cgroup_file_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">cgroup_dir_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lookup</span> <span class="o">=</span> <span class="n">cgroup_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mkdir</span> <span class="o">=</span> <span class="n">cgroup_mkdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rmdir</span> <span class="o">=</span> <span class="n">cgroup_rmdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rename</span> <span class="o">=</span> <span class="n">cgroup_rename</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">cgroup_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">NAME_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>
	<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if a file is a control file</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="nf">__file_cft</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">cgroup_file_operations</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__d_cft</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_create_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">cgroup_new_inode</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cgroup_dir_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">simple_dir_operations</span><span class="p">;</span>

		<span class="cm">/* start off with i_nlink == 2 (for &quot;.&quot; entry) */</span>
		<span class="n">inc_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="cm">/* start with the directory inode held, so that we can</span>
<span class="cm">		 * populate it without racing with another mkdir */</span>
		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_CHILD</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cgroup_file_operations</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">dget</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>	<span class="cm">/* Extra count - pin the dentry in core */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cgroup_create_dir - create a directory for an object.</span>
<span class="cm"> * @cgrp: the cgroup we create the directory for. It must have a valid</span>
<span class="cm"> *        -&gt;parent field. And we are going to fill its -&gt;dentry field.</span>
<span class="cm"> * @dentry: dentry of the new cgroup</span>
<span class="cm"> * @mode: mode to set on new directory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_create_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				<span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">cgroup_create_file</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">S_IFDIR</span> <span class="o">|</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span> <span class="o">=</span> <span class="n">cgrp</span><span class="p">;</span>
		<span class="n">inc_nlink</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
		<span class="n">dget</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_file_mode - deduce file mode of a control file</span>
<span class="cm"> * @cft: the control file in question</span>
<span class="cm"> *</span>
<span class="cm"> * returns cft-&gt;mode if -&gt;mode is not 0</span>
<span class="cm"> * returns S_IRUGO|S_IWUSR if it has both a read and a write handler</span>
<span class="cm"> * returns S_IRUGO if it has only a read handler</span>
<span class="cm"> * returns S_IWUSR if it has only a write hander</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">umode_t</span> <span class="nf">cgroup_file_mode</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">umode_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">||</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">read_u64</span> <span class="o">||</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">read_s64</span> <span class="o">||</span>
	    <span class="n">cft</span><span class="o">-&gt;</span><span class="n">read_map</span> <span class="o">||</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">read_seq_string</span><span class="p">)</span>
		<span class="n">mode</span> <span class="o">|=</span> <span class="n">S_IRUGO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">||</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">write_u64</span> <span class="o">||</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">write_s64</span> <span class="o">||</span>
	    <span class="n">cft</span><span class="o">-&gt;</span><span class="n">write_string</span> <span class="o">||</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">trigger</span><span class="p">)</span>
		<span class="n">mode</span> <span class="o">|=</span> <span class="n">S_IWUSR</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_add_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">subsys</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">__d_cgrp</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfent</span> <span class="o">*</span><span class="n">cfe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">mode</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">MAX_CGROUP_TYPE_NAMELEN</span> <span class="o">+</span> <span class="n">MAX_CFTYPE_NAME</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="cm">/* does @cft-&gt;flags tell us to skip creation on @cgrp? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CFTYPE_NOT_ON_ROOT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CFTYPE_ONLY_ON_ROOT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">subsys</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ROOT_NOPREFIX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">subsys</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">strcat</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">));</span>

	<span class="n">cfe</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cfe</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfe</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">lookup_one_len</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="n">cgroup_file_mode</span><span class="p">(</span><span class="n">cft</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">cgroup_create_file</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span> <span class="o">|</span> <span class="n">S_IFREG</span><span class="p">,</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfe</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">cft</span><span class="p">;</span>
		<span class="n">cfe</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span> <span class="o">=</span> <span class="n">cfe</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfe</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">);</span>
		<span class="n">cfe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cfe</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_addrm_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">subsys</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="n">cfts</span><span class="p">[],</span> <span class="n">bool</span> <span class="n">is_add</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cft</span> <span class="o">=</span> <span class="n">cfts</span><span class="p">;</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="n">cft</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_add</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">cgroup_add_file</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">subsys</span><span class="p">,</span> <span class="n">cft</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">cgroup_rm_file</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">cft</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;cgroup_addrm_files: failed to %s %s, err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">is_add</span> <span class="o">?</span> <span class="s">&quot;add&quot;</span> <span class="o">:</span> <span class="s">&quot;remove&quot;</span><span class="p">,</span> <span class="n">cft</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">cgroup_cft_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_cfts_prepare</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_cft_mutex</span><span class="p">)</span> <span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Thanks to the entanglement with vfs inode locking, we can&#39;t walk</span>
<span class="cm">	 * the existing cgroups under cgroup_mutex and create files.</span>
<span class="cm">	 * Instead, we increment reference on all cgroups and build list of</span>
<span class="cm">	 * them using @cgrp-&gt;cft_q_node.  Grab cgroup_cft_mutex to ensure</span>
<span class="cm">	 * exclusive access to the field.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_cft_mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_cfts_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cfts</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_add</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">)</span> <span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_cft_mutex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">pending</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="cm">/* %NULL @cfts indicates abort and don&#39;t bother if @ss isn&#39;t attached */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfts</span> <span class="o">&amp;&amp;</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">rootnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">allcg_list</span><span class="p">,</span> <span class="n">allcg_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dget</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">cft_q_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pending</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * All new cgroups will see @cfts update on @ss-&gt;cftsets.  Add/rm</span>
<span class="cm">	 * files for all cgroups which were created before.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pending</span><span class="p">,</span> <span class="n">cft_q_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgroup_is_removed</span><span class="p">(</span><span class="n">cgrp</span><span class="p">))</span>
			<span class="n">cgroup_addrm_files</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">cfts</span><span class="p">,</span> <span class="n">is_add</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">cft_q_node</span><span class="p">);</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_cft_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_add_cftypes - add an array of cftypes to a subsystem</span>
<span class="cm"> * @ss: target cgroup subsystem</span>
<span class="cm"> * @cfts: zero-length name terminated array of cftypes</span>
<span class="cm"> *</span>
<span class="cm"> * Register @cfts to @ss.  Files described by @cfts are created for all</span>
<span class="cm"> * existing cgroups to which @ss is attached and all future cgroups will</span>
<span class="cm"> * have them too.  This function can be called anytime whether @ss is</span>
<span class="cm"> * attached or not.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on successful registration, -errno on failure.  Note that this</span>
<span class="cm"> * function currently returns 0 as long as @cfts registration is successful</span>
<span class="cm"> * even if some file creation attempts on existing cgroups fail.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cgroup_add_cftypes</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cfts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cftype_set</span> <span class="o">*</span><span class="n">set</span><span class="p">;</span>

	<span class="n">set</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">set</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">set</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">cgroup_cfts_prepare</span><span class="p">();</span>
	<span class="n">set</span><span class="o">-&gt;</span><span class="n">cfts</span> <span class="o">=</span> <span class="n">cfts</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">cftsets</span><span class="p">);</span>
	<span class="n">cgroup_cfts_commit</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">cfts</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cgroup_add_cftypes</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_rm_cftypes - remove an array of cftypes from a subsystem</span>
<span class="cm"> * @ss: target cgroup subsystem</span>
<span class="cm"> * @cfts: zero-length name terminated array of cftypes</span>
<span class="cm"> *</span>
<span class="cm"> * Unregister @cfts from @ss.  Files described by @cfts are removed from</span>
<span class="cm"> * all existing cgroups to which @ss is attached and all future cgroups</span>
<span class="cm"> * won&#39;t have them either.  This function can be called anytime whether @ss</span>
<span class="cm"> * is attached or not.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on successful unregistration, -ENOENT if @cfts is not</span>
<span class="cm"> * registered with @ss.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cgroup_rm_cftypes</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cfts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cftype_set</span> <span class="o">*</span><span class="n">set</span><span class="p">;</span>

	<span class="n">cgroup_cfts_prepare</span><span class="p">();</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">cftsets</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">cfts</span> <span class="o">==</span> <span class="n">cfts</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="n">cgroup_cfts_commit</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">cfts</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cgroup_cfts_commit</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_task_count - count the number of tasks in a cgroup.</span>
<span class="cm"> * @cgrp: the cgroup in question</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of tasks in the cgroup.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cgroup_task_count</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">css_sets</span><span class="p">,</span> <span class="n">cgrp_link_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Advance a list_head iterator.  The iterator should be positioned at</span>
<span class="cm"> * the start of a css_set</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_advance_iter</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">cgroup_iter</span> <span class="o">*</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">cg_link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">cg</span><span class="p">;</span>

	<span class="cm">/* Advance to the next non-empty css_set */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">css_sets</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">it</span><span class="o">-&gt;</span><span class="n">cg_link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">link</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cg_cgroup_link</span><span class="p">,</span> <span class="n">cgrp_link_list</span><span class="p">);</span>
		<span class="n">cg</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">cg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">));</span>
	<span class="n">it</span><span class="o">-&gt;</span><span class="n">cg_link</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
	<span class="n">it</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">cg</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * To reduce the fork() overhead for systems that are not actually</span>
<span class="cm"> * using their cgroups capability, we don&#39;t maintain the lists running</span>
<span class="cm"> * through each css_set to its tasks until we see the list actually</span>
<span class="cm"> * used - in other words after the first call to cgroup_iter_start().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_enable_task_cg_lists</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">g</span><span class="p">;</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="n">use_task_css_set_links</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We need tasklist_lock because RCU is not safe against</span>
<span class="cm">	 * while_each_thread(). Besides, a forking task that has passed</span>
<span class="cm">	 * cgroup_post_fork() without seeing use_task_css_set_links = 1</span>
<span class="cm">	 * is not guaranteed to have its child immediately visible in the</span>
<span class="cm">	 * tasklist if we walk through it with RCU.</span>
<span class="cm">	 */</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">do_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task_lock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We should check if the process is exiting, otherwise</span>
<span class="cm">		 * it will race with cgroup_exit() in that the list</span>
<span class="cm">		 * entry won&#39;t be deleted though the process has exited.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cg_list</span><span class="p">))</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cg_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cgroups</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">);</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cgroup_iter_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_iter</span> <span class="o">*</span><span class="n">it</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">css_set_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The first time anyone tries to iterate across a cgroup,</span>
<span class="cm">	 * we need to enable the list linking each css_set to its</span>
<span class="cm">	 * tasks, and fix up all existing tasks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">use_task_css_set_links</span><span class="p">)</span>
		<span class="n">cgroup_enable_task_cg_lists</span><span class="p">();</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="n">it</span><span class="o">-&gt;</span><span class="n">cg_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">css_sets</span><span class="p">;</span>
	<span class="n">cgroup_advance_iter</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">it</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">cgroup_iter_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cgroup_iter</span> <span class="o">*</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>

	<span class="cm">/* If the iterator cg is NULL, we have no tasks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">cg_link</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">cg_list</span><span class="p">);</span>
	<span class="cm">/* Advance iterator to find next entry */</span>
	<span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">link</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">cg_link</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cg_cgroup_link</span><span class="p">,</span> <span class="n">cgrp_link_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We reached the end of this task list - move on to</span>
<span class="cm">		 * the next cg_cgroup_link */</span>
		<span class="n">cgroup_advance_iter</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">it</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cgroup_iter_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_iter</span> <span class="o">*</span><span class="n">it</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">css_set_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">started_after_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t1</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">time</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">start_diff</span> <span class="o">=</span> <span class="n">timespec_compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t1</span><span class="o">-&gt;</span><span class="n">start_time</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">start_diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Arbitrarily, if two processes started at the same</span>
<span class="cm">		 * time, we&#39;ll say that the lower pointer value</span>
<span class="cm">		 * started first. Note that t2 may have exited by now</span>
<span class="cm">		 * so this may not be a valid pointer any longer, but</span>
<span class="cm">		 * that&#39;s fine - it still serves to distinguish</span>
<span class="cm">		 * between two tasks started (effectively) simultaneously.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">t1</span> <span class="o">&gt;</span> <span class="n">t2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is a callback from heap_insert() and is used to order</span>
<span class="cm"> * the heap.</span>
<span class="cm"> * In this case we order the heap in descending task start time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">started_after</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t1</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t2</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">started_after_time</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t2</span><span class="o">-&gt;</span><span class="n">start_time</span><span class="p">,</span> <span class="n">t2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_scan_tasks - iterate though all the tasks in a cgroup</span>
<span class="cm"> * @scan: struct cgroup_scanner containing arguments for the scan</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments include pointers to callback functions test_task() and</span>
<span class="cm"> * process_task().</span>
<span class="cm"> * Iterate through all the tasks in a cgroup, calling test_task() for each,</span>
<span class="cm"> * and if it returns true, call process_task() for it also.</span>
<span class="cm"> * The test_task pointer may be NULL, meaning always true (select all tasks).</span>
<span class="cm"> * Effectively duplicates cgroup_iter_{start,next,end}()</span>
<span class="cm"> * but does not lock css_set_lock for the call to process_task().</span>
<span class="cm"> * The struct cgroup_scanner may be embedded in any structure of the caller&#39;s</span>
<span class="cm"> * creation.</span>
<span class="cm"> * It is guaranteed that process_task() will act on every task that</span>
<span class="cm"> * is a member of the cgroup for the duration of this call. This</span>
<span class="cm"> * function may or may not call process_task() for tasks that exit</span>
<span class="cm"> * or move to a different cgroup during the call, or are forked or</span>
<span class="cm"> * move into the cgroup during the call.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that test_task() may be called with locks held, and may in some</span>
<span class="cm"> * situations be called multiple times for the same task, so it should</span>
<span class="cm"> * be cheap.</span>
<span class="cm"> * If the heap pointer in the struct cgroup_scanner is non-NULL, a heap has been</span>
<span class="cm"> * pre-allocated and will be used for heap operations (and its &quot;gt&quot; member will</span>
<span class="cm"> * be overwritten), else a temporary heap will be used (allocation of which</span>
<span class="cm"> * may cause this function to fail).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cgroup_scan_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_scanner</span> <span class="o">*</span><span class="n">scan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_iter</span> <span class="n">it</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">dropped</span><span class="p">;</span>
	<span class="cm">/* Never dereference latest_task, since it&#39;s not refcounted */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">latest_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptr_heap</span> <span class="n">tmp_heap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ptr_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">latest_time</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scan</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The caller supplied our heap and pre-allocated its memory */</span>
		<span class="n">heap</span> <span class="o">=</span> <span class="n">scan</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">;</span>
		<span class="n">heap</span><span class="o">-&gt;</span><span class="n">gt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">started_after</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We need to allocate our own heap memory */</span>
		<span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp_heap</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">heap_init</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">started_after</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="cm">/* cannot allocate the heap */</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">again:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Scan tasks in the cgroup, using the scanner&#39;s &quot;test_task&quot; callback</span>
<span class="cm">	 * to determine which are of interest, and using the scanner&#39;s</span>
<span class="cm">	 * &quot;process_task&quot; callback to process any of them that need an update.</span>
<span class="cm">	 * Since we don&#39;t want to hold any locks during the task updates,</span>
<span class="cm">	 * gather tasks to be processed in a heap structure.</span>
<span class="cm">	 * The heap is sorted by descending task start time.</span>
<span class="cm">	 * If the statically-sized heap fills up, we overflow tasks that</span>
<span class="cm">	 * started later, and in future iterations only consider tasks that</span>
<span class="cm">	 * started after the latest task in the previous pass. This</span>
<span class="cm">	 * guarantees forward progress and that we don&#39;t miss any tasks.</span>
<span class="cm">	 */</span>
	<span class="n">heap</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cgroup_iter_start</span><span class="p">(</span><span class="n">scan</span><span class="o">-&gt;</span><span class="n">cg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">cgroup_iter_next</span><span class="p">(</span><span class="n">scan</span><span class="o">-&gt;</span><span class="n">cg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Only affect tasks that qualify per the caller&#39;s callback,</span>
<span class="cm">		 * if he provided one</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scan</span><span class="o">-&gt;</span><span class="n">test_task</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">scan</span><span class="o">-&gt;</span><span class="n">test_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">scan</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Only process tasks that started after the last task</span>
<span class="cm">		 * we processed</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">started_after_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">latest_time</span><span class="p">,</span> <span class="n">latest_task</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">dropped</span> <span class="o">=</span> <span class="n">heap_insert</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dropped</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The new task was inserted; the heap wasn&#39;t</span>
<span class="cm">			 * previously full</span>
<span class="cm">			 */</span>
			<span class="n">get_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dropped</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The new task was inserted, and pushed out a</span>
<span class="cm">			 * different task</span>
<span class="cm">			 */</span>
			<span class="n">get_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="n">put_task_struct</span><span class="p">(</span><span class="n">dropped</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Else the new task was newer than anything already in</span>
<span class="cm">		 * the heap and wasn&#39;t inserted</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
	<span class="n">cgroup_iter_end</span><span class="p">(</span><span class="n">scan</span><span class="o">-&gt;</span><span class="n">cg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">ptrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">latest_time</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">start_time</span><span class="p">;</span>
				<span class="n">latest_task</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Process the task per the caller&#39;s callback */</span>
			<span class="n">scan</span><span class="o">-&gt;</span><span class="n">process_task</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">scan</span><span class="p">);</span>
			<span class="n">put_task_struct</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we had to process any tasks at all, scan again</span>
<span class="cm">		 * in case some of them were in the middle of forking</span>
<span class="cm">		 * children that didn&#39;t get processed.</span>
<span class="cm">		 * Not the most efficient way to do it, but it avoids</span>
<span class="cm">		 * having to take callback_mutex in the fork path</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">heap</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">tmp_heap</span><span class="p">)</span>
		<span class="n">heap_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_heap</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stuff for reading the &#39;tasks&#39;/&#39;procs&#39; files.</span>
<span class="cm"> *</span>
<span class="cm"> * Reading this file can return large amounts of data if a cgroup has</span>
<span class="cm"> * *lots* of attached tasks. So it may need several calls to read(),</span>
<span class="cm"> * but we cannot guarantee that the information we produce is correct</span>
<span class="cm"> * unless we produce it entirely atomically.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/* which pidlist file are we talking about? */</span>
<span class="k">enum</span> <span class="n">cgroup_filetype</span> <span class="p">{</span>
	<span class="n">CGROUP_FILE_PROCS</span><span class="p">,</span>
	<span class="n">CGROUP_FILE_TASKS</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * A pidlist is a list of pids that virtually represents the contents of one</span>
<span class="cm"> * of the cgroup files (&quot;procs&quot; or &quot;tasks&quot;). We keep a list of such pidlists,</span>
<span class="cm"> * a pair (one each for procs, tasks) for each pid namespace that&#39;s relevant</span>
<span class="cm"> * to the cgroup.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cgroup_pidlist</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * used to find which pidlist is wanted. doesn&#39;t change as long as</span>
<span class="cm">	 * this particular list stays in the list.</span>
<span class="cm">	*/</span>
	<span class="k">struct</span> <span class="p">{</span> <span class="k">enum</span> <span class="n">cgroup_filetype</span> <span class="n">type</span><span class="p">;</span> <span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span> <span class="p">}</span> <span class="n">key</span><span class="p">;</span>
	<span class="cm">/* array of xids */</span>
	<span class="n">pid_t</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
	<span class="cm">/* how many elements the above list has */</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="cm">/* how many files are using the current array */</span>
	<span class="kt">int</span> <span class="n">use_count</span><span class="p">;</span>
	<span class="cm">/* each of these stored in a list by its cgroup */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">links</span><span class="p">;</span>
	<span class="cm">/* pointer to the cgroup we belong to, for list removal purposes */</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="cm">/* protects the other fields */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">mutex</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The following two functions &quot;fix&quot; the issue where there are more pids</span>
<span class="cm"> * than kmalloc will give memory for; in such cases, we use vmalloc/vfree.</span>
<span class="cm"> * TODO: replace with a kernel-wide solution to this problem</span>
<span class="cm"> */</span>
<span class="cp">#define PIDLIST_TOO_LARGE(c) ((c) * sizeof(pid_t) &gt; (PAGE_SIZE * 2))</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">pidlist_allocate</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PIDLIST_TOO_LARGE</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pid_t</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pid_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pidlist_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_vmalloc_addr</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">pidlist_resize</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newcount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">newlist</span><span class="p">;</span>
	<span class="cm">/* note: if new alloc fails, old p will still be valid either way */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_vmalloc_addr</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">newlist</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">newcount</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pid_t</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newlist</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">newlist</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">newcount</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pid_t</span><span class="p">));</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">newlist</span> <span class="o">=</span> <span class="n">krealloc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">newcount</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pid_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">newlist</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pidlist_uniq - given a kmalloc()ed list, strip out all duplicate entries</span>
<span class="cm"> * If the new stripped list is sufficiently smaller and there&#39;s enough memory</span>
<span class="cm"> * to allocate a new buffer, will let go of the unneeded memory. Returns the</span>
<span class="cm"> * number of unique elements.</span>
<span class="cm"> */</span>
<span class="cm">/* is the size difference enough that we should re-allocate the array? */</span>
<span class="cp">#define PIDLIST_REALLOC_DIFFERENCE(old, new) ((old) - PAGE_SIZE &gt;= (new))</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pidlist_uniq</span><span class="p">(</span><span class="n">pid_t</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">src</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="o">*</span><span class="n">newlist</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we presume the 0th element is unique, so i starts at 1. trivial</span>
<span class="cm">	 * edge cases first; no work needs to be done for either</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
	<span class="cm">/* src and dest walk down the list; dest counts unique elements */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">src</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">src</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">src</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* find next unique element */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">==</span> <span class="n">list</span><span class="p">[</span><span class="n">src</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">src</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">src</span> <span class="o">==</span> <span class="n">length</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">after</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* dest always points to where the next unique element goes */</span>
		<span class="n">list</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">src</span><span class="p">];</span>
		<span class="n">dest</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">after:</span>
	<span class="cm">/*</span>
<span class="cm">	 * if the length difference is large enough, we want to allocate a</span>
<span class="cm">	 * smaller buffer to save memory. if this fails due to out of memory,</span>
<span class="cm">	 * we&#39;ll just stay with what we&#39;ve got.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PIDLIST_REALLOC_DIFFERENCE</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">dest</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">newlist</span> <span class="o">=</span> <span class="n">pidlist_resize</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newlist</span><span class="p">)</span>
			<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">newlist</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dest</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmppid</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">pid_t</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">-</span> <span class="o">*</span><span class="p">(</span><span class="n">pid_t</span> <span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find the appropriate pidlist for our purpose (given procs vs tasks)</span>
<span class="cm"> * returns with the lock on that pidlist already held, and takes care</span>
<span class="cm"> * of the use count, or returns NULL with no locks held if we&#39;re out of</span>
<span class="cm"> * memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cgroup_pidlist</span> <span class="o">*</span><span class="nf">cgroup_pidlist_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
						  <span class="k">enum</span> <span class="n">cgroup_filetype</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_pidlist</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="cm">/* don&#39;t need task_nsproxy() if we&#39;re looking at ourself */</span>
	<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">pid_ns</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t drop the pidlist_mutex before taking the l-&gt;mutex in case</span>
<span class="cm">	 * the last ref-holder is trying to remove l from the list at the same</span>
<span class="cm">	 * time. Holding the pidlist_mutex precludes somebody taking whichever</span>
<span class="cm">	 * list we find out from under us - compare release_pid_array().</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">pidlist_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">pidlists</span><span class="p">,</span> <span class="n">links</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">type</span> <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">ns</span> <span class="o">==</span> <span class="n">ns</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* make sure l doesn&#39;t vanish out from under us */</span>
			<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">pidlist_mutex</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">l</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* entry not found; create a new one */</span>
	<span class="n">l</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_pidlist</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">pidlist_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">l</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">ns</span> <span class="o">=</span> <span class="n">get_pid_ns</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">use_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* don&#39;t increment here */</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">cgrp</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">pidlists</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">pidlist_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">l</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Load a cgroup&#39;s pidarray with either procs&#39; tgids or tasks&#39; pids</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pidlist_array_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">enum</span> <span class="n">cgroup_filetype</span> <span class="n">type</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">cgroup_pidlist</span> <span class="o">**</span><span class="n">lp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pid_t</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* used for populating the array */</span>
	<span class="k">struct</span> <span class="n">cgroup_iter</span> <span class="n">it</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_pidlist</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If cgroup gets more users after we read count, we won&#39;t have</span>
<span class="cm">	 * enough space - tough.  This race is indistinguishable to the</span>
<span class="cm">	 * caller from the case that the additional cgroup users didn&#39;t</span>
<span class="cm">	 * show up until sometime later on.</span>
<span class="cm">	 */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">cgroup_task_count</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="n">array</span> <span class="o">=</span> <span class="n">pidlist_allocate</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">array</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="cm">/* now, populate the array */</span>
	<span class="n">cgroup_iter_start</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">cgroup_iter_next</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">length</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* get tgid or pid for procs or tasks file respectively */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CGROUP_FILE_PROCS</span><span class="p">)</span>
			<span class="n">pid</span> <span class="o">=</span> <span class="n">task_tgid_vnr</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pid</span> <span class="o">=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* make sure to only use valid results */</span>
			<span class="n">array</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cgroup_iter_end</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">);</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="cm">/* now sort &amp; (if procs) strip out duplicates */</span>
	<span class="n">sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pid_t</span><span class="p">),</span> <span class="n">cmppid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CGROUP_FILE_PROCS</span><span class="p">)</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">pidlist_uniq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">l</span> <span class="o">=</span> <span class="n">cgroup_pidlist_find</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pidlist_free</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* store array, freeing old if necessary - lock already held */</span>
	<span class="n">pidlist_free</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="n">array</span><span class="p">;</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cgroupstats_build - build and fill cgroupstats</span>
<span class="cm"> * @stats: cgroupstats to fill information into</span>
<span class="cm"> * @dentry: A dentry entry belonging to the cgroup for which stats have</span>
<span class="cm"> * been requested.</span>
<span class="cm"> *</span>
<span class="cm"> * Build and fill cgroupstats so that taskstats can export it to user</span>
<span class="cm"> * space.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cgroupstats_build</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroupstats</span> <span class="o">*</span><span class="n">stats</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_iter</span> <span class="n">it</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Validate dentry by checking the superblock operations,</span>
<span class="cm">	 * and make sure it&#39;s a directory.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_op</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">cgroup_ops</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		 <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cgrp</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>

	<span class="n">cgroup_iter_start</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">cgroup_iter_next</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TASK_RUNNING</span>:
			<span class="n">stats</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TASK_INTERRUPTIBLE</span>:
			<span class="n">stats</span><span class="o">-&gt;</span><span class="n">nr_sleeping</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TASK_UNINTERRUPTIBLE</span>:
			<span class="n">stats</span><span class="o">-&gt;</span><span class="n">nr_uninterruptible</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TASK_STOPPED</span>:
			<span class="n">stats</span><span class="o">-&gt;</span><span class="n">nr_stopped</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">delayacct_is_task_waiting_on_io</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
				<span class="n">stats</span><span class="o">-&gt;</span><span class="n">nr_io_wait</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cgroup_iter_end</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">);</span>

<span class="nl">err:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * seq_file methods for the tasks/procs files. The seq_file position is the</span>
<span class="cm"> * next pid to display; the seq_file iterator is a pointer to the pid</span>
<span class="cm"> * in the cgroup-&gt;l-&gt;list array.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">cgroup_pidlist_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Initially we receive a position value that corresponds to</span>
<span class="cm">	 * one more than the last pid shown (or 0 on the first call or</span>
<span class="cm">	 * after a seek to the start). Use a binary-search to find the</span>
<span class="cm">	 * next pid to display, if any</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">cgroup_pidlist</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pid</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">index</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pid</span><span class="p">)</span>
				<span class="n">index</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* If we&#39;re off the end of the array, we&#39;re done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Update the abstract position to be the actual pid that we found */</span>
	<span class="n">iter</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">iter</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_pidlist_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_pidlist</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">cgroup_pidlist_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_pidlist</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">+</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Advance to the next pid in the array. If this goes off the</span>
<span class="cm">	 * end, we&#39;re done</span>
<span class="cm">	 */</span>
	<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_pidlist_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * seq_operations functions for iterating on pidlists through seq_file -</span>
<span class="cm"> * independent of whether it&#39;s tasks or procs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">cgroup_pidlist_seq_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">cgroup_pidlist_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">cgroup_pidlist_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">cgroup_pidlist_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">cgroup_pidlist_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_release_pid_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_pidlist</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * the case where we&#39;re the last user of this particular pidlist will</span>
<span class="cm">	 * have us remove it from the cgroup&#39;s list, which entails taking the</span>
<span class="cm">	 * mutex. since in pidlist_find the pidlist-&gt;lock depends on cgroup-&gt;</span>
<span class="cm">	 * pidlist_mutex, we have to take pidlist_mutex first.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pidlist_mutex</span><span class="p">);</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we&#39;re the last user if refcount is 0; remove and free */</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pidlist_mutex</span><span class="p">);</span>
		<span class="n">pidlist_free</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">put_pid_ns</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">ns</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pidlist_mutex</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_pidlist_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_pidlist</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * the seq_file will only be initialized if the file was opened for</span>
<span class="cm">	 * reading; hence we check if it&#39;s not null only in that case.</span>
<span class="cm">	 */</span>
	<span class="n">l</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">cgroup_release_pid_array</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">seq_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">cgroup_pidlist_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">cgroup_file_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">cgroup_pidlist_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The following functions handle opens on a file that displays a pidlist</span>
<span class="cm"> * (tasks or procs). Prepare an array of the process/thread IDs of whoever&#39;s</span>
<span class="cm"> * in the cgroup.</span>
<span class="cm"> */</span>
<span class="cm">/* helper function for the two below it */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_pidlist_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">enum</span> <span class="n">cgroup_filetype</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">__d_cgrp</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cgroup_pidlist</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* Nothing to do for write-only files */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* have the array populated */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">pidlist_array_load</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="cm">/* configure file information */</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cgroup_pidlist_operations</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgroup_pidlist_seq_operations</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cgroup_release_pid_array</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_tasks_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">unused</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cgroup_pidlist_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">CGROUP_FILE_TASKS</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_procs_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">unused</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cgroup_pidlist_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">CGROUP_FILE_PROCS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">cgroup_read_notify_on_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">notify_on_release</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_write_notify_on_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
					  <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">CGRP_RELEASABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CGRP_NOTIFY_ON_RELEASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CGRP_NOTIFY_ON_RELEASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unregister event and free resources.</span>
<span class="cm"> *</span>
<span class="cm"> * Gets called from workqueue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_event_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_event</span><span class="p">,</span>
			<span class="n">remove</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">unregister_event</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cft</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">eventfd</span><span class="p">);</span>

	<span class="n">eventfd_ctx_put</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">eventfd</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Gets called on POLLHUP on eventfd when user closes it.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with wqh-&gt;lock held and interrupts disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_event_wake</span><span class="p">(</span><span class="n">wait_queue_t</span> <span class="o">*</span><span class="n">wait</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">sync</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cgroup_event</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">key</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">POLLHUP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__remove_wait_queue</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">wqh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">event_list_lock</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">event_list_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are in atomic context, but cgroup_event_remove() may</span>
<span class="cm">		 * sleep, so we have to call it in workqueue.</span>
<span class="cm">		 */</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_event_ptable_queue_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wqh</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cgroup_event</span><span class="p">,</span> <span class="n">pt</span><span class="p">);</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">wqh</span> <span class="o">=</span> <span class="n">wqh</span><span class="p">;</span>
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="n">wqh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Parse input and register new cgroup event handler.</span>
<span class="cm"> *</span>
<span class="cm"> * Input must be in format &#39;&lt;event_fd&gt; &lt;control_fd&gt; &lt;args&gt;&#39;.</span>
<span class="cm"> * Interpretation of args is defined by control file implementation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_write_event_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">efd</span><span class="p">,</span> <span class="n">cfd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">efile</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">cfile</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">efd</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">endp</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">endp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">cfd</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">endp</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">endp</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">endp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">cgrp</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">init_poll_funcptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">,</span> <span class="n">cgroup_event_ptable_queue_proc</span><span class="p">);</span>
	<span class="n">init_waitqueue_func_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">cgroup_event_wake</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">,</span> <span class="n">cgroup_event_remove</span><span class="p">);</span>

	<span class="n">efile</span> <span class="o">=</span> <span class="n">eventfd_fget</span><span class="p">(</span><span class="n">efd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">efile</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">efile</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">eventfd</span> <span class="o">=</span> <span class="n">eventfd_ctx_fileget</span><span class="p">(</span><span class="n">efile</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">eventfd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">eventfd</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cfile</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">cfd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfile</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* the process need read permission on control file */</span>
	<span class="cm">/* AV: shouldn&#39;t we check that it&#39;s been opened for read instead? */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">inode_permission</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">MAY_READ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">cft</span> <span class="o">=</span> <span class="n">__file_cft</span><span class="p">(</span><span class="n">cfile</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cft</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cft</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">register_event</span> <span class="o">||</span> <span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">unregister_event</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">register_event</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cft</span><span class="p">,</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">eventfd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">efile</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">efile</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">POLLHUP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">unregister_event</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cft</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">eventfd</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Events should be removed after rmdir of cgroup directory, but before</span>
<span class="cm">	 * destroying subsystem state objects. Let&#39;s take reference to cgroup</span>
<span class="cm">	 * directory dentry to do that.</span>
<span class="cm">	 */</span>
	<span class="n">dget</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">event_list_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">event_list_lock</span><span class="p">);</span>

	<span class="n">fput</span><span class="p">(</span><span class="n">cfile</span><span class="p">);</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">efile</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfile</span><span class="p">)</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">cfile</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">eventfd</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">eventfd</span><span class="p">))</span>
		<span class="n">eventfd_ctx_put</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">eventfd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">efile</span><span class="p">))</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">efile</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">cgroup_clone_children_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">clone_children</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_clone_children_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CGRP_CLONE_CHILDREN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CGRP_CLONE_CHILDREN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * for the common functions, &#39;private&#39; gives the type of file</span>
<span class="cm"> */</span>
<span class="cm">/* for hysterical raisins, we can&#39;t put this on the older files */</span>
<span class="cp">#define CGROUP_FILE_GENERIC_PREFIX &quot;cgroup.&quot;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="n">files</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;tasks&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">cgroup_tasks_open</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cgroup_tasks_write</span><span class="p">,</span>
		<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">cgroup_pidlist_release</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">CGROUP_FILE_GENERIC_PREFIX</span> <span class="s">&quot;procs&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">cgroup_procs_open</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cgroup_procs_write</span><span class="p">,</span>
		<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">cgroup_pidlist_release</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;notify_on_release&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cgroup_read_notify_on_release</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cgroup_write_notify_on_release</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">CGROUP_FILE_GENERIC_PREFIX</span> <span class="s">&quot;event_control&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_string</span> <span class="o">=</span> <span class="n">cgroup_write_event_control</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">S_IWUGO</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;cgroup.clone_children&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cgroup_clone_children_read</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cgroup_clone_children_write</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;release_agent&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CFTYPE_ONLY_ON_ROOT</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cgroup_release_agent_show</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_string</span> <span class="o">=</span> <span class="n">cgroup_release_agent_write</span><span class="p">,</span>
		<span class="p">.</span><span class="n">max_write_len</span> <span class="o">=</span> <span class="n">PATH_MAX</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>	<span class="cm">/* terminate */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_populate_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">cgroup_addrm_files</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* process cftsets of each subsystem */</span>
	<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cftype_set</span> <span class="o">*</span><span class="n">set</span><span class="p">;</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">cftsets</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
			<span class="n">cgroup_addrm_files</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">cfts</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* This cgroup is ready now */</span>
	<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span> <span class="o">=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">];</span>
		<span class="cm">/*</span>
<span class="cm">		 * Update id-&gt;css pointer and make this css visible from</span>
<span class="cm">		 * CSS ID functions. This pointer will be dereferened</span>
<span class="cm">		 * from RCU-read-side without locks.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span>
			<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">,</span> <span class="n">css</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">css_dput_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_subsys_state</span><span class="p">,</span> <span class="n">dput_work</span><span class="p">);</span>

	<span class="n">dput</span><span class="p">(</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">cgroup</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_cgroup_css</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">css</span><span class="o">-&gt;</span><span class="n">cgroup</span> <span class="o">=</span> <span class="n">cgrp</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">css</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">css</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cgrp</span> <span class="o">==</span> <span class="n">dummytop</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CSS_ROOT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">]);</span>
	<span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">css</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If !clear_css_refs, css holds an extra ref to @cgrp-&gt;dentry</span>
<span class="cm">	 * which is put on the last css_put().  dput() requires process</span>
<span class="cm">	 * context, which css_put() may be called without.  @css-&gt;dput_work</span>
<span class="cm">	 * will be used to invoke dput() asynchronously from css_put().</span>
<span class="cm">	 */</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">dput_work</span><span class="p">,</span> <span class="n">css_dput_fn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">__DEPRECATED_clear_css_refs</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CSS_CLEAR_CSS_REFS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_lock_hierarchy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We need to take each hierarchy_mutex in a consistent order */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * No worry about a race with rebind_subsystems that might mess up the</span>
<span class="cm">	 * locking order, since both parties are under cgroup_mutex.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span> <span class="o">=</span> <span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">==</span> <span class="n">root</span><span class="p">)</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">hierarchy_mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_unlock_hierarchy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span> <span class="o">=</span> <span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">==</span> <span class="n">root</span><span class="p">)</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">hierarchy_mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cgroup_create - create a cgroup</span>
<span class="cm"> * @parent: cgroup that will be parent of the new cgroup</span>
<span class="cm"> * @dentry: dentry of the new cgroup</span>
<span class="cm"> * @mode: mode to set on new inode</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with the mutex on the parent inode held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">cgroup_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			     <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">;</span>

	<span class="n">cgrp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cgrp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgrp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Grab a reference on the superblock so the hierarchy doesn&#39;t</span>
<span class="cm">	 * get deleted on unmount if there are child cgroups.  This</span>
<span class="cm">	 * can be done outside cgroup_mutex, since the sb can&#39;t</span>
<span class="cm">	 * disappear while someone has an open control file on the</span>
<span class="cm">	 * fs */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_active</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>

	<span class="n">init_cgroup_housekeeping</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>

	<span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">top_cgroup</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">top_cgroup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notify_on_release</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CGRP_NOTIFY_ON_RELEASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clone_children</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CGRP_CLONE_CHILDREN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">css</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_destroy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">init_cgroup_css</span><span class="p">(</span><span class="n">css</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">cgrp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">use_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">alloc_css_id</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">cgrp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_destroy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* At error, -&gt;destroy() callback has to free assigned ID. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clone_children</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">post_clone</span><span class="p">)</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">post_clone</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cgroup_lock_hierarchy</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>
	<span class="n">cgroup_unlock_hierarchy</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">number_of_cgroups</span><span class="o">++</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">cgroup_create_dir</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_remove</span><span class="p">;</span>

	<span class="cm">/* If !clear_css_refs, each css holds a ref to the cgroup&#39;s dentry */</span>
	<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">__DEPRECATED_clear_css_refs</span><span class="p">)</span>
			<span class="n">dget</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="cm">/* The cgroup directory was pre-locked for us */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">));</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">allcg_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">allcg_list</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">cgroup_populate_dir</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="cm">/* If err &lt; 0, we have a half-filled directory - oh well ;) */</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">err_remove:</span>

	<span class="n">cgroup_lock_hierarchy</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">);</span>
	<span class="n">cgroup_unlock_hierarchy</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">number_of_cgroups</span><span class="o">--</span><span class="p">;</span>

 <span class="nl">err_destroy:</span>

	<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">])</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>

	<span class="cm">/* Release the reference count that we took on the superblock */</span>
	<span class="n">deactivate_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">c_parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>

	<span class="cm">/* the vfs holds inode-&gt;i_mutex already */</span>
	<span class="k">return</span> <span class="n">cgroup_create</span><span class="p">(</span><span class="n">c_parent</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span> <span class="o">|</span> <span class="n">S_IFDIR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check the reference count on each subsystem. Since we already</span>
<span class="cm"> * established that there are no tasks in the cgroup, if the css refcount</span>
<span class="cm"> * is also 1, then there should be no outstanding references, so the</span>
<span class="cm"> * subsystem is safe to destroy. We scan across all subsystems rather than</span>
<span class="cm"> * using the per-hierarchy linked list of mounted subsystems since we can</span>
<span class="cm"> * be called via check_for_release() with no synchronization other than</span>
<span class="cm"> * RCU, and the subsystem linked list isn&#39;t RCU-safe.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_has_css_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We won&#39;t need to lock the subsys array, because the subsystems</span>
<span class="cm">	 * we&#39;re concerned about aren&#39;t going anywhere since our cgroup root</span>
<span class="cm">	 * has a reference on them.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span> <span class="o">=</span> <span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">;</span>

		<span class="cm">/* Skip subsystems not present or not in this hierarchy */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">!=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">css</span> <span class="o">=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">];</span>
		<span class="cm">/*</span>
<span class="cm">		 * When called from check_for_release() it&#39;s possible</span>
<span class="cm">		 * that by this point the cgroup has been removed</span>
<span class="cm">		 * and the css deleted. But a false-positive doesn&#39;t</span>
<span class="cm">		 * matter, since it can only happen if the cgroup</span>
<span class="cm">		 * has been deleted and hence no longer needs the</span>
<span class="cm">		 * release agent to be called anyway.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">css</span> <span class="o">&amp;&amp;</span> <span class="n">css_refcnt</span><span class="p">(</span><span class="n">css</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Atomically mark all (or else none) of the cgroup&#39;s CSS objects as</span>
<span class="cm"> * CSS_REMOVED. Return true on success, or false if the cgroup has</span>
<span class="cm"> * busy subsystems. Call with cgroup_mutex held</span>
<span class="cm"> *</span>
<span class="cm"> * Depending on whether a subsys has __DEPRECATED_clear_css_refs set or</span>
<span class="cm"> * not, cgroup removal behaves differently.</span>
<span class="cm"> *</span>
<span class="cm"> * If clear is set, css refcnt for the subsystem should be zero before</span>
<span class="cm"> * cgroup removal can be committed.  This is implemented by</span>
<span class="cm"> * CGRP_WAIT_ON_RMDIR and retry logic around -&gt;pre_destroy(), which may be</span>
<span class="cm"> * called multiple times until all css refcnts reach zero and is allowed to</span>
<span class="cm"> * veto removal on any invocation.  This behavior is deprecated and will be</span>
<span class="cm"> * removed as soon as the existing user (memcg) is updated.</span>
<span class="cm"> *</span>
<span class="cm"> * If clear is not set, each css holds an extra reference to the cgroup&#39;s</span>
<span class="cm"> * dentry and cgroup removal proceeds regardless of css refs.</span>
<span class="cm"> * -&gt;pre_destroy() will be called at least once and is not allowed to fail.</span>
<span class="cm"> * On the last put of each css, whenever that may be, the extra dentry ref</span>
<span class="cm"> * is put so that dentry destruction happens only after all css&#39;s are</span>
<span class="cm"> * released.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_clear_css_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">failed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Block new css_tryget() by deactivating refcnt.  If all refcnts</span>
<span class="cm">	 * for subsystems w/ clear_css_refs set were 1 at the moment of</span>
<span class="cm">	 * deactivation, we succeeded.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span> <span class="o">=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">];</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">atomic_add</span><span class="p">(</span><span class="n">CSS_DEACT_BIAS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">__DEPRECATED_clear_css_refs</span><span class="p">)</span>
			<span class="n">failed</span> <span class="o">|=</span> <span class="n">css_refcnt</span><span class="p">(</span><span class="n">css</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If succeeded, set REMOVED and put all the base refs; otherwise,</span>
<span class="cm">	 * restore refcnts to positive values.  Either way, all in-progress</span>
<span class="cm">	 * css_tryget() will be released.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span> <span class="o">=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">failed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">CSS_REMOVED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">css_put</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">atomic_sub</span><span class="p">(</span><span class="n">CSS_DEACT_BIAS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">failed</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">unused_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cgroup_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* the vfs holds both inode-&gt;i_mutex already */</span>
<span class="nl">again:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In general, subsystem has no css-&gt;refcnt after pre_destroy(). But</span>
<span class="cm">	 * in racy cases, subsystem may have to get css-&gt;refcnt after</span>
<span class="cm">	 * pre_destroy() and it makes rmdir return with -EBUSY. This sometimes</span>
<span class="cm">	 * make rmdir return -EBUSY too often. To avoid that, we use waitqueue</span>
<span class="cm">	 * for cgroup&#39;s rmdir. CGRP_WAIT_ON_RMDIR is for synchronizing rmdir</span>
<span class="cm">	 * and subsystem&#39;s reference count handling. Please see css_get/put</span>
<span class="cm">	 * and css_tryget() and cgroup_wakeup_rmdir_waiter() implementation.</span>
<span class="cm">	 */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">CGRP_WAIT_ON_RMDIR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call pre_destroy handlers of subsys. Notify subsystems</span>
<span class="cm">	 * that rmdir() request comes.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">cgroup_call_pre_destroy</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CGRP_WAIT_ON_RMDIR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CGRP_WAIT_ON_RMDIR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_rmdir_waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgroup_clear_css_refs</span><span class="p">(</span><span class="n">cgrp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Because someone may call cgroup_wakeup_rmdir_waiter() before</span>
<span class="cm">		 * prepare_to_wait(), we need to check this flag.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CGRP_WAIT_ON_RMDIR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">schedule</span><span class="p">();</span>
		<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_rmdir_waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CGRP_WAIT_ON_RMDIR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* NO css_tryget() can success after here. */</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_rmdir_waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">CGRP_WAIT_ON_RMDIR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">release_list_lock</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">CGRP_REMOVED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">release_list</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">release_list</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">release_list_lock</span><span class="p">);</span>

	<span class="n">cgroup_lock_hierarchy</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
	<span class="cm">/* delete this cgroup from parent-&gt;children */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">);</span>
	<span class="n">cgroup_unlock_hierarchy</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">allcg_node</span><span class="p">);</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>

	<span class="n">cgroup_d_remove_dir</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">CGRP_RELEASABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">check_for_release</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unregister events and notify userspace.</span>
<span class="cm">	 * Notify userspace about cgroup removing only after rmdir of cgroup</span>
<span class="cm">	 * directory to avoid race between userspace and kernelspace</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">event_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">remove_wait_queue</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">wqh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">eventfd_signal</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">eventfd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">event_list_lock</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init_or_module</span> <span class="nf">cgroup_init_cftsets</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">cftsets</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * base_cftset is embedded in subsys itself, no need to worry about</span>
<span class="cm">	 * deregistration.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">base_cftypes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ss</span><span class="o">-&gt;</span><span class="n">base_cftset</span><span class="p">.</span><span class="n">cfts</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">base_cftypes</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">base_cftset</span><span class="p">.</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">cftsets</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">cgroup_init_subsys</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Initializing cgroup subsys %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* init base cftset */</span>
	<span class="n">cgroup_init_cftsets</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span>

	<span class="cm">/* Create the top cgroup state for this subsystem */</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rootnode</span><span class="p">.</span><span class="n">subsys_list</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rootnode</span><span class="p">;</span>
	<span class="n">css</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span><span class="n">dummytop</span><span class="p">);</span>
	<span class="cm">/* We don&#39;t handle early failures gracefully */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">css</span><span class="p">));</span>
	<span class="n">init_cgroup_css</span><span class="p">(</span><span class="n">css</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">dummytop</span><span class="p">);</span>

	<span class="cm">/* Update the init_css_set to contain a subsys</span>
<span class="cm">	 * pointer to this state - since the subsystem is</span>
<span class="cm">	 * newly registered, all tasks and hence the</span>
<span class="cm">	 * init_css_set is in the subsystem&#39;s top cgroup. */</span>
	<span class="n">init_css_set</span><span class="p">.</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">dummytop</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">];</span>

	<span class="n">need_forkexit_callback</span> <span class="o">|=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">fork</span> <span class="o">||</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">;</span>

	<span class="cm">/* At system boot, before all subsystems have been</span>
<span class="cm">	 * registered, no tasks have been forked, so we don&#39;t</span>
<span class="cm">	 * need to invoke fork callbacks here. */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_task</span><span class="p">.</span><span class="n">tasks</span><span class="p">));</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">hierarchy_mutex</span><span class="p">);</span>
	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">hierarchy_mutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_key</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* this function shouldn&#39;t be used with modular subsystems, since they</span>
<span class="cm">	 * need to register a subsys_id, among other things */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_load_subsys: load and register a modular subsystem at runtime</span>
<span class="cm"> * @ss: the subsystem to load</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called in a modular subsystem&#39;s initcall. If the</span>
<span class="cm"> * subsystem is built as a module, it will be assigned a new subsys_id and set</span>
<span class="cm"> * up for use. If the subsystem is built-in anyway, work is delegated to the</span>
<span class="cm"> * simpler cgroup_init_subsys.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">cgroup_load_subsys</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">;</span>

	<span class="cm">/* check name and function validity */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">strlen</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_CGROUP_TYPE_NAMELEN</span> <span class="o">||</span>
	    <span class="n">ss</span><span class="o">-&gt;</span><span class="n">create</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we don&#39;t support callbacks in modular subsystems. this check is</span>
<span class="cm">	 * before the ss-&gt;module check for consistency; a subsystem that could</span>
<span class="cm">	 * be a module should still have no callbacks even if the user isn&#39;t</span>
<span class="cm">	 * compiling it as one.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fork</span> <span class="o">||</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * an optionally modular subsystem is built-in: we want to do nothing,</span>
<span class="cm">	 * since cgroup_init_subsys will have already taken care of it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">module</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* a few sanity checks */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span> <span class="o">&gt;=</span> <span class="n">CGROUP_BUILTIN_SUBSYS_COUNT</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ss</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* init base cftset */</span>
	<span class="n">cgroup_init_cftsets</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * need to register a subsys id before anything else - for example,</span>
<span class="cm">	 * init_cgroup_css needs it.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="cm">/* find the first empty slot in the array */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">CGROUP_BUILTIN_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* maximum number of subsystems already registered! */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* assign ourselves the subsys_id */</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ss</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * no ss-&gt;create seems to need anything important in the ss struct, so</span>
<span class="cm">	 * this can happen first (i.e. before the rootnode attachment).</span>
<span class="cm">	 */</span>
	<span class="n">css</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span><span class="n">dummytop</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">css</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* failure case - need to deassign the subsys[] slot. */</span>
		<span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rootnode</span><span class="p">.</span><span class="n">subsys_list</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rootnode</span><span class="p">;</span>

	<span class="cm">/* our new subsystem will be attached to the dummy hierarchy. */</span>
	<span class="n">init_cgroup_css</span><span class="p">(</span><span class="n">css</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">dummytop</span><span class="p">);</span>
	<span class="cm">/* init_idr must be after init_cgroup_css because it sets css-&gt;id. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">use_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">cgroup_init_idr</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">css</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dummytop</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">ss</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">dummytop</span><span class="p">);</span>
			<span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we need to entangle the css into the existing css_sets. unlike</span>
<span class="cm">	 * in cgroup_init_subsys, there are now multiple css_sets, so each one</span>
<span class="cm">	 * will need a new pointer to it; done by iterating the css_set_table.</span>
<span class="cm">	 * furthermore, modifying the existing css_sets will corrupt the hash</span>
<span class="cm">	 * table state, so each changed css_set will need its hash recomputed.</span>
<span class="cm">	 * this is all done under the css_set_lock.</span>
<span class="cm">	 */</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CSS_SET_TABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">cg</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">bucket</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">css_set_table</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">new_bucket</span><span class="p">;</span>

		<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">bucket</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* skip entries that we already rehashed */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">])</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/* remove existing entry */</span>
			<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
			<span class="cm">/* set new value */</span>
			<span class="n">cg</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">css</span><span class="p">;</span>
			<span class="cm">/* recompute hash and restore entry */</span>
			<span class="n">new_bucket</span> <span class="o">=</span> <span class="n">css_set_hash</span><span class="p">(</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">);</span>
			<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="n">new_bucket</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">hierarchy_mutex</span><span class="p">);</span>
	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">hierarchy_mutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_key</span><span class="p">);</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* success! */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cgroup_load_subsys</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_unload_subsys: unload a modular subsystem</span>
<span class="cm"> * @ss: the subsystem to unload</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called in a modular subsystem&#39;s exitcall. When this</span>
<span class="cm"> * function is invoked, the refcount on the subsystem&#39;s module will be 0, so</span>
<span class="cm"> * the subsystem will not be attached to any hierarchy.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cgroup_unload_subsys</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hhead</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">module</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we shouldn&#39;t be called if the subsystem is in use, and the use of</span>
<span class="cm">	 * try_module_get in parse_cgroupfs_options should ensure that it</span>
<span class="cm">	 * doesn&#39;t start being used while we&#39;re killing it off.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">rootnode</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="cm">/* deassign the subsys_id */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span> <span class="o">&lt;</span> <span class="n">CGROUP_BUILTIN_SUBSYS_COUNT</span><span class="p">);</span>
	<span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* remove subsystem from rootnode&#39;s list of subsystems */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * disentangle the css from all css_sets attached to the dummytop. as</span>
<span class="cm">	 * in loading, we need to pay our respects to the hashtable gods.</span>
<span class="cm">	 */</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummytop</span><span class="o">-&gt;</span><span class="n">css_sets</span><span class="p">,</span> <span class="n">cgrp_link_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">cg</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">cg</span><span class="p">;</span>

		<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">]);</span>
		<span class="n">cg</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">hhead</span> <span class="o">=</span> <span class="n">css_set_hash</span><span class="p">(</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">);</span>
		<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="n">hhead</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * remove subsystem&#39;s css from the dummytop and free it - need to free</span>
<span class="cm">	 * before marking as null because ss-&gt;destroy needs the cgrp-&gt;subsys</span>
<span class="cm">	 * pointer to find their state. note that this also takes care of</span>
<span class="cm">	 * freeing the css_id.</span>
<span class="cm">	 */</span>
	<span class="n">ss</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">dummytop</span><span class="p">);</span>
	<span class="n">dummytop</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cgroup_unload_subsys</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_init_early - cgroup initialization at system boot</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize cgroups at system boot, and initialize any</span>
<span class="cm"> * subsystems that request early init.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">cgroup_init_early</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_css_set</span><span class="p">.</span><span class="n">refcount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_css_set</span><span class="p">.</span><span class="n">cg_links</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_css_set</span><span class="p">.</span><span class="n">tasks</span><span class="p">);</span>
	<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_css_set</span><span class="p">.</span><span class="n">hlist</span><span class="p">);</span>
	<span class="n">css_set_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">init_cgroup_root</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rootnode</span><span class="p">);</span>
	<span class="n">root_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">init_task</span><span class="p">.</span><span class="n">cgroups</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_css_set</span><span class="p">;</span>

	<span class="n">init_css_set_link</span><span class="p">.</span><span class="n">cg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_css_set</span><span class="p">;</span>
	<span class="n">init_css_set_link</span><span class="p">.</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">dummytop</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_css_set_link</span><span class="p">.</span><span class="n">cgrp_link_list</span><span class="p">,</span>
		 <span class="o">&amp;</span><span class="n">rootnode</span><span class="p">.</span><span class="n">top_cgroup</span><span class="p">.</span><span class="n">css_sets</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_css_set_link</span><span class="p">.</span><span class="n">cg_link_list</span><span class="p">,</span>
		 <span class="o">&amp;</span><span class="n">init_css_set</span><span class="p">.</span><span class="n">cg_links</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CSS_SET_TABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* at bootup time, we don&#39;t worry about modular subsystems */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_BUILTIN_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span> <span class="o">=</span> <span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_CGROUP_TYPE_NAMELEN</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;cgroup: Subsys %s id == %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ss</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">early_init</span><span class="p">)</span>
			<span class="n">cgroup_init_subsys</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_init - cgroup initialization</span>
<span class="cm"> *</span>
<span class="cm"> * Register cgroup filesystem and /proc file, and initialize</span>
<span class="cm"> * any subsystems that didn&#39;t request early init.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">cgroup_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hhead</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">bdi_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_backing_dev_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* at bootup time, we don&#39;t worry about modular subsystems */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_BUILTIN_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span> <span class="o">=</span> <span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">early_init</span><span class="p">)</span>
			<span class="n">cgroup_init_subsys</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">use_id</span><span class="p">)</span>
			<span class="n">cgroup_init_idr</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">init_css_set</span><span class="p">.</span><span class="n">subsys</span><span class="p">[</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* Add init_css_set to the hash table */</span>
	<span class="n">hhead</span> <span class="o">=</span> <span class="n">css_set_hash</span><span class="p">(</span><span class="n">init_css_set</span><span class="p">.</span><span class="n">subsys</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_css_set</span><span class="p">.</span><span class="n">hlist</span><span class="p">,</span> <span class="n">hhead</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">init_root_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rootnode</span><span class="p">));</span>

	<span class="n">cgroup_kobj</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">&quot;cgroup&quot;</span><span class="p">,</span> <span class="n">fs_kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgroup_kobj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="n">cgroup_kobj</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;cgroups&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_cgroupstats_operations</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">bdi_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_backing_dev_info</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * proc_cgroup_show()</span>
<span class="cm"> *  - Print task&#39;s cgroup paths into seq_file, one line for each hierarchy</span>
<span class="cm"> *  - Used for /proc/&lt;pid&gt;/cgroup.</span>
<span class="cm"> *  - No need to task_lock(tsk) on this tsk-&gt;cgroup reference, as it</span>
<span class="cm"> *    doesn&#39;t really matter if tsk-&gt;cgroup changes after we read it,</span>
<span class="cm"> *    and we take cgroup_mutex, keeping cgroup_attach_task() from changing it</span>
<span class="cm"> *    anyway.  No need to check that tsk-&gt;cgroup != NULL, thanks to</span>
<span class="cm"> *    the_top_cgroup_hack in cgroup_exit(), which sets an exiting tasks</span>
<span class="cm"> *    cgroup to top_cgroup.</span>
<span class="cm"> */</span>

<span class="cm">/* TODO: Use a proper seq_file iterator */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_cgroup_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroupfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">pid</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">tsk</span> <span class="o">=</span> <span class="n">get_pid_task</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>

	<span class="n">for_each_active_root</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%d:&quot;</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">hierarchy_id</span><span class="p">);</span>
		<span class="n">for_each_subsys</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s%s&quot;</span><span class="p">,</span> <span class="n">count</span><span class="o">++</span> <span class="o">?</span> <span class="s">&quot;,&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%sname=%s&quot;</span><span class="p">,</span> <span class="n">count</span> <span class="o">?</span> <span class="s">&quot;,&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
				   <span class="n">root</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">);</span>
		<span class="n">cgrp</span> <span class="o">=</span> <span class="n">task_cgroup_from_root</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">cgroup_path</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span> <span class="o">=</span> <span class="n">PROC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">proc_cgroup_show</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_cgroup_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">cgroup_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Display information about each subsystem and each hierarchy */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_cgroupstats_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;#subsys_name</span><span class="se">\t</span><span class="s">hierarchy</span><span class="se">\t</span><span class="s">num_cgroups</span><span class="se">\t</span><span class="s">enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * ideally we don&#39;t want subsystems moving around while we do this.</span>
<span class="cm">	 * cgroup_mutex is also necessary to guarantee an atomic snapshot of</span>
<span class="cm">	 * subsys/hierarchy state.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span> <span class="o">=</span> <span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">ss</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">hierarchy_id</span><span class="p">,</span>
			   <span class="n">ss</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">number_of_cgroups</span><span class="p">,</span> <span class="o">!</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroupstats_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">proc_cgroupstats_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_cgroupstats_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">cgroupstats_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_fork - attach newly forked task to its parents cgroup.</span>
<span class="cm"> * @child: pointer to task_struct of forking parent process.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: A task inherits its parent&#39;s cgroup at fork().</span>
<span class="cm"> *</span>
<span class="cm"> * A pointer to the shared css_set was automatically copied in</span>
<span class="cm"> * fork.c by dup_task_struct().  However, we ignore that copy, since</span>
<span class="cm"> * it was not made under the protection of RCU, cgroup_mutex or</span>
<span class="cm"> * threadgroup_change_begin(), so it might no longer be a valid</span>
<span class="cm"> * cgroup pointer.  cgroup_attach_task() might have already changed</span>
<span class="cm"> * current-&gt;cgroups, allowing the previously referenced cgroup</span>
<span class="cm"> * group to be removed and freed.</span>
<span class="cm"> *</span>
<span class="cm"> * Outside the pointer validity we also need to process the css_set</span>
<span class="cm"> * inheritance between threadgoup_change_begin() and</span>
<span class="cm"> * threadgoup_change_end(), this way there is no leak in any process</span>
<span class="cm"> * wide migration performed by cgroup_attach_proc() that could otherwise</span>
<span class="cm"> * miss a thread because it is too early or too late in the fork stage.</span>
<span class="cm"> *</span>
<span class="cm"> * At the point that cgroup_fork() is called, &#39;current&#39; is the parent</span>
<span class="cm"> * task, and the passed argument &#39;child&#39; points to the child task.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cgroup_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t need to task_lock() current because current-&gt;cgroups</span>
<span class="cm">	 * can&#39;t be changed concurrently here. The parent obviously hasn&#39;t</span>
<span class="cm">	 * exited and called cgroup_exit(), and we are synchronized against</span>
<span class="cm">	 * cgroup migration through threadgroup_change_begin().</span>
<span class="cm">	 */</span>
	<span class="n">child</span><span class="o">-&gt;</span><span class="n">cgroups</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">cgroups</span><span class="p">;</span>
	<span class="n">get_css_set</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">cgroups</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">cg_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_fork_callbacks - run fork callbacks</span>
<span class="cm"> * @child: the new task</span>
<span class="cm"> *</span>
<span class="cm"> * Called on a new task very soon before adding it to the</span>
<span class="cm"> * tasklist. No need to take any locks since no-one can</span>
<span class="cm"> * be operating on this task.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cgroup_fork_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_forkexit_callback</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * forkexit callbacks are only supported for builtin</span>
<span class="cm">		 * subsystems, and the builtin section of the subsys array is</span>
<span class="cm">		 * immutable, so we don&#39;t need to lock the subsys array here.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_BUILTIN_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span> <span class="o">=</span> <span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">)</span>
				<span class="n">ss</span><span class="o">-&gt;</span><span class="n">fork</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_post_fork - called on a new task after adding it to the task list</span>
<span class="cm"> * @child: the task in question</span>
<span class="cm"> *</span>
<span class="cm"> * Adds the task to the list running through its css_set if necessary.</span>
<span class="cm"> * Has to be after the task is visible on the task list in case we race</span>
<span class="cm"> * with the first call to cgroup_iter_start() - to guarantee that the</span>
<span class="cm"> * new task ends up on its list.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cgroup_post_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * use_task_css_set_links is set to 1 before we walk the tasklist</span>
<span class="cm">	 * under the tasklist_lock and we read it here after we added the child</span>
<span class="cm">	 * to the tasklist under the tasklist_lock as well. If the child wasn&#39;t</span>
<span class="cm">	 * yet in the tasklist when we walked through it from</span>
<span class="cm">	 * cgroup_enable_task_cg_lists(), then use_task_css_set_links value</span>
<span class="cm">	 * should be visible now due to the paired locking and barriers implied</span>
<span class="cm">	 * by LOCK/UNLOCK: it is written before the tasklist_lock unlock</span>
<span class="cm">	 * in cgroup_enable_task_cg_lists() and read here after the tasklist_lock</span>
<span class="cm">	 * lock on fork.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_task_css_set_links</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">cg_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * It&#39;s safe to use child-&gt;cgroups without task_lock()</span>
<span class="cm">			 * here because we are protected through</span>
<span class="cm">			 * threadgroup_change_begin() against concurrent</span>
<span class="cm">			 * css_set change in cgroup_task_migrate(). Also</span>
<span class="cm">			 * the task can&#39;t exit at that point until</span>
<span class="cm">			 * wake_up_new_task() is called, so we are protected</span>
<span class="cm">			 * against cgroup_exit() setting child-&gt;cgroup to</span>
<span class="cm">			 * init_css_set.</span>
<span class="cm">			 */</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">cg_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">cgroups</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * cgroup_exit - detach cgroup from exiting task</span>
<span class="cm"> * @tsk: pointer to task_struct of exiting process</span>
<span class="cm"> * @run_callback: run exit callbacks?</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Detach cgroup from @tsk and release it.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that cgroups marked notify_on_release force every task in</span>
<span class="cm"> * them to take the global cgroup_mutex mutex when exiting.</span>
<span class="cm"> * This could impact scaling on very large systems.  Be reluctant to</span>
<span class="cm"> * use notify_on_release cgroups where very high task exit scaling</span>
<span class="cm"> * is required on large systems.</span>
<span class="cm"> *</span>
<span class="cm"> * the_top_cgroup_hack:</span>
<span class="cm"> *</span>
<span class="cm"> *    Set the exiting tasks cgroup to the root cgroup (top_cgroup).</span>
<span class="cm"> *</span>
<span class="cm"> *    We call cgroup_exit() while the task is still competent to</span>
<span class="cm"> *    handle notify_on_release(), then leave the task attached to the</span>
<span class="cm"> *    root cgroup in each hierarchy for the remainder of its exit.</span>
<span class="cm"> *</span>
<span class="cm"> *    To do this properly, we would increment the reference count on</span>
<span class="cm"> *    top_cgroup, and near the very end of the kernel/exit.c do_exit()</span>
<span class="cm"> *    code we would add a second cgroup function call, to drop that</span>
<span class="cm"> *    reference.  This would just create an unnecessary hot spot on</span>
<span class="cm"> *    the top_cgroup reference count, to no avail.</span>
<span class="cm"> *</span>
<span class="cm"> *    Normally, holding a reference to a cgroup without bumping its</span>
<span class="cm"> *    count is unsafe.   The cgroup could go away, or someone could</span>
<span class="cm"> *    attach us to a different cgroup, decrementing the count on</span>
<span class="cm"> *    the first cgroup that we never incremented.  But in this case,</span>
<span class="cm"> *    top_cgroup isn&#39;t going away, and either task has PF_EXITING set,</span>
<span class="cm"> *    which wards off any cgroup_attach_task() attempts, or task is a failed</span>
<span class="cm"> *    fork, never visible to cgroup_attach_task.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cgroup_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">run_callbacks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">cg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unlink from the css_set task list if necessary.</span>
<span class="cm">	 * Optimistically check cg_list before taking</span>
<span class="cm">	 * css_set_lock</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cg_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cg_list</span><span class="p">))</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cg_list</span><span class="p">);</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Reassign the task to the init_css_set. */</span>
	<span class="n">task_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">cg</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cgroups</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cgroups</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_css_set</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">run_callbacks</span> <span class="o">&amp;&amp;</span> <span class="n">need_forkexit_callback</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * modular subsystems can&#39;t use callbacks, so no need to lock</span>
<span class="cm">		 * the subsys array</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_BUILTIN_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span> <span class="o">=</span> <span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">old_cgrp</span> <span class="o">=</span>
					<span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">cgroup</span><span class="p">;</span>
				<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">task_cgroup</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">ss</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">old_cgrp</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cg</span><span class="p">)</span>
		<span class="n">put_css_set_taskexit</span><span class="p">(</span><span class="n">cg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cgroup_is_descendant - see if @cgrp is a descendant of @task&#39;s cgrp</span>
<span class="cm"> * @cgrp: the cgroup in question</span>
<span class="cm"> * @task: the task in question</span>
<span class="cm"> *</span>
<span class="cm"> * See if @cgrp is a descendant of @task&#39;s cgroup in the appropriate</span>
<span class="cm"> * hierarchy.</span>
<span class="cm"> *</span>
<span class="cm"> * If we are sending in dummytop, then presumably we are creating</span>
<span class="cm"> * the top cgroup in the subsystem.</span>
<span class="cm"> *</span>
<span class="cm"> * Called only by the ns (nsproxy) cgroup.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cgroup_is_descendant</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cgrp</span> <span class="o">==</span> <span class="n">dummytop</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">target</span> <span class="o">=</span> <span class="n">task_cgroup_from_root</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cgrp</span> <span class="o">!=</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">cgrp</span><span class="o">!=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">top_cgroup</span><span class="p">)</span>
		<span class="n">cgrp</span> <span class="o">=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">cgrp</span> <span class="o">==</span> <span class="n">target</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_for_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* All of these checks rely on RCU to keep the cgroup</span>
<span class="cm">	 * structure alive */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cgroup_is_releasable</span><span class="p">(</span><span class="n">cgrp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cgroup_has_css_refs</span><span class="p">(</span><span class="n">cgrp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Control Group is currently removeable. If it&#39;s not</span>
<span class="cm">		 * already queued for a userspace notification, queue</span>
<span class="cm">		 * it now */</span>
		<span class="kt">int</span> <span class="n">need_schedule_work</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">release_list_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgroup_is_removed</span><span class="p">(</span><span class="n">cgrp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">release_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">release_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">release_list</span><span class="p">);</span>
			<span class="n">need_schedule_work</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">release_list_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_schedule_work</span><span class="p">)</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">release_agent_work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Caller must verify that the css is not for root cgroup */</span>
<span class="n">bool</span> <span class="nf">__css_tryget</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">css_refcnt</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CSS_REMOVED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__css_tryget</span><span class="p">);</span>

<span class="cm">/* Caller must verify that the css is not for root cgroup */</span>
<span class="kt">void</span> <span class="nf">__css_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">css</span><span class="o">-&gt;</span><span class="n">cgroup</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">css_unbias_refcnt</span><span class="p">(</span><span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">));</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">notify_on_release</span><span class="p">(</span><span class="n">cgrp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">CGRP_RELEASABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">check_for_release</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">cgroup_wakeup_rmdir_waiter</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CSS_CLEAR_CSS_REFS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">dput_work</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__css_put</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Notify userspace when a cgroup is released, by running the</span>
<span class="cm"> * configured release agent with the name of the cgroup (path</span>
<span class="cm"> * relative to the root of cgroup file system) as the argument.</span>
<span class="cm"> *</span>
<span class="cm"> * Most likely, this user command will try to rmdir this cgroup.</span>
<span class="cm"> *</span>
<span class="cm"> * This races with the possibility that some other task will be</span>
<span class="cm"> * attached to this cgroup before it is removed, or that some other</span>
<span class="cm"> * user task will &#39;mkdir&#39; a child cgroup of this cgroup.  That&#39;s ok.</span>
<span class="cm"> * The presumed &#39;rmdir&#39; will fail quietly if this cgroup is no longer</span>
<span class="cm"> * unused, and this cgroup will be reprieved from its death sentence,</span>
<span class="cm"> * to continue to serve a useful existence.  Next time it&#39;s released,</span>
<span class="cm"> * we will get notified again, if it still has &#39;notify_on_release&#39; set.</span>
<span class="cm"> *</span>
<span class="cm"> * The final arg to call_usermodehelper() is UMH_WAIT_EXEC, which</span>
<span class="cm"> * means only wait until the task is successfully execve()&#39;d.  The</span>
<span class="cm"> * separate release agent task is forked by call_usermodehelper(),</span>
<span class="cm"> * then control in this thread returns here, without waiting for the</span>
<span class="cm"> * release agent task.  We don&#39;t bother to wait because the caller of</span>
<span class="cm"> * this routine has no use for the exit status of the release agent</span>
<span class="cm"> * task, so no sense holding our caller up for that.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cgroup_release_agent</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">work</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">release_agent_work</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">release_list_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">release_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">*</span><span class="n">envp</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">pathbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">agentbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">release_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">cgroup</span><span class="p">,</span>
						    <span class="n">release_list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">release_list</span><span class="p">);</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">release_list_lock</span><span class="p">);</span>
		<span class="n">pathbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pathbuf</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">continue_free</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cgroup_path</span><span class="p">(</span><span class="n">cgrp</span><span class="p">,</span> <span class="n">pathbuf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">continue_free</span><span class="p">;</span>
		<span class="n">agentbuf</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">release_agent_path</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">agentbuf</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">continue_free</span><span class="p">;</span>

		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">agentbuf</span><span class="p">;</span>
		<span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">pathbuf</span><span class="p">;</span>
		<span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* minimal command environment */</span>
		<span class="n">envp</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;HOME=/&quot;</span><span class="p">;</span>
		<span class="n">envp</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;</span><span class="p">;</span>
		<span class="n">envp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* Drop the lock while we invoke the usermode helper,</span>
<span class="cm">		 * since the exec could involve hitting disk and hence</span>
<span class="cm">		 * be a slow process */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
		<span class="n">call_usermodehelper</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">,</span> <span class="n">UMH_WAIT_EXEC</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
 <span class="nl">continue_free:</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pathbuf</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">agentbuf</span><span class="p">);</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">release_list_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">release_list_lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cgroup_disable</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">token</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">token</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">token</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * cgroup_disable, being at boot time, can&#39;t know about module</span>
<span class="cm">		 * subsystems, so we don&#39;t worry about them.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CGROUP_BUILTIN_SUBSYS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span> <span class="o">=</span> <span class="n">subsys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ss</span><span class="o">-&gt;</span><span class="n">disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Disabling %s control group&quot;</span>
					<span class="s">&quot; subsystem</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;cgroup_disable=&quot;</span><span class="p">,</span> <span class="n">cgroup_disable</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Functons for CSS ID.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *To get ID other than 0, this should be called when !cgroup_is_removed().</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">css_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">css_id</span> <span class="o">*</span><span class="n">cssid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This css_id() can return correct value when somone has refcnt</span>
<span class="cm">	 * on this or this is under rcu_read_lock(). Once css-&gt;id is allocated,</span>
<span class="cm">	 * it&#39;s unchanged until freed.</span>
<span class="cm">	 */</span>
	<span class="n">cssid</span> <span class="o">=</span> <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">css_refcnt</span><span class="p">(</span><span class="n">css</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cssid</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cssid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">css_id</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">css_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">css_id</span> <span class="o">*</span><span class="n">cssid</span><span class="p">;</span>

	<span class="n">cssid</span> <span class="o">=</span> <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">css_refcnt</span><span class="p">(</span><span class="n">css</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cssid</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cssid</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">css_depth</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *  css_is_ancestor - test &quot;root&quot; css is an ancestor of &quot;child&quot;</span>
<span class="cm"> * @child: the css to be tested.</span>
<span class="cm"> * @root: the css supporsed to be an ancestor of the child.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if &quot;root&quot; is an ancestor of &quot;child&quot; in its hierarchy. Because</span>
<span class="cm"> * this function reads css-&gt;id, the caller must hold rcu_read_lock().</span>
<span class="cm"> * But, considering usual usage, the csses should be valid objects after test.</span>
<span class="cm"> * Assuming that the caller will do some action to the child if this returns</span>
<span class="cm"> * returns true, the caller must take &quot;child&quot;;s reference count.</span>
<span class="cm"> * If &quot;child&quot; is valid object and this returns true, &quot;root&quot; is valid, too.</span>
<span class="cm"> */</span>

<span class="n">bool</span> <span class="nf">css_is_ancestor</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span>
		    <span class="k">const</span> <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">css_id</span> <span class="o">*</span><span class="n">child_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">css_id</span> <span class="o">*</span><span class="n">root_id</span><span class="p">;</span>

	<span class="n">child_id</span>  <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">root_id</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">child_id</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="n">root_id</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">child_id</span><span class="o">-&gt;</span><span class="n">stack</span><span class="p">[</span><span class="n">root_id</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">]</span> <span class="o">!=</span> <span class="n">root_id</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_css_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">css_id</span> <span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="n">css</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="cm">/* When this is called before css_id initialization, id can be NULL */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">id</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">use_id</span><span class="p">);</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">id_lock</span><span class="p">);</span>
	<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">,</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">id_lock</span><span class="p">);</span>
	<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">rcu_head</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">free_css_id</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This is called by init or create(). Then, calls to this function are</span>
<span class="cm"> * always serialized (By cgroup_mutex() at create()).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">css_id</span> <span class="o">*</span><span class="nf">get_new_cssid</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">css_id</span> <span class="o">*</span><span class="n">newid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">myid</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">use_id</span><span class="p">);</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">newid</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">newid</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newid</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="cm">/* get id */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">id_lock</span><span class="p">);</span>
	<span class="cm">/* Don&#39;t use 0. allocates an ID of 1-65535 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">idr_get_new_above</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">,</span> <span class="n">newid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">myid</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">id_lock</span><span class="p">);</span>

	<span class="cm">/* Returns error when there are no free spaces for new ID.*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">myid</span> <span class="o">&gt;</span> <span class="n">CSS_ID_MAX</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">remove_idr</span><span class="p">;</span>

	<span class="n">newid</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">myid</span><span class="p">;</span>
	<span class="n">newid</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">newid</span><span class="p">;</span>
<span class="nl">remove_idr:</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">id_lock</span><span class="p">);</span>
	<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">,</span> <span class="n">myid</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">id_lock</span><span class="p">);</span>
<span class="nl">err_out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">newid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init_or_module</span> <span class="nf">cgroup_init_idr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">rootcss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">css_id</span> <span class="o">*</span><span class="n">newid</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">id_lock</span><span class="p">);</span>
	<span class="n">idr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">);</span>

	<span class="n">newid</span> <span class="o">=</span> <span class="n">get_new_cssid</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">newid</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">newid</span><span class="p">);</span>

	<span class="n">newid</span><span class="o">-&gt;</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">newid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">newid</span><span class="o">-&gt;</span><span class="n">css</span> <span class="o">=</span> <span class="n">rootcss</span><span class="p">;</span>
	<span class="n">rootcss</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">newid</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_css_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">subsys_id</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">parent_css</span><span class="p">,</span> <span class="o">*</span><span class="n">child_css</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">css_id</span> <span class="o">*</span><span class="n">child_id</span><span class="p">,</span> <span class="o">*</span><span class="n">parent_id</span><span class="p">;</span>

	<span class="n">subsys_id</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">subsys_id</span><span class="p">;</span>
	<span class="n">parent_css</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">subsys_id</span><span class="p">];</span>
	<span class="n">child_css</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">subsys_id</span><span class="p">];</span>
	<span class="n">parent_id</span> <span class="o">=</span> <span class="n">parent_css</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">parent_id</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">child_id</span> <span class="o">=</span> <span class="n">get_new_cssid</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">child_id</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">child_id</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">child_id</span><span class="o">-&gt;</span><span class="n">stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent_id</span><span class="o">-&gt;</span><span class="n">stack</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">child_id</span><span class="o">-&gt;</span><span class="n">stack</span><span class="p">[</span><span class="n">depth</span><span class="p">]</span> <span class="o">=</span> <span class="n">child_id</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * child_id-&gt;css pointer will be set after this cgroup is available</span>
<span class="cm">	 * see cgroup_populate_dir()</span>
<span class="cm">	 */</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">child_css</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">child_id</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * css_lookup - lookup css by id</span>
<span class="cm"> * @ss: cgroup subsys to be looked into.</span>
<span class="cm"> * @id: the id</span>
<span class="cm"> *</span>
<span class="cm"> * Returns pointer to cgroup_subsys_state if there is valid one with id.</span>
<span class="cm"> * NULL if not. Should be called under rcu_read_lock()</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="nf">css_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">css_id</span> <span class="o">*</span><span class="n">cssid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">use_id</span><span class="p">);</span>
	<span class="n">cssid</span> <span class="o">=</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cssid</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">cssid</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">css_lookup</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * css_get_next - lookup next cgroup under specified hierarchy.</span>
<span class="cm"> * @ss: pointer to subsystem</span>
<span class="cm"> * @id: current position of iteration.</span>
<span class="cm"> * @root: pointer to css. search tree under this.</span>
<span class="cm"> * @foundid: position of found object.</span>
<span class="cm"> *</span>
<span class="cm"> * Search next css under the specified hierarchy of rootid. Calling under</span>
<span class="cm"> * rcu_read_lock() is necessary. Returns NULL if it reaches the end.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span>
<span class="nf">css_get_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">foundid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">css_id</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmpid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rootid</span> <span class="o">=</span> <span class="n">css_id</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">css_depth</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rootid</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">use_id</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">rcu_read_lock_held</span><span class="p">());</span>

	<span class="cm">/* fill start point for scan */</span>
	<span class="n">tmpid</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * scan next entry from bitmap(tree), tmpid is updated after</span>
<span class="cm">		 * idr_get_next().</span>
<span class="cm">		 */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">idr_get_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmpid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">&gt;=</span> <span class="n">depth</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">stack</span><span class="p">[</span><span class="n">depth</span><span class="p">]</span> <span class="o">==</span> <span class="n">rootid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">foundid</span> <span class="o">=</span> <span class="n">tmpid</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* continue to scan from next id */</span>
		<span class="n">tmpid</span> <span class="o">=</span> <span class="n">tmpid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get corresponding css from file open on cgroupfs directory</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="nf">cgroup_css_from_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="cm">/* check in cgroup filesystem dir */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">cgroup_dir_inode_operations</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EBADF</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">id</span> <span class="o">&gt;=</span> <span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="cm">/* get cgroup */</span>
	<span class="n">cgrp</span> <span class="o">=</span> <span class="n">__d_cgrp</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="p">);</span>
	<span class="n">css</span> <span class="o">=</span> <span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">css</span> <span class="o">?</span> <span class="n">css</span> <span class="o">:</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CGROUP_DEBUG</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="nf">debug_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">css</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">css</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">css</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">debug_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cont</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">[</span><span class="n">debug_subsys_id</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">cgroup_refcount_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cont</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">debug_taskcount_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cgroup_task_count</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">current_css_set_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">cgroups</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">current_css_set_refcount_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">cgroups</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">current_css_set_cg_links_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">cg</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">cg</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">cgroups</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">cg_links</span><span class="p">,</span> <span class="n">cg_link_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">)</span>
			<span class="n">name</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;?&quot;</span><span class="p">;</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Root %d group %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">c</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">hierarchy_id</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define MAX_TASKS_SHOWN_PER_CSS 25</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cgroup_css_links_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cg_cgroup_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cont</span><span class="o">-&gt;</span><span class="n">css_sets</span><span class="p">,</span> <span class="n">cgrp_link_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">cg</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">cg</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;css_set %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cg</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">,</span> <span class="n">cg_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="o">++</span> <span class="o">&gt;</span> <span class="n">MAX_TASKS_SHOWN_PER_CSS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  task %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css_set_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">releasable_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">CGRP_RELEASABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="n">debug_files</span><span class="p">[]</span> <span class="o">=</span>  <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;cgroup_refcount&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cgroup_refcount_read</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;taskcount&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">debug_taskcount_read</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;current_css_set&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">current_css_set_read</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;current_css_set_refcount&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">current_css_set_refcount_read</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;current_css_set_cg_links&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">current_css_set_cg_links_read</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;cgroup_css_links&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">cgroup_css_links_read</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;releasable&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">releasable_read</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">{</span> <span class="p">}</span>	<span class="cm">/* terminate */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="n">debug_subsys</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;debug&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">debug_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">debug_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">subsys_id</span> <span class="o">=</span> <span class="n">debug_subsys_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">base_cftypes</span> <span class="o">=</span> <span class="n">debug_files</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CGROUP_DEBUG */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
