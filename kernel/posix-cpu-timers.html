<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › posix-cpu-timers.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>posix-cpu-timers.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Implement CPU time clocks for the POSIX clock interface.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/posix-timers.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/math64.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;trace/events/timer.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Called after updating RLIMIT_CPU to run cpu timer and update</span>
<span class="cm"> * tsk-&gt;signal-&gt;cputime_expires expiration cache if necessary. Needs</span>
<span class="cm"> * siglock protection since other code may update expiration cache as</span>
<span class="cm"> * well.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">update_rlimit_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rlim_new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cputime_t</span> <span class="n">cputime</span> <span class="o">=</span> <span class="n">secs_to_cputime</span><span class="p">(</span><span class="n">rlim_new</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">set_process_cpu_timer</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">CPUCLOCK_PROF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cputime</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_clock</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">CPUCLOCK_PID</span><span class="p">(</span><span class="n">which_clock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_WHICH</span><span class="p">(</span><span class="n">which_clock</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">CPUCLOCK_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">CPUCLOCK_PERTHREAD</span><span class="p">(</span><span class="n">which_clock</span><span class="p">)</span> <span class="o">?</span>
		   <span class="n">same_thread_group</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span> <span class="o">:</span> <span class="n">has_group_leader_pid</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">union</span> <span class="n">cpu_time_count</span>
<span class="nf">timespec_to_sample</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">cpu_time_count</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span><span class="p">.</span><span class="n">sched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* high half always zero when .cpu used */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_WHICH</span><span class="p">(</span><span class="n">which_clock</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPUCLOCK_SCHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span><span class="p">.</span><span class="n">sched</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span> <span class="o">+</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span><span class="p">.</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">timespec_to_cputime</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sample_to_timespec</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span>
			       <span class="k">union</span> <span class="n">cpu_time_count</span> <span class="n">cpu</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_WHICH</span><span class="p">(</span><span class="n">which_clock</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPUCLOCK_SCHED</span><span class="p">)</span>
		<span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">ns_to_timespec</span><span class="p">(</span><span class="n">cpu</span><span class="p">.</span><span class="n">sched</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cputime_to_timespec</span><span class="p">(</span><span class="n">cpu</span><span class="p">.</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cpu_time_before</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span>
				  <span class="k">union</span> <span class="n">cpu_time_count</span> <span class="n">now</span><span class="p">,</span>
				  <span class="k">union</span> <span class="n">cpu_time_count</span> <span class="n">then</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_WHICH</span><span class="p">(</span><span class="n">which_clock</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPUCLOCK_SCHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">now</span><span class="p">.</span><span class="n">sched</span> <span class="o">&lt;</span> <span class="n">then</span><span class="p">.</span><span class="n">sched</span><span class="p">;</span>
	<span class="p">}</span>  <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">now</span><span class="p">.</span><span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">then</span><span class="p">.</span><span class="n">cpu</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpu_time_add</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span>
				<span class="k">union</span> <span class="n">cpu_time_count</span> <span class="o">*</span><span class="n">acc</span><span class="p">,</span>
			        <span class="k">union</span> <span class="n">cpu_time_count</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_WHICH</span><span class="p">(</span><span class="n">which_clock</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPUCLOCK_SCHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">acc</span><span class="o">-&gt;</span><span class="n">sched</span> <span class="o">+=</span> <span class="n">val</span><span class="p">.</span><span class="n">sched</span><span class="p">;</span>
	<span class="p">}</span>  <span class="k">else</span> <span class="p">{</span>
		<span class="n">acc</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">+=</span> <span class="n">val</span><span class="p">.</span><span class="n">cpu</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">union</span> <span class="n">cpu_time_count</span> <span class="nf">cpu_time_sub</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span>
						<span class="k">union</span> <span class="n">cpu_time_count</span> <span class="n">a</span><span class="p">,</span>
						<span class="k">union</span> <span class="n">cpu_time_count</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_WHICH</span><span class="p">(</span><span class="n">which_clock</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPUCLOCK_SCHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">a</span><span class="p">.</span><span class="n">sched</span> <span class="o">-=</span> <span class="n">b</span><span class="p">.</span><span class="n">sched</span><span class="p">;</span>
	<span class="p">}</span>  <span class="k">else</span> <span class="p">{</span>
		<span class="n">a</span><span class="p">.</span><span class="n">cpu</span> <span class="o">-=</span> <span class="n">b</span><span class="p">.</span><span class="n">cpu</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update expiry time from increment, and increase overrun count,</span>
<span class="cm"> * given the current clock sample.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bump_cpu_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">k_itimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
				  <span class="k">union</span> <span class="n">cpu_time_count</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">incr</span><span class="p">.</span><span class="n">sched</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_WHICH</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPUCLOCK_SCHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">,</span> <span class="n">incr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">sched</span> <span class="o">&lt;</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">incr</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">incr</span><span class="p">.</span><span class="n">sched</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">sched</span> <span class="o">+</span> <span class="n">incr</span> <span class="o">-</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span><span class="p">;</span>
		<span class="cm">/* Don&#39;t use (incr*2 &lt; delta), incr*2 might overflow. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">incr</span> <span class="o">&lt;</span> <span class="n">delta</span> <span class="o">-</span> <span class="n">incr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">incr</span> <span class="o">=</span> <span class="n">incr</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">incr</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="n">incr</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span> <span class="o">+=</span> <span class="n">incr</span><span class="p">;</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_overrun</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">delta</span> <span class="o">-=</span> <span class="n">incr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cputime_t</span> <span class="n">delta</span><span class="p">,</span> <span class="n">incr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">incr</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">incr</span><span class="p">.</span><span class="n">cpu</span><span class="p">;</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">cpu</span> <span class="o">+</span> <span class="n">incr</span> <span class="o">-</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span><span class="p">;</span>
		<span class="cm">/* Don&#39;t use (incr*2 &lt; delta), incr*2 might overflow. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">incr</span> <span class="o">&lt;</span> <span class="n">delta</span> <span class="o">-</span> <span class="n">incr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			     <span class="n">incr</span> <span class="o">+=</span> <span class="n">incr</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">incr</span> <span class="o">=</span> <span class="n">incr</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="n">incr</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span> <span class="o">+=</span> <span class="n">incr</span><span class="p">;</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_overrun</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">delta</span> <span class="o">-=</span> <span class="n">incr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">cputime_t</span> <span class="nf">prof_ticks</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">cputime_t</span> <span class="nf">virt_ticks</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">utime</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">posix_cpu_clock_getres</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">check_clock</span><span class="p">(</span><span class="n">which_clock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="p">((</span><span class="n">NSEC_PER_SEC</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_WHICH</span><span class="p">(</span><span class="n">which_clock</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPUCLOCK_SCHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If sched_clock is using a cycle counter, we</span>
<span class="cm">			 * don&#39;t have any idea of its true resolution</span>
<span class="cm">			 * exported, but it is much more than 1s/HZ.</span>
<span class="cm">			 */</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">posix_cpu_clock_set</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * You can never reset a CPU clock, but we check for other errors</span>
<span class="cm">	 * in the call before failing with EPERM.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">check_clock</span><span class="p">(</span><span class="n">which_clock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Sample a per-thread clock for the given task.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_clock_sample</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
			    <span class="k">union</span> <span class="n">cpu_time_count</span> <span class="o">*</span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">CPUCLOCK_WHICH</span><span class="p">(</span><span class="n">which_clock</span><span class="p">))</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPUCLOCK_PROF</span>:
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">prof_ticks</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPUCLOCK_VIRT</span>:
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">virt_ticks</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPUCLOCK_SCHED</span>:
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">sched</span> <span class="o">=</span> <span class="n">task_sched_runtime</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread_group_cputime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_cputime</span> <span class="o">*</span><span class="n">times</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="n">times</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">=</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">utime</span><span class="p">;</span>
	<span class="n">times</span><span class="o">-&gt;</span><span class="n">stime</span> <span class="o">=</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">;</span>
	<span class="n">times</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span> <span class="o">=</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">sum_sched_runtime</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="cm">/* make sure we can trust tsk-&gt;thread_group list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">likely</span><span class="p">(</span><span class="n">pid_alive</span><span class="p">(</span><span class="n">tsk</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">tsk</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">times</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">+=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">utime</span><span class="p">;</span>
		<span class="n">times</span><span class="o">-&gt;</span><span class="n">stime</span> <span class="o">+=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">;</span>
		<span class="n">times</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span> <span class="o">+=</span> <span class="n">task_sched_runtime</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_gt_cputime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_cputime</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_cputime</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">utime</span><span class="p">)</span>
		<span class="n">a</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">utime</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">stime</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">)</span>
		<span class="n">a</span><span class="o">-&gt;</span><span class="n">stime</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span><span class="p">)</span>
		<span class="n">a</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread_group_cputimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_cputime</span> <span class="o">*</span><span class="n">times</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_group_cputimer</span> <span class="o">*</span><span class="n">cputimer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cputimer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_cputime</span> <span class="n">sum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cputimer</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The POSIX timer interface allows for absolute time expiry</span>
<span class="cm">		 * values through the TIMER_ABSTIME flag, therefore we have</span>
<span class="cm">		 * to synchronize the timer to the clock every time we start</span>
<span class="cm">		 * it.</span>
<span class="cm">		 */</span>
		<span class="n">thread_group_cputime</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sum</span><span class="p">);</span>
		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cputimer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">cputimer</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">update_gt_cputime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cputimer</span><span class="o">-&gt;</span><span class="n">cputime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sum</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cputimer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="o">*</span><span class="n">times</span> <span class="o">=</span> <span class="n">cputimer</span><span class="o">-&gt;</span><span class="n">cputime</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cputimer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sample a process (thread group) clock for the given group_leader task.</span>
<span class="cm"> * Must be called with tasklist_lock held for reading.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_clock_sample_group</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				  <span class="k">union</span> <span class="n">cpu_time_count</span> <span class="o">*</span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_cputime</span> <span class="n">cputime</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">CPUCLOCK_WHICH</span><span class="p">(</span><span class="n">which_clock</span><span class="p">))</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPUCLOCK_PROF</span>:
		<span class="n">thread_group_cputime</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cputime</span><span class="p">);</span>
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cputime</span><span class="p">.</span><span class="n">utime</span> <span class="o">+</span> <span class="n">cputime</span><span class="p">.</span><span class="n">stime</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPUCLOCK_VIRT</span>:
		<span class="n">thread_group_cputime</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cputime</span><span class="p">);</span>
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cputime</span><span class="p">.</span><span class="n">utime</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPUCLOCK_SCHED</span>:
		<span class="n">thread_group_cputime</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cputime</span><span class="p">);</span>
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">sched</span> <span class="o">=</span> <span class="n">cputime</span><span class="p">.</span><span class="n">sum_exec_runtime</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">posix_cpu_clock_get</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">CPUCLOCK_PID</span><span class="p">(</span><span class="n">which_clock</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cpu_time_count</span> <span class="n">rtn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Special case constant value for our own clocks.</span>
<span class="cm">		 * We don&#39;t have to do any lookup to find ourselves.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_PERTHREAD</span><span class="p">(</span><span class="n">which_clock</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Sampling just ourselves we can do with no locking.</span>
<span class="cm">			 */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">cpu_clock_sample</span><span class="p">(</span><span class="n">which_clock</span><span class="p">,</span>
						 <span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rtn</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">cpu_clock_sample_group</span><span class="p">(</span><span class="n">which_clock</span><span class="p">,</span>
						       <span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rtn</span><span class="p">);</span>
			<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Find the given PID, and validate that the caller</span>
<span class="cm">		 * should be able to see it.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_PERTHREAD</span><span class="p">(</span><span class="n">which_clock</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">same_thread_group</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">error</span> <span class="o">=</span> <span class="n">cpu_clock_sample</span><span class="p">(</span><span class="n">which_clock</span><span class="p">,</span>
								 <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rtn</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">thread_group_leader</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">error</span> <span class="o">=</span>
					    <span class="n">cpu_clock_sample_group</span><span class="p">(</span><span class="n">which_clock</span><span class="p">,</span>
							           <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rtn</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">sample_to_timespec</span><span class="p">(</span><span class="n">which_clock</span><span class="p">,</span> <span class="n">rtn</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Validate the clockid_t for a new CPU-clock timer, and initialize the timer.</span>
<span class="cm"> * This is called from sys_timer_create() and do_cpu_nanosleep() with the</span>
<span class="cm"> * new timer already all-zeros initialized.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">posix_cpu_timer_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">k_itimer</span> <span class="o">*</span><span class="n">new_timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">CPUCLOCK_PID</span><span class="p">(</span><span class="n">new_timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_WHICH</span><span class="p">(</span><span class="n">new_timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">CPUCLOCK_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">entry</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_PERTHREAD</span><span class="p">(</span><span class="n">new_timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">same_thread_group</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span>
				<span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">has_group_leader_pid</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
				<span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">new_timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">get_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clean up a CPU-clock timer that is about to be destroyed.</span>
<span class="cm"> * This is called from timer deletion with the timer already locked.</span>
<span class="cm"> * If we return TIMER_RETRY, it&#39;s necessary to release the timer&#39;s lock</span>
<span class="cm"> * and try again.  (This happens when the timer is in the middle of firing.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">posix_cpu_timer_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">k_itimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We raced with the reaping of the task.</span>
<span class="cm">			 * The deletion should have cleared us off the list.</span>
<span class="cm">			 */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">entry</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">firing</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">TIMER_RETRY</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">entry</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clean out CPU timers still ticking when a thread exited.  The task</span>
<span class="cm"> * pointer is cleared, and the expiry time is replaced with the residual</span>
<span class="cm"> * time for later timer_gettime calls to return.</span>
<span class="cm"> * This must be called with the siglock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
			   <span class="n">cputime_t</span> <span class="n">utime</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="n">stime</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum_exec_runtime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">cputime_t</span> <span class="n">ptime</span> <span class="o">=</span> <span class="n">utime</span> <span class="o">+</span> <span class="n">stime</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">ptime</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span> <span class="o">-=</span> <span class="n">ptime</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">++</span><span class="n">head</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">utime</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span> <span class="o">-=</span> <span class="n">utime</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">++</span><span class="n">head</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span> <span class="o">&lt;</span> <span class="n">sum_exec_runtime</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span> <span class="o">-=</span> <span class="n">sum_exec_runtime</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These are both called with the siglock held, when the current thread</span>
<span class="cm"> * is being reaped.  When the final (leader) thread in the group is reaped,</span>
<span class="cm"> * posix_cpu_timers_exit_group will be called after posix_cpu_timers_exit.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">posix_cpu_timers_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cleanup_timers</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cpu_timers</span><span class="p">,</span>
		       <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">utime</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span><span class="p">);</span>

<span class="p">}</span>
<span class="kt">void</span> <span class="nf">posix_cpu_timers_exit_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="k">const</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>

	<span class="n">cleanup_timers</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cpu_timers</span><span class="p">,</span>
		       <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">utime</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">stime</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">,</span>
		       <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span> <span class="o">+</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">sum_sched_runtime</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_dead_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">k_itimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="k">union</span> <span class="n">cpu_time_count</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * That&#39;s all for this thread or process.</span>
<span class="cm">	 * We leave our residual in expires to be reported.</span>
<span class="cm">	 */</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">task</span><span class="p">);</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">cpu_time_sub</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span>
					     <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">,</span>
					     <span class="n">now</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">expires_gt</span><span class="p">(</span><span class="n">cputime_t</span> <span class="n">expires</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="n">new_exp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">expires</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">expires</span> <span class="o">&gt;</span> <span class="n">new_exp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Insert the timer on the appropriate list before any timers that</span>
<span class="cm"> * expire later.  This must be called with the tasklist_lock held</span>
<span class="cm"> * for reading, interrupts disabled and p-&gt;sighand-&gt;siglock taken.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">arm_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">k_itimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">listpos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_cputime</span> <span class="o">*</span><span class="n">cputime_expires</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_timer_list</span> <span class="o">*</span><span class="k">const</span> <span class="n">nt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_timer_list</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_PERTHREAD</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">cpu_timers</span><span class="p">;</span>
		<span class="n">cputime_expires</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cpu_timers</span><span class="p">;</span>
		<span class="n">cputime_expires</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">head</span> <span class="o">+=</span> <span class="n">CPUCLOCK_WHICH</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">);</span>

	<span class="n">listpos</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_time_before</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span> <span class="n">nt</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">listpos</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nt</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">listpos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">listpos</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">cpu_time_count</span> <span class="o">*</span><span class="n">exp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nt</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We are the new earliest-expiring POSIX 1.b timer, hence</span>
<span class="cm">		 * need to update expiration cache. Take into account that</span>
<span class="cm">		 * for process timers we share expiration cache with itimers</span>
<span class="cm">		 * and RLIMIT_CPU and for thread timers with RLIMIT_RTTIME.</span>
<span class="cm">		 */</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">CPUCLOCK_WHICH</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CPUCLOCK_PROF</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">expires_gt</span><span class="p">(</span><span class="n">cputime_expires</span><span class="o">-&gt;</span><span class="n">prof_exp</span><span class="p">,</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">))</span>
				<span class="n">cputime_expires</span><span class="o">-&gt;</span><span class="n">prof_exp</span> <span class="o">=</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CPUCLOCK_VIRT</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">expires_gt</span><span class="p">(</span><span class="n">cputime_expires</span><span class="o">-&gt;</span><span class="n">virt_exp</span><span class="p">,</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">))</span>
				<span class="n">cputime_expires</span><span class="o">-&gt;</span><span class="n">virt_exp</span> <span class="o">=</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CPUCLOCK_SCHED</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">cputime_expires</span><span class="o">-&gt;</span><span class="n">sched_exp</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			    <span class="n">cputime_expires</span><span class="o">-&gt;</span><span class="n">sched_exp</span> <span class="o">&gt;</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">sched</span><span class="p">)</span>
				<span class="n">cputime_expires</span><span class="o">-&gt;</span><span class="n">sched_exp</span> <span class="o">=</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">sched</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The timer is locked, fire it and arrange for its reload.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_timer_fire</span><span class="p">(</span><span class="k">struct</span> <span class="n">k_itimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_sigev_notify</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SIGEV_THREAD_ID</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIGEV_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * User don&#39;t want any signal.</span>
<span class="cm">		 */</span>
		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">sigq</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This a special case for clock_nanosleep,</span>
<span class="cm">		 * not a normal timer from sys_timer_create.</span>
<span class="cm">		 */</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_process</span><span class="p">);</span>
		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">incr</span><span class="p">.</span><span class="n">sched</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * One-shot timer.  Clear it as soon as it&#39;s fired.</span>
<span class="cm">		 */</span>
		<span class="n">posix_timer_event</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">posix_timer_event</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">++</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_requeue_pending</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The signal did not get queued because the signal</span>
<span class="cm">		 * was ignored, so we won&#39;t get any callback to</span>
<span class="cm">		 * reload the timer.  But we need to keep it</span>
<span class="cm">		 * ticking in case the signal is deliverable next time.</span>
<span class="cm">		 */</span>
		<span class="n">posix_cpu_timer_schedule</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sample a process (thread group) timer for the given group_leader task.</span>
<span class="cm"> * Must be called with tasklist_lock held for reading.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_timer_sample_group</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				  <span class="k">union</span> <span class="n">cpu_time_count</span> <span class="o">*</span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_cputime</span> <span class="n">cputime</span><span class="p">;</span>

	<span class="n">thread_group_cputimer</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cputime</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">CPUCLOCK_WHICH</span><span class="p">(</span><span class="n">which_clock</span><span class="p">))</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPUCLOCK_PROF</span>:
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cputime</span><span class="p">.</span><span class="n">utime</span> <span class="o">+</span> <span class="n">cputime</span><span class="p">.</span><span class="n">stime</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPUCLOCK_VIRT</span>:
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cputime</span><span class="p">.</span><span class="n">utime</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPUCLOCK_SCHED</span>:
		<span class="n">cpu</span><span class="o">-&gt;</span><span class="n">sched</span> <span class="o">=</span> <span class="n">cputime</span><span class="p">.</span><span class="n">sum_exec_runtime</span> <span class="o">+</span> <span class="n">task_delta_exec</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Guts of sys_timer_settime for CPU timers.</span>
<span class="cm"> * This is called with the timer locked and interrupts disabled.</span>
<span class="cm"> * If we return TIMER_RETRY, it&#39;s necessary to release the timer&#39;s lock</span>
<span class="cm"> * and try again.  (This happens when the timer is in the middle of firing.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">posix_cpu_timer_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">k_itimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">itimerspec</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">itimerspec</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">task</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cpu_time_count</span> <span class="n">old_expires</span><span class="p">,</span> <span class="n">new_expires</span><span class="p">,</span> <span class="n">old_incr</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Timer refers to a dead task&#39;s clock.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new_expires</span> <span class="o">=</span> <span class="n">timespec_to_sample</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">it_value</span><span class="p">);</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We need the tasklist_lock to protect against reaping that</span>
<span class="cm">	 * clears p-&gt;sighand.  If p has just been reaped, we can no</span>
<span class="cm">	 * longer get any information about it at all.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disarm any old timer after extracting its expiry time.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">old_incr</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">incr</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">old_expires</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">firing</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">firing</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">TIMER_RETRY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">entry</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to sample the current value to convert the new</span>
<span class="cm">	 * value from to relative and absolute, and to convert the</span>
<span class="cm">	 * old value from absolute to relative.  To set a process</span>
<span class="cm">	 * timer, we need a sample to balance the thread expiry</span>
<span class="cm">	 * times (in arm_timer).  With an absolute time, we must</span>
<span class="cm">	 * check if it&#39;s already passed.  In short, we need a sample.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_PERTHREAD</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cpu_clock_sample</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cpu_timer_sample_group</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_expires</span><span class="p">.</span><span class="n">sched</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">old</span><span class="o">-&gt;</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">old</span><span class="o">-&gt;</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Update the timer in case it has</span>
<span class="cm">			 * overrun already.  If it has,</span>
<span class="cm">			 * we&#39;ll report it as having overrun</span>
<span class="cm">			 * and with the next reloaded timer</span>
<span class="cm">			 * already ticking, though we are</span>
<span class="cm">			 * swallowing that pending</span>
<span class="cm">			 * notification here to install the</span>
<span class="cm">			 * new setting.</span>
<span class="cm">			 */</span>
			<span class="n">bump_cpu_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_time_before</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
					    <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">old_expires</span> <span class="o">=</span> <span class="n">cpu_time_sub</span><span class="p">(</span>
					<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span>
					<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
				<span class="n">sample_to_timespec</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span>
						   <span class="n">old_expires</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">it_value</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">old</span><span class="o">-&gt;</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">old</span><span class="o">-&gt;</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are colliding with the timer actually firing.</span>
<span class="cm">		 * Punt after filling in the timer&#39;s old value, and</span>
<span class="cm">		 * disable this firing since we are already reporting</span>
<span class="cm">		 * it as an overrun (thanks to bump_cpu_timer above).</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_expires</span><span class="p">.</span><span class="n">sched</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TIMER_ABSTIME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cpu_time_add</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_expires</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Install the new expiry time (or zero).</span>
<span class="cm">	 * For a timer with no notification action, we don&#39;t actually</span>
<span class="cm">	 * arm the timer (we&#39;ll just fake it for timer_gettime).</span>
<span class="cm">	 */</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">new_expires</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_expires</span><span class="p">.</span><span class="n">sched</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cpu_time_before</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">new_expires</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">arm_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Install the new reload setting, and</span>
<span class="cm">	 * set up the signal and overrun bookkeeping.</span>
<span class="cm">	 */</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">incr</span> <span class="o">=</span> <span class="n">timespec_to_sample</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">it_interval</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This acts as a modification timestamp for the timer,</span>
<span class="cm">	 * so any automatic reload attempt will punt on seeing</span>
<span class="cm">	 * that we have reset the timer manually.</span>
<span class="cm">	 */</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_requeue_pending</span> <span class="o">=</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_requeue_pending</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="o">~</span><span class="n">REQUEUE_PENDING</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_overrun_last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_overrun</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_expires</span><span class="p">.</span><span class="n">sched</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">cpu_time_before</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">new_expires</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The designated time already passed, so we notify</span>
<span class="cm">		 * immediately, even if the thread never runs to</span>
<span class="cm">		 * accumulate more time on this clock.</span>
<span class="cm">		 */</span>
		<span class="n">cpu_timer_fire</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sample_to_timespec</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span>
				   <span class="n">old_incr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">it_interval</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">posix_cpu_timer_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">k_itimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">itimerspec</span> <span class="o">*</span><span class="n">itp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">cpu_time_count</span> <span class="n">now</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">clear_dead</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Easy part: convert the reload time.</span>
<span class="cm">	 */</span>
	<span class="n">sample_to_timespec</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span>
			   <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">incr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">itp</span><span class="o">-&gt;</span><span class="n">it_interval</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Timer not armed at all.  */</span>
		<span class="n">itp</span><span class="o">-&gt;</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">itp</span><span class="o">-&gt;</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This task already died and the timer will never fire.</span>
<span class="cm">		 * In this case, expires is actually the dead value.</span>
<span class="cm">		 */</span>
	<span class="nl">dead:</span>
		<span class="n">sample_to_timespec</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">itp</span><span class="o">-&gt;</span><span class="n">it_value</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sample the clock to take the difference with the expiry time.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_PERTHREAD</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cpu_clock_sample</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
		<span class="n">clear_dead</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The process has been reaped.</span>
<span class="cm">			 * We can&#39;t even collect a sample any more.</span>
<span class="cm">			 * Call the timer disarmed, nothing else to do.</span>
<span class="cm">			 */</span>
			<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">dead</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cpu_timer_sample_group</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
			<span class="n">clear_dead</span> <span class="o">=</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				      <span class="n">thread_group_empty</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">clear_dead</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;ve noticed that the thread is dead, but</span>
<span class="cm">		 * not yet reaped.  Take this opportunity to</span>
<span class="cm">		 * drop our task ref.</span>
<span class="cm">		 */</span>
		<span class="n">clear_dead_task</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">dead</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_time_before</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sample_to_timespec</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span>
				   <span class="n">cpu_time_sub</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span>
						<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">,</span> <span class="n">now</span><span class="p">),</span>
				   <span class="o">&amp;</span><span class="n">itp</span><span class="o">-&gt;</span><span class="n">it_value</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The timer should have expired already, but the firing</span>
<span class="cm">		 * hasn&#39;t taken place yet.  Say it&#39;s just about to expire.</span>
<span class="cm">		 */</span>
		<span class="n">itp</span><span class="o">-&gt;</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">itp</span><span class="o">-&gt;</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check for any per-thread CPU timers that have fired and move them off</span>
<span class="cm"> * the tsk-&gt;cpu_timers[N] list onto the firing list.  Here we update the</span>
<span class="cm"> * tsk-&gt;it_*_expires values to reflect the remaining thread CPU timers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_thread_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">firing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">maxfire</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">timers</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cpu_timers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="k">const</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">soft</span><span class="p">;</span>

	<span class="n">maxfire</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">prof_exp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">timers</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpu_timer_list</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">timers</span><span class="p">,</span>
						      <span class="k">struct</span> <span class="n">cpu_timer_list</span><span class="p">,</span>
						      <span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">maxfire</span> <span class="o">||</span> <span class="n">prof_ticks</span><span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">prof_exp</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">firing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">firing</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">++</span><span class="n">timers</span><span class="p">;</span>
	<span class="n">maxfire</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">virt_exp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">timers</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpu_timer_list</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">timers</span><span class="p">,</span>
						      <span class="k">struct</span> <span class="n">cpu_timer_list</span><span class="p">,</span>
						      <span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">maxfire</span> <span class="o">||</span> <span class="n">virt_ticks</span><span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">virt_exp</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">firing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">firing</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">++</span><span class="n">timers</span><span class="p">;</span>
	<span class="n">maxfire</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">sched_exp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">timers</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpu_timer_list</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">timers</span><span class="p">,</span>
						      <span class="k">struct</span> <span class="n">cpu_timer_list</span><span class="p">,</span>
						      <span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">maxfire</span> <span class="o">||</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">sched_exp</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">firing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">firing</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for the special case thread timers.</span>
<span class="cm">	 */</span>
	<span class="n">soft</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_RTTIME</span><span class="p">].</span><span class="n">rlim_cur</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">soft</span> <span class="o">!=</span> <span class="n">RLIM_INFINITY</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hard</span> <span class="o">=</span>
			<span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_RTTIME</span><span class="p">].</span><span class="n">rlim_max</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hard</span> <span class="o">!=</span> <span class="n">RLIM_INFINITY</span> <span class="o">&amp;&amp;</span>
		    <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">hard</span><span class="p">,</span> <span class="n">USEC_PER_SEC</span><span class="o">/</span><span class="n">HZ</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * At the hard limit, we just die.</span>
<span class="cm">			 * No need to calculate anything else now.</span>
<span class="cm">			 */</span>
			<span class="n">__group_send_sig_info</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">,</span> <span class="n">SEND_SIG_PRIV</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">soft</span><span class="p">,</span> <span class="n">USEC_PER_SEC</span><span class="o">/</span><span class="n">HZ</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * At the soft limit, send a SIGXCPU every second.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">soft</span> <span class="o">&lt;</span> <span class="n">hard</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">soft</span> <span class="o">+=</span> <span class="n">USEC_PER_SEC</span><span class="p">;</span>
				<span class="n">sig</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_RTTIME</span><span class="p">].</span><span class="n">rlim_cur</span> <span class="o">=</span> <span class="n">soft</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				<span class="s">&quot;RT Watchdog Timeout: %s[%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">tsk</span><span class="p">));</span>
			<span class="n">__group_send_sig_info</span><span class="p">(</span><span class="n">SIGXCPU</span><span class="p">,</span> <span class="n">SEND_SIG_PRIV</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">stop_process_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_group_cputimer</span> <span class="o">*</span><span class="n">cputimer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">cputimer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cputimer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cputimer</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cputimer</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">onecputick</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_cpu_itimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpu_itimer</span> <span class="o">*</span><span class="n">it</span><span class="p">,</span>
			     <span class="n">cputime_t</span> <span class="o">*</span><span class="n">expires</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="n">cur_time</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cur_time</span> <span class="o">&gt;=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">incr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">it</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">+=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">incr</span><span class="p">;</span>
			<span class="n">it</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">+=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">incr_error</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">&gt;=</span> <span class="n">onecputick</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">it</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">-=</span> <span class="n">cputime_one_jiffy</span><span class="p">;</span>
				<span class="n">it</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">-=</span> <span class="n">onecputick</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">it</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">trace_itimer_expire</span><span class="p">(</span><span class="n">signo</span> <span class="o">==</span> <span class="n">SIGPROF</span> <span class="o">?</span>
				    <span class="n">ITIMER_PROF</span> <span class="o">:</span> <span class="n">ITIMER_VIRTUAL</span><span class="p">,</span>
				    <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">leader_pid</span><span class="p">,</span> <span class="n">cur_time</span><span class="p">);</span>
		<span class="n">__group_send_sig_info</span><span class="p">(</span><span class="n">signo</span><span class="p">,</span> <span class="n">SEND_SIG_PRIV</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!*</span><span class="n">expires</span> <span class="o">||</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">expires</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">expires</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * task_cputime_zero - Check a task_cputime struct for all zero fields.</span>
<span class="cm"> *</span>
<span class="cm"> * @cputime:	The struct to compare.</span>
<span class="cm"> *</span>
<span class="cm"> * Checks @cputime to see if all fields are zero.  Returns true if all fields</span>
<span class="cm"> * are zero, false if any field is nonzero.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">task_cputime_zero</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_cputime</span> <span class="o">*</span><span class="n">cputime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cputime</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cputime</span><span class="o">-&gt;</span><span class="n">stime</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cputime</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check for any per-thread CPU timers that have fired and move them</span>
<span class="cm"> * off the tsk-&gt;*_timers list onto the firing list.  Per-thread timers</span>
<span class="cm"> * have already been taken off.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_process_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">firing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">maxfire</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="k">const</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
	<span class="n">cputime_t</span> <span class="n">utime</span><span class="p">,</span> <span class="n">ptime</span><span class="p">,</span> <span class="n">virt_expires</span><span class="p">,</span> <span class="n">prof_expires</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum_sched_runtime</span><span class="p">,</span> <span class="n">sched_expires</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">timers</span> <span class="o">=</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">cpu_timers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_cputime</span> <span class="n">cputime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">soft</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Collect the current process totals.</span>
<span class="cm">	 */</span>
	<span class="n">thread_group_cputimer</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cputime</span><span class="p">);</span>
	<span class="n">utime</span> <span class="o">=</span> <span class="n">cputime</span><span class="p">.</span><span class="n">utime</span><span class="p">;</span>
	<span class="n">ptime</span> <span class="o">=</span> <span class="n">utime</span> <span class="o">+</span> <span class="n">cputime</span><span class="p">.</span><span class="n">stime</span><span class="p">;</span>
	<span class="n">sum_sched_runtime</span> <span class="o">=</span> <span class="n">cputime</span><span class="p">.</span><span class="n">sum_exec_runtime</span><span class="p">;</span>
	<span class="n">maxfire</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
	<span class="n">prof_expires</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">timers</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpu_timer_list</span> <span class="o">*</span><span class="n">tl</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">timers</span><span class="p">,</span>
						      <span class="k">struct</span> <span class="n">cpu_timer_list</span><span class="p">,</span>
						      <span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">maxfire</span> <span class="o">||</span> <span class="n">ptime</span> <span class="o">&lt;</span> <span class="n">tl</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prof_expires</span> <span class="o">=</span> <span class="n">tl</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tl</span><span class="o">-&gt;</span><span class="n">firing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tl</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">firing</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">++</span><span class="n">timers</span><span class="p">;</span>
	<span class="n">maxfire</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
	<span class="n">virt_expires</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">timers</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpu_timer_list</span> <span class="o">*</span><span class="n">tl</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">timers</span><span class="p">,</span>
						      <span class="k">struct</span> <span class="n">cpu_timer_list</span><span class="p">,</span>
						      <span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">maxfire</span> <span class="o">||</span> <span class="n">utime</span> <span class="o">&lt;</span> <span class="n">tl</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">virt_expires</span> <span class="o">=</span> <span class="n">tl</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">cpu</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tl</span><span class="o">-&gt;</span><span class="n">firing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tl</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">firing</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">++</span><span class="n">timers</span><span class="p">;</span>
	<span class="n">maxfire</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
	<span class="n">sched_expires</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">timers</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpu_timer_list</span> <span class="o">*</span><span class="n">tl</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">timers</span><span class="p">,</span>
						      <span class="k">struct</span> <span class="n">cpu_timer_list</span><span class="p">,</span>
						      <span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">maxfire</span> <span class="o">||</span> <span class="n">sum_sched_runtime</span> <span class="o">&lt;</span> <span class="n">tl</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sched_expires</span> <span class="o">=</span> <span class="n">tl</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tl</span><span class="o">-&gt;</span><span class="n">firing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tl</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">firing</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for the special case process timers.</span>
<span class="cm">	 */</span>
	<span class="n">check_cpu_itimer</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">[</span><span class="n">CPUCLOCK_PROF</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">prof_expires</span><span class="p">,</span> <span class="n">ptime</span><span class="p">,</span>
			 <span class="n">SIGPROF</span><span class="p">);</span>
	<span class="n">check_cpu_itimer</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">[</span><span class="n">CPUCLOCK_VIRT</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">virt_expires</span><span class="p">,</span> <span class="n">utime</span><span class="p">,</span>
			 <span class="n">SIGVTALRM</span><span class="p">);</span>
	<span class="n">soft</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_CPU</span><span class="p">].</span><span class="n">rlim_cur</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">soft</span> <span class="o">!=</span> <span class="n">RLIM_INFINITY</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">psecs</span> <span class="o">=</span> <span class="n">cputime_to_secs</span><span class="p">(</span><span class="n">ptime</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hard</span> <span class="o">=</span>
			<span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_CPU</span><span class="p">].</span><span class="n">rlim_max</span><span class="p">);</span>
		<span class="n">cputime_t</span> <span class="n">x</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">psecs</span> <span class="o">&gt;=</span> <span class="n">hard</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * At the hard limit, we just die.</span>
<span class="cm">			 * No need to calculate anything else now.</span>
<span class="cm">			 */</span>
			<span class="n">__group_send_sig_info</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">,</span> <span class="n">SEND_SIG_PRIV</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">psecs</span> <span class="o">&gt;=</span> <span class="n">soft</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * At the soft limit, send a SIGXCPU every second.</span>
<span class="cm">			 */</span>
			<span class="n">__group_send_sig_info</span><span class="p">(</span><span class="n">SIGXCPU</span><span class="p">,</span> <span class="n">SEND_SIG_PRIV</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">soft</span> <span class="o">&lt;</span> <span class="n">hard</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">soft</span><span class="o">++</span><span class="p">;</span>
				<span class="n">sig</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_CPU</span><span class="p">].</span><span class="n">rlim_cur</span> <span class="o">=</span> <span class="n">soft</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">secs_to_cputime</span><span class="p">(</span><span class="n">soft</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prof_expires</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">prof_expires</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prof_expires</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">prof_exp</span> <span class="o">=</span> <span class="n">prof_expires</span><span class="p">;</span>
	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">virt_exp</span> <span class="o">=</span> <span class="n">virt_expires</span><span class="p">;</span>
	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">sched_exp</span> <span class="o">=</span> <span class="n">sched_expires</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task_cputime_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">))</span>
		<span class="n">stop_process_timers</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called from the signal code (via do_schedule_next_timer)</span>
<span class="cm"> * when the last timer signal was delivered and we have to reload the timer.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">posix_cpu_timer_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">k_itimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">task</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">cpu_time_count</span> <span class="n">now</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * The task was cleaned up already, no future firings.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fetch the current sample and update the timer&#39;s expiry time.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_PERTHREAD</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cpu_clock_sample</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
		<span class="n">bump_cpu_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">clear_dead_task</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span> <span class="cm">/* arm_timer needs it.  */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The process has been reaped.</span>
<span class="cm">			 * We can&#39;t even collect a sample any more.</span>
<span class="cm">			 */</span>
			<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">thread_group_empty</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We&#39;ve noticed that the thread is dead, but</span>
<span class="cm">			 * not yet reaped.  Take this opportunity to</span>
<span class="cm">			 * drop our task ref.</span>
<span class="cm">			 */</span>
			<span class="n">clear_dead_task</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="n">cpu_timer_sample_group</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
		<span class="n">bump_cpu_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
		<span class="cm">/* Leave the tasklist_lock locked for the call below.  */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now re-arm for the new expiry time.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>
	<span class="n">arm_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_overrun_last</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_overrun</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_overrun</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="o">++</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_requeue_pending</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * task_cputime_expired - Compare two task_cputime entities.</span>
<span class="cm"> *</span>
<span class="cm"> * @sample:	The task_cputime structure to be checked for expiration.</span>
<span class="cm"> * @expires:	Expiration times, against which @sample will be checked.</span>
<span class="cm"> *</span>
<span class="cm"> * Checks @sample against @expires to see if any field of @sample has expired.</span>
<span class="cm"> * Returns true if any field of the former is greater than the corresponding</span>
<span class="cm"> * field of the latter if the latter field is set.  Otherwise returns false.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">task_cputime_expired</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_cputime</span> <span class="o">*</span><span class="n">sample</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">task_cputime</span> <span class="o">*</span><span class="n">expires</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expires</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">&amp;&amp;</span> <span class="n">sample</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">&gt;=</span> <span class="n">expires</span><span class="o">-&gt;</span><span class="n">utime</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expires</span><span class="o">-&gt;</span><span class="n">stime</span> <span class="o">&amp;&amp;</span> <span class="n">sample</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">+</span> <span class="n">sample</span><span class="o">-&gt;</span><span class="n">stime</span> <span class="o">&gt;=</span> <span class="n">expires</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expires</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sample</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span> <span class="o">&gt;=</span> <span class="n">expires</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fastpath_timer_check - POSIX CPU timers fast path.</span>
<span class="cm"> *</span>
<span class="cm"> * @tsk:	The task (thread) being checked.</span>
<span class="cm"> *</span>
<span class="cm"> * Check the task and thread group timers.  If both are zero (there are no</span>
<span class="cm"> * timers set) return false.  Otherwise snapshot the task and thread group</span>
<span class="cm"> * timers and compare them with the corresponding expiration times.  Return</span>
<span class="cm"> * true if a timer has expired, else return false.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fastpath_timer_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_cputime_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_cputime</span> <span class="n">task_sample</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">utime</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">utime</span><span class="p">,</span>
			<span class="p">.</span><span class="n">stime</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">,</span>
			<span class="p">.</span><span class="n">sum_exec_runtime</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span>
		<span class="p">};</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">task_cputime_expired</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_sample</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sig</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">cputimer</span><span class="p">.</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_cputime</span> <span class="n">group_sample</span><span class="p">;</span>

		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">cputimer</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">group_sample</span> <span class="o">=</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">cputimer</span><span class="p">.</span><span class="n">cputime</span><span class="p">;</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">cputimer</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">task_cputime_expired</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group_sample</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called from the timer interrupt handler.  The irq handler has</span>
<span class="cm"> * already updated our counts.  We need to check if any timers fire now.</span>
<span class="cm"> * Interrupts are disabled.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">run_posix_cpu_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">firing</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">k_itimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="cm">/*</span>
<span class="cm">	 * The fast path checks that there are no expired thread or thread</span>
<span class="cm">	 * group timers.  If that&#39;s so, just return.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fastpath_timer_check</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Here we take off tsk-&gt;signal-&gt;cpu_timers[N] and</span>
<span class="cm">	 * tsk-&gt;cpu_timers[N] all the timers that are firing, and</span>
<span class="cm">	 * put them on the firing list.</span>
<span class="cm">	 */</span>
	<span class="n">check_thread_timers</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">firing</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If there are any active process wide timers (POSIX 1.b, itimers,</span>
<span class="cm">	 * RLIMIT_CPU) cputimer must be running.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cputimer</span><span class="p">.</span><span class="n">running</span><span class="p">)</span>
		<span class="n">check_process_timers</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">firing</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must release these locks before taking any timer&#39;s lock.</span>
<span class="cm">	 * There is a potential race with timer deletion here, as the</span>
<span class="cm">	 * siglock now protects our private firing list.  We have set</span>
<span class="cm">	 * the firing flag in each timer, so that a deletion attempt</span>
<span class="cm">	 * that gets the timer lock before we do will give it up and</span>
<span class="cm">	 * spin until we&#39;ve taken care of that timer below.</span>
<span class="cm">	 */</span>
	<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that all the timers on our list have the firing flag,</span>
<span class="cm">	 * no one will touch their list entries but us.  We&#39;ll take</span>
<span class="cm">	 * each timer&#39;s lock before clearing its firing flag, so no</span>
<span class="cm">	 * timer call will interfere.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">firing</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cpu_firing</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">cpu_firing</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">firing</span><span class="p">;</span>
		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">firing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The firing flag is -1 if we collided with a reset</span>
<span class="cm">		 * of the timer, which already reported this</span>
<span class="cm">		 * almost-firing as an overrun.  So don&#39;t generate an event.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cpu_firing</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">cpu_timer_fire</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set one of the process-wide special case CPU timers or RLIMIT_CPU.</span>
<span class="cm"> * The tsk-&gt;sighand-&gt;siglock must be held by the caller.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">set_process_cpu_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clock_idx</span><span class="p">,</span>
			   <span class="n">cputime_t</span> <span class="o">*</span><span class="n">newval</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="o">*</span><span class="n">oldval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">cpu_time_count</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">clock_idx</span> <span class="o">==</span> <span class="n">CPUCLOCK_SCHED</span><span class="p">);</span>
	<span class="n">cpu_timer_sample_group</span><span class="p">(</span><span class="n">clock_idx</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oldval</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are setting itimer. The *oldval is absolute and we update</span>
<span class="cm">		 * it to be relative, *newval argument is relative and we update</span>
<span class="cm">		 * it to be absolute.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">oldval</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">oldval</span> <span class="o">&lt;=</span> <span class="n">now</span><span class="p">.</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Just about to fire. */</span>
				<span class="o">*</span><span class="n">oldval</span> <span class="o">=</span> <span class="n">cputime_one_jiffy</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">oldval</span> <span class="o">-=</span> <span class="n">now</span><span class="p">.</span><span class="n">cpu</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">newval</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="o">*</span><span class="n">newval</span> <span class="o">+=</span> <span class="n">now</span><span class="p">.</span><span class="n">cpu</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update expiration cache if we are the earliest timer, or eventually</span>
<span class="cm">	 * RLIMIT_CPU limit is earlier than prof_exp cpu timer expire.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">clock_idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPUCLOCK_PROF</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">expires_gt</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">prof_exp</span><span class="p">,</span> <span class="o">*</span><span class="n">newval</span><span class="p">))</span>
			<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">prof_exp</span> <span class="o">=</span> <span class="o">*</span><span class="n">newval</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPUCLOCK_VIRT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">expires_gt</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">virt_exp</span><span class="p">,</span> <span class="o">*</span><span class="n">newval</span><span class="p">))</span>
			<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">virt_exp</span> <span class="o">=</span> <span class="o">*</span><span class="n">newval</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_cpu_nanosleep</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">rqtp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">itimerspec</span> <span class="o">*</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">k_itimer</span> <span class="n">timer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up a temporary timer and then wait for it to go off.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">timer</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">.</span><span class="n">it_lock</span><span class="p">);</span>
	<span class="n">timer</span><span class="p">.</span><span class="n">it_clock</span> <span class="o">=</span> <span class="n">which_clock</span><span class="p">;</span>
	<span class="n">timer</span><span class="p">.</span><span class="n">it_overrun</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">posix_cpu_timer_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">timer</span><span class="p">.</span><span class="n">it_process</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">struct</span> <span class="n">itimerspec</span> <span class="n">zero_it</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">it_value</span> <span class="o">=</span> <span class="o">*</span><span class="n">rqtp</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">.</span><span class="n">it_lock</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">posix_cpu_timer_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">.</span><span class="n">it_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="p">.</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="n">sched</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Our timer fired and was reset.</span>
<span class="cm">				 */</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">.</span><span class="n">it_lock</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Block until cpu_timer_fire (or a signal) wakes us.</span>
<span class="cm">			 */</span>
			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">.</span><span class="n">it_lock</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">.</span><span class="n">it_lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We were interrupted by a signal.</span>
<span class="cm">		 */</span>
		<span class="n">sample_to_timespec</span><span class="p">(</span><span class="n">which_clock</span><span class="p">,</span> <span class="n">timer</span><span class="p">.</span><span class="n">it</span><span class="p">.</span><span class="n">cpu</span><span class="p">.</span><span class="n">expires</span><span class="p">,</span> <span class="n">rqtp</span><span class="p">);</span>
		<span class="n">posix_cpu_timer_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zero_it</span><span class="p">,</span> <span class="n">it</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">.</span><span class="n">it_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">|</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * It actually did fire already.</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTART_RESTARTBLOCK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="n">posix_cpu_nsleep_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">restart_block</span> <span class="o">*</span><span class="n">restart_block</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">posix_cpu_nsleep</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">rqtp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="n">rmtp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">restart_block</span> <span class="o">*</span><span class="n">restart_block</span> <span class="o">=</span>
		<span class="o">&amp;</span><span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">restart_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">itimerspec</span> <span class="n">it</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Diagnose required errors first.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CPUCLOCK_PERTHREAD</span><span class="p">(</span><span class="n">which_clock</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">CPUCLOCK_PID</span><span class="p">(</span><span class="n">which_clock</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	     <span class="n">CPUCLOCK_PID</span><span class="p">(</span><span class="n">which_clock</span><span class="p">)</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">do_cpu_nanosleep</span><span class="p">(</span><span class="n">which_clock</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">rqtp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTART_RESTARTBLOCK</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TIMER_ABSTIME</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTNOHAND</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Report back to the user the time still remaining.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rmtp</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">rmtp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">.</span><span class="n">it_value</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">rmtp</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">fn</span> <span class="o">=</span> <span class="n">posix_cpu_nsleep_restart</span><span class="p">;</span>
		<span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">nanosleep</span><span class="p">.</span><span class="n">clockid</span> <span class="o">=</span> <span class="n">which_clock</span><span class="p">;</span>
		<span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">nanosleep</span><span class="p">.</span><span class="n">rmtp</span> <span class="o">=</span> <span class="n">rmtp</span><span class="p">;</span>
		<span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">nanosleep</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">timespec_to_ns</span><span class="p">(</span><span class="n">rqtp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">posix_cpu_nsleep_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">restart_block</span> <span class="o">*</span><span class="n">restart_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clockid_t</span> <span class="n">which_clock</span> <span class="o">=</span> <span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">nanosleep</span><span class="p">.</span><span class="n">clockid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">itimerspec</span> <span class="n">it</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">ns_to_timespec</span><span class="p">(</span><span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">nanosleep</span><span class="p">.</span><span class="n">expires</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">do_cpu_nanosleep</span><span class="p">(</span><span class="n">which_clock</span><span class="p">,</span> <span class="n">TIMER_ABSTIME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTART_RESTARTBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="n">rmtp</span> <span class="o">=</span> <span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">nanosleep</span><span class="p">.</span><span class="n">rmtp</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Report back to the user the time still remaining.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rmtp</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">rmtp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">.</span><span class="n">it_value</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">rmtp</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">nanosleep</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">timespec_to_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="p">}</span>

<span class="cp">#define PROCESS_CLOCK	MAKE_PROCESS_CPUCLOCK(0, CPUCLOCK_SCHED)</span>
<span class="cp">#define THREAD_CLOCK	MAKE_THREAD_CPUCLOCK(0, CPUCLOCK_SCHED)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_cpu_clock_getres</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">posix_cpu_clock_getres</span><span class="p">(</span><span class="n">PROCESS_CLOCK</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_cpu_clock_get</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">posix_cpu_clock_get</span><span class="p">(</span><span class="n">PROCESS_CLOCK</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_cpu_timer_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">k_itimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span> <span class="o">=</span> <span class="n">PROCESS_CLOCK</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">posix_cpu_timer_create</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_cpu_nsleep</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">rqtp</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="n">rmtp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">posix_cpu_nsleep</span><span class="p">(</span><span class="n">PROCESS_CLOCK</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">rqtp</span><span class="p">,</span> <span class="n">rmtp</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">process_cpu_nsleep_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">restart_block</span> <span class="o">*</span><span class="n">restart_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">thread_cpu_clock_getres</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">posix_cpu_clock_getres</span><span class="p">(</span><span class="n">THREAD_CLOCK</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">thread_cpu_clock_get</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">posix_cpu_clock_get</span><span class="p">(</span><span class="n">THREAD_CLOCK</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">thread_cpu_timer_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">k_itimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">it_clock</span> <span class="o">=</span> <span class="n">THREAD_CLOCK</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">posix_cpu_timer_create</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">k_clock</span> <span class="n">clock_posix_cpu</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">clock_getres</span>	<span class="o">=</span> <span class="n">posix_cpu_clock_getres</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clock_set</span>	<span class="o">=</span> <span class="n">posix_cpu_clock_set</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clock_get</span>	<span class="o">=</span> <span class="n">posix_cpu_clock_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">timer_create</span>	<span class="o">=</span> <span class="n">posix_cpu_timer_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nsleep</span>		<span class="o">=</span> <span class="n">posix_cpu_nsleep</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nsleep_restart</span>	<span class="o">=</span> <span class="n">posix_cpu_nsleep_restart</span><span class="p">,</span>
	<span class="p">.</span><span class="n">timer_set</span>	<span class="o">=</span> <span class="n">posix_cpu_timer_set</span><span class="p">,</span>
	<span class="p">.</span><span class="n">timer_del</span>	<span class="o">=</span> <span class="n">posix_cpu_timer_del</span><span class="p">,</span>
	<span class="p">.</span><span class="n">timer_get</span>	<span class="o">=</span> <span class="n">posix_cpu_timer_get</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">init_posix_cpu_timers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">k_clock</span> <span class="n">process</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">clock_getres</span>	<span class="o">=</span> <span class="n">process_cpu_clock_getres</span><span class="p">,</span>
		<span class="p">.</span><span class="n">clock_get</span>	<span class="o">=</span> <span class="n">process_cpu_clock_get</span><span class="p">,</span>
		<span class="p">.</span><span class="n">timer_create</span>	<span class="o">=</span> <span class="n">process_cpu_timer_create</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nsleep</span>		<span class="o">=</span> <span class="n">process_cpu_nsleep</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nsleep_restart</span>	<span class="o">=</span> <span class="n">process_cpu_nsleep_restart</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">k_clock</span> <span class="kr">thread</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">clock_getres</span>	<span class="o">=</span> <span class="n">thread_cpu_clock_getres</span><span class="p">,</span>
		<span class="p">.</span><span class="n">clock_get</span>	<span class="o">=</span> <span class="n">thread_cpu_clock_get</span><span class="p">,</span>
		<span class="p">.</span><span class="n">timer_create</span>	<span class="o">=</span> <span class="n">thread_cpu_timer_create</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>

	<span class="n">posix_timers_register_clock</span><span class="p">(</span><span class="n">CLOCK_PROCESS_CPUTIME_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">process</span><span class="p">);</span>
	<span class="n">posix_timers_register_clock</span><span class="p">(</span><span class="n">CLOCK_THREAD_CPUTIME_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="kr">thread</span><span class="p">);</span>

	<span class="n">cputime_to_timespec</span><span class="p">(</span><span class="n">cputime_one_jiffy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
	<span class="n">onecputick</span> <span class="o">=</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__initcall</span><span class="p">(</span><span class="n">init_posix_cpu_timers</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
