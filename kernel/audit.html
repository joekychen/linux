<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › audit.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>audit.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* audit.c -- Auditing support</span>
<span class="cm"> * Gateway between the kernel (e.g., selinux) and the user-space audit daemon.</span>
<span class="cm"> * System-call specific features have moved to auditsc.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2003-2007 Red Hat Inc., Durham, North Carolina.</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Rickard E. (Rik) Faith &lt;faith@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Goals: 1) Integrate fully with Security Modules.</span>
<span class="cm"> *	  2) Minimal run-time overhead:</span>
<span class="cm"> *	     a) Minimal when syscall auditing is disabled (audit_enable=0).</span>
<span class="cm"> *	     b) Small when syscall auditing is enabled and no audit record</span>
<span class="cm"> *		is generated (defer as much work as possible to record</span>
<span class="cm"> *		generation time):</span>
<span class="cm"> *		i) context is allocated,</span>
<span class="cm"> *		ii) names from getname are stored without a copy, and</span>
<span class="cm"> *		iii) inode information stored from path_lookup.</span>
<span class="cm"> *	  3) Ability to disable syscall auditing at boot time (audit=0).</span>
<span class="cm"> *	  4) Usable by other parts of the kernel (if audit_log* is called,</span>
<span class="cm"> *	     then a syscall record will be generated automatically for the</span>
<span class="cm"> *	     current syscall).</span>
<span class="cm"> *	  5) Netlink interface to user-space.</span>
<span class="cm"> *	  6) Support low-overhead kernel-based filtering to minimize the</span>
<span class="cm"> *	     information that must be passed to user-space.</span>
<span class="cm"> *</span>
<span class="cm"> * Example user-space utilities: http://people.redhat.com/sgrubb/audit/</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>

<span class="cp">#include &lt;linux/audit.h&gt;</span>

<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/netlink.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#ifdef CONFIG_SECURITY</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;linux/netlink.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>

<span class="cp">#include &quot;audit.h&quot;</span>

<span class="cm">/* No auditing will take place until audit_initialized == AUDIT_INITIALIZED.</span>
<span class="cm"> * (Initialization happens after skb_init is called.) */</span>
<span class="cp">#define AUDIT_DISABLED		-1</span>
<span class="cp">#define AUDIT_UNINITIALIZED	0</span>
<span class="cp">#define AUDIT_INITIALIZED	1</span>
<span class="k">static</span> <span class="kt">int</span>	<span class="n">audit_initialized</span><span class="p">;</span>

<span class="cp">#define AUDIT_OFF	0</span>
<span class="cp">#define AUDIT_ON	1</span>
<span class="cp">#define AUDIT_LOCKED	2</span>
<span class="kt">int</span>		<span class="n">audit_enabled</span><span class="p">;</span>
<span class="kt">int</span>		<span class="n">audit_ever_enabled</span><span class="p">;</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">audit_enabled</span><span class="p">);</span>

<span class="cm">/* Default state when kernel boots without any parameters. */</span>
<span class="k">static</span> <span class="kt">int</span>	<span class="n">audit_default</span><span class="p">;</span>

<span class="cm">/* If auditing cannot proceed, audit_failure selects what happens. */</span>
<span class="k">static</span> <span class="kt">int</span>	<span class="n">audit_failure</span> <span class="o">=</span> <span class="n">AUDIT_FAIL_PRINTK</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * If audit records are to be written to the netlink socket, audit_pid</span>
<span class="cm"> * contains the pid of the auditd process and audit_nlk_pid contains</span>
<span class="cm"> * the pid to use to send netlink messages to that process.</span>
<span class="cm"> */</span>
<span class="kt">int</span>		<span class="n">audit_pid</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>	<span class="n">audit_nlk_pid</span><span class="p">;</span>

<span class="cm">/* If audit_rate_limit is non-zero, limit the rate of sending audit records</span>
<span class="cm"> * to that number per second.  This prevents DoS attacks, but results in</span>
<span class="cm"> * audit records being dropped. */</span>
<span class="k">static</span> <span class="kt">int</span>	<span class="n">audit_rate_limit</span><span class="p">;</span>

<span class="cm">/* Number of outstanding audit_buffers allowed. */</span>
<span class="k">static</span> <span class="kt">int</span>	<span class="n">audit_backlog_limit</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>	<span class="n">audit_backlog_wait_time</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>	<span class="n">audit_backlog_wait_overflow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* The identity of the user shutting down the audit system. */</span>
<span class="n">uid_t</span>		<span class="n">audit_sig_uid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">pid_t</span>		<span class="n">audit_sig_pid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">u32</span>		<span class="n">audit_sig_sid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* Records can be lost in several ways:</span>
<span class="cm">   0) [suppressed in audit_alloc]</span>
<span class="cm">   1) out of memory in audit_log_start [kmalloc of struct audit_buffer]</span>
<span class="cm">   2) out of memory in audit_log_move [alloc_skb]</span>
<span class="cm">   3) suppressed due to audit_rate_limit</span>
<span class="cm">   4) suppressed due to audit_backlog_limit</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">atomic_t</span>    <span class="n">audit_lost</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="cm">/* The netlink socket. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">audit_sock</span><span class="p">;</span>

<span class="cm">/* Hash for inode-based rules */</span>
<span class="k">struct</span> <span class="n">list_head</span> <span class="n">audit_inode_hash</span><span class="p">[</span><span class="n">AUDIT_INODE_BUCKETS</span><span class="p">];</span>

<span class="cm">/* The audit_freelist is a list of pre-allocated audit buffers (if more</span>
<span class="cm"> * than AUDIT_MAXFREE are in use, the audit buffer is freed instead of</span>
<span class="cm"> * being placed on the freelist). */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">audit_freelist_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>	   <span class="n">audit_freelist_count</span><span class="p">;</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">audit_freelist</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">audit_skb_queue</span><span class="p">;</span>
<span class="cm">/* queue of skbs to send to auditd when/if it comes back */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">audit_skb_hold_queue</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">kauditd_task</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">kauditd_wait</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">audit_backlog_wait</span><span class="p">);</span>

<span class="cm">/* Serialize requests from userspace. */</span>
<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">audit_cmd_mutex</span><span class="p">);</span>

<span class="cm">/* AUDIT_BUFSIZ is the size of the temporary buffer used for formatting</span>
<span class="cm"> * audit records.  Since printk uses a 1024 byte buffer, this buffer</span>
<span class="cm"> * should be at least that large. */</span>
<span class="cp">#define AUDIT_BUFSIZ 1024</span>

<span class="cm">/* AUDIT_MAXFREE is the number of empty audit_buffers we keep on the</span>
<span class="cm"> * audit_freelist.  Doing so eliminates many kmalloc/kfree calls. */</span>
<span class="cp">#define AUDIT_MAXFREE  (2*NR_CPUS)</span>

<span class="cm">/* The audit_buffer is used when formatting an audit record.  The caller</span>
<span class="cm"> * locks briefly to get the record off the freelist or to allocate the</span>
<span class="cm"> * buffer, and locks briefly to send the buffer to the netlink layer or</span>
<span class="cm"> * to place it on a transmit queue.  Multiple audit_buffers can be in</span>
<span class="cm"> * use simultaneously. */</span>
<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>     <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>       <span class="o">*</span><span class="n">skb</span><span class="p">;</span>	<span class="cm">/* formatted skb ready to send */</span>
	<span class="k">struct</span> <span class="n">audit_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>	<span class="cm">/* NULL or associated context */</span>
	<span class="n">gfp_t</span>		     <span class="n">gfp_mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">audit_reply</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">audit_set_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ab</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span> <span class="o">=</span> <span class="n">nlmsg_hdr</span><span class="p">(</span><span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">audit_panic</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">audit_failure</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="k">case</span> <span class="n">AUDIT_FAIL_SILENT</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_FAIL_PRINTK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;audit: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_FAIL_PANIC</span>:
		<span class="cm">/* test audit_pid since printk is always losey, why bother? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">audit_pid</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;audit: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">audit_rate_check</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">last_check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span>		<span class="n">messages</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">now</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">elapsed</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span>	   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">audit_rate_limit</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">messages</span> <span class="o">&lt;</span> <span class="n">audit_rate_limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">now</span>     <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">elapsed</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">last_check</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">elapsed</span> <span class="o">&gt;</span> <span class="n">HZ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">last_check</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
			<span class="n">messages</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">retval</span>     <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * audit_log_lost - conditionally log lost audit message event</span>
<span class="cm"> * @message: the message stating reason for lost audit message</span>
<span class="cm"> *</span>
<span class="cm"> * Emit at least 1 message per second, even if audit_rate_check is</span>
<span class="cm"> * throttling.</span>
<span class="cm"> * Always increment the lost messages counter.</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="nf">audit_log_lost</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">last_msg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">now</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">print</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_lost</span><span class="p">);</span>

	<span class="n">print</span> <span class="o">=</span> <span class="p">(</span><span class="n">audit_failure</span> <span class="o">==</span> <span class="n">AUDIT_FAIL_PANIC</span> <span class="o">||</span> <span class="o">!</span><span class="n">audit_rate_limit</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">print</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">last_msg</span> <span class="o">&gt;</span> <span class="n">HZ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">print</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">last_msg</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">print</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;audit: audit_lost=%d audit_rate_limit=%d &quot;</span>
				<span class="s">&quot;audit_backlog_limit=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_lost</span><span class="p">),</span>
				<span class="n">audit_rate_limit</span><span class="p">,</span>
				<span class="n">audit_backlog_limit</span><span class="p">);</span>
		<span class="n">audit_panic</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">audit_log_config_change</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">function_name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new</span><span class="p">,</span> <span class="kt">int</span> <span class="n">old</span><span class="p">,</span>
				   <span class="n">uid_t</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sid</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">allow_changes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ab</span> <span class="o">=</span> <span class="n">audit_log_start</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">AUDIT_CONFIG_CHANGE</span><span class="p">);</span>
	<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot;%s=%d old=%d auid=%u ses=%u&quot;</span><span class="p">,</span> <span class="n">function_name</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span>
			 <span class="n">old</span><span class="p">,</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sid</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_secid_to_secctx</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; sid=%u&quot;</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
			<span class="n">allow_changes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Something weird, deny request */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; subj=%s&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
			<span class="n">security_release_secctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; res=%d&quot;</span><span class="p">,</span> <span class="n">allow_changes</span><span class="p">);</span>
	<span class="n">audit_log_end</span><span class="p">(</span><span class="n">ab</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">audit_do_config_change</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">function_name</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">to_change</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">new</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sessionid</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">allow_changes</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">to_change</span><span class="p">;</span>

	<span class="cm">/* check if we are locked */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">audit_enabled</span> <span class="o">==</span> <span class="n">AUDIT_LOCKED</span><span class="p">)</span>
		<span class="n">allow_changes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">allow_changes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">audit_enabled</span> <span class="o">!=</span> <span class="n">AUDIT_OFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">audit_log_config_change</span><span class="p">(</span><span class="n">function_name</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">loginuid</span><span class="p">,</span>
					     <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">allow_changes</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">allow_changes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we are allowed, make the change */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">allow_changes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">*</span><span class="n">to_change</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="cm">/* Not allowed, update reason */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">audit_set_rate_limit</span><span class="p">(</span><span class="kt">int</span> <span class="n">limit</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sessionid</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">audit_do_config_change</span><span class="p">(</span><span class="s">&quot;audit_rate_limit&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_rate_limit</span><span class="p">,</span>
				      <span class="n">limit</span><span class="p">,</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">audit_set_backlog_limit</span><span class="p">(</span><span class="kt">int</span> <span class="n">limit</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sessionid</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">audit_do_config_change</span><span class="p">(</span><span class="s">&quot;audit_backlog_limit&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_backlog_limit</span><span class="p">,</span>
				      <span class="n">limit</span><span class="p">,</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">audit_set_enabled</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">AUDIT_OFF</span> <span class="o">||</span> <span class="n">state</span> <span class="o">&gt;</span> <span class="n">AUDIT_LOCKED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span>  <span class="n">audit_do_config_change</span><span class="p">(</span><span class="s">&quot;audit_enabled&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_enabled</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span>
				     <span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">audit_ever_enabled</span> <span class="o">|=</span> <span class="o">!!</span><span class="n">state</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">audit_set_failure</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">AUDIT_FAIL_SILENT</span>
	    <span class="o">&amp;&amp;</span> <span class="n">state</span> <span class="o">!=</span> <span class="n">AUDIT_FAIL_PRINTK</span>
	    <span class="o">&amp;&amp;</span> <span class="n">state</span> <span class="o">!=</span> <span class="n">AUDIT_FAIL_PANIC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">audit_do_config_change</span><span class="p">(</span><span class="s">&quot;audit_failure&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_failure</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span>
				      <span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Queue skbs to be sent to auditd when/if it comes back.  These skbs should</span>
<span class="cm"> * already have been sent via prink/syslog and so if these messages are dropped</span>
<span class="cm"> * it is not a huge concern since we already passed the audit_log_lost()</span>
<span class="cm"> * notification and stuff.  This is just nice to get audit messages during</span>
<span class="cm"> * boot before auditd is running or messages generated while auditd is stopped.</span>
<span class="cm"> * This only holds messages is audit_default is set, aka booting with audit=1</span>
<span class="cm"> * or building your kernel that way.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">audit_hold_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">audit_default</span> <span class="o">&amp;&amp;</span>
	    <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_skb_hold_queue</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">audit_backlog_limit</span><span class="p">)</span>
		<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_skb_hold_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For one reason or another this nlh isn&#39;t getting delivered to the userspace</span>
<span class="cm"> * audit daemon, just send it to printk.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">audit_printk_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span> <span class="o">=</span> <span class="n">nlmsg_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">NLMSG_DATA</span><span class="p">(</span><span class="n">nlh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_type</span> <span class="o">!=</span> <span class="n">AUDIT_EOE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;type=%d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_type</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">audit_log_lost</span><span class="p">(</span><span class="s">&quot;printk limit exceeded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">audit_hold_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kauditd_send_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/* take a reference in case we can&#39;t send it and we want to hold it */</span>
	<span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">netlink_unicast</span><span class="p">(</span><span class="n">audit_sock</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">audit_nlk_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">);</span> <span class="cm">/* Shouldn&#39;t happen */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;audit: *NO* daemon at audit_pid=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">audit_pid</span><span class="p">);</span>
		<span class="n">audit_log_lost</span><span class="p">(</span><span class="s">&quot;auditd disappeared</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">audit_pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* we might get lucky and get this in the next auditd */</span>
		<span class="n">audit_hold_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* drop the extra reference if sent ok */</span>
		<span class="n">consume_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kauditd_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">set_freezable</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if auditd just started drain the queue of messages already</span>
<span class="cm">		 * sent to syslog/printk.  remember loss here is ok.  we already</span>
<span class="cm">		 * called audit_log_lost() if it didn&#39;t go out normally.  so the</span>
<span class="cm">		 * race between the skb_dequeue and the next check for audit_pid</span>
<span class="cm">		 * doesn&#39;t matter.</span>
<span class="cm">		 *</span>
<span class="cm">		 * if you ever find kauditd to be too slow we can get a perf win</span>
<span class="cm">		 * by doing our own locking and keeping better track if there</span>
<span class="cm">		 * are messages in this queue.  I don&#39;t see the need now, but</span>
<span class="cm">		 * in 5 years when I want to play with this again I&#39;ll see this</span>
<span class="cm">		 * note and still have no friggin idea what i&#39;m thinking today.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">audit_default</span> <span class="o">&amp;&amp;</span> <span class="n">audit_pid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_skb_hold_queue</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="n">audit_pid</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">kauditd_send_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
					<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_skb_hold_queue</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_skb_queue</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_backlog_wait</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">audit_pid</span><span class="p">)</span>
				<span class="n">kauditd_send_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">audit_printk_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kauditd_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_skb_queue</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">try_to_freeze</span><span class="p">();</span>
				<span class="n">schedule</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
			<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kauditd_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">audit_prepare_user_tty</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sessionid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">tsk</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">tty_audit_push_task</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">);</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">audit_send_list</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_dest</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_netlink_list</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">_dest</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* wait for parent to finish and send an ACK */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_cmd_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_cmd_mutex</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">netlink_unicast</span><span class="p">(</span><span class="n">audit_sock</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">audit_make_reply</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">done</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">multi</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>	<span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlmsghdr</span>	<span class="o">*</span><span class="n">nlh</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">flags</span> <span class="o">=</span> <span class="n">multi</span> <span class="o">?</span> <span class="n">NLM_F_MULTI</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">t</span>     <span class="o">=</span> <span class="n">done</span>  <span class="o">?</span> <span class="n">NLMSG_DONE</span>  <span class="o">:</span> <span class="n">type</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">nlmsg_new</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">nlh</span>	<span class="o">=</span> <span class="n">NLMSG_NEW</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">data</span>	<span class="o">=</span> <span class="n">NLMSG_DATA</span><span class="p">(</span><span class="n">nlh</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>

<span class="nl">nlmsg_failure:</span>			<span class="cm">/* Used by NLMSG_NEW */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">audit_send_reply_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_reply</span> <span class="o">*</span><span class="n">reply</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">audit_reply</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_cmd_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_cmd_mutex</span><span class="p">);</span>

	<span class="cm">/* Ignore failure. It&#39;ll only happen if the sender goes away,</span>
<span class="cm">	   because our timeout is set to infinite. */</span>
	<span class="n">netlink_unicast</span><span class="p">(</span><span class="n">audit_sock</span><span class="p">,</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">reply</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * audit_send_reply - send an audit reply message via netlink</span>
<span class="cm"> * @pid: process id to send reply to</span>
<span class="cm"> * @seq: sequence number</span>
<span class="cm"> * @type: audit message type</span>
<span class="cm"> * @done: done (last) flag</span>
<span class="cm"> * @multi: multi-part message flag</span>
<span class="cm"> * @payload: payload data</span>
<span class="cm"> * @size: payload size</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates an skb, builds the netlink message, and sends it to the pid.</span>
<span class="cm"> * No failure notifications.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">audit_send_reply</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">done</span><span class="p">,</span> <span class="kt">int</span> <span class="n">multi</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_reply</span> <span class="o">*</span><span class="n">reply</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_reply</span><span class="p">),</span>
					    <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reply</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">audit_make_reply</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">multi</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">reply</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
	<span class="n">reply</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="n">tsk</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">audit_send_reply_thread</span><span class="p">,</span> <span class="n">reply</span><span class="p">,</span> <span class="s">&quot;audit_send_reply&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">reply</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check for appropriate CAP_AUDIT_ capabilities on incoming audit</span>
<span class="cm"> * control messages.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">audit_netlink_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u16</span> <span class="n">msg_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msg_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AUDIT_GET</span>:
	<span class="k">case</span> <span class="n">AUDIT_LIST</span>:
	<span class="k">case</span> <span class="n">AUDIT_LIST_RULES</span>:
	<span class="k">case</span> <span class="n">AUDIT_SET</span>:
	<span class="k">case</span> <span class="n">AUDIT_ADD</span>:
	<span class="k">case</span> <span class="n">AUDIT_ADD_RULE</span>:
	<span class="k">case</span> <span class="n">AUDIT_DEL</span>:
	<span class="k">case</span> <span class="n">AUDIT_DEL_RULE</span>:
	<span class="k">case</span> <span class="n">AUDIT_SIGNAL_INFO</span>:
	<span class="k">case</span> <span class="n">AUDIT_TTY_GET</span>:
	<span class="k">case</span> <span class="n">AUDIT_TTY_SET</span>:
	<span class="k">case</span> <span class="n">AUDIT_TRIM</span>:
	<span class="k">case</span> <span class="n">AUDIT_MAKE_EQUIV</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_AUDIT_CONTROL</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_USER</span>:
	<span class="k">case</span> <span class="n">AUDIT_FIRST_USER_MSG</span> <span class="p">...</span> <span class="n">AUDIT_LAST_USER_MSG</span>:
	<span class="k">case</span> <span class="n">AUDIT_FIRST_USER_MSG2</span> <span class="p">...</span> <span class="n">AUDIT_LAST_USER_MSG2</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_AUDIT_WRITE</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>  <span class="cm">/* bad msg */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">audit_log_common_recv_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">**</span><span class="n">ab</span><span class="p">,</span> <span class="n">u16</span> <span class="n">msg_type</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">pid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">uid</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">auid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ses</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">audit_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ab</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">ab</span> <span class="o">=</span> <span class="n">audit_log_start</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">msg_type</span><span class="p">);</span>
	<span class="n">audit_log_format</span><span class="p">(</span><span class="o">*</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot;pid=%d uid=%u auid=%u ses=%u&quot;</span><span class="p">,</span>
			 <span class="n">pid</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">auid</span><span class="p">,</span> <span class="n">ses</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">security_secid_to_secctx</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">audit_log_format</span><span class="p">(</span><span class="o">*</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; ssid=%u&quot;</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">audit_log_format</span><span class="p">(</span><span class="o">*</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; subj=%s&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
			<span class="n">security_release_secctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">audit_receive_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>			<span class="n">uid</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">sid</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_status</span>	<span class="o">*</span><span class="n">status_get</span><span class="p">,</span> <span class="n">status_set</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_buffer</span>	<span class="o">*</span><span class="n">ab</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">msg_type</span> <span class="o">=</span> <span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_type</span><span class="p">;</span>
	<span class="n">uid_t</span>			<span class="n">loginuid</span><span class="p">;</span> <span class="cm">/* loginuid of sender */</span>
	<span class="n">u32</span>			<span class="n">sessionid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_sig_info</span>   <span class="o">*</span><span class="n">sig_data</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">len</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">audit_netlink_ok</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">msg_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* As soon as there&#39;s any sign of userspace auditd,</span>
<span class="cm">	 * start kauditd to talk to it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kauditd_task</span><span class="p">)</span>
		<span class="n">kauditd_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">kauditd_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;kauditd&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">kauditd_task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">kauditd_task</span><span class="p">);</span>
		<span class="n">kauditd_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pid</span>  <span class="o">=</span> <span class="n">NETLINK_CREDS</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="n">uid</span>  <span class="o">=</span> <span class="n">NETLINK_CREDS</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">;</span>
	<span class="n">loginuid</span> <span class="o">=</span> <span class="n">audit_get_loginuid</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">sessionid</span> <span class="o">=</span> <span class="n">audit_get_sessionid</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">security_task_getsecid</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sid</span><span class="p">);</span>
	<span class="n">seq</span>  <span class="o">=</span> <span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_seq</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">NLMSG_DATA</span><span class="p">(</span><span class="n">nlh</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msg_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AUDIT_GET</span>:
		<span class="n">status_set</span><span class="p">.</span><span class="n">enabled</span>	 <span class="o">=</span> <span class="n">audit_enabled</span><span class="p">;</span>
		<span class="n">status_set</span><span class="p">.</span><span class="n">failure</span>	 <span class="o">=</span> <span class="n">audit_failure</span><span class="p">;</span>
		<span class="n">status_set</span><span class="p">.</span><span class="n">pid</span>		 <span class="o">=</span> <span class="n">audit_pid</span><span class="p">;</span>
		<span class="n">status_set</span><span class="p">.</span><span class="n">rate_limit</span>	 <span class="o">=</span> <span class="n">audit_rate_limit</span><span class="p">;</span>
		<span class="n">status_set</span><span class="p">.</span><span class="n">backlog_limit</span> <span class="o">=</span> <span class="n">audit_backlog_limit</span><span class="p">;</span>
		<span class="n">status_set</span><span class="p">.</span><span class="n">lost</span>		 <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_lost</span><span class="p">);</span>
		<span class="n">status_set</span><span class="p">.</span><span class="n">backlog</span>	 <span class="o">=</span> <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_skb_queue</span><span class="p">);</span>
		<span class="n">audit_send_reply</span><span class="p">(</span><span class="n">NETLINK_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">AUDIT_GET</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">status_set</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">status_set</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_SET</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_status</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">status_get</span>   <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">audit_status</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status_get</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AUDIT_STATUS_ENABLED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">audit_set_enabled</span><span class="p">(</span><span class="n">status_get</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">,</span>
						<span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status_get</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AUDIT_STATUS_FAILURE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">audit_set_failure</span><span class="p">(</span><span class="n">status_get</span><span class="o">-&gt;</span><span class="n">failure</span><span class="p">,</span>
						<span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status_get</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AUDIT_STATUS_PID</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">new_pid</span> <span class="o">=</span> <span class="n">status_get</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">audit_enabled</span> <span class="o">!=</span> <span class="n">AUDIT_OFF</span><span class="p">)</span>
				<span class="n">audit_log_config_change</span><span class="p">(</span><span class="s">&quot;audit_pid&quot;</span><span class="p">,</span> <span class="n">new_pid</span><span class="p">,</span>
							<span class="n">audit_pid</span><span class="p">,</span> <span class="n">loginuid</span><span class="p">,</span>
							<span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

			<span class="n">audit_pid</span> <span class="o">=</span> <span class="n">new_pid</span><span class="p">;</span>
			<span class="n">audit_nlk_pid</span> <span class="o">=</span> <span class="n">NETLINK_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status_get</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AUDIT_STATUS_RATE_LIMIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">audit_set_rate_limit</span><span class="p">(</span><span class="n">status_get</span><span class="o">-&gt;</span><span class="n">rate_limit</span><span class="p">,</span>
						   <span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status_get</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AUDIT_STATUS_BACKLOG_LIMIT</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">audit_set_backlog_limit</span><span class="p">(</span><span class="n">status_get</span><span class="o">-&gt;</span><span class="n">backlog_limit</span><span class="p">,</span>
						      <span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_USER</span>:
	<span class="k">case</span> <span class="n">AUDIT_FIRST_USER_MSG</span> <span class="p">...</span> <span class="n">AUDIT_LAST_USER_MSG</span>:
	<span class="k">case</span> <span class="n">AUDIT_FIRST_USER_MSG2</span> <span class="p">...</span> <span class="n">AUDIT_LAST_USER_MSG2</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">audit_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">msg_type</span> <span class="o">!=</span> <span class="n">AUDIT_USER_AVC</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">audit_filter_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NETLINK_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">msg_type</span> <span class="o">==</span> <span class="n">AUDIT_USER_TTY</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">audit_prepare_user_tty</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">loginuid</span><span class="p">,</span>
							     <span class="n">sessionid</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">audit_log_common_recv_msg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ab</span><span class="p">,</span> <span class="n">msg_type</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span>
						  <span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">msg_type</span> <span class="o">!=</span> <span class="n">AUDIT_USER_TTY</span><span class="p">)</span>
				<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; msg=&#39;%.1024s&#39;&quot;</span><span class="p">,</span>
						 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

				<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; msg=&quot;</span><span class="p">);</span>
				<span class="n">size</span> <span class="o">=</span> <span class="n">nlmsg_len</span><span class="p">(</span><span class="n">nlh</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				    <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">)[</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
					<span class="n">size</span><span class="o">--</span><span class="p">;</span>
				<span class="n">audit_log_n_untrustedstring</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">audit_set_pid</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
			<span class="n">audit_log_end</span><span class="p">(</span><span class="n">ab</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_ADD</span>:
	<span class="k">case</span> <span class="n">AUDIT_DEL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">nlmsg_len</span><span class="p">(</span><span class="n">nlh</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_rule</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">audit_enabled</span> <span class="o">==</span> <span class="n">AUDIT_LOCKED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">audit_log_common_recv_msg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ab</span><span class="p">,</span> <span class="n">AUDIT_CONFIG_CHANGE</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span>
						  <span class="n">uid</span><span class="p">,</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>

			<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; audit_enabled=%d res=0&quot;</span><span class="p">,</span>
					 <span class="n">audit_enabled</span><span class="p">);</span>
			<span class="n">audit_log_end</span><span class="p">(</span><span class="n">ab</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* fallthrough */</span>
	<span class="k">case</span> <span class="n">AUDIT_LIST</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">audit_receive_filter</span><span class="p">(</span><span class="n">msg_type</span><span class="p">,</span> <span class="n">NETLINK_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span><span class="p">,</span>
					   <span class="n">uid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">nlmsg_len</span><span class="p">(</span><span class="n">nlh</span><span class="p">),</span>
					   <span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_ADD_RULE</span>:
	<span class="k">case</span> <span class="n">AUDIT_DEL_RULE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">nlmsg_len</span><span class="p">(</span><span class="n">nlh</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_rule_data</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">audit_enabled</span> <span class="o">==</span> <span class="n">AUDIT_LOCKED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">audit_log_common_recv_msg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ab</span><span class="p">,</span> <span class="n">AUDIT_CONFIG_CHANGE</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span>
						  <span class="n">uid</span><span class="p">,</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>

			<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; audit_enabled=%d res=0&quot;</span><span class="p">,</span>
					 <span class="n">audit_enabled</span><span class="p">);</span>
			<span class="n">audit_log_end</span><span class="p">(</span><span class="n">ab</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* fallthrough */</span>
	<span class="k">case</span> <span class="n">AUDIT_LIST_RULES</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">audit_receive_filter</span><span class="p">(</span><span class="n">msg_type</span><span class="p">,</span> <span class="n">NETLINK_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span><span class="p">,</span>
					   <span class="n">uid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">nlmsg_len</span><span class="p">(</span><span class="n">nlh</span><span class="p">),</span>
					   <span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_TRIM</span>:
		<span class="n">audit_trim_trees</span><span class="p">();</span>

		<span class="n">audit_log_common_recv_msg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ab</span><span class="p">,</span> <span class="n">AUDIT_CONFIG_CHANGE</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span>
					  <span class="n">uid</span><span class="p">,</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>

		<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; op=trim res=1&quot;</span><span class="p">);</span>
		<span class="n">audit_log_end</span><span class="p">(</span><span class="n">ab</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_MAKE_EQUIV</span>: <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">bufp</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="kt">size_t</span> <span class="n">msglen</span> <span class="o">=</span> <span class="n">nlmsg_len</span><span class="p">(</span><span class="n">nlh</span><span class="p">);</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msglen</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">bufp</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
		<span class="n">bufp</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
		<span class="n">msglen</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
		<span class="n">old</span> <span class="o">=</span> <span class="n">audit_unpack_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msglen</span><span class="p">,</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">old</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">audit_unpack_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msglen</span><span class="p">,</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* OK, here comes... */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">audit_tag_tree</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>

		<span class="n">audit_log_common_recv_msg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ab</span><span class="p">,</span> <span class="n">AUDIT_CONFIG_CHANGE</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span>
					  <span class="n">uid</span><span class="p">,</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>

		<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; op=make_equiv old=&quot;</span><span class="p">);</span>
		<span class="n">audit_log_untrustedstring</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
		<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; new=&quot;</span><span class="p">);</span>
		<span class="n">audit_log_untrustedstring</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
		<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; res=%d&quot;</span><span class="p">,</span> <span class="o">!</span><span class="n">err</span><span class="p">);</span>
		<span class="n">audit_log_end</span><span class="p">(</span><span class="n">ab</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">AUDIT_SIGNAL_INFO</span>:
		<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">audit_sig_sid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">security_secid_to_secctx</span><span class="p">(</span><span class="n">audit_sig_sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sig_data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sig_data</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sig_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">audit_sig_sid</span><span class="p">)</span>
				<span class="n">security_release_secctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sig_data</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">audit_sig_uid</span><span class="p">;</span>
		<span class="n">sig_data</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">audit_sig_pid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">audit_sig_sid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">sig_data</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">security_release_secctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">audit_send_reply</span><span class="p">(</span><span class="n">NETLINK_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">AUDIT_SIGNAL_INFO</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sig_data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sig_data</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sig_data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_TTY_GET</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">audit_tty_status</span> <span class="n">s</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">tsk</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span> <span class="o">&amp;&amp;</span> <span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">s</span><span class="p">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">audit_tty</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">audit_send_reply</span><span class="p">(</span><span class="n">NETLINK_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span>
					 <span class="n">AUDIT_TTY_GET</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">AUDIT_TTY_SET</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">audit_tty_status</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_tty_status</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">tsk</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span> <span class="o">&amp;&amp;</span> <span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">audit_tty</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">err</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get message from skb.  Each message is processed by audit_receive_msg.</span>
<span class="cm"> * Malformed skbs with wrong length are discarded silently.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">audit_receive_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * len MUST be signed for NLMSG_NEXT to be able to dec it below 0</span>
<span class="cm">	 * if the nlmsg_len was not aligned</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">nlh</span> <span class="o">=</span> <span class="n">nlmsg_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">NLMSG_OK</span><span class="p">(</span><span class="n">nlh</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">audit_receive_msg</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nlh</span><span class="p">);</span>
		<span class="cm">/* if err or if this message says it wants a response */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="p">(</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_flags</span> <span class="o">&amp;</span> <span class="n">NLM_F_ACK</span><span class="p">))</span>
			<span class="n">netlink_ack</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nlh</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

		<span class="n">nlh</span> <span class="o">=</span> <span class="n">NLMSG_NEXT</span><span class="p">(</span><span class="n">nlh</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Receive messages from netlink socket. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">audit_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span>  <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_cmd_mutex</span><span class="p">);</span>
	<span class="n">audit_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_cmd_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Initialize audit support at boot time. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">audit_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">audit_initialized</span> <span class="o">==</span> <span class="n">AUDIT_DISABLED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;audit: initializing netlink socket (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">audit_default</span> <span class="o">?</span> <span class="s">&quot;enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;disabled&quot;</span><span class="p">);</span>
	<span class="n">audit_sock</span> <span class="o">=</span> <span class="n">netlink_kernel_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">NETLINK_AUDIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="n">audit_receive</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">THIS_MODULE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">audit_sock</span><span class="p">)</span>
		<span class="n">audit_panic</span><span class="p">(</span><span class="s">&quot;cannot initialize netlink socket&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">audit_sock</span><span class="o">-&gt;</span><span class="n">sk_sndtimeo</span> <span class="o">=</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">;</span>

	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_skb_queue</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_skb_hold_queue</span><span class="p">);</span>
	<span class="n">audit_initialized</span> <span class="o">=</span> <span class="n">AUDIT_INITIALIZED</span><span class="p">;</span>
	<span class="n">audit_enabled</span> <span class="o">=</span> <span class="n">audit_default</span><span class="p">;</span>
	<span class="n">audit_ever_enabled</span> <span class="o">|=</span> <span class="o">!!</span><span class="n">audit_default</span><span class="p">;</span>

	<span class="n">audit_log</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">AUDIT_KERNEL</span><span class="p">,</span> <span class="s">&quot;initialized&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AUDIT_INODE_BUCKETS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_inode_hash</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__initcall</span><span class="p">(</span><span class="n">audit_init</span><span class="p">);</span>

<span class="cm">/* Process kernel command-line parameter at boot time.  audit=0 or audit=1. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">audit_enable</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">audit_default</span> <span class="o">=</span> <span class="o">!!</span><span class="n">simple_strtol</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">audit_default</span><span class="p">)</span>
		<span class="n">audit_initialized</span> <span class="o">=</span> <span class="n">AUDIT_DISABLED</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;audit: %s&quot;</span><span class="p">,</span> <span class="n">audit_default</span> <span class="o">?</span> <span class="s">&quot;enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;disabled&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">audit_initialized</span> <span class="o">==</span> <span class="n">AUDIT_INITIALIZED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">audit_enabled</span> <span class="o">=</span> <span class="n">audit_default</span><span class="p">;</span>
		<span class="n">audit_ever_enabled</span> <span class="o">|=</span> <span class="o">!!</span><span class="n">audit_default</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">audit_initialized</span> <span class="o">==</span> <span class="n">AUDIT_UNINITIALIZED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; (after initialization)&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; (until reboot)&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;audit=&quot;</span><span class="p">,</span> <span class="n">audit_enable</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">audit_buffer_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ab</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_freelist_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">audit_freelist_count</span> <span class="o">&gt;</span> <span class="n">AUDIT_MAXFREE</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ab</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">audit_freelist_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ab</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_freelist</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_freelist_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span> <span class="nf">audit_buffer_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
						<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_freelist_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_freelist</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ab</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">audit_freelist</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">audit_buffer</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ab</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="o">--</span><span class="n">audit_freelist_count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_freelist_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ab</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ab</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ab</span><span class="p">),</span> <span class="n">gfp_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ab</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ab</span><span class="o">-&gt;</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="n">ab</span><span class="o">-&gt;</span><span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">gfp_mask</span><span class="p">;</span>

	<span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">nlmsg_new</span><span class="p">(</span><span class="n">AUDIT_BUFSIZ</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nlmsg_failure</span><span class="p">;</span>

	<span class="n">nlh</span> <span class="o">=</span> <span class="n">NLMSG_NEW</span><span class="p">(</span><span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ab</span><span class="p">;</span>

<span class="nl">nlmsg_failure:</span>                  <span class="cm">/* Used by NLMSG_NEW */</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">audit_buffer_free</span><span class="p">(</span><span class="n">ab</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * audit_serial - compute a serial number for the audit record</span>
<span class="cm"> *</span>
<span class="cm"> * Compute a serial number for the audit record.  Audit records are</span>
<span class="cm"> * written to user-space as soon as they are generated, so a complete</span>
<span class="cm"> * audit record may be written in several pieces.  The timestamp of the</span>
<span class="cm"> * record and this serial number are used by the user-space tools to</span>
<span class="cm"> * determine which pieces belong to the same audit record.  The</span>
<span class="cm"> * (timestamp,serial) tuple is unique for each syscall and is live from</span>
<span class="cm"> * syscall entry to syscall exit.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Another possibility is to store the formatted records off the</span>
<span class="cm"> * audit context (for those records that have a context), and emit them</span>
<span class="cm"> * all at syscall exit.  However, this could delay the reporting of</span>
<span class="cm"> * significant errors until syscall exit (or never, if the system</span>
<span class="cm"> * halts).</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">audit_serial</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">serial_lock</span><span class="p">);</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">serial</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">++</span><span class="n">serial</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serial_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">audit_get_stamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">serial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span> <span class="o">||</span> <span class="o">!</span><span class="n">auditsc_get_stamp</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">serial</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
		<span class="o">*</span><span class="n">serial</span> <span class="o">=</span> <span class="n">audit_serial</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Obtain an audit buffer.  This routine does locking to obtain the</span>
<span class="cm"> * audit buffer, but then no locking is required for calls to</span>
<span class="cm"> * audit_log_*format.  If the tsk is a task that is currently in a</span>
<span class="cm"> * syscall, then the syscall is marked as auditable and an audit record</span>
<span class="cm"> * will be written at syscall exit.  If there is no associated task, tsk</span>
<span class="cm"> * should be NULL. */</span>

<span class="cm">/**</span>
<span class="cm"> * audit_log_start - obtain an audit buffer</span>
<span class="cm"> * @ctx: audit_context (may be NULL)</span>
<span class="cm"> * @gfp_mask: type of allocation</span>
<span class="cm"> * @type: audit message type</span>
<span class="cm"> *</span>
<span class="cm"> * Returns audit_buffer pointer on success or NULL on error.</span>
<span class="cm"> *</span>
<span class="cm"> * Obtain an audit buffer.  This routine does locking to obtain the</span>
<span class="cm"> * audit buffer, but then no locking is required for calls to</span>
<span class="cm"> * audit_log_*format.  If the task (ctx) is a task that is currently in a</span>
<span class="cm"> * syscall, then the syscall is marked as auditable and an audit record</span>
<span class="cm"> * will be written at syscall exit.  If there is no associated task, then</span>
<span class="cm"> * task context (ctx) should be NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="nf">audit_log_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_buffer</span>	<span class="o">*</span><span class="n">ab</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span>		<span class="n">t</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">uninitialized_var</span><span class="p">(</span><span class="n">serial</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">reserve</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">audit_initialized</span> <span class="o">!=</span> <span class="n">AUDIT_INITIALIZED</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">audit_filter_type</span><span class="p">(</span><span class="n">type</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">)</span>
		<span class="n">reserve</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">reserve</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="cm">/* Allow atomic callers to go up to five</span>
<span class="cm">				entries over the normal backlog limit */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">audit_backlog_limit</span>
	       <span class="o">&amp;&amp;</span> <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_skb_queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">audit_backlog_limit</span> <span class="o">+</span> <span class="n">reserve</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span> <span class="o">&amp;&amp;</span> <span class="n">audit_backlog_wait_time</span>
		    <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout_start</span> <span class="o">+</span> <span class="n">audit_backlog_wait_time</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* Wait for auditd to drain the queue a little */</span>
			<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_backlog_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">audit_backlog_limit</span> <span class="o">&amp;&amp;</span>
			    <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_skb_queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">audit_backlog_limit</span><span class="p">)</span>
				<span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeout_start</span> <span class="o">+</span> <span class="n">audit_backlog_wait_time</span> <span class="o">-</span> <span class="n">jiffies</span><span class="p">);</span>

			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
			<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_backlog_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">audit_rate_check</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;audit: audit_backlog=%d &gt; &quot;</span>
			       <span class="s">&quot;audit_backlog_limit=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_skb_queue</span><span class="p">),</span>
			       <span class="n">audit_backlog_limit</span><span class="p">);</span>
		<span class="n">audit_log_lost</span><span class="p">(</span><span class="s">&quot;backlog limit exceeded&quot;</span><span class="p">);</span>
		<span class="n">audit_backlog_wait_time</span> <span class="o">=</span> <span class="n">audit_backlog_wait_overflow</span><span class="p">;</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_backlog_wait</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ab</span> <span class="o">=</span> <span class="n">audit_buffer_alloc</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ab</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">audit_log_lost</span><span class="p">(</span><span class="s">&quot;out of memory in audit_log_start&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">audit_get_stamp</span><span class="p">(</span><span class="n">ab</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">serial</span><span class="p">);</span>

	<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot;audit(%lu.%03lu:%u): &quot;</span><span class="p">,</span>
			 <span class="n">t</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">tv_nsec</span><span class="o">/</span><span class="mi">1000000</span><span class="p">,</span> <span class="n">serial</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ab</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * audit_expand - expand skb in the audit buffer</span>
<span class="cm"> * @ab: audit_buffer</span>
<span class="cm"> * @extra: space to add at tail of the skb</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 (no space) on failed expansion, or available space if</span>
<span class="cm"> * successful.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">audit_expand</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">,</span> <span class="kt">int</span> <span class="n">extra</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oldtail</span> <span class="o">=</span> <span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">extra</span><span class="p">,</span> <span class="n">ab</span><span class="o">-&gt;</span><span class="n">gfp_mask</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">newtail</span> <span class="o">=</span> <span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">audit_log_lost</span><span class="p">(</span><span class="s">&quot;out of memory in audit_expand&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">newtail</span> <span class="o">-</span> <span class="n">oldtail</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">newtail</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Format an audit message into the audit buffer.  If there isn&#39;t enough</span>
<span class="cm"> * room in the audit buffer, more room will be allocated and vsnprint</span>
<span class="cm"> * will be called a second time.  Currently, we assume that a printk</span>
<span class="cm"> * can&#39;t format message larger than 1024 bytes, so we don&#39;t either.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">audit_log_vformat</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span>
			      <span class="kt">va_list</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">avail</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ab</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">avail</span> <span class="o">=</span> <span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">avail</span> <span class="o">=</span> <span class="n">audit_expand</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">AUDIT_BUFSIZ</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avail</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">va_copy</span><span class="p">(</span><span class="n">args2</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">vsnprintf</span><span class="p">(</span><span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">avail</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The printk buffer is 1024 bytes long, so if we get</span>
<span class="cm">		 * here and AUDIT_BUFSIZ is at least 1024, then we can</span>
<span class="cm">		 * log everything that printk could have logged. */</span>
		<span class="n">avail</span> <span class="o">=</span> <span class="n">audit_expand</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span>
			<span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">AUDIT_BUFSIZ</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">len</span><span class="o">-</span><span class="n">avail</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avail</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_va_end</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">vsnprintf</span><span class="p">(</span><span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">avail</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="nl">out_va_end:</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args2</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * audit_log_format - format a message into the audit buffer.</span>
<span class="cm"> * @ab: audit_buffer</span>
<span class="cm"> * @fmt: format string</span>
<span class="cm"> * @...: optional parameters matching @fmt string</span>
<span class="cm"> *</span>
<span class="cm"> * All the work is done in audit_log_vformat.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">audit_log_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ab</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">audit_log_vformat</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * audit_log_hex - convert a buffer to hex and append it to the audit skb</span>
<span class="cm"> * @ab: the audit_buffer</span>
<span class="cm"> * @buf: buffer to convert to hex</span>
<span class="cm"> * @len: length of @buf to be converted</span>
<span class="cm"> *</span>
<span class="cm"> * No return value; failure to expand is silently ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will take the passed buf and convert it into a string of</span>
<span class="cm"> * ascii hex digits. The new string is placed onto the skb.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">audit_log_n_hex</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">avail</span><span class="p">,</span> <span class="n">new_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hex</span> <span class="o">=</span> <span class="s">&quot;0123456789ABCDEF&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ab</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">avail</span> <span class="o">=</span> <span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">new_len</span> <span class="o">=</span> <span class="n">len</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_len</span> <span class="o">&gt;=</span> <span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Round the buffer request up to the next multiple */</span>
		<span class="n">new_len</span> <span class="o">=</span> <span class="n">AUDIT_BUFSIZ</span><span class="o">*</span><span class="p">(((</span><span class="n">new_len</span><span class="o">-</span><span class="n">avail</span><span class="p">)</span><span class="o">/</span><span class="n">AUDIT_BUFSIZ</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">avail</span> <span class="o">=</span> <span class="n">audit_expand</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">new_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avail</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">hex</span><span class="p">[(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">];</span> <span class="cm">/* Upper nibble */</span>
		<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">hex</span><span class="p">[</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">];</span>	  <span class="cm">/* Lower nibble */</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* new string is twice the old string */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Format a string of no more than slen characters into the audit buffer,</span>
<span class="cm"> * enclosed in quote marks.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">audit_log_n_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">slen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">avail</span><span class="p">,</span> <span class="n">new_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ab</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">avail</span> <span class="o">=</span> <span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">new_len</span> <span class="o">=</span> <span class="n">slen</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* enclosing quotes + null terminator */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_len</span> <span class="o">&gt;</span> <span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">avail</span> <span class="o">=</span> <span class="n">audit_expand</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">new_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avail</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;&quot;&#39;</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">slen</span><span class="p">);</span>
	<span class="n">ptr</span> <span class="o">+=</span> <span class="n">slen</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;&quot;&#39;</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">slen</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/* don&#39;t include null terminator */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * audit_string_contains_control - does a string need to be logged in hex</span>
<span class="cm"> * @string: string to be checked</span>
<span class="cm"> * @len: max length of the string to check</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">audit_string_contains_control</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">string</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">string</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">&#39;&quot;&#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;</span> <span class="mh">0x21</span> <span class="o">||</span> <span class="o">*</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mh">0x7e</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * audit_log_n_untrustedstring - log a string that may contain random characters</span>
<span class="cm"> * @ab: audit_buffer</span>
<span class="cm"> * @len: length of string (not including trailing null)</span>
<span class="cm"> * @string: string to be logged</span>
<span class="cm"> *</span>
<span class="cm"> * This code will escape a string that is passed to it if the string</span>
<span class="cm"> * contains a control character, unprintable character, double quote mark,</span>
<span class="cm"> * or a space. Unescaped strings will start and end with a double quote mark.</span>
<span class="cm"> * Strings that are escaped are printed in hex (2 digits per char).</span>
<span class="cm"> *</span>
<span class="cm"> * The caller specifies the number of characters in the string to log, which may</span>
<span class="cm"> * or may not be the entire string.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">audit_log_n_untrustedstring</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">audit_string_contains_control</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="n">audit_log_n_hex</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">audit_log_n_string</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * audit_log_untrustedstring - log a string that may contain random characters</span>
<span class="cm"> * @ab: audit_buffer</span>
<span class="cm"> * @string: string to be logged</span>
<span class="cm"> *</span>
<span class="cm"> * Same as audit_log_n_untrustedstring(), except that strlen is used to</span>
<span class="cm"> * determine string length.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">audit_log_untrustedstring</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">audit_log_n_untrustedstring</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">string</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* This is a helper-function to print the escaped d_path */</span>
<span class="kt">void</span> <span class="nf">audit_log_d_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">pathname</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
		<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="p">);</span>

	<span class="cm">/* We will allow 11 spaces for &#39; (deleted)&#39; to be appended */</span>
	<span class="n">pathname</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PATH_MAX</span><span class="o">+</span><span class="mi">11</span><span class="p">,</span> <span class="n">ab</span><span class="o">-&gt;</span><span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pathname</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">audit_log_string</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot;&lt;no_memory&gt;&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">d_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">PATH_MAX</span><span class="o">+</span><span class="mi">11</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* Should never happen since we send PATH_MAX */</span>
		<span class="cm">/* FIXME: can we save some information here? */</span>
		<span class="n">audit_log_string</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot;&lt;too_long&gt;&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">audit_log_untrustedstring</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pathname</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">audit_log_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; key=&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">)</span>
		<span class="n">audit_log_untrustedstring</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot;(null)&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * audit_log_end - end one audit record</span>
<span class="cm"> * @ab: the audit_buffer</span>
<span class="cm"> *</span>
<span class="cm"> * The netlink_* functions cannot be called inside an irq context, so</span>
<span class="cm"> * the audit buffer is placed on a queue and a tasklet is scheduled to</span>
<span class="cm"> * remove them from the queue outside the irq context.  May be called in</span>
<span class="cm"> * any context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">audit_log_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ab</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">audit_rate_check</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">audit_log_lost</span><span class="p">(</span><span class="s">&quot;rate limit exceeded&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span> <span class="o">=</span> <span class="n">nlmsg_hdr</span><span class="p">(</span><span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_len</span> <span class="o">=</span> <span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">NLMSG_SPACE</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">audit_pid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_skb_queue</span><span class="p">,</span> <span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kauditd_wait</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">audit_printk_skb</span><span class="p">(</span><span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ab</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">audit_buffer_free</span><span class="p">(</span><span class="n">ab</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * audit_log - Log an audit record</span>
<span class="cm"> * @ctx: audit context</span>
<span class="cm"> * @gfp_mask: type of allocation</span>
<span class="cm"> * @type: audit message type</span>
<span class="cm"> * @fmt: format string to use</span>
<span class="cm"> * @...: variable parameters matching the format string</span>
<span class="cm"> *</span>
<span class="cm"> * This is a convenience function that calls audit_log_start,</span>
<span class="cm"> * audit_log_vformat, and audit_log_end.  It may be called</span>
<span class="cm"> * in any context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">audit_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
	       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>

	<span class="n">ab</span> <span class="o">=</span> <span class="n">audit_log_start</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ab</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
		<span class="n">audit_log_vformat</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
		<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="n">audit_log_end</span><span class="p">(</span><span class="n">ab</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SECURITY</span>
<span class="cm">/**</span>
<span class="cm"> * audit_log_secctx - Converts and logs SELinux context</span>
<span class="cm"> * @ab: audit_buffer</span>
<span class="cm"> * @secid: security number</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function that calls security_secid_to_secctx to convert</span>
<span class="cm"> * secid to secctx and then adds the (converted) SELinux context to the audit</span>
<span class="cm"> * log by calling audit_log_format, thus also preventing leak of internal secid</span>
<span class="cm"> * to userspace. If secid cannot be converted audit_panic is called.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">audit_log_secctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">secctx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">security_secid_to_secctx</span><span class="p">(</span><span class="n">secid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">audit_panic</span><span class="p">(</span><span class="s">&quot;Cannot convert secid to context&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; obj=%s&quot;</span><span class="p">,</span> <span class="n">secctx</span><span class="p">);</span>
		<span class="n">security_release_secctx</span><span class="p">(</span><span class="n">secctx</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">audit_log_secctx</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">audit_log_start</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">audit_log_end</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">audit_log_format</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">audit_log</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
