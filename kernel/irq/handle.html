<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › irq › handle.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>handle.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/kernel/irq/handle.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992, 1998-2006 Linus Torvalds, Ingo Molnar</span>
<span class="cm"> * Copyright (C) 2005-2006, Thomas Gleixner, Russell King</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains the core interrupt handling code.</span>
<span class="cm"> *</span>
<span class="cm"> * Detailed information is available in Documentation/DocBook/genericirq</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>

<span class="cp">#include &lt;trace/events/irq.h&gt;</span>

<span class="cp">#include &quot;internals.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * handle_bad_irq - handle spurious and unhandled irqs</span>
<span class="cm"> * @irq:       the interrupt number</span>
<span class="cm"> * @desc:      description of the interrupt</span>
<span class="cm"> *</span>
<span class="cm"> * Handles spurious and unhandled IRQ&#39;s. It also prints a debugmessage.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">handle_bad_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">print_irq_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
	<span class="n">kstat_incr_irqs_this_cpu</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
	<span class="n">ack_bad_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Special, empty irq handler:</span>
<span class="cm"> */</span>
<span class="n">irqreturn_t</span> <span class="nf">no_action</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">warn_no_thread</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">IRQTF_WARNED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">thread_flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;IRQ %d device %s returned IRQ_WAKE_THREAD &quot;</span>
	       <span class="s">&quot;but no thread function available.&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">action</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_wake_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * In case the thread crashed and was killed we just pretend that</span>
<span class="cm">	 * we handled the interrupt. The hardirq handler has disabled the</span>
<span class="cm">	 * device interrupt, so no irq storm is lurking.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wake up the handler thread for this action. If the</span>
<span class="cm">	 * RUNTHREAD bit is already set, nothing to do.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">IRQTF_RUNTHREAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">thread_flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s safe to OR the mask lockless here. We have only two</span>
<span class="cm">	 * places which write to threads_oneshot: This code and the</span>
<span class="cm">	 * irq thread.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This code is the hard irq context and can never run on two</span>
<span class="cm">	 * cpus in parallel. If it ever does we have more serious</span>
<span class="cm">	 * problems than this bitmask.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The irq threads of this irq which clear their &quot;running&quot; bit</span>
<span class="cm">	 * in threads_oneshot are serialized via desc-&gt;lock against</span>
<span class="cm">	 * each other and they are serialized against this code by</span>
<span class="cm">	 * IRQS_INPROGRESS.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Hard irq handler:</span>
<span class="cm">	 *</span>
<span class="cm">	 *	spin_lock(desc-&gt;lock);</span>
<span class="cm">	 *	desc-&gt;state |= IRQS_INPROGRESS;</span>
<span class="cm">	 *	spin_unlock(desc-&gt;lock);</span>
<span class="cm">	 *	set_bit(IRQTF_RUNTHREAD, &amp;action-&gt;thread_flags);</span>
<span class="cm">	 *	desc-&gt;threads_oneshot |= mask;</span>
<span class="cm">	 *	spin_lock(desc-&gt;lock);</span>
<span class="cm">	 *	desc-&gt;state &amp;= ~IRQS_INPROGRESS;</span>
<span class="cm">	 *	spin_unlock(desc-&gt;lock);</span>
<span class="cm">	 *</span>
<span class="cm">	 * irq thread:</span>
<span class="cm">	 *</span>
<span class="cm">	 * again:</span>
<span class="cm">	 *	spin_lock(desc-&gt;lock);</span>
<span class="cm">	 *	if (desc-&gt;state &amp; IRQS_INPROGRESS) {</span>
<span class="cm">	 *		spin_unlock(desc-&gt;lock);</span>
<span class="cm">	 *		while(desc-&gt;state &amp; IRQS_INPROGRESS)</span>
<span class="cm">	 *			cpu_relax();</span>
<span class="cm">	 *		goto again;</span>
<span class="cm">	 *	}</span>
<span class="cm">	 *	if (!test_bit(IRQTF_RUNTHREAD, &amp;action-&gt;thread_flags))</span>
<span class="cm">	 *		desc-&gt;threads_oneshot &amp;= ~mask;</span>
<span class="cm">	 *	spin_unlock(desc-&gt;lock);</span>
<span class="cm">	 *</span>
<span class="cm">	 * So either the thread waits for us to clear IRQS_INPROGRESS</span>
<span class="cm">	 * or we are waiting in the flow handler for desc-&gt;lock to be</span>
<span class="cm">	 * released before we reach this point. The thread also checks</span>
<span class="cm">	 * IRQTF_RUNTHREAD under desc-&gt;lock. If set it leaves</span>
<span class="cm">	 * threads_oneshot untouched and runs the thread another time.</span>
<span class="cm">	 */</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">threads_oneshot</span> <span class="o">|=</span> <span class="n">action</span><span class="o">-&gt;</span><span class="n">thread_mask</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We increment the threads_active counter in case we wake up</span>
<span class="cm">	 * the irq thread. The irq thread decrements the counter when</span>
<span class="cm">	 * it returns from the handler or in the exit path and wakes</span>
<span class="cm">	 * up waiters which are stuck in synchronize_irq() when the</span>
<span class="cm">	 * active count becomes zero. synchronize_irq() is serialized</span>
<span class="cm">	 * against this code (hard irq handler) via IRQS_INPROGRESS</span>
<span class="cm">	 * like the finalize_oneshot() code. See comment above.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">threads_active</span><span class="p">);</span>

	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">irqreturn_t</span>
<span class="nf">handle_irq_event_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irqreturn_t</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">random</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">.</span><span class="n">irq</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">irqreturn_t</span> <span class="n">res</span><span class="p">;</span>

		<span class="n">trace_irq_handler_entry</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">action</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">action</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">);</span>
		<span class="n">trace_irq_handler_exit</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">(),</span><span class="s">&quot;irq %u handler %pF enabled interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">irq</span><span class="p">,</span> <span class="n">action</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">))</span>
			<span class="n">local_irq_disable</span><span class="p">();</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IRQ_WAKE_THREAD</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Catch drivers which return WAKE_THREAD but</span>
<span class="cm">			 * did not set up a thread function</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">thread_fn</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">warn_no_thread</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">irq_wake_thread</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>

			<span class="cm">/* Fall through to add to randomness */</span>
		<span class="k">case</span> <span class="n">IRQ_HANDLED</span>:
			<span class="n">random</span> <span class="o">|=</span> <span class="n">action</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">retval</span> <span class="o">|=</span> <span class="n">res</span><span class="p">;</span>
		<span class="n">action</span> <span class="o">=</span> <span class="n">action</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">action</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">random</span> <span class="o">&amp;</span> <span class="n">IRQF_SAMPLE_RANDOM</span><span class="p">)</span>
		<span class="n">add_interrupt_randomness</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">noirqdebug</span><span class="p">)</span>
		<span class="n">note_interrupt</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">irqreturn_t</span> <span class="nf">handle_irq_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">;</span>
	<span class="n">irqreturn_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">istate</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IRQS_PENDING</span><span class="p">;</span>
	<span class="n">irqd_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">,</span> <span class="n">IRQD_IRQ_INPROGRESS</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">handle_irq_event_percpu</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">irqd_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">,</span> <span class="n">IRQD_IRQ_INPROGRESS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
