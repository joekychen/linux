<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › irq › manage.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>manage.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/kernel/irq/manage.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992, 1998-2006 Linus Torvalds, Ingo Molnar</span>
<span class="cm"> * Copyright (C) 2005-2006 Thomas Gleixner</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains driver APIs to the irq subsystem.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) &quot;genirq: &quot; fmt</span>

<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/task_work.h&gt;</span>

<span class="cp">#include &quot;internals.h&quot;</span>

<span class="cp">#ifdef CONFIG_IRQ_FORCED_THREADING</span>
<span class="n">__read_mostly</span> <span class="n">bool</span> <span class="n">force_irqthreads</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_forced_irqthreads</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">force_irqthreads</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;threadirqs&quot;</span><span class="p">,</span> <span class="n">setup_forced_irqthreads</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *	synchronize_irq - wait for pending IRQ handlers (on other CPUs)</span>
<span class="cm"> *	@irq: interrupt number to wait for</span>
<span class="cm"> *</span>
<span class="cm"> *	This function waits for any pending IRQ handlers for this interrupt</span>
<span class="cm"> *	to complete before returning. If you use this function while</span>
<span class="cm"> *	holding a resource the IRQ handler may need you will deadlock.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function may be called - with care - from IRQ context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">synchronize_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">inprogress</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Wait until we&#39;re out of the critical section.  This might</span>
<span class="cm">		 * give the wrong answer due to the lack of memory barriers.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">irqd_irq_inprogress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">))</span>
			<span class="n">cpu_relax</span><span class="p">();</span>

		<span class="cm">/* Ok, that indicated we&#39;re done: double-check carefully. */</span>
		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">inprogress</span> <span class="o">=</span> <span class="n">irqd_irq_inprogress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Oops, that failed? */</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">inprogress</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We made sure that no hardirq handler is running. Now verify</span>
<span class="cm">	 * that no threaded handlers are active.</span>
<span class="cm">	 */</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">wait_for_threads</span><span class="p">,</span> <span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">threads_active</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">synchronize_irq</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="n">cpumask_var_t</span> <span class="n">irq_default_affinity</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *	irq_can_set_affinity - Check if the affinity of a given irq can be set</span>
<span class="cm"> *	@irq:		Interrupt to check</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irq_can_set_affinity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span> <span class="o">||</span> <span class="o">!</span><span class="n">irqd_can_balance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">.</span><span class="n">chip</span> <span class="o">||</span> <span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">.</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_set_affinity</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	irq_set_thread_affinity - Notify irq threads to adjust affinity</span>
<span class="cm"> *	@desc:		irq descriptor which has affitnity changed</span>
<span class="cm"> *</span>
<span class="cm"> *	We just set IRQTF_AFFINITY and delegate the affinity setting</span>
<span class="cm"> *	to the interrupt thread itself. We can not call</span>
<span class="cm"> *	set_cpus_allowed_ptr() here as we hold desc-&gt;lock and this</span>
<span class="cm"> *	code can be called from hard interrupt context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">irq_set_thread_affinity</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">IRQTF_AFFINITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">thread_flags</span><span class="p">);</span>
		<span class="n">action</span> <span class="o">=</span> <span class="n">action</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_GENERIC_PENDING_IRQ</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">irq_can_move_pcntxt</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">irqd_can_move_in_process_context</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">irq_move_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">irqd_is_setaffinity_pending</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">irq_copy_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">pending_mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">irq_get_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">pending_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">irq_can_move_pcntxt</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">irq_move_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">irq_copy_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">irq_get_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">irq_do_set_affinity</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
			<span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_data_to_desc</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">irq_data_get_irq_chip</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_set_affinity</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IRQ_SET_MASK_OK</span>:
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">affinity</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">IRQ_SET_MASK_OK_NOCOPY</span>:
		<span class="n">irq_set_thread_affinity</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__irq_set_affinity_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">irq_data_get_irq_chip</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_data_to_desc</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span> <span class="o">||</span> <span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_set_affinity</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_can_move_pcntxt</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">irq_do_set_affinity</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">irqd_set_move_pending</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="n">irq_copy_pending</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">affinity_notify</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">affinity_notify</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">affinity_notify</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">irqd_set</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">IRQD_AFFINITY_SET</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	irq_set_affinity - Set the irq affinity of a given irq</span>
<span class="cm"> *	@irq:		Interrupt to set affinity</span>
<span class="cm"> *	@mask:		cpumask</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irq_set_affinity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span>  <span class="n">__irq_set_affinity_locked</span><span class="p">(</span><span class="n">irq_desc_get_irq_data</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">irq_set_affinity_hint</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_get_desc_lock</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="n">IRQ_GET_DESC_CHECK_GLOBAL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">affinity_hint</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
	<span class="n">irq_put_desc_unlock</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">irq_set_affinity_hint</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_affinity_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_affinity_notify</span> <span class="o">*</span><span class="n">notify</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_affinity_notify</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">notify</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">cpumask_var_t</span> <span class="n">cpumask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span> <span class="o">||</span> <span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_move_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">))</span>
		<span class="n">irq_get_pending</span><span class="p">(</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">.</span><span class="n">affinity</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">notify</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">(</span><span class="n">notify</span><span class="p">,</span> <span class="n">cpumask</span><span class="p">);</span>

	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">cpumask</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notify</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">notify</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	irq_set_affinity_notifier - control notification of IRQ affinity changes</span>
<span class="cm"> *	@irq:		Interrupt for which to enable/disable notification</span>
<span class="cm"> *	@notify:	Context for notification, or %NULL to disable</span>
<span class="cm"> *			notification.  Function pointers must be initialised;</span>
<span class="cm"> *			the other fields will be initialised by this function.</span>
<span class="cm"> *</span>
<span class="cm"> *	Must be called in process context.  Notification may only be enabled</span>
<span class="cm"> *	after the IRQ is allocated and must be disabled before the IRQ is</span>
<span class="cm"> *	freed using free_irq().</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">irq_set_affinity_notifier</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_affinity_notify</span> <span class="o">*</span><span class="n">notify</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">irq_affinity_notify</span> <span class="o">*</span><span class="n">old_notify</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* The release function is promised process context */</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Complete initialisation of *notify */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">notify</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">notify</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
		<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notify</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notify</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">irq_affinity_notify</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">old_notify</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">affinity_notify</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">affinity_notify</span> <span class="o">=</span> <span class="n">notify</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_notify</span><span class="p">)</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_notify</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">old_notify</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">irq_set_affinity_notifier</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_AUTO_IRQ_AFFINITY</span>
<span class="cm">/*</span>
<span class="cm"> * Generic version of the affinity autoselector.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">setup_affinity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">set</span> <span class="o">=</span> <span class="n">irq_default_affinity</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">.</span><span class="n">node</span><span class="p">;</span>

	<span class="cm">/* Excludes PER_CPU and NO_BALANCE interrupts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irq_can_set_affinity</span><span class="p">(</span><span class="n">irq</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Preserve an userspace affinity setup, but make sure that</span>
<span class="cm">	 * one of the targets is online.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqd_has_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">,</span> <span class="n">IRQD_AFFINITY_SET</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">.</span><span class="n">affinity</span><span class="p">,</span>
				       <span class="n">cpu_online_mask</span><span class="p">))</span>
			<span class="n">set</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">.</span><span class="n">affinity</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">irqd_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">,</span> <span class="n">IRQD_AFFINITY_SET</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cpumask_and</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">nodemask</span> <span class="o">=</span> <span class="n">cpumask_of_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

		<span class="cm">/* make sure at least one of the cpus in nodemask is online */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">))</span>
			<span class="n">cpumask_and</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">irq_do_set_affinity</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">setup_affinity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">irq_select_affinity</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Called when affinity is set via /proc/irq</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irq_select_affinity_usr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">setup_affinity</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">setup_affinity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">__disable_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">bool</span> <span class="n">suspend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">suspend</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">||</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQF_NO_SUSPEND</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">istate</span> <span class="o">|=</span> <span class="n">IRQS_SUSPENDED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">depth</span><span class="o">++</span><span class="p">)</span>
		<span class="n">irq_disable</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__disable_irq_nosync</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_get_desc_buslock</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="n">IRQ_GET_DESC_CHECK_GLOBAL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">__disable_irq</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">irq_put_desc_busunlock</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	disable_irq_nosync - disable an irq without waiting</span>
<span class="cm"> *	@irq: Interrupt to disable</span>
<span class="cm"> *</span>
<span class="cm"> *	Disable the selected interrupt line.  Disables and Enables are</span>
<span class="cm"> *	nested.</span>
<span class="cm"> *	Unlike disable_irq(), this function does not ensure existing</span>
<span class="cm"> *	instances of the IRQ handler have completed before returning.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function may be called from IRQ context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">disable_irq_nosync</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__disable_irq_nosync</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">disable_irq_nosync</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	disable_irq - disable an irq and wait for completion</span>
<span class="cm"> *	@irq: Interrupt to disable</span>
<span class="cm"> *</span>
<span class="cm"> *	Disable the selected interrupt line.  Enables and Disables are</span>
<span class="cm"> *	nested.</span>
<span class="cm"> *	This function waits for any pending IRQ handlers for this interrupt</span>
<span class="cm"> *	to complete before returning. If you use this function while</span>
<span class="cm"> *	holding a resource the IRQ handler may need you will deadlock.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function may be called - with care - from IRQ context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">disable_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__disable_irq_nosync</span><span class="p">(</span><span class="n">irq</span><span class="p">))</span>
		<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">disable_irq</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">__enable_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">bool</span> <span class="n">resume</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">resume</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">istate</span> <span class="o">&amp;</span> <span class="n">IRQS_SUSPENDED</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQF_FORCE_RESUME</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="cm">/* Pretend that it got disabled ! */</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">depth</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">istate</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IRQS_SUSPENDED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
 <span class="nl">err_out:</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">KERN_WARNING</span> <span class="s">&quot;Unbalanced enable for IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">istate</span> <span class="o">&amp;</span> <span class="n">IRQS_SUSPENDED</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="cm">/* Prevent probing on this irq: */</span>
		<span class="n">irq_settings_set_noprobe</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">irq_enable</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">check_irq_resend</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
		<span class="cm">/* fall-through */</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">depth</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	enable_irq - enable handling of an irq</span>
<span class="cm"> *	@irq: Interrupt to enable</span>
<span class="cm"> *</span>
<span class="cm"> *	Undoes the effect of one call to disable_irq().  If this</span>
<span class="cm"> *	matches the last disable, processing of interrupts on this</span>
<span class="cm"> *	IRQ line is re-enabled.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function may be called from IRQ context only when</span>
<span class="cm"> *	desc-&gt;irq_data.chip-&gt;bus_lock and desc-&gt;chip-&gt;bus_sync_unlock are NULL !</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">enable_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_get_desc_buslock</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="n">IRQ_GET_DESC_CHECK_GLOBAL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">.</span><span class="n">chip</span><span class="p">,</span>
		 <span class="n">KERN_ERR</span> <span class="s">&quot;enable_irq before setup/request_irq: irq %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">__enable_irq</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">irq_put_desc_busunlock</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">enable_irq</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_irq_wake_real</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_desc_get_chip</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span>  <span class="n">IRQCHIP_SKIP_SET_WAKE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">.</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_set_wake</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">.</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_set_wake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">,</span> <span class="n">on</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	irq_set_irq_wake - control irq power management wakeup</span>
<span class="cm"> *	@irq:	interrupt to control</span>
<span class="cm"> *	@on:	enable/disable power management wakeup</span>
<span class="cm"> *</span>
<span class="cm"> *	Enable/disable power management wakeup mode, which is</span>
<span class="cm"> *	disabled by default.  Enables and disables must match,</span>
<span class="cm"> *	just as they match for non-wakeup mode support.</span>
<span class="cm"> *</span>
<span class="cm"> *	Wakeup mode lets this IRQ wake the system from sleep</span>
<span class="cm"> *	states like &quot;suspend to RAM&quot;.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">irq_set_irq_wake</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_get_desc_buslock</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="n">IRQ_GET_DESC_CHECK_GLOBAL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* wakeup-capable irqs can be shared between drivers that</span>
<span class="cm">	 * don&#39;t need to have the same sleep mode behaviors.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">wake_depth</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">set_irq_wake_real</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">on</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">desc</span><span class="o">-&gt;</span><span class="n">wake_depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">irqd_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">,</span> <span class="n">IRQD_WAKEUP_STATE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">wake_depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Unbalanced IRQ %d wake disable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">wake_depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">set_irq_wake_real</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">on</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">desc</span><span class="o">-&gt;</span><span class="n">wake_depth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">irqd_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">,</span> <span class="n">IRQD_WAKEUP_STATE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">irq_put_desc_busunlock</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">irq_set_irq_wake</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Internal function that tells the architecture code whether a</span>
<span class="cm"> * particular irq has been exclusively allocated or is available</span>
<span class="cm"> * for driver use.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">can_request_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_get_desc_lock</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">canrequest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_settings_can_request</span><span class="p">(</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">irqflags</span> <span class="o">&amp;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQF_SHARED</span><span class="p">)</span>
				<span class="n">canrequest</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">irq_put_desc_unlock</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">canrequest</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__irq_set_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">.</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">unmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span> <span class="o">||</span> <span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_set_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * IRQF_TRIGGER_* but the PIC does not support multiple</span>
<span class="cm">		 * flow-types?</span>
<span class="cm">		 */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;No set_type function for IRQ %d (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span>
			 <span class="n">chip</span> <span class="o">?</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">?</span> <span class="o">:</span> <span class="s">&quot;unknown&quot;</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;unknown&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">IRQ_TYPE_SENSE_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQCHIP_SET_TYPE_MASKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irqd_irq_masked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">))</span>
			<span class="n">mask_irq</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irqd_irq_disabled</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">))</span>
			<span class="n">unmask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* caller masked out all except trigger mode flags */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_set_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IRQ_SET_MASK_OK</span>:
		<span class="n">irqd_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">,</span> <span class="n">IRQD_TRIGGER_MASK</span><span class="p">);</span>
		<span class="n">irqd_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">IRQ_SET_MASK_OK_NOCOPY</span>:
		<span class="n">flags</span> <span class="o">=</span> <span class="n">irqd_get_trigger_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">);</span>
		<span class="n">irq_settings_set_trigger_mask</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">irqd_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">,</span> <span class="n">IRQD_LEVEL</span><span class="p">);</span>
		<span class="n">irq_settings_clr_level</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQ_TYPE_LEVEL_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irq_settings_set_level</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
			<span class="n">irqd_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">,</span> <span class="n">IRQD_LEVEL</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Setting trigger mode %lu for irq %u failed (%pF)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">flags</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_set_type</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unmask</span><span class="p">)</span>
		<span class="n">unmask_irq</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Default primary interrupt handler for threaded interrupts. Is</span>
<span class="cm"> * assigned as primary handler when request_threaded_irq is called</span>
<span class="cm"> * with handler == NULL. Useful for oneshot interrupts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">irq_default_primary_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">IRQ_WAKE_THREAD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Primary handler for nested threaded interrupts. Should never be</span>
<span class="cm"> * called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">irq_nested_primary_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Primary handler called for nested irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">irq_wait_for_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">IRQTF_RUNTHREAD</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">thread_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Oneshot interrupts keep the irq line masked until the threaded</span>
<span class="cm"> * handler finished. unmask if the interrupt has not been disabled and</span>
<span class="cm"> * is marked MASKED.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_finalize_oneshot</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">istate</span> <span class="o">&amp;</span> <span class="n">IRQS_ONESHOT</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
<span class="nl">again:</span>
	<span class="n">chip_bus_lock</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Implausible though it may be we need to protect us against</span>
<span class="cm">	 * the following scenario:</span>
<span class="cm">	 *</span>
<span class="cm">	 * The thread is faster done than the hard interrupt handler</span>
<span class="cm">	 * on the other CPU. If we unmask the irq line then the</span>
<span class="cm">	 * interrupt can come in again and masks the line, leaves due</span>
<span class="cm">	 * to IRQS_INPROGRESS and the irq line is masked forever.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This also serializes the state of shared oneshot handlers</span>
<span class="cm">	 * versus &quot;desc-&gt;threads_onehsot |= action-&gt;thread_mask;&quot; in</span>
<span class="cm">	 * irq_wake_thread(). See the comment there which explains the</span>
<span class="cm">	 * serialization.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">irqd_irq_inprogress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">chip_bus_sync_unlock</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now check again, whether the thread should run. Otherwise</span>
<span class="cm">	 * we would clear the threads_oneshot bit of this thread which</span>
<span class="cm">	 * was just set.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IRQTF_RUNTHREAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">thread_flags</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">threads_oneshot</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">thread_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">threads_oneshot</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">irqd_irq_disabled</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">irqd_irq_masked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">))</span>
		<span class="n">unmask_irq</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">chip_bus_sync_unlock</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/*</span>
<span class="cm"> * Check whether we need to chasnge the affinity of the interrupt thread.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">irq_thread_check_affinity</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_var_t</span> <span class="n">mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">IRQTF_AFFINITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">thread_flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In case we are out of memory we set IRQTF_AFFINITY again and</span>
<span class="cm">	 * try again next time</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">IRQTF_AFFINITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">thread_flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">.</span><span class="n">affinity</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">irq_thread_check_affinity</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupts which are not explicitely requested as threaded</span>
<span class="cm"> * interrupts rely on the implicit bh/preempt disable of the hard irq</span>
<span class="cm"> * context. So we need to disable bh here to avoid deadlocks and other</span>
<span class="cm"> * side effects.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">irq_forced_thread_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irqreturn_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">action</span><span class="o">-&gt;</span><span class="n">thread_fn</span><span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">action</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">);</span>
	<span class="n">irq_finalize_oneshot</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupts explicitely requested as threaded interupts want to be</span>
<span class="cm"> * preemtible - many of them need to sleep and wait for slow busses to</span>
<span class="cm"> * complete.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">irq_thread_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irqreturn_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">action</span><span class="o">-&gt;</span><span class="n">thread_fn</span><span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">action</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">);</span>
	<span class="n">irq_finalize_oneshot</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wake_threads_waitq</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">threads_active</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">wait_for_threads</span><span class="p">))</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">wait_for_threads</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_thread_dtor</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_work</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">action</span> <span class="o">=</span> <span class="n">kthread_data</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;exiting task </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> (%d) is an active IRQ thread (irq %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">comm</span> <span class="o">?</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">comm</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">action</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>


	<span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If IRQTF_RUNTHREAD is set, we need to decrement</span>
<span class="cm">	 * desc-&gt;threads_active and wake possible waiters.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">IRQTF_RUNTHREAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">thread_flags</span><span class="p">))</span>
		<span class="n">wake_threads_waitq</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>

	<span class="cm">/* Prevent a stale desc-&gt;threads_oneshot */</span>
	<span class="n">irq_finalize_oneshot</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupt handler thread</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irq_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_work</span> <span class="n">on_exit_work</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="n">param</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="n">MAX_USER_RT_PRIO</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">irqreturn_t</span> <span class="p">(</span><span class="o">*</span><span class="n">handler_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">force_irqthreads</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">IRQTF_FORCED_THREAD</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">thread_flags</span><span class="p">))</span>
		<span class="n">handler_fn</span> <span class="o">=</span> <span class="n">irq_forced_thread_fn</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">handler_fn</span> <span class="o">=</span> <span class="n">irq_thread_fn</span><span class="p">;</span>

	<span class="n">sched_setscheduler</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">SCHED_FIFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>

	<span class="n">init_task_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">on_exit_work</span><span class="p">,</span> <span class="n">irq_thread_dtor</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">task_work_add</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">on_exit_work</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">irq_wait_for_interrupt</span><span class="p">(</span><span class="n">action</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">irqreturn_t</span> <span class="n">action_ret</span><span class="p">;</span>

		<span class="n">irq_thread_check_affinity</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>

		<span class="n">action_ret</span> <span class="o">=</span> <span class="n">handler_fn</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">noirqdebug</span><span class="p">)</span>
			<span class="n">note_interrupt</span><span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">action_ret</span><span class="p">);</span>

		<span class="n">wake_threads_waitq</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is the regular exit path. __free_irq() is stopping the</span>
<span class="cm">	 * thread via kthread_stop() after calling</span>
<span class="cm">	 * synchronize_irq(). So neither IRQTF_RUNTHREAD nor the</span>
<span class="cm">	 * oneshot mask bit can be set. We cannot verify that as we</span>
<span class="cm">	 * cannot touch the oneshot mask at this point anymore as</span>
<span class="cm">	 * __setup_irq() might have given out currents thread_mask</span>
<span class="cm">	 * again.</span>
<span class="cm">	 */</span>
	<span class="n">task_work_cancel</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">irq_thread_dtor</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irq_setup_forced_threading</span><span class="p">(</span><span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">force_irqthreads</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IRQF_NO_THREAD</span> <span class="o">|</span> <span class="n">IRQF_PERCPU</span> <span class="o">|</span> <span class="n">IRQF_ONESHOT</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IRQF_ONESHOT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">thread_fn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">IRQTF_FORCED_THREAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">thread_flags</span><span class="p">);</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">thread_fn</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">;</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="n">irq_default_primary_handler</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Internal function to register an irqaction - typically used to</span>
<span class="cm"> * allocate special interrupts that are part of the architecture.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">__setup_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="o">**</span><span class="n">old_ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">thread_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">nested</span><span class="p">,</span> <span class="n">shared</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpumask_var_t</span> <span class="n">mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">.</span><span class="n">chip</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">no_irq_chip</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Some drivers like serial.c use request_irq() heavily,</span>
<span class="cm">	 * so we have to be careful not to interfere with a</span>
<span class="cm">	 * running system.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQF_SAMPLE_RANDOM</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This function might sleep, we want to call it first,</span>
<span class="cm">		 * outside of the atomic block.</span>
<span class="cm">		 * Yes, this might clear the entropy pool if the wrong</span>
<span class="cm">		 * driver is attempted to be loaded, without actually</span>
<span class="cm">		 * installing a new handler, but is this really a problem,</span>
<span class="cm">		 * only the sysadmin is able to do this.</span>
<span class="cm">		 */</span>
		<span class="n">rand_initialize_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check whether the interrupt nests into another interrupt</span>
<span class="cm">	 * thread.</span>
<span class="cm">	 */</span>
	<span class="n">nested</span> <span class="o">=</span> <span class="n">irq_settings_is_nested_thread</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nested</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">thread_fn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_mput</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Replace the primary handler which was provided from</span>
<span class="cm">		 * the driver for non nested interrupt handling by the</span>
<span class="cm">		 * dummy function which warns when called.</span>
<span class="cm">		 */</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="n">irq_nested_primary_handler</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq_settings_can_thread</span><span class="p">(</span><span class="n">desc</span><span class="p">))</span>
			<span class="n">irq_setup_forced_threading</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create a handler thread when a thread function is supplied</span>
<span class="cm">	 * and the interrupt does not nest into another interrupt</span>
<span class="cm">	 * thread.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">thread_fn</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nested</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

		<span class="n">t</span> <span class="o">=</span> <span class="n">kthread_create</span><span class="p">(</span><span class="n">irq_thread</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="s">&quot;irq/%d-%s&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span>
				   <span class="n">new</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_mput</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * We keep the reference to the task struct even if</span>
<span class="cm">		 * the thread dies to avoid that the interrupt code</span>
<span class="cm">		 * references an already freed task_struct.</span>
<span class="cm">		 */</span>
		<span class="n">get_task_struct</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_thread</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following block of code has to be executed atomically</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">old_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">;</span>
	<span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">old_ptr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Can&#39;t share interrupts unless both agree to and are</span>
<span class="cm">		 * the same type (level, edge, polarity). So both flag</span>
<span class="cm">		 * fields must have IRQF_SHARED set and the bits which</span>
<span class="cm">		 * set the trigger type must match. Also all must</span>
<span class="cm">		 * agree on ONESHOT.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IRQF_SHARED</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">^</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IRQF_TRIGGER_MASK</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">^</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IRQF_ONESHOT</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">mismatch</span><span class="p">;</span>

		<span class="cm">/* All handlers must agree on per-cpuness */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQF_PERCPU</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQF_PERCPU</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">mismatch</span><span class="p">;</span>

		<span class="cm">/* add new interrupt at end of irq queue */</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Or all existing action-&gt;thread_mask bits,</span>
<span class="cm">			 * so we can find the next zero bit for this</span>
<span class="cm">			 * new action.</span>
<span class="cm">			 */</span>
			<span class="n">thread_mask</span> <span class="o">|=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">thread_mask</span><span class="p">;</span>
			<span class="n">old_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">old_ptr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">old</span><span class="p">);</span>
		<span class="n">shared</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup the thread mask for this irqaction for ONESHOT. For</span>
<span class="cm">	 * !ONESHOT irqs the thread mask is 0 so we can avoid a</span>
<span class="cm">	 * conditional in irq_wake_thread().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQF_ONESHOT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Unlikely to have 32 resp 64 irqs sharing one line,</span>
<span class="cm">		 * but who knows.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">thread_mask</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_mask</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * The thread_mask for the action is or&#39;ed to</span>
<span class="cm">		 * desc-&gt;thread_active to indicate that the</span>
<span class="cm">		 * IRQF_ONESHOT thread handler has been woken, but not</span>
<span class="cm">		 * yet finished. The bit is cleared when a thread</span>
<span class="cm">		 * completes. When all threads of a shared interrupt</span>
<span class="cm">		 * line have completed desc-&gt;threads_active becomes</span>
<span class="cm">		 * zero and the interrupt line is unmasked. See</span>
<span class="cm">		 * handle.c:irq_wake_thread() for further information.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If no thread is woken by primary (hard irq context)</span>
<span class="cm">		 * interrupt handlers, then desc-&gt;threads_active is</span>
<span class="cm">		 * also checked for zero to unmask the irq line in the</span>
<span class="cm">		 * affected hard irq flow handlers</span>
<span class="cm">		 * (handle_[fasteoi|level]_irq).</span>
<span class="cm">		 *</span>
<span class="cm">		 * The new action gets the first zero bit of</span>
<span class="cm">		 * thread_mask assigned. See the loop above which or&#39;s</span>
<span class="cm">		 * all existing action-&gt;thread_mask bits.</span>
<span class="cm">		 */</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">thread_mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ffz</span><span class="p">(</span><span class="n">thread_mask</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">==</span> <span class="n">irq_default_primary_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The interrupt was requested with handler = NULL, so</span>
<span class="cm">		 * we use the default primary handler for it. But it</span>
<span class="cm">		 * does not have the oneshot flag set. In combination</span>
<span class="cm">		 * with level interrupts this is deadly, because the</span>
<span class="cm">		 * default primary handler just wakes the thread, then</span>
<span class="cm">		 * the irq lines is reenabled, but the device still</span>
<span class="cm">		 * has the level irq asserted. Rinse and repeat....</span>
<span class="cm">		 *</span>
<span class="cm">		 * While this works for edge type interrupts, we play</span>
<span class="cm">		 * it safe and reject unconditionally because we can&#39;t</span>
<span class="cm">		 * say for sure which type this interrupt really</span>
<span class="cm">		 * has. The type flags are unreliable as the</span>
<span class="cm">		 * underlying chip implementation can override them.</span>
<span class="cm">		 */</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Threaded irq requested with handler=NULL and !ONESHOT for irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">irq</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_mask</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shared</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">wait_for_threads</span><span class="p">);</span>

		<span class="cm">/* Setup the type (level, edge polarity) if configured: */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQF_TRIGGER_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__irq_set_trigger</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span>
					<span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQF_TRIGGER_MASK</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_mask</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">istate</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IRQS_AUTODETECT</span> <span class="o">|</span> <span class="n">IRQS_SPURIOUS_DISABLED</span> <span class="o">|</span> \
				  <span class="n">IRQS_ONESHOT</span> <span class="o">|</span> <span class="n">IRQS_WAITING</span><span class="p">);</span>
		<span class="n">irqd_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">,</span> <span class="n">IRQD_IRQ_INPROGRESS</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQF_PERCPU</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irqd_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">,</span> <span class="n">IRQD_PER_CPU</span><span class="p">);</span>
			<span class="n">irq_settings_set_per_cpu</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQF_ONESHOT</span><span class="p">)</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">istate</span> <span class="o">|=</span> <span class="n">IRQS_ONESHOT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">irq_settings_can_autoenable</span><span class="p">(</span><span class="n">desc</span><span class="p">))</span>
			<span class="n">irq_startup</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="cm">/* Undo nested disables: */</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Exclude IRQ from balancing if requested */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQF_NOBALANCING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irq_settings_set_no_balancing</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
			<span class="n">irqd_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_data</span><span class="p">,</span> <span class="n">IRQD_NO_BALANCING</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Set default affinity mask once everything is setup */</span>
		<span class="n">setup_affinity</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQF_TRIGGER_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nmsk</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQF_TRIGGER_MASK</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">omsk</span> <span class="o">=</span> <span class="n">irq_settings_get_trigger_mask</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nmsk</span> <span class="o">!=</span> <span class="n">omsk</span><span class="p">)</span>
			<span class="cm">/* hope the handler works with current  trigger mode */</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;irq %d uses trigger mode %u; requested %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">irq</span><span class="p">,</span> <span class="n">nmsk</span><span class="p">,</span> <span class="n">omsk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="o">*</span><span class="n">old_ptr</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>

	<span class="cm">/* Reset broken irq detection when installing new handler */</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">irq_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">irqs_unhandled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check whether we disabled the irq via the spurious handler</span>
<span class="cm">	 * before. Reenable it and give it another chance.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shared</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">istate</span> <span class="o">&amp;</span> <span class="n">IRQS_SPURIOUS_DISABLED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">istate</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IRQS_SPURIOUS_DISABLED</span><span class="p">;</span>
		<span class="n">__enable_irq</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Strictly no need to wake it up, but hung_task complains</span>
<span class="cm">	 * when no hard interrupt wakes the thread up.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">)</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>

	<span class="n">register_irq_proc</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">register_handler_proc</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">mismatch:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQF_PROBE_SHARED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Flags mismatch irq %d. %08x (%s) vs. %08x (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">irq</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_DEBUG_SHIRQ</span>
		<span class="n">dump_stack</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

<span class="nl">out_mask:</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

<span class="nl">out_thread:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>

		<span class="n">new</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_mput:</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	setup_irq - setup an interrupt</span>
<span class="cm"> *	@irq: Interrupt line to setup</span>
<span class="cm"> *	@act: irqaction for the interrupt</span>
<span class="cm"> *</span>
<span class="cm"> * Used to statically setup interrupts in the early boot process.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">setup_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">act</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">irq_settings_is_per_cpu_devid</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">chip_bus_lock</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">__setup_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">act</span><span class="p">);</span>
	<span class="n">chip_bus_sync_unlock</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">setup_irq</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Internal function to unregister an irqaction - used to free</span>
<span class="cm"> * regular and special interrupts that are part of the architecture.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="nf">__free_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span><span class="p">,</span> <span class="o">**</span><span class="n">action_ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">WARN</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">(),</span> <span class="s">&quot;Trying to free IRQ %d from IRQ context!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * There can be multiple actions per IRQ descriptor, find the right</span>
<span class="cm">	 * one based on the dev_id:</span>
<span class="cm">	 */</span>
	<span class="n">action_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">action</span> <span class="o">=</span> <span class="o">*</span><span class="n">action_ptr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Trying to free already-free IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
			<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">dev_id</span> <span class="o">==</span> <span class="n">dev_id</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">action_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Found it - now remove it from the list of entries: */</span>
	<span class="o">*</span><span class="n">action_ptr</span> <span class="o">=</span> <span class="n">action</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/* If this was the last handler, shut down the IRQ line: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">)</span>
		<span class="n">irq_shutdown</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="cm">/* make sure affinity_hint is cleaned up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">affinity_hint</span><span class="p">))</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">affinity_hint</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">unregister_handler_proc</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>

	<span class="cm">/* Make sure it&#39;s not being used on another CPU: */</span>
	<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_SHIRQ</span>
	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s a shared IRQ -- the driver ought to be prepared for an IRQ</span>
<span class="cm">	 * event to happen even now it&#39;s being freed, so let&#39;s make sure that</span>
<span class="cm">	 * is so by doing an extra call to the handler ....</span>
<span class="cm">	 *</span>
<span class="cm">	 * ( We do this after actually deregistering it, to make sure that a</span>
<span class="cm">	 *   &#39;real&#39; IRQ doesn&#39;t run in * parallel with our fake. )</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQF_SHARED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">action</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">module_put</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">action</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	remove_irq - free an interrupt</span>
<span class="cm"> *	@irq: Interrupt line to free</span>
<span class="cm"> *	@act: irqaction for the interrupt</span>
<span class="cm"> *</span>
<span class="cm"> * Used to remove interrupts statically setup by the early boot process.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">remove_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">act</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">irq_settings_is_per_cpu_devid</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
	    <span class="n">__free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">act</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">remove_irq</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	free_irq - free an interrupt allocated with request_irq</span>
<span class="cm"> *	@irq: Interrupt line to free</span>
<span class="cm"> *	@dev_id: Device identity to free</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove an interrupt handler. The handler is removed and if the</span>
<span class="cm"> *	interrupt line is no longer in use by any driver it is disabled.</span>
<span class="cm"> *	On a shared IRQ the caller must ensure the interrupt is disabled</span>
<span class="cm"> *	on the card it drives before calling this function. The function</span>
<span class="cm"> *	does not return until any executing interrupts for this IRQ</span>
<span class="cm"> *	have completed.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function must not be called from interrupt context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">free_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span> <span class="o">||</span> <span class="n">WARN_ON</span><span class="p">(</span><span class="n">irq_settings_is_per_cpu_devid</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">affinity_notify</span><span class="p">))</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">affinity_notify</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">chip_bus_lock</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">__free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">));</span>
	<span class="n">chip_bus_sync_unlock</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">free_irq</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	request_threaded_irq - allocate an interrupt line</span>
<span class="cm"> *	@irq: Interrupt line to allocate</span>
<span class="cm"> *	@handler: Function to be called when the IRQ occurs.</span>
<span class="cm"> *		  Primary handler for threaded interrupts</span>
<span class="cm"> *		  If NULL and thread_fn != NULL the default</span>
<span class="cm"> *		  primary handler is installed</span>
<span class="cm"> *	@thread_fn: Function called from the irq handler thread</span>
<span class="cm"> *		    If NULL, no irq thread is created</span>
<span class="cm"> *	@irqflags: Interrupt type flags</span>
<span class="cm"> *	@devname: An ascii name for the claiming device</span>
<span class="cm"> *	@dev_id: A cookie passed back to the handler function</span>
<span class="cm"> *</span>
<span class="cm"> *	This call allocates interrupt resources and enables the</span>
<span class="cm"> *	interrupt line and IRQ handling. From the point this</span>
<span class="cm"> *	call is made your handler function may be invoked. Since</span>
<span class="cm"> *	your handler function must clear any interrupt the board</span>
<span class="cm"> *	raises, you must take care both to initialise your hardware</span>
<span class="cm"> *	and to set up the interrupt handler in the right order.</span>
<span class="cm"> *</span>
<span class="cm"> *	If you want to set up a threaded irq handler for your device</span>
<span class="cm"> *	then you need to supply @handler and @thread_fn. @handler is</span>
<span class="cm"> *	still called in hard interrupt context and has to check</span>
<span class="cm"> *	whether the interrupt originates from the device. If yes it</span>
<span class="cm"> *	needs to disable the interrupt on the device and return</span>
<span class="cm"> *	IRQ_WAKE_THREAD which will wake up the handler thread and run</span>
<span class="cm"> *	@thread_fn. This split handler design is necessary to support</span>
<span class="cm"> *	shared interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> *	Dev_id must be globally unique. Normally the address of the</span>
<span class="cm"> *	device data structure is used as the cookie. Since the handler</span>
<span class="cm"> *	receives this value it makes sense to use it.</span>
<span class="cm"> *</span>
<span class="cm"> *	If your interrupt is shared you must pass a non NULL dev_id</span>
<span class="cm"> *	as this is required when freeing the interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> *	Flags:</span>
<span class="cm"> *</span>
<span class="cm"> *	IRQF_SHARED		Interrupt is shared</span>
<span class="cm"> *	IRQF_SAMPLE_RANDOM	The interrupt can be used for entropy</span>
<span class="cm"> *	IRQF_TRIGGER_*		Specify active edge(s) or level</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">request_threaded_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
			 <span class="n">irq_handler_t</span> <span class="n">thread_fn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sanity-check: shared interrupts must pass in a real dev-ID,</span>
<span class="cm">	 * otherwise we&#39;ll have trouble later trying to figure out</span>
<span class="cm">	 * which interrupt is which (messes up the interrupt freeing</span>
<span class="cm">	 * logic etc).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">irqflags</span> <span class="o">&amp;</span> <span class="n">IRQF_SHARED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dev_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irq_settings_can_request</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">WARN_ON</span><span class="p">(</span><span class="n">irq_settings_is_per_cpu_devid</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">thread_fn</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">handler</span> <span class="o">=</span> <span class="n">irq_default_primary_handler</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">action</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irqaction</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">action</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">action</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
	<span class="n">action</span><span class="o">-&gt;</span><span class="n">thread_fn</span> <span class="o">=</span> <span class="n">thread_fn</span><span class="p">;</span>
	<span class="n">action</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">irqflags</span><span class="p">;</span>
	<span class="n">action</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">devname</span><span class="p">;</span>
	<span class="n">action</span><span class="o">-&gt;</span><span class="n">dev_id</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>

	<span class="n">chip_bus_lock</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">__setup_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
	<span class="n">chip_bus_sync_unlock</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">action</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_SHIRQ_FIXME</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">irqflags</span> <span class="o">&amp;</span> <span class="n">IRQF_SHARED</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s a shared IRQ -- the driver ought to be prepared for it</span>
<span class="cm">		 * to happen immediately, so let&#39;s make sure....</span>
<span class="cm">		 * We disable the irq to make sure that a &#39;real&#39; IRQ doesn&#39;t</span>
<span class="cm">		 * run in parallel with our fake.</span>
<span class="cm">		 */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">disable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">handler</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>

		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">request_threaded_irq</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	request_any_context_irq - allocate an interrupt line</span>
<span class="cm"> *	@irq: Interrupt line to allocate</span>
<span class="cm"> *	@handler: Function to be called when the IRQ occurs.</span>
<span class="cm"> *		  Threaded handler for threaded interrupts.</span>
<span class="cm"> *	@flags: Interrupt type flags</span>
<span class="cm"> *	@name: An ascii name for the claiming device</span>
<span class="cm"> *	@dev_id: A cookie passed back to the handler function</span>
<span class="cm"> *</span>
<span class="cm"> *	This call allocates interrupt resources and enables the</span>
<span class="cm"> *	interrupt line and IRQ handling. It selects either a</span>
<span class="cm"> *	hardirq or threaded handling method depending on the</span>
<span class="cm"> *	context.</span>
<span class="cm"> *</span>
<span class="cm"> *	On failure, it returns a negative value. On success,</span>
<span class="cm"> *	it returns either IRQC_IS_HARDIRQ or IRQC_IS_NESTED.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">request_any_context_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_settings_is_nested_thread</span><span class="p">(</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">request_threaded_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span>
					   <span class="n">flags</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">!</span><span class="n">ret</span> <span class="o">?</span> <span class="n">IRQC_IS_NESTED</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">ret</span> <span class="o">?</span> <span class="n">IRQC_IS_HARDIRQ</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">request_any_context_irq</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">enable_percpu_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_get_desc_lock</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="n">IRQ_GET_DESC_CHECK_PERCPU</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">&amp;=</span> <span class="n">IRQ_TYPE_SENSE_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">IRQ_TYPE_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">__irq_set_trigger</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;failed to set type for IRQ%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">irq_percpu_enable</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">irq_put_desc_unlock</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">disable_percpu_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_get_desc_lock</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="n">IRQ_GET_DESC_CHECK_PERCPU</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">irq_percpu_disable</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">irq_put_desc_unlock</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Internal function to unregister a percpu irqaction.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="nf">__free_percpu_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">WARN</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">(),</span> <span class="s">&quot;Trying to free IRQ %d from IRQ context!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">action</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">action</span> <span class="o">||</span> <span class="n">action</span><span class="o">-&gt;</span><span class="n">percpu_dev_id</span> <span class="o">!=</span> <span class="n">dev_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Trying to free already-free IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">percpu_enabled</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;percpu IRQ %d still enabled on CPU%d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">irq</span><span class="p">,</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">percpu_enabled</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Found it - now remove it from the list of entries: */</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">unregister_handler_proc</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>

	<span class="n">module_put</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">action</span><span class="p">;</span>

<span class="nl">bad:</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	remove_percpu_irq - free a per-cpu interrupt</span>
<span class="cm"> *	@irq: Interrupt line to free</span>
<span class="cm"> *	@act: irqaction for the interrupt</span>
<span class="cm"> *</span>
<span class="cm"> * Used to remove interrupts statically setup by the early boot process.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">remove_percpu_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">act</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span> <span class="o">&amp;&amp;</span> <span class="n">irq_settings_is_per_cpu_devid</span><span class="p">(</span><span class="n">desc</span><span class="p">))</span>
	    <span class="n">__free_percpu_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">act</span><span class="o">-&gt;</span><span class="n">percpu_dev_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	free_percpu_irq - free an interrupt allocated with request_percpu_irq</span>
<span class="cm"> *	@irq: Interrupt line to free</span>
<span class="cm"> *	@dev_id: Device identity to free</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove a percpu interrupt handler. The handler is removed, but</span>
<span class="cm"> *	the interrupt line is not disabled. This must be done on each</span>
<span class="cm"> *	CPU before calling this function. The function does not return</span>
<span class="cm"> *	until any executing interrupts for this IRQ have completed.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function must not be called from interrupt context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">free_percpu_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span> <span class="o">||</span> <span class="o">!</span><span class="n">irq_settings_is_per_cpu_devid</span><span class="p">(</span><span class="n">desc</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">chip_bus_lock</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">__free_percpu_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">));</span>
	<span class="n">chip_bus_sync_unlock</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	setup_percpu_irq - setup a per-cpu interrupt</span>
<span class="cm"> *	@irq: Interrupt line to setup</span>
<span class="cm"> *	@act: irqaction for the interrupt</span>
<span class="cm"> *</span>
<span class="cm"> * Used to statically setup per-cpu interrupts in the early boot process.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">setup_percpu_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">act</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span> <span class="o">||</span> <span class="o">!</span><span class="n">irq_settings_is_per_cpu_devid</span><span class="p">(</span><span class="n">desc</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">chip_bus_lock</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">__setup_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">act</span><span class="p">);</span>
	<span class="n">chip_bus_sync_unlock</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	request_percpu_irq - allocate a percpu interrupt line</span>
<span class="cm"> *	@irq: Interrupt line to allocate</span>
<span class="cm"> *	@handler: Function to be called when the IRQ occurs.</span>
<span class="cm"> *	@devname: An ascii name for the claiming device</span>
<span class="cm"> *	@dev_id: A percpu cookie passed back to the handler function</span>
<span class="cm"> *</span>
<span class="cm"> *	This call allocates interrupt resources, but doesn&#39;t</span>
<span class="cm"> *	automatically enable the interrupt. It has to be done on each</span>
<span class="cm"> *	CPU using enable_percpu_irq().</span>
<span class="cm"> *</span>
<span class="cm"> *	Dev_id must be globally unique. It is a per-cpu variable, and</span>
<span class="cm"> *	the handler gets called with the interrupted CPU&#39;s instance of</span>
<span class="cm"> *	that variable.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">request_percpu_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">action</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">irq_to_desc</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span> <span class="o">||</span> <span class="o">!</span><span class="n">irq_settings_can_request</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">irq_settings_is_per_cpu_devid</span><span class="p">(</span><span class="n">desc</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">action</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">irqaction</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">action</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">action</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
	<span class="n">action</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IRQF_PERCPU</span> <span class="o">|</span> <span class="n">IRQF_NO_SUSPEND</span><span class="p">;</span>
	<span class="n">action</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">devname</span><span class="p">;</span>
	<span class="n">action</span><span class="o">-&gt;</span><span class="n">percpu_dev_id</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>

	<span class="n">chip_bus_lock</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">__setup_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
	<span class="n">chip_bus_sync_unlock</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">action</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
