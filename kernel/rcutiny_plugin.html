<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › rcutiny_plugin.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>rcutiny_plugin.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Read-Copy Update mechanism for mutual exclusion, the Bloatwatch edition</span>
<span class="cm"> * Internal non-public definitions that provide either classic</span>
<span class="cm"> * or preemptible semantics.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2010 Linaro</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Paul E. McKenney &lt;paulmck@linux.vnet.ibm.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>

<span class="cm">/* Global control variables for rcupdate callback mechanism. */</span>
<span class="k">struct</span> <span class="n">rcu_ctrlblk</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rcucblist</span><span class="p">;</span>	<span class="cm">/* List of pending callbacks (CBs). */</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">**</span><span class="n">donetail</span><span class="p">;</span>	<span class="cm">/* -&gt;next pointer of last &quot;done&quot; CB. */</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">**</span><span class="n">curtail</span><span class="p">;</span>	<span class="cm">/* -&gt;next pointer of last CB. */</span>
	<span class="n">RCU_TRACE</span><span class="p">(</span><span class="kt">long</span> <span class="n">qlen</span><span class="p">);</span>		<span class="cm">/* Number of pending CBs. */</span>
	<span class="n">RCU_TRACE</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>		<span class="cm">/* Name of RCU type. */</span>
<span class="p">};</span>

<span class="cm">/* Definition for rcupdate control block. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_ctrlblk</span> <span class="n">rcu_sched_ctrlblk</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">donetail</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">rcu_sched_ctrlblk</span><span class="p">.</span><span class="n">rcucblist</span><span class="p">,</span>
	<span class="p">.</span><span class="n">curtail</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">rcu_sched_ctrlblk</span><span class="p">.</span><span class="n">rcucblist</span><span class="p">,</span>
	<span class="n">RCU_TRACE</span><span class="p">(.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;rcu_sched&quot;</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_ctrlblk</span> <span class="n">rcu_bh_ctrlblk</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">donetail</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">rcu_bh_ctrlblk</span><span class="p">.</span><span class="n">rcucblist</span><span class="p">,</span>
	<span class="p">.</span><span class="n">curtail</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">rcu_bh_ctrlblk</span><span class="p">.</span><span class="n">rcucblist</span><span class="p">,</span>
	<span class="n">RCU_TRACE</span><span class="p">(.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;rcu_bh&quot;</span><span class="p">)</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
<span class="kt">int</span> <span class="n">rcu_scheduler_active</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">rcu_scheduler_active</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_DEBUG_LOCK_ALLOC */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_TINY_PREEMPT_RCU</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>

<span class="cm">/* Global control variables for preemptible RCU. */</span>
<span class="k">struct</span> <span class="n">rcu_preempt_ctrlblk</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_ctrlblk</span> <span class="n">rcb</span><span class="p">;</span>	<span class="cm">/* curtail: -&gt;next ptr of last CB for GP. */</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">**</span><span class="n">nexttail</span><span class="p">;</span>
				<span class="cm">/* Tasks blocked in a preemptible RCU */</span>
				<span class="cm">/*  read-side critical section while an */</span>
				<span class="cm">/*  preemptible-RCU grace period is in */</span>
				<span class="cm">/*  progress must wait for a later grace */</span>
				<span class="cm">/*  period.  This pointer points to the */</span>
				<span class="cm">/*  -&gt;next pointer of the last task that */</span>
				<span class="cm">/*  must wait for a later grace period, or */</span>
				<span class="cm">/*  to &amp;-&gt;rcb.rcucblist if there is no */</span>
				<span class="cm">/*  such task. */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">blkd_tasks</span><span class="p">;</span>
				<span class="cm">/* Tasks blocked in RCU read-side critical */</span>
				<span class="cm">/*  section.  Tasks are placed at the head */</span>
				<span class="cm">/*  of this list and age towards the tail. */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">gp_tasks</span><span class="p">;</span>
				<span class="cm">/* Pointer to the first task blocking the */</span>
				<span class="cm">/*  current grace period, or NULL if there */</span>
				<span class="cm">/*  is no such task. */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">exp_tasks</span><span class="p">;</span>
				<span class="cm">/* Pointer to first task blocking the */</span>
				<span class="cm">/*  current expedited grace period, or NULL */</span>
				<span class="cm">/*  if there is no such task.  If there */</span>
				<span class="cm">/*  is no current expedited grace period, */</span>
				<span class="cm">/*  then there cannot be any such task. */</span>
<span class="cp">#ifdef CONFIG_RCU_BOOST</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">boost_tasks</span><span class="p">;</span>
				<span class="cm">/* Pointer to first task that needs to be */</span>
				<span class="cm">/*  priority-boosted, or NULL if no priority */</span>
				<span class="cm">/*  boosting is needed.  If there is no */</span>
				<span class="cm">/*  current or expedited grace period, there */</span>
				<span class="cm">/*  can be no such task. */</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_BOOST */</span><span class="cp"></span>
	<span class="n">u8</span> <span class="n">gpnum</span><span class="p">;</span>		<span class="cm">/* Current grace period. */</span>
	<span class="n">u8</span> <span class="n">gpcpu</span><span class="p">;</span>		<span class="cm">/* Last grace period blocked by the CPU. */</span>
	<span class="n">u8</span> <span class="n">completed</span><span class="p">;</span>		<span class="cm">/* Last grace period completed. */</span>
				<span class="cm">/*  If all three are equal, RCU is idle. */</span>
<span class="cp">#ifdef CONFIG_RCU_BOOST</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">boost_time</span><span class="p">;</span> <span class="cm">/* When to start boosting (jiffies) */</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_BOOST */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_RCU_TRACE</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n_grace_periods</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_RCU_BOOST</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n_tasks_boosted</span><span class="p">;</span>
				<span class="cm">/* Total number of tasks boosted. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n_exp_boosts</span><span class="p">;</span>
				<span class="cm">/* Number of tasks boosted for expedited GP. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n_normal_boosts</span><span class="p">;</span>
				<span class="cm">/* Number of tasks boosted for normal GP. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n_balk_blkd_tasks</span><span class="p">;</span>
				<span class="cm">/* Refused to boost: no blocked tasks. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n_balk_exp_gp_tasks</span><span class="p">;</span>
				<span class="cm">/* Refused to boost: nothing blocking GP. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n_balk_boost_tasks</span><span class="p">;</span>
				<span class="cm">/* Refused to boost: already boosting. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n_balk_notyet</span><span class="p">;</span>
				<span class="cm">/* Refused to boost: not yet time. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n_balk_nos</span><span class="p">;</span>
				<span class="cm">/* Refused to boost: not sure why, though. */</span>
				<span class="cm">/*  This can happen due to race conditions. */</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_BOOST */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_TRACE */</span><span class="cp"></span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_preempt_ctrlblk</span> <span class="n">rcu_preempt_ctrlblk</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">rcb</span><span class="p">.</span><span class="n">donetail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">rcb</span><span class="p">.</span><span class="n">rcucblist</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rcb</span><span class="p">.</span><span class="n">curtail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">rcb</span><span class="p">.</span><span class="n">rcucblist</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nexttail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">rcb</span><span class="p">.</span><span class="n">rcucblist</span><span class="p">,</span>
	<span class="p">.</span><span class="n">blkd_tasks</span> <span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">blkd_tasks</span><span class="p">),</span>
	<span class="n">RCU_TRACE</span><span class="p">(.</span><span class="n">rcb</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;rcu_preempt&quot;</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">rcu_read_unlock_special</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rcu_preempted_readers_exp</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">rcu_report_exp_done</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if the CPU has not yet responded to the current grace period.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_cpu_blocking_cur_gp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gpcpu</span> <span class="o">!=</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gpnum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check for a running RCU reader.  Because there is only one CPU,</span>
<span class="cm"> * there can be but one running RCU reader at a time.  ;-)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if there are no running readers.  Returns a positive</span>
<span class="cm"> * number if there is at least one reader within its RCU read-side</span>
<span class="cm"> * critical section.  Returns a negative number if an outermost reader</span>
<span class="cm"> * is in the midst of exiting from its RCU read-side critical section</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if there are no running readers.  Returns a positive</span>
<span class="cm"> * number if there is at least one reader within its RCU read-side</span>
<span class="cm"> * critical section.  Returns a negative number if an outermost reader</span>
<span class="cm"> * is in the midst of exiting from its RCU read-side critical section.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_preempt_running_reader</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">rcu_read_lock_nesting</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check for preempted RCU readers blocking any grace period.</span>
<span class="cm"> * If the caller needs a reliable answer, it must disable hard irqs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_preempt_blocked_readers_any</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">blkd_tasks</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check for preempted RCU readers blocking the current grace period.</span>
<span class="cm"> * If the caller needs a reliable answer, it must disable hard irqs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_preempt_blocked_readers_cgp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gp_tasks</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if another preemptible-RCU grace period is needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_preempt_needs_another_gp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">rcb</span><span class="p">.</span><span class="n">curtail</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if a preemptible-RCU grace period is in progress.</span>
<span class="cm"> * The caller must disable hardirqs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_preempt_gp_in_progress</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">completed</span> <span class="o">!=</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gpnum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Advance a -&gt;blkd_tasks-list pointer to the next entry, instead</span>
<span class="cm"> * returning NULL if at the end of the list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="nf">rcu_next_node_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>

	<span class="n">np</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_node_entry</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">blkd_tasks</span><span class="p">)</span>
		<span class="n">np</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">np</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_RCU_TRACE</span>

<span class="cp">#ifdef CONFIG_RCU_BOOST</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">rcu_initiate_boost_trace</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_BOOST */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Dump additional statistice for TINY_PREEMPT_RCU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">show_tiny_preempt_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;rcu_preempt: qlen=%ld gp=%lu g%u/p%u/c%u tasks=%c%c%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">rcb</span><span class="p">.</span><span class="n">qlen</span><span class="p">,</span>
		   <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_grace_periods</span><span class="p">,</span>
		   <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gpnum</span><span class="p">,</span>
		   <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gpcpu</span><span class="p">,</span>
		   <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">completed</span><span class="p">,</span>
		   <span class="s">&quot;T.&quot;</span><span class="p">[</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">blkd_tasks</span><span class="p">)],</span>
		   <span class="s">&quot;N.&quot;</span><span class="p">[</span><span class="o">!</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gp_tasks</span><span class="p">],</span>
		   <span class="s">&quot;E.&quot;</span><span class="p">[</span><span class="o">!</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">exp_tasks</span><span class="p">]);</span>
<span class="cp">#ifdef CONFIG_RCU_BOOST</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%sttb=%c ntb=%lu neb=%lu nnb=%lu j=%04x bt=%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="s">&quot;             &quot;</span><span class="p">,</span>
		   <span class="s">&quot;B.&quot;</span><span class="p">[</span><span class="o">!</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">boost_tasks</span><span class="p">],</span>
		   <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_tasks_boosted</span><span class="p">,</span>
		   <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_exp_boosts</span><span class="p">,</span>
		   <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_normal_boosts</span><span class="p">,</span>
		   <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">jiffies</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">),</span>
		   <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">boost_time</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s: nt=%lu egt=%lu bt=%lu ny=%lu nos=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="s">&quot;             balk&quot;</span><span class="p">,</span>
		   <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_balk_blkd_tasks</span><span class="p">,</span>
		   <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_balk_exp_gp_tasks</span><span class="p">,</span>
		   <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_balk_boost_tasks</span><span class="p">,</span>
		   <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_balk_notyet</span><span class="p">,</span>
		   <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_balk_nos</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_BOOST */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_TRACE */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_RCU_BOOST</span>

<span class="cp">#include &quot;rtmutex_common.h&quot;</span>

<span class="cp">#define RCU_BOOST_PRIO CONFIG_RCU_BOOST_PRIO</span>

<span class="cm">/* Controls for rcu_kthread() kthread. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">rcu_kthread_task</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">rcu_kthread_wq</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">have_rcu_kthread_work</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Carry out RCU priority boosting on the task indicated by -&gt;boost_tasks,</span>
<span class="cm"> * and advance -&gt;boost_tasks to the next task in the -&gt;blkd_tasks list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_boost</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_mutex</span> <span class="n">mtx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">boost_tasks</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">exp_tasks</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* Nothing to boost. */</span>

	<span class="n">raw_local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Recheck with irqs disabled: all tasks in need of boosting</span>
<span class="cm">	 * might exit their RCU read-side critical sections on their own</span>
<span class="cm">	 * if we are preempted just before disabling irqs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">boost_tasks</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">exp_tasks</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Preferentially boost tasks blocking expedited grace periods.</span>
<span class="cm">	 * This cannot starve the normal grace periods because a second</span>
<span class="cm">	 * expedited grace period must boost all blocked tasks, including</span>
<span class="cm">	 * those blocking the pre-existing normal grace period.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">exp_tasks</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tb</span> <span class="o">=</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">exp_tasks</span><span class="p">;</span>
		<span class="n">RCU_TRACE</span><span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_exp_boosts</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tb</span> <span class="o">=</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">boost_tasks</span><span class="p">;</span>
		<span class="n">RCU_TRACE</span><span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_normal_boosts</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">RCU_TRACE</span><span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_tasks_boosted</span><span class="o">++</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We boost task t by manufacturing an rt_mutex that appears to</span>
<span class="cm">	 * be held by task t.  We leave a pointer to that rt_mutex where</span>
<span class="cm">	 * task t can find it, and task t will release the mutex when it</span>
<span class="cm">	 * exits its outermost RCU read-side critical section.  Then</span>
<span class="cm">	 * simply acquiring this artificial rt_mutex will boost task</span>
<span class="cm">	 * t&#39;s priority.  (Thanks to tglx for suggesting this approach!)</span>
<span class="cm">	 */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">rcu_node_entry</span><span class="p">);</span>
	<span class="n">rt_mutex_init_proxy_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_boost_mutex</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mtx</span><span class="p">;</span>
	<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">rt_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">rt_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>  <span class="cm">/* Keep lockdep happy. */</span>

	<span class="k">return</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">boost_tasks</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span>
	       <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">exp_tasks</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check to see if it is now time to start boosting RCU readers blocking</span>
<span class="cm"> * the current grace period, and, if so, tell the rcu_kthread_task to</span>
<span class="cm"> * start boosting them.  If there is an expedited boost in progress,</span>
<span class="cm"> * we wait for it to complete.</span>
<span class="cm"> *</span>
<span class="cm"> * If there are no blocked readers blocking the current grace period,</span>
<span class="cm"> * return 0 to let the caller know, otherwise return 1.  Note that this</span>
<span class="cm"> * return value is independent of whether or not boosting was done.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_initiate_boost</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcu_preempt_blocked_readers_cgp</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
	    <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">exp_tasks</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">RCU_TRACE</span><span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_balk_exp_gp_tasks</span><span class="o">++</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">exp_tasks</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gp_tasks</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	     <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">boost_tasks</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	     <span class="n">ULONG_CMP_GE</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">boost_time</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">exp_tasks</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">boost_tasks</span> <span class="o">=</span>
				<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gp_tasks</span><span class="p">;</span>
		<span class="n">invoke_rcu_callbacks</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">RCU_TRACE</span><span class="p">(</span><span class="n">rcu_initiate_boost_trace</span><span class="p">());</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define RCU_BOOST_DELAY_JIFFIES DIV_ROUND_UP(CONFIG_RCU_BOOST_DELAY * HZ, 1000)</span>

<span class="cm">/*</span>
<span class="cm"> * Do priority-boost accounting for the start of a new grace period.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_preempt_boost_start_gp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">boost_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">RCU_BOOST_DELAY_JIFFIES</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* #ifdef CONFIG_RCU_BOOST */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * If there is no RCU priority boosting, we don&#39;t initiate boosting,</span>
<span class="cm"> * but we do indicate whether there are blocked readers blocking the</span>
<span class="cm"> * current grace period.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_initiate_boost</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rcu_preempt_blocked_readers_cgp</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If there is no RCU priority boosting, nothing to do at grace-period start.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_preempt_boost_start_gp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* else #ifdef CONFIG_RCU_BOOST */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Record a preemptible-RCU quiescent state for the specified CPU.  Note</span>
<span class="cm"> * that this just means that the task currently running on the CPU is</span>
<span class="cm"> * in a quiescent state.  There might be any number of tasks blocked</span>
<span class="cm"> * while in an RCU read-side critical section.</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike the other rcu_*_qs() functions, callers to this function</span>
<span class="cm"> * must disable irqs in order to protect the assignment to</span>
<span class="cm"> * -&gt;rcu_read_unlock_special.</span>
<span class="cm"> *</span>
<span class="cm"> * Because this is a single-CPU implementation, the only way a grace</span>
<span class="cm"> * period can end is if the CPU is in a quiescent state.  The reason is</span>
<span class="cm"> * that a blocked preemptible-RCU reader can exit its critical section</span>
<span class="cm"> * only if the CPU is running it at the time.  Therefore, when the</span>
<span class="cm"> * last task blocking the current grace period exits its RCU read-side</span>
<span class="cm"> * critical section, neither the CPU nor blocked tasks will be stopping</span>
<span class="cm"> * the current grace period.  (In contrast, SMP implementations</span>
<span class="cm"> * might have CPUs running in RCU read-side critical sections that</span>
<span class="cm"> * block later grace periods -- but this is not possible given only</span>
<span class="cm"> * one CPU.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_preempt_cpu_qs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Record both CPU and task as having responded to current GP. */</span>
	<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gpcpu</span> <span class="o">=</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gpnum</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">rcu_read_unlock_special</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RCU_READ_UNLOCK_NEED_QS</span><span class="p">;</span>

	<span class="cm">/* If there is no GP then there is nothing more to do.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcu_preempt_gp_in_progress</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check up on boosting.  If there are readers blocking the</span>
<span class="cm">	 * current grace period, leave.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_initiate_boost</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Advance callbacks. */</span>
	<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">completed</span> <span class="o">=</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gpnum</span><span class="p">;</span>
	<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">rcb</span><span class="p">.</span><span class="n">donetail</span> <span class="o">=</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">rcb</span><span class="p">.</span><span class="n">curtail</span><span class="p">;</span>
	<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">rcb</span><span class="p">.</span><span class="n">curtail</span> <span class="o">=</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">nexttail</span><span class="p">;</span>

	<span class="cm">/* If there are no blocked readers, next GP is done instantly. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcu_preempt_blocked_readers_any</span><span class="p">())</span>
		<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">rcb</span><span class="p">.</span><span class="n">donetail</span> <span class="o">=</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">nexttail</span><span class="p">;</span>

	<span class="cm">/* If there are done callbacks, cause them to be invoked. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">rcb</span><span class="p">.</span><span class="n">donetail</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">invoke_rcu_callbacks</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start a new RCU grace period if warranted.  Hard irqs must be disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_preempt_start_gp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcu_preempt_gp_in_progress</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">rcu_preempt_needs_another_gp</span><span class="p">())</span> <span class="p">{</span>

		<span class="cm">/* Official start of GP. */</span>
		<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gpnum</span><span class="o">++</span><span class="p">;</span>
		<span class="n">RCU_TRACE</span><span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_grace_periods</span><span class="o">++</span><span class="p">);</span>

		<span class="cm">/* Any blocked RCU readers block new GP. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcu_preempt_blocked_readers_any</span><span class="p">())</span>
			<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gp_tasks</span> <span class="o">=</span>
				<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">blkd_tasks</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

		<span class="cm">/* Set up for RCU priority boosting. */</span>
		<span class="n">rcu_preempt_boost_start_gp</span><span class="p">();</span>

		<span class="cm">/* If there is no running reader, CPU is done with GP. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcu_preempt_running_reader</span><span class="p">())</span>
			<span class="n">rcu_preempt_cpu_qs</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We have entered the scheduler, and the current task might soon be</span>
<span class="cm"> * context-switched away from.  If this task is in an RCU read-side</span>
<span class="cm"> * critical section, we will no longer be able to rely on the CPU to</span>
<span class="cm"> * record that fact, so we enqueue the task on the blkd_tasks list.</span>
<span class="cm"> * If the task started after the current grace period began, as recorded</span>
<span class="cm"> * by -&gt;gpcpu, we enqueue at the beginning of the list.  Otherwise</span>
<span class="cm"> * before the element referenced by -&gt;gp_tasks (or at the tail if</span>
<span class="cm"> * -&gt;gp_tasks is NULL) and point -&gt;gp_tasks at the newly added element.</span>
<span class="cm"> * The task will dequeue itself when it exits the outermost enclosing</span>
<span class="cm"> * RCU read-side critical section.  Therefore, the current grace period</span>
<span class="cm"> * cannot be permitted to complete until the -&gt;gp_tasks pointer becomes</span>
<span class="cm"> * NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must disable preemption.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rcu_preempt_note_context_switch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span> <span class="cm">/* must exclude scheduler_tick(). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_preempt_running_reader</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_read_unlock_special</span> <span class="o">&amp;</span> <span class="n">RCU_READ_UNLOCK_BLOCKED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Possibly blocking in an RCU read-side critical section. */</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_read_unlock_special</span> <span class="o">|=</span> <span class="n">RCU_READ_UNLOCK_BLOCKED</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If this CPU has already checked in, then this task</span>
<span class="cm">		 * will hold up the next grace period rather than the</span>
<span class="cm">		 * current grace period.  Queue the task accordingly.</span>
<span class="cm">		 * If the task is queued for the current grace period</span>
<span class="cm">		 * (i.e., this CPU has not yet passed through a quiescent</span>
<span class="cm">		 * state for the current grace period), then as long</span>
<span class="cm">		 * as that task remains queued, the current grace period</span>
<span class="cm">		 * cannot end.</span>
<span class="cm">		 */</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_node_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">blkd_tasks</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcu_cpu_blocking_cur_gp</span><span class="p">())</span>
			<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gp_tasks</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_node_entry</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rcu_preempt_running_reader</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		   <span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_read_unlock_special</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Complete exit from RCU read-side critical section on</span>
<span class="cm">		 * behalf of preempted instance of __rcu_read_unlock().</span>
<span class="cm">		 */</span>
		<span class="n">rcu_read_unlock_special</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Either we were not in an RCU read-side critical section to</span>
<span class="cm">	 * begin with, or we have now recorded that critical section</span>
<span class="cm">	 * globally.  Either way, we can now note a quiescent state</span>
<span class="cm">	 * for this CPU.  Again, if we were in an RCU read-side critical</span>
<span class="cm">	 * section, and if that critical section was blocking the current</span>
<span class="cm">	 * grace period, then the fact that the task has been enqueued</span>
<span class="cm">	 * means that current grace period continues to be blocked.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_preempt_cpu_qs</span><span class="p">();</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Tiny-preemptible RCU implementation for rcu_read_lock().</span>
<span class="cm"> * Just increment -&gt;rcu_read_lock_nesting, shared state will be updated</span>
<span class="cm"> * if we block.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__rcu_read_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">rcu_read_lock_nesting</span><span class="o">++</span><span class="p">;</span>
	<span class="n">barrier</span><span class="p">();</span>  <span class="cm">/* needed if we ever invoke rcu_read_lock in rcutiny.c */</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__rcu_read_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Handle special cases during rcu_read_unlock(), such as needing to</span>
<span class="cm"> * notify RCU core processing or task having blocked during the RCU</span>
<span class="cm"> * read-side critical section.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">rcu_read_unlock_special</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">empty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">empty_exp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_RCU_BOOST</span>
	<span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">rbmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_BOOST */</span><span class="cp"></span>
	<span class="kt">int</span> <span class="n">special</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * NMI handlers cannot block and cannot safely manipulate state.</span>
<span class="cm">	 * They therefore cannot possibly be special, so just leave.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_nmi</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If RCU core is waiting for this CPU to exit critical section,</span>
<span class="cm">	 * let it know that we have done so.</span>
<span class="cm">	 */</span>
	<span class="n">special</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_read_unlock_special</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">special</span> <span class="o">&amp;</span> <span class="n">RCU_READ_UNLOCK_NEED_QS</span><span class="p">)</span>
		<span class="n">rcu_preempt_cpu_qs</span><span class="p">();</span>

	<span class="cm">/* Hardware IRQ handlers cannot block. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_irq</span><span class="p">()</span> <span class="o">||</span> <span class="n">in_serving_softirq</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clean up if blocked during RCU read-side critical section. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">special</span> <span class="o">&amp;</span> <span class="n">RCU_READ_UNLOCK_BLOCKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_read_unlock_special</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RCU_READ_UNLOCK_BLOCKED</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Remove this task from the -&gt;blkd_tasks list and adjust</span>
<span class="cm">		 * any pointers that might have been referencing it.</span>
<span class="cm">		 */</span>
		<span class="n">empty</span> <span class="o">=</span> <span class="o">!</span><span class="n">rcu_preempt_blocked_readers_cgp</span><span class="p">();</span>
		<span class="n">empty_exp</span> <span class="o">=</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">exp_tasks</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">np</span> <span class="o">=</span> <span class="n">rcu_next_node_entry</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_node_entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_node_entry</span> <span class="o">==</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gp_tasks</span><span class="p">)</span>
			<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gp_tasks</span> <span class="o">=</span> <span class="n">np</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_node_entry</span> <span class="o">==</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">exp_tasks</span><span class="p">)</span>
			<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">exp_tasks</span> <span class="o">=</span> <span class="n">np</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_RCU_BOOST</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_node_entry</span> <span class="o">==</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">boost_tasks</span><span class="p">)</span>
			<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">boost_tasks</span> <span class="o">=</span> <span class="n">np</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_BOOST */</span><span class="cp"></span>

		<span class="cm">/*</span>
<span class="cm">		 * If this was the last task on the current list, and if</span>
<span class="cm">		 * we aren&#39;t waiting on the CPU, report the quiescent state</span>
<span class="cm">		 * and start a new grace period if needed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">empty</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rcu_preempt_blocked_readers_cgp</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">rcu_preempt_cpu_qs</span><span class="p">();</span>
			<span class="n">rcu_preempt_start_gp</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If this was the last task on the expedited lists,</span>
<span class="cm">		 * then we need wake up the waiting task.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">empty_exp</span> <span class="o">&amp;&amp;</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">exp_tasks</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">rcu_report_exp_done</span><span class="p">();</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_RCU_BOOST</span>
	<span class="cm">/* Unboost self if was boosted. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_boost_mutex</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rbmp</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_boost_mutex</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_boost_mutex</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rt_mutex_unlock</span><span class="p">(</span><span class="n">rbmp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_BOOST */</span><span class="cp"></span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Tiny-preemptible RCU implementation for rcu_read_unlock().</span>
<span class="cm"> * Decrement -&gt;rcu_read_lock_nesting.  If the result is zero (outermost</span>
<span class="cm"> * rcu_read_unlock()) and -&gt;rcu_read_unlock_special is non-zero, then</span>
<span class="cm"> * invoke rcu_read_unlock_special() to clean up after a context switch</span>
<span class="cm"> * in an RCU read-side critical section and other special cases.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__rcu_read_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="n">barrier</span><span class="p">();</span>  <span class="cm">/* needed if we ever invoke rcu_read_unlock in rcutiny.c */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_read_lock_nesting</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">--</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_read_lock_nesting</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_read_lock_nesting</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
		<span class="n">barrier</span><span class="p">();</span>  <span class="cm">/* assign before -&gt;rcu_read_unlock_special load */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_read_unlock_special</span><span class="p">)))</span>
			<span class="n">rcu_read_unlock_special</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="n">barrier</span><span class="p">();</span>  <span class="cm">/* -&gt;rcu_read_unlock_special load before assign */</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_read_lock_nesting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_PROVE_LOCKING</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">rrln</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_read_lock_nesting</span><span class="p">);</span>

		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">rrln</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rrln</span> <span class="o">&gt;</span> <span class="n">INT_MIN</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_PROVE_LOCKING */</span><span class="cp"></span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__rcu_read_unlock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Check for a quiescent state from the current CPU.  When a task blocks,</span>
<span class="cm"> * the task is recorded in the rcu_preempt_ctrlblk structure, which is</span>
<span class="cm"> * checked elsewhere.  This is called from the scheduling-clock interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must disable hard irqs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_preempt_check_callbacks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_preempt_gp_in_progress</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">rcu_preempt_running_reader</span><span class="p">()</span> <span class="o">||</span>
	     <span class="o">!</span><span class="n">rcu_cpu_blocking_cur_gp</span><span class="p">()))</span>
		<span class="n">rcu_preempt_cpu_qs</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">rcb</span><span class="p">.</span><span class="n">rcucblist</span> <span class="o">!=</span>
	    <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">rcb</span><span class="p">.</span><span class="n">donetail</span><span class="p">)</span>
		<span class="n">invoke_rcu_callbacks</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_preempt_gp_in_progress</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
	    <span class="n">rcu_cpu_blocking_cur_gp</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
	    <span class="n">rcu_preempt_running_reader</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">rcu_read_unlock_special</span> <span class="o">|=</span> <span class="n">RCU_READ_UNLOCK_NEED_QS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * TINY_PREEMPT_RCU has an extra callback-list tail pointer to</span>
<span class="cm"> * update, so this is invoked from rcu_process_callbacks() to</span>
<span class="cm"> * handle that case.  Of course, it is invoked for all flavors of</span>
<span class="cm"> * RCU, but RCU callbacks can appear only on one of the lists, and</span>
<span class="cm"> * neither -&gt;nexttail nor -&gt;donetail can possibly be NULL, so there</span>
<span class="cm"> * is no need for an explicit check.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_preempt_remove_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_ctrlblk</span> <span class="o">*</span><span class="n">rcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">nexttail</span> <span class="o">==</span> <span class="n">rcp</span><span class="o">-&gt;</span><span class="n">donetail</span><span class="p">)</span>
		<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">nexttail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rcp</span><span class="o">-&gt;</span><span class="n">rcucblist</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process callbacks for preemptible RCU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_preempt_process_callbacks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__rcu_process_callbacks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">rcb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Queue a preemptible -RCU callback for invocation after a grace period.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">call_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rcu</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">debug_rcu_head_queue</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
	<span class="n">head</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
	<span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="o">*</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">nexttail</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">nexttail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">RCU_TRACE</span><span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">rcb</span><span class="p">.</span><span class="n">qlen</span><span class="o">++</span><span class="p">);</span>
	<span class="n">rcu_preempt_start_gp</span><span class="p">();</span>  <span class="cm">/* checks to see if GP needed. */</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">call_rcu</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * synchronize_rcu - wait until a grace period has elapsed.</span>
<span class="cm"> *</span>
<span class="cm"> * Control will return to the caller some time after a full grace</span>
<span class="cm"> * period has elapsed, in other words after all currently executing RCU</span>
<span class="cm"> * read-side critical sections have completed.  RCU read-side critical</span>
<span class="cm"> * sections are delimited by rcu_read_lock() and rcu_read_unlock(),</span>
<span class="cm"> * and may be nested.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">synchronize_rcu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_lockdep_assert</span><span class="p">(</span><span class="o">!</span><span class="n">lock_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_bh_lock_map</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="o">!</span><span class="n">lock_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_lock_map</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="o">!</span><span class="n">lock_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_sched_lock_map</span><span class="p">),</span>
			   <span class="s">&quot;Illegal synchronize_rcu() in RCU read-side critical section&quot;</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcu_scheduler_active</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_DEBUG_LOCK_ALLOC */</span><span class="cp"></span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">rcu_preempt_running_reader</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcu_preempt_blocked_readers_any</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Once we get past the fastpath checks, same code as rcu_barrier(). */</span>
	<span class="n">rcu_barrier</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">synchronize_rcu</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">sync_rcu_preempt_exp_wq</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sync_rcu_preempt_exp_count</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">sync_rcu_preempt_exp_mutex</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Return non-zero if there are any tasks in RCU read-side critical</span>
<span class="cm"> * sections blocking the current preemptible-RCU expedited grace period.</span>
<span class="cm"> * If there is no preemptible-RCU expedited grace period currently in</span>
<span class="cm"> * progress, returns zero unconditionally.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_preempted_readers_exp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">exp_tasks</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Report the exit from RCU read-side critical section for the last task</span>
<span class="cm"> * that queued itself during or before the current expedited preemptible-RCU</span>
<span class="cm"> * grace period.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_report_exp_done</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_rcu_preempt_exp_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for an rcu-preempt grace period, but expedite it.  The basic idea</span>
<span class="cm"> * is to rely in the fact that there is but one CPU, and that it is</span>
<span class="cm"> * illegal for a task to invoke synchronize_rcu_expedited() while in a</span>
<span class="cm"> * preemptible-RCU read-side critical section.  Therefore, any such</span>
<span class="cm"> * critical sections must correspond to blocked tasks, which must therefore</span>
<span class="cm"> * be on the -&gt;blkd_tasks list.  So just record the current head of the</span>
<span class="cm"> * list in the -&gt;exp_tasks pointer, and wait for all tasks including and</span>
<span class="cm"> * after the task pointed to by -&gt;exp_tasks to drain.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">synchronize_rcu_expedited</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_preempt_ctrlblk</span> <span class="o">*</span><span class="n">rpcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">snap</span><span class="p">;</span>

	<span class="n">barrier</span><span class="p">();</span> <span class="cm">/* ensure prior action seen before grace period. */</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">rcu_preempt_running_reader</span><span class="p">());</span>

	<span class="cm">/*</span>
<span class="cm">	 * Acquire lock so that there is only one preemptible RCU grace</span>
<span class="cm">	 * period in flight.  Of course, if someone does the expedited</span>
<span class="cm">	 * grace period for us while we are acquiring the lock, just leave.</span>
<span class="cm">	 */</span>
	<span class="n">snap</span> <span class="o">=</span> <span class="n">sync_rcu_preempt_exp_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_rcu_preempt_exp_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ULONG_CMP_LT</span><span class="p">(</span><span class="n">snap</span><span class="p">,</span> <span class="n">sync_rcu_preempt_exp_count</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock_mb_ret</span><span class="p">;</span> <span class="cm">/* Others did our work for us. */</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * All RCU readers have to already be on blkd_tasks because</span>
<span class="cm">	 * we cannot legally be executing in an RCU read-side critical</span>
<span class="cm">	 * section.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Snapshot current head of -&gt;blkd_tasks list. */</span>
	<span class="n">rpcp</span><span class="o">-&gt;</span><span class="n">exp_tasks</span> <span class="o">=</span> <span class="n">rpcp</span><span class="o">-&gt;</span><span class="n">blkd_tasks</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rpcp</span><span class="o">-&gt;</span><span class="n">exp_tasks</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rpcp</span><span class="o">-&gt;</span><span class="n">blkd_tasks</span><span class="p">)</span>
		<span class="n">rpcp</span><span class="o">-&gt;</span><span class="n">exp_tasks</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Wait for tail of -&gt;blkd_tasks list to drain. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcu_preempted_readers_exp</span><span class="p">())</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">rcu_initiate_boost</span><span class="p">();</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">sync_rcu_preempt_exp_wq</span><span class="p">,</span>
			   <span class="o">!</span><span class="n">rcu_preempted_readers_exp</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="cm">/* Clean up and exit. */</span>
	<span class="n">barrier</span><span class="p">();</span> <span class="cm">/* ensure expedited GP seen before counter increment. */</span>
	<span class="n">sync_rcu_preempt_exp_count</span><span class="o">++</span><span class="p">;</span>
<span class="nl">unlock_mb_ret:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_rcu_preempt_exp_mutex</span><span class="p">);</span>
	<span class="n">barrier</span><span class="p">();</span> <span class="cm">/* ensure subsequent action seen after grace period. */</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">synchronize_rcu_expedited</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Does preemptible RCU need the CPU to stay out of dynticks mode?</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">rcu_preempt_needs_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcu_preempt_running_reader</span><span class="p">())</span>
		<span class="n">rcu_preempt_cpu_qs</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">rcb</span><span class="p">.</span><span class="n">rcucblist</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* #ifdef CONFIG_TINY_PREEMPT_RCU */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_RCU_TRACE</span>

<span class="cm">/*</span>
<span class="cm"> * Because preemptible RCU does not exist, it is not necessary to</span>
<span class="cm"> * dump out its statistics.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">show_tiny_preempt_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_TRACE */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Because preemptible RCU does not exist, it never has any callbacks</span>
<span class="cm"> * to check.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_preempt_check_callbacks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Because preemptible RCU does not exist, it never has any callbacks</span>
<span class="cm"> * to remove.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_preempt_remove_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_ctrlblk</span> <span class="o">*</span><span class="n">rcp</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Because preemptible RCU does not exist, it never has any callbacks</span>
<span class="cm"> * to process.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_preempt_process_callbacks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* #else #ifdef CONFIG_TINY_PREEMPT_RCU */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_RCU_BOOST</span>

<span class="cm">/*</span>
<span class="cm"> * Wake up rcu_kthread() to process callbacks now eligible for invocation</span>
<span class="cm"> * or to boost readers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">invoke_rcu_callbacks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">have_rcu_kthread_work</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_kthread_task</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_kthread_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_RCU_TRACE</span>

<span class="cm">/*</span>
<span class="cm"> * Is the current CPU running the RCU-callbacks kthread?</span>
<span class="cm"> * Caller must have preemption disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">rcu_is_callbacks_kthread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rcu_kthread_task</span> <span class="o">==</span> <span class="n">current</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_TRACE */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * This kthread invokes RCU callbacks whose grace periods have</span>
<span class="cm"> * elapsed.  It is awakened as needed, and takes the place of the</span>
<span class="cm"> * RCU_SOFTIRQ that is used for this purpose when boosting is disabled.</span>
<span class="cm"> * This is a kthread, but it is never stopped, at least not until</span>
<span class="cm"> * the system goes down.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_kthread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">work</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">morework</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">rcu_kthread_wq</span><span class="p">,</span>
					 <span class="n">have_rcu_kthread_work</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">morework</span> <span class="o">=</span> <span class="n">rcu_boost</span><span class="p">();</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">work</span> <span class="o">=</span> <span class="n">have_rcu_kthread_work</span><span class="p">;</span>
		<span class="n">have_rcu_kthread_work</span> <span class="o">=</span> <span class="n">morework</span><span class="p">;</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="p">)</span>
			<span class="n">rcu_process_callbacks</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
		<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/* Leave CPU for others. */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* Not reached, but needed to shut gcc up. */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Spawn the kthread that invokes RCU callbacks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">rcu_spawn_kthreads</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_param</span> <span class="n">sp</span><span class="p">;</span>

	<span class="n">rcu_kthread_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">rcu_kthread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;rcu_kthread&quot;</span><span class="p">);</span>
	<span class="n">sp</span><span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="n">RCU_BOOST_PRIO</span><span class="p">;</span>
	<span class="n">sched_setscheduler_nocheck</span><span class="p">(</span><span class="n">rcu_kthread_task</span><span class="p">,</span> <span class="n">SCHED_FIFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_initcall</span><span class="p">(</span><span class="n">rcu_spawn_kthreads</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* #ifdef CONFIG_RCU_BOOST */</span><span class="cp"></span>

<span class="cm">/* Hold off callback invocation until early_initcall() time. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">rcu_scheduler_fully_active</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Start up softirq processing of callbacks.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">invoke_rcu_callbacks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_scheduler_fully_active</span><span class="p">)</span>
		<span class="n">raise_softirq</span><span class="p">(</span><span class="n">RCU_SOFTIRQ</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_RCU_TRACE</span>

<span class="cm">/*</span>
<span class="cm"> * There is no callback kthread, so this thread is never it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">rcu_is_callbacks_kthread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_TRACE */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">rcu_scheduler_really_started</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_scheduler_fully_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">open_softirq</span><span class="p">(</span><span class="n">RCU_SOFTIRQ</span><span class="p">,</span> <span class="n">rcu_process_callbacks</span><span class="p">);</span>
	<span class="n">raise_softirq</span><span class="p">(</span><span class="n">RCU_SOFTIRQ</span><span class="p">);</span>  <span class="cm">/* Invoke any callbacks from early boot. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_initcall</span><span class="p">(</span><span class="n">rcu_scheduler_really_started</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* #else #ifdef CONFIG_RCU_BOOST */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * During boot, we forgive RCU lockdep issues.  After this function is</span>
<span class="cm"> * invoked, we start taking RCU lockdep issues seriously.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">rcu_scheduler_starting</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">nr_context_switches</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">rcu_scheduler_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_DEBUG_LOCK_ALLOC */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_RCU_TRACE</span>

<span class="cp">#ifdef CONFIG_RCU_BOOST</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_initiate_boost_trace</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">blkd_tasks</span><span class="p">))</span>
		<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_balk_blkd_tasks</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">gp_tasks</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
		 <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">exp_tasks</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_balk_exp_gp_tasks</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">boost_tasks</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_balk_boost_tasks</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ULONG_CMP_GE</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">boost_time</span><span class="p">))</span>
		<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_balk_notyet</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rcu_preempt_ctrlblk</span><span class="p">.</span><span class="n">n_balk_nos</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_BOOST */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_trace_sub_qlen</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_ctrlblk</span> <span class="o">*</span><span class="n">rcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">rcp</span><span class="o">-&gt;</span><span class="n">qlen</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">raw_local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Dump statistics for TINY_RCU, such as they are.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">show_tiny_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">show_tiny_preempt_stats</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;rcu_sched: qlen: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rcu_sched_ctrlblk</span><span class="p">.</span><span class="n">qlen</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;rcu_bh: qlen: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rcu_bh_ctrlblk</span><span class="p">.</span><span class="n">qlen</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">show_tiny_stats_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">show_tiny_stats</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">show_tiny_stats_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">show_tiny_stats_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">rcudir</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">rcutiny_trace_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>

	<span class="n">rcudir</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;rcu&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcudir</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;rcudata&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">rcudir</span><span class="p">,</span>
				     <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">show_tiny_stats_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">free_out:</span>
	<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">rcudir</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">rcutiny_trace_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">rcudir</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">rcutiny_trace_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">rcutiny_trace_cleanup</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Paul E. McKenney&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Read-Copy Update tracing for tiny implementation&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_TRACE */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
