<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › events › core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Performance events core code:</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2008 Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="cm"> *  Copyright (C) 2008-2011 Red Hat, Inc., Ingo Molnar</span>
<span class="cm"> *  Copyright (C) 2008-2011 Red Hat, Inc., Peter Zijlstra &lt;pzijlstr@redhat.com&gt;</span>
<span class="cm"> *  Copyright  ©  2009 Paul Mackerras, IBM Corp. &lt;paulus@au1.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * For licensing details see kernel-base/COPYING</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/sysfs.h&gt;</span>
<span class="cp">#include &lt;linux/dcache.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/vmstat.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/rculist.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/anon_inodes.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/perf_event.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace_event.h&gt;</span>
<span class="cp">#include &lt;linux/hw_breakpoint.h&gt;</span>

<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#include &lt;asm/irq_regs.h&gt;</span>

<span class="k">struct</span> <span class="n">remote_function_call</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ret</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remote_function</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">remote_function_call</span> <span class="o">*</span><span class="n">tfc</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">tfc</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tfc</span><span class="o">-&gt;</span><span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">task_curr</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tfc</span><span class="o">-&gt;</span><span class="n">ret</span> <span class="o">=</span> <span class="n">tfc</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">tfc</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * task_function_call - call a function on the cpu on which a task runs</span>
<span class="cm"> * @p:		the task to evaluate</span>
<span class="cm"> * @func:	the function to be called</span>
<span class="cm"> * @info:	the function call argument</span>
<span class="cm"> *</span>
<span class="cm"> * Calls the function @func when the task is currently running. This might</span>
<span class="cm"> * be on the current CPU, which just calls the function directly</span>
<span class="cm"> *</span>
<span class="cm"> * returns: @func return value, or</span>
<span class="cm"> *	    -ESRCH  - when the process isn&#39;t running</span>
<span class="cm"> *	    -EAGAIN - when the process moved away</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">task_function_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">remote_function_call</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">p</span>	<span class="o">=</span> <span class="n">p</span><span class="p">,</span>
		<span class="p">.</span><span class="n">func</span>	<span class="o">=</span> <span class="n">func</span><span class="p">,</span>
		<span class="p">.</span><span class="n">info</span>	<span class="o">=</span> <span class="n">info</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ret</span>	<span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">,</span> <span class="cm">/* No such (running) process */</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_curr</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">remote_function</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">.</span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpu_function_call - call a function on the cpu</span>
<span class="cm"> * @func:	the function to be called</span>
<span class="cm"> * @info:	the function call argument</span>
<span class="cm"> *</span>
<span class="cm"> * Calls the function @func on the remote cpu.</span>
<span class="cm"> *</span>
<span class="cm"> * returns: @func return value or -ENXIO when the cpu is offline</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_function_call</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">remote_function_call</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">p</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">func</span>	<span class="o">=</span> <span class="n">func</span><span class="p">,</span>
		<span class="p">.</span><span class="n">info</span>	<span class="o">=</span> <span class="n">info</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ret</span>	<span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">,</span> <span class="cm">/* No such CPU */</span>
	<span class="p">};</span>

	<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">remote_function</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">.</span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PERF_FLAG_ALL (PERF_FLAG_FD_NO_GROUP |\</span>
<span class="cp">		       PERF_FLAG_FD_OUTPUT  |\</span>
<span class="cp">		       PERF_FLAG_PID_CGROUP)</span>

<span class="cm">/*</span>
<span class="cm"> * branch priv levels that need permission checks</span>
<span class="cm"> */</span>
<span class="cp">#define PERF_SAMPLE_BRANCH_PERM_PLM \</span>
<span class="cp">	(PERF_SAMPLE_BRANCH_KERNEL |\</span>
<span class="cp">	 PERF_SAMPLE_BRANCH_HV)</span>

<span class="k">enum</span> <span class="n">event_type_t</span> <span class="p">{</span>
	<span class="n">EVENT_FLEXIBLE</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">EVENT_PINNED</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
	<span class="n">EVENT_ALL</span> <span class="o">=</span> <span class="n">EVENT_FLEXIBLE</span> <span class="o">|</span> <span class="n">EVENT_PINNED</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * perf_sched_events : &gt;0 events exist</span>
<span class="cm"> * perf_cgroup_events: &gt;0 per-cpu cgroup events exist on this cpu</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">static_key_deferred</span> <span class="n">perf_sched_events</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">atomic_t</span><span class="p">,</span> <span class="n">perf_cgroup_events</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">atomic_t</span><span class="p">,</span> <span class="n">perf_branch_stack_events</span><span class="p">);</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">nr_mmap_events</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">nr_comm_events</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">nr_task_events</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">pmus</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">pmus_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">srcu_struct</span> <span class="n">pmus_srcu</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * perf event paranoia level:</span>
<span class="cm"> *  -1 - not paranoid at all</span>
<span class="cm"> *   0 - disallow raw tracepoint access for unpriv</span>
<span class="cm"> *   1 - disallow cpu events for unpriv</span>
<span class="cm"> *   2 - disallow kernel profiling for unpriv</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sysctl_perf_event_paranoid</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/* Minimum for 512 kiB + 1 user control page */</span>
<span class="kt">int</span> <span class="n">sysctl_perf_event_mlock</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">512</span> <span class="o">+</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">);</span> <span class="cm">/* &#39;free&#39; kiB per user */</span>

<span class="cm">/*</span>
<span class="cm"> * max perf event sample rate</span>
<span class="cm"> */</span>
<span class="cp">#define DEFAULT_MAX_SAMPLE_RATE 100000</span>
<span class="kt">int</span> <span class="n">sysctl_perf_event_sample_rate</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">DEFAULT_MAX_SAMPLE_RATE</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_samples_per_tick</span> <span class="n">__read_mostly</span> <span class="o">=</span>
	<span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">DEFAULT_MAX_SAMPLE_RATE</span><span class="p">,</span> <span class="n">HZ</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">perf_proc_update_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">proc_dointvec</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="o">!</span><span class="n">write</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">max_samples_per_tick</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">sysctl_perf_event_sample_rate</span><span class="p">,</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">atomic64_t</span> <span class="n">perf_event_id</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">cpu_ctx_sched_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">event_type_t</span> <span class="n">event_type</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">cpu_ctx_sched_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">event_type_t</span> <span class="n">event_type</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">update_context_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">perf_event_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ring_buffer_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">rb</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__weak</span> <span class="nf">perf_event_print_debug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>	<span class="p">{</span> <span class="p">}</span>

<span class="k">extern</span> <span class="n">__weak</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">perf_pmu_name</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="s">&quot;pmu&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">perf_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">local_clock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span>
<span class="nf">__get_cpu_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_ctx_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_ctx_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CGROUP_PERF</span>

<span class="cm">/*</span>
<span class="cm"> * Must ensure cgroup is pinned (css_get) before calling</span>
<span class="cm"> * this function. In other words, we cannot call this function</span>
<span class="cm"> * if there is no cgroup event for the current CPU context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">perf_cgroup</span> <span class="o">*</span>
<span class="nf">perf_cgroup_from_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">task_subsys_state</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">perf_subsys_id</span><span class="p">),</span>
			<span class="k">struct</span> <span class="n">perf_cgroup</span><span class="p">,</span> <span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">perf_cgroup_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span> <span class="o">=</span> <span class="n">__get_cpu_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp</span> <span class="o">||</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp</span> <span class="o">==</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">perf_tryget_cgroup</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">css_tryget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_put_cgroup</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">css_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_detach_cgroup</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">perf_put_cgroup</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_cgroup_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">perf_cgroup_event_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cgroup_info</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__update_cgrp_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cgroup_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">perf_clock</span><span class="p">();</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">+=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_cgrp_time_from_cpuctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cgroup</span> <span class="o">*</span><span class="n">cgrp_out</span> <span class="o">=</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cgrp_out</span><span class="p">)</span>
		<span class="n">__update_cgrp_time</span><span class="p">(</span><span class="n">cgrp_out</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_cgrp_time_from_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * ensure we access cgroup data only when needed and</span>
<span class="cm">	 * when we know the cgroup is pinned (css_get)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_cgroup_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cgrp</span> <span class="o">=</span> <span class="n">perf_cgroup_from_task</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Do not update time when cgroup is not active</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cgrp</span> <span class="o">==</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="p">)</span>
		<span class="n">__update_cgrp_time</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">perf_cgroup_set_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_cgroup_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * ctx-&gt;lock held by caller</span>
<span class="cm">	 * ensure we do not access cgroup data</span>
<span class="cm">	 * unless we have the cgroup pinned (css_get)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span> <span class="o">||</span> <span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_cgroups</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cgrp</span> <span class="o">=</span> <span class="n">perf_cgroup_from_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PERF_CGROUP_SWOUT	0x1 </span><span class="cm">/* cgroup switch out every event */</span><span class="cp"></span>
<span class="cp">#define PERF_CGROUP_SWIN	0x2 </span><span class="cm">/* cgroup switch in events based on task */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * reschedule events based on the cgroup constraint of task.</span>
<span class="cm"> *</span>
<span class="cm"> * mode SWOUT : schedule out everything</span>
<span class="cm"> * mode SWIN : schedule in based on cgroup for next</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">perf_cgroup_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * disable interrupts to avoid geting nr_cgroup</span>
<span class="cm">	 * changes via __perf_event_disable(). Also</span>
<span class="cm">	 * avoids preemption.</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we reschedule only in the presence of cgroup</span>
<span class="cm">	 * constrained events.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">pmu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmus</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpuctx</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * perf_cgroup_events says at least one</span>
<span class="cm">		 * context on this CPU has cgroup events.</span>
<span class="cm">		 *</span>
<span class="cm">		 * ctx-&gt;nr_cgroups reports the number of cgroup</span>
<span class="cm">		 * events for a context.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">nr_cgroups</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">perf_ctx_lock</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span><span class="p">);</span>
			<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">pmu</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">PERF_CGROUP_SWOUT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cpu_ctx_sched_out</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">EVENT_ALL</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * must not be done before ctxswout due</span>
<span class="cm">				 * to event_filter_match() in event_sched_out()</span>
<span class="cm">				 */</span>
				<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">cgrp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">PERF_CGROUP_SWIN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="p">);</span>
				<span class="cm">/* set cgrp before ctxsw in to</span>
<span class="cm">				 * allow event_filter_match() to not</span>
<span class="cm">				 * have to pass task around</span>
<span class="cm">				 */</span>
				<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">perf_cgroup_from_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
				<span class="n">cpu_ctx_sched_in</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">EVENT_ALL</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">pmu</span><span class="p">);</span>
			<span class="n">perf_ctx_unlock</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_cgroup_sched_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cgroup</span> <span class="o">*</span><span class="n">cgrp1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_cgroup</span> <span class="o">*</span><span class="n">cgrp2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we come here when we know perf_cgroup_events &gt; 0</span>
<span class="cm">	 */</span>
	<span class="n">cgrp1</span> <span class="o">=</span> <span class="n">perf_cgroup_from_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * next is NULL when called from perf_event_enable_on_exec()</span>
<span class="cm">	 * that will systematically cause a cgroup_switch()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span>
		<span class="n">cgrp2</span> <span class="o">=</span> <span class="n">perf_cgroup_from_task</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * only schedule out current cgroup events if we know</span>
<span class="cm">	 * that we are switching to a different cgroup. Otherwise,</span>
<span class="cm">	 * do no touch the cgroup events.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cgrp1</span> <span class="o">!=</span> <span class="n">cgrp2</span><span class="p">)</span>
		<span class="n">perf_cgroup_switch</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PERF_CGROUP_SWOUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_cgroup_sched_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cgroup</span> <span class="o">*</span><span class="n">cgrp1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_cgroup</span> <span class="o">*</span><span class="n">cgrp2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we come here when we know perf_cgroup_events &gt; 0</span>
<span class="cm">	 */</span>
	<span class="n">cgrp1</span> <span class="o">=</span> <span class="n">perf_cgroup_from_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="cm">/* prev can never be NULL */</span>
	<span class="n">cgrp2</span> <span class="o">=</span> <span class="n">perf_cgroup_from_task</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * only need to schedule in cgroup events if we are changing</span>
<span class="cm">	 * cgroup during ctxsw. Cgroup events were not scheduled</span>
<span class="cm">	 * out of ctxsw out if that was not the case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cgrp1</span> <span class="o">!=</span> <span class="n">cgrp2</span><span class="p">)</span>
		<span class="n">perf_cgroup_switch</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PERF_CGROUP_SWIN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">perf_cgroup_connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">perf_event_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">group_leader</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">fget_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

	<span class="n">css</span> <span class="o">=</span> <span class="n">cgroup_css_from_dir</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">perf_subsys_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">css</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cgrp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">css</span><span class="p">,</span> <span class="k">struct</span> <span class="n">perf_cgroup</span><span class="p">,</span> <span class="n">css</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">cgrp</span><span class="p">;</span>

	<span class="cm">/* must be done before we fput() the file */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">perf_tryget_cgroup</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * all events in a group must monitor</span>
<span class="cm">	 * the same cgroup because a task belongs</span>
<span class="cm">	 * to only one perf cgroup at a time</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group_leader</span> <span class="o">&amp;&amp;</span> <span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">cgrp</span> <span class="o">!=</span> <span class="n">cgrp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perf_detach_cgroup</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">fput_light</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">perf_cgroup_set_shadow_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">u64</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cgroup_info</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">shadow_ctx_time</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">perf_cgroup_defer_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * when the current task&#39;s perf cgroup does not match</span>
<span class="cm">	 * the event&#39;s, we need to remember to call the</span>
<span class="cm">	 * perf_mark_enable() function the first time a task with</span>
<span class="cm">	 * a matching perf cgroup is scheduled in.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_cgroup_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">perf_cgroup_match</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp_defer_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">perf_cgroup_mark_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">sub</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tstamp</span> <span class="o">=</span> <span class="n">perf_event_time</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp_defer_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">cgrp_defer_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_enabled</span> <span class="o">=</span> <span class="n">tstamp</span> <span class="o">-</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">total_time_enabled</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sub</span><span class="o">-&gt;</span><span class="n">tstamp_enabled</span> <span class="o">=</span> <span class="n">tstamp</span> <span class="o">-</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">total_time_enabled</span><span class="p">;</span>
			<span class="n">sub</span><span class="o">-&gt;</span><span class="n">cgrp_defer_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_CGROUP_PERF */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">perf_cgroup_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_detach_cgroup</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_cgroup_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">perf_cgroup_event_cgrp_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_cgrp_time_from_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_cgrp_time_from_cpuctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_cgroup_sched_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_cgroup_sched_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">perf_cgroup_connect</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">perf_event_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">group_leader</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">perf_cgroup_set_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">perf_cgroup_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">perf_cgroup_set_shadow_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">u64</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">perf_cgroup_event_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">perf_cgroup_defer_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">perf_cgroup_mark_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">perf_pmu_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_disable_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">count</span><span class="p">)</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_disable</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">perf_pmu_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_disable_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="p">(</span><span class="o">*</span><span class="n">count</span><span class="p">))</span>
		<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_enable</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">,</span> <span class="n">rotation_list</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * perf_pmu_rotate_start() and perf_rotate_context() are fully serialized</span>
<span class="cm"> * because they&#39;re strictly cpu affine and rotate_start is called with IRQs</span>
<span class="cm"> * disabled, while rotate_context is called from IRQ context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_pmu_rotate_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">rotation_list</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">rotation_list</span><span class="p">))</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">rotation_list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">)</span>
			<span class="n">put_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">)</span>
			<span class="n">put_task_struct</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
		<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">rcu_head</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unclone_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">perf_event_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * only top level events have the pid namespace they were created in</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">task_tgid_nr_ns</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">perf_event_tid</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * only top level events have the pid namespace they were created in</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">event</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">task_pid_nr_ns</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If we inherit events we want to return the parent event id</span>
<span class="cm"> * to userspace.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">primary_event_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">id</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">id</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the perf_event_context for a task and lock it.</span>
<span class="cm"> * This has to cope with with the fact that until it is locked,</span>
<span class="cm"> * the context could get moved to another task.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span>
<span class="nf">perf_lock_task_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ctxn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="nl">retry:</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this context is a clone of another, it might</span>
<span class="cm">		 * get swapped for another underneath us by</span>
<span class="cm">		 * perf_event_task_sched_out, though the</span>
<span class="cm">		 * rcu_read_lock() protects us from any context</span>
<span class="cm">		 * getting freed.  Lock the context and check if it</span>
<span class="cm">		 * got swapped before we could get the lock, and retry</span>
<span class="cm">		 * if so.  If we locked the right context, then it</span>
<span class="cm">		 * can&#39;t get swapped on us any more.</span>
<span class="cm">		 */</span>
		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">!=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the context for a task and increment its pin_count so it</span>
<span class="cm"> * can&#39;t get swapped to another task.  This also increments its</span>
<span class="cm"> * reference count so that the context can&#39;t get freed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span>
<span class="nf">perf_pin_task_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ctxn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">perf_lock_task_context</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ctxn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pin_count</span><span class="p">;</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_unpin_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="o">--</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pin_count</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update the record of the current time in a context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_context_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">now</span> <span class="o">=</span> <span class="n">perf_clock</span><span class="p">();</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">+=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">perf_event_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_cgroup_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">perf_cgroup_event_time</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ctx</span> <span class="o">?</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update the total_time_enabled and total_time_running fields for a event.</span>
<span class="cm"> * The caller of this function needs to hold the ctx-&gt;lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_event_times</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">run_end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span> <span class="o">||</span>
	    <span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * in cgroup mode, time_enabled represents</span>
<span class="cm">	 * the time the event was enabled AND active</span>
<span class="cm">	 * tasks were in the monitored cgroup. This is</span>
<span class="cm">	 * independent of the activity of the context as</span>
<span class="cm">	 * there may be a mix of cgroup and non-cgroup events.</span>
<span class="cm">	 *</span>
<span class="cm">	 * That is why we treat cgroup events differently</span>
<span class="cm">	 * here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_cgroup_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="n">run_end</span> <span class="o">=</span> <span class="n">perf_cgroup_event_time</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">is_active</span><span class="p">)</span>
		<span class="n">run_end</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">run_end</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_stopped</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">total_time_enabled</span> <span class="o">=</span> <span class="n">run_end</span> <span class="o">-</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_enabled</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">)</span>
		<span class="n">run_end</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_stopped</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">run_end</span> <span class="o">=</span> <span class="n">perf_event_time</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">total_time_running</span> <span class="o">=</span> <span class="n">run_end</span> <span class="o">-</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_running</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update total_time_enabled and total_time_running for all events in a group.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_group_times</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">leader</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">update_event_times</span><span class="p">(</span><span class="n">leader</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">leader</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span>
		<span class="n">update_event_times</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span>
<span class="nf">ctx_group_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">pinned</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pinned_groups</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flexible_groups</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a event from the lists for its context.</span>
<span class="cm"> * Must be called with ctx-&gt;mutex and ctx-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">list_add_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attach_state</span> <span class="o">&amp;</span> <span class="n">PERF_ATTACH_CONTEXT</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">attach_state</span> <span class="o">|=</span> <span class="n">PERF_ATTACH_CONTEXT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re a stand alone event or group leader, we go to the context</span>
<span class="cm">	 * list, group events are kept attached to the group so that</span>
<span class="cm">	 * perf_group_detach can, at all times, locate all siblings.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">==</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_software_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">group_flags</span> <span class="o">|=</span> <span class="n">PERF_GROUP_SOFTWARE</span><span class="p">;</span>

		<span class="n">list</span> <span class="o">=</span> <span class="n">ctx_group_list</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_entry</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_cgroup_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_cgroups</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">has_branch_stack</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_branch_stack</span><span class="o">++</span><span class="p">;</span>

	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="p">)</span>
		<span class="n">perf_pmu_rotate_start</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">inherit_stat</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_stat</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called at perf_event creation and when events are attached/detached from a</span>
<span class="cm"> * group.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event__read_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">entry</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span> <span class="cm">/* value */</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_TOTAL_TIME_ENABLED</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_TOTAL_TIME_RUNNING</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_ID</span><span class="p">)</span>
		<span class="n">entry</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_GROUP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr</span> <span class="o">+=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">nr_siblings</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">size</span> <span class="o">+=</span> <span class="n">entry</span> <span class="o">*</span> <span class="n">nr</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">read_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event__header_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">sample_type</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_type</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">perf_event__read_size</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_IP</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_ADDR</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_PERIOD</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_READ</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">read_size</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">header_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event__id_header_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">sample_type</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_type</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_TID</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">tid_entry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_TIME</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_ID</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_STREAM_ID</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_CPU</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">cpu_entry</span><span class="p">);</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">id_header_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_group_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">group_leader</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can have double attach due to group movement in perf_event_open.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attach_state</span> <span class="o">&amp;</span> <span class="n">PERF_ATTACH_GROUP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">attach_state</span> <span class="o">|=</span> <span class="n">PERF_ATTACH_GROUP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">group_leader</span> <span class="o">==</span> <span class="n">event</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">group_flags</span> <span class="o">&amp;</span> <span class="n">PERF_GROUP_SOFTWARE</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">is_software_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">group_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PERF_GROUP_SOFTWARE</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">);</span>
	<span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">nr_siblings</span><span class="o">++</span><span class="p">;</span>

	<span class="n">perf_event__header_size</span><span class="p">(</span><span class="n">group_leader</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span>
		<span class="n">perf_event__header_size</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a event from the lists for its context.</span>
<span class="cm"> * Must be called with ctx-&gt;mutex and ctx-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">list_del_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We can have double detach due to exit/hot-unplug + close.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attach_state</span> <span class="o">&amp;</span> <span class="n">PERF_ATTACH_CONTEXT</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">attach_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PERF_ATTACH_CONTEXT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_cgroup_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_cgroups</span><span class="o">--</span><span class="p">;</span>
		<span class="n">cpuctx</span> <span class="o">=</span> <span class="n">__get_cpu_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * if there are no more cgroup events</span>
<span class="cm">		 * then cler cgrp to avoid stale pointer</span>
<span class="cm">		 * in update_cgrp_time_from_cpuctx()</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_cgroups</span><span class="p">)</span>
			<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">cgrp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">has_branch_stack</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_branch_stack</span><span class="o">--</span><span class="p">;</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">inherit_stat</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_stat</span><span class="o">--</span><span class="p">;</span>

	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event_entry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">==</span> <span class="n">event</span><span class="p">)</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_entry</span><span class="p">);</span>

	<span class="n">update_group_times</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If event was in error state, then keep it</span>
<span class="cm">	 * that way, otherwise bogus counts will be</span>
<span class="cm">	 * returned on read(). The only way to get out</span>
<span class="cm">	 * of error state is by explicit re-enabling</span>
<span class="cm">	 * of the event</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">)</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_group_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">sibling</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can have double detach due to exit/hot-unplug + close.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attach_state</span> <span class="o">&amp;</span> <span class="n">PERF_ATTACH_GROUP</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">attach_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PERF_ATTACH_GROUP</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a sibling, remove it from its group.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">!=</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_entry</span><span class="p">);</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">nr_siblings</span><span class="o">--</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_entry</span><span class="p">))</span>
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_entry</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this was a group event with sibling events then</span>
<span class="cm">	 * upgrade the siblings to singleton events by adding them</span>
<span class="cm">	 * to whatever list we are on.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sibling</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="p">)</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sibling</span><span class="o">-&gt;</span><span class="n">group_entry</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">sibling</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">=</span> <span class="n">sibling</span><span class="p">;</span>

		<span class="cm">/* Inherit group flags from the previous leader */</span>
		<span class="n">sibling</span><span class="o">-&gt;</span><span class="n">group_flags</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">group_flags</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">perf_event__header_size</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span>
		<span class="n">perf_event__header_size</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">event_filter_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">())</span>
	    <span class="o">&amp;&amp;</span> <span class="n">perf_cgroup_match</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">event_sched_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tstamp</span> <span class="o">=</span> <span class="n">perf_event_time</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">delta</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * An event which could not be activated because of</span>
<span class="cm">	 * filter mismatch still needs to have its timings</span>
<span class="cm">	 * maintained, otherwise bogus information is return</span>
<span class="cm">	 * via read() for time_enabled, time_running:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span>
	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">event_filter_match</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">tstamp</span> <span class="o">-</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_stopped</span><span class="p">;</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_running</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_stopped</span> <span class="o">=</span> <span class="n">tstamp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">PERF_EVENT_STATE_ACTIVE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pending_disable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">pending_disable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_stopped</span> <span class="o">=</span> <span class="n">tstamp</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">del</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">oncpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_software_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">active_oncpu</span><span class="o">--</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_active</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">freq</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_freq</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_freq</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclusive</span> <span class="o">||</span> <span class="o">!</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">active_oncpu</span><span class="p">)</span>
		<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">exclusive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">group_sched_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">group_event</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="n">group_event</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

	<span class="n">event_sched_out</span><span class="p">(</span><span class="n">group_event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Schedule out siblings (if any):</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">group_event</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span>
		<span class="n">event_sched_out</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PERF_EVENT_STATE_ACTIVE</span> <span class="o">&amp;&amp;</span> <span class="n">group_event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclusive</span><span class="p">)</span>
		<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">exclusive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cross CPU call to remove a performance event</span>
<span class="cm"> *</span>
<span class="cm"> * We disable the event on the hardware level first. After that we</span>
<span class="cm"> * remove it from the context list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__perf_remove_from_context</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span> <span class="o">=</span> <span class="n">__get_cpu_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">event_sched_out</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">list_del_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_events</span> <span class="o">&amp;&amp;</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span> <span class="o">==</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">is_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Remove the event from a task&#39;s (or a CPU&#39;s) list of events.</span>
<span class="cm"> *</span>
<span class="cm"> * CPU events are removed with a smp call. For task events we only</span>
<span class="cm"> * call when the task is on a CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * If event-&gt;ctx is a cloned context, callers must make sure that</span>
<span class="cm"> * every task struct that event-&gt;ctx-&gt;task could possibly point to</span>
<span class="cm"> * remains valid.  This is OK when called from perf_release since</span>
<span class="cm"> * that only calls us on the top-level context, which can&#39;t be a clone.</span>
<span class="cm"> * When called from perf_event_exit_task, it&#39;s OK because the</span>
<span class="cm"> * context has been detached from its task.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_remove_from_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>

	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Per cpu events are removed via an smp call and</span>
<span class="cm">		 * the removal is always successful.</span>
<span class="cm">		 */</span>
		<span class="n">cpu_function_call</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">__perf_remove_from_context</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_function_call</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">__perf_remove_from_context</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we failed to find a running task, but find the context active now</span>
<span class="cm">	 * that we&#39;ve acquired the ctx-&gt;lock, retry.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">is_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since the task isn&#39;t running, its safe to remove the event, us</span>
<span class="cm">	 * holding the ctx-&gt;lock ensures the task won&#39;t get scheduled in.</span>
<span class="cm">	 */</span>
	<span class="n">list_del_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cross CPU call to disable a performance event</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__perf_event_disable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span> <span class="o">=</span> <span class="n">__get_cpu_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a per-task event, need to check whether this</span>
<span class="cm">	 * event&#39;s task is the current task on this cpu.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Can trigger due to concurrent perf_event_context_sched_out()</span>
<span class="cm">	 * flipping contexts around.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">&amp;&amp;</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span> <span class="o">!=</span> <span class="n">ctx</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the event is on, turn it off.</span>
<span class="cm">	 * If it is in error state, leave it in error state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">update_context_time</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">update_cgrp_time_from_event</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="n">update_group_times</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">)</span>
			<span class="n">group_sched_out</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">event_sched_out</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Disable a event.</span>
<span class="cm"> *</span>
<span class="cm"> * If event-&gt;ctx is a cloned context, callers must make sure that</span>
<span class="cm"> * every task struct that event-&gt;ctx-&gt;task could possibly point to</span>
<span class="cm"> * remains valid.  This condition is satisifed when called through</span>
<span class="cm"> * perf_event_for_each_child or perf_event_for_each because they</span>
<span class="cm"> * hold the top-level event&#39;s child_mutex, so any descendant that</span>
<span class="cm"> * goes to exit will block in sync_child_event.</span>
<span class="cm"> * When called from perf_pending_event it&#39;s OK because event-&gt;ctx</span>
<span class="cm"> * is the current context on this CPU and preemption is disabled,</span>
<span class="cm"> * hence we can&#39;t get into perf_event_task_sched_out for this context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">perf_event_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Disable the event on the cpu that it&#39;s on</span>
<span class="cm">		 */</span>
		<span class="n">cpu_function_call</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">__perf_event_disable</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_function_call</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">__perf_event_disable</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the event is still active, we need to retry the cross-call.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">PERF_EVENT_STATE_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Reload the task pointer, it might have been changed by</span>
<span class="cm">		 * a concurrent perf_event_context_sched_out().</span>
<span class="cm">		 */</span>
		<span class="n">task</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we have the lock this context can&#39;t be scheduled</span>
<span class="cm">	 * in, so we can change the state safely.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">update_group_times</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">perf_event_disable</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_set_shadow_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">tstamp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * use the correct time source for the time snapshot</span>
<span class="cm">	 *</span>
<span class="cm">	 * We could get by without this by leveraging the</span>
<span class="cm">	 * fact that to get to this function, the caller</span>
<span class="cm">	 * has most likely already called update_context_time()</span>
<span class="cm">	 * and update_cgrp_time_xx() and thus both timestamp</span>
<span class="cm">	 * are identical (or very close). Given that tstamp is,</span>
<span class="cm">	 * already adjusted for cgroup, we could say that:</span>
<span class="cm">	 *    tstamp - ctx-&gt;timestamp</span>
<span class="cm">	 * is equivalent to</span>
<span class="cm">	 *    tstamp - cgrp-&gt;timestamp.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Then, in perf_output_read(), the calculation would</span>
<span class="cm">	 * work with no changes because:</span>
<span class="cm">	 * - event is guaranteed scheduled in</span>
<span class="cm">	 * - no scheduled out in between</span>
<span class="cm">	 * - thus the timestamp would be the same</span>
<span class="cm">	 *</span>
<span class="cm">	 * But this is a bit hairy.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So instead, we have an explicit cgroup call to remain</span>
<span class="cm">	 * within the time time source all along. We believe it</span>
<span class="cm">	 * is cleaner and simpler to understand.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_cgroup_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="n">perf_cgroup_set_shadow_time</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">tstamp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">shadow_ctx_time</span> <span class="o">=</span> <span class="n">tstamp</span> <span class="o">-</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define MAX_INTERRUPTS (~0ULL)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">perf_log_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">event_sched_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tstamp</span> <span class="o">=</span> <span class="n">perf_event_time</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;=</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_EVENT_STATE_ACTIVE</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">oncpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unthrottle events, since we scheduled we might have missed several</span>
<span class="cm">	 * ticks already, also for a heavily scheduling task there is little</span>
<span class="cm">	 * guarantee it&#39;ll get a tick in a timely manner.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">interrupts</span> <span class="o">==</span> <span class="n">MAX_INTERRUPTS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">perf_log_throttle</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">interrupts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The new state must be visible before we turn it on in the hardware:</span>
<span class="cm">	 */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">PERF_EF_START</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">;</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">oncpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_running</span> <span class="o">+=</span> <span class="n">tstamp</span> <span class="o">-</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_stopped</span><span class="p">;</span>

	<span class="n">perf_set_shadow_time</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">tstamp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_software_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">active_oncpu</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_active</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">freq</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_freq</span><span class="p">)</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_freq</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclusive</span><span class="p">)</span>
		<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">exclusive</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">group_sched_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">group_event</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="o">*</span><span class="n">partial_group</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span> <span class="o">=</span> <span class="n">group_event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">now</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">simulate</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">group_event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">start_txn</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event_sched_in</span><span class="p">(</span><span class="n">group_event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">cancel_txn</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Schedule in siblings as one group (if any):</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">group_event</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event_sched_in</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">partial_group</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">group_error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">commit_txn</span><span class="p">(</span><span class="n">pmu</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">group_error:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Groups can be scheduled in as one unit only, so undo any</span>
<span class="cm">	 * partial group before returning:</span>
<span class="cm">	 * The events up to the failed event are scheduled out normally,</span>
<span class="cm">	 * tstamp_stopped will be updated.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The failed events and the remaining siblings need to have</span>
<span class="cm">	 * their timings updated as if they had gone thru event_sched_in()</span>
<span class="cm">	 * and event_sched_out(). This is required to get consistent timings</span>
<span class="cm">	 * across the group. This also takes care of the case where the group</span>
<span class="cm">	 * could never be scheduled by ensuring tstamp_stopped is set to mark</span>
<span class="cm">	 * the time the event was actually stopped, such that time delta</span>
<span class="cm">	 * calculation in update_event_times() is correct.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">group_event</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">partial_group</span><span class="p">)</span>
			<span class="n">simulate</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">simulate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_running</span> <span class="o">+=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_stopped</span><span class="p">;</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_stopped</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">event_sched_out</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">event_sched_out</span><span class="p">(</span><span class="n">group_event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">cancel_txn</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Work out whether we can put this event group on the CPU now.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">group_can_go_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">can_add_hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Groups consisting entirely of software events can always go on.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_flags</span> <span class="o">&amp;</span> <span class="n">PERF_GROUP_SOFTWARE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If an exclusive group is already on, no other hardware</span>
<span class="cm">	 * events can go on.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">exclusive</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this group is exclusive and there are already</span>
<span class="cm">	 * events on the CPU, it can&#39;t go on.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclusive</span> <span class="o">&amp;&amp;</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">active_oncpu</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Otherwise, try to add it if all previous groups were able</span>
<span class="cm">	 * to go on.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">can_add_hw</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_event_to_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tstamp</span> <span class="o">=</span> <span class="n">perf_event_time</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="n">list_add_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">perf_group_attach</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_enabled</span> <span class="o">=</span> <span class="n">tstamp</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_running</span> <span class="o">=</span> <span class="n">tstamp</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_stopped</span> <span class="o">=</span> <span class="n">tstamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">task_ctx_sched_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="n">ctx_sched_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">,</span>
	     <span class="k">enum</span> <span class="n">event_type_t</span> <span class="n">event_type</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_sched_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpu_ctx_sched_in</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">EVENT_PINNED</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
		<span class="n">ctx_sched_in</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">EVENT_PINNED</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="n">cpu_ctx_sched_in</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">EVENT_FLEXIBLE</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
		<span class="n">ctx_sched_in</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">EVENT_FLEXIBLE</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cross CPU call to install and enable a performance event</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with ctx-&gt;mutex held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="nf">__perf_install_in_context</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span> <span class="o">=</span> <span class="n">__get_cpu_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">task_ctx</span> <span class="o">=</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="n">perf_ctx_lock</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">task_ctx</span><span class="p">);</span>
	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">pmu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there was an active task_ctx schedule it out.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task_ctx</span><span class="p">)</span>
		<span class="n">task_ctx_sched_out</span><span class="p">(</span><span class="n">task_ctx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the context we&#39;re installing events in is not the</span>
<span class="cm">	 * active task_ctx, flip them.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">&amp;&amp;</span> <span class="n">task_ctx</span> <span class="o">!=</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task_ctx</span><span class="p">)</span>
			<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">task_ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span> <span class="o">=</span> <span class="n">task_ctx</span><span class="p">;</span>
		<span class="n">task</span> <span class="o">=</span> <span class="n">task_ctx</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cpu_ctx_sched_out</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">EVENT_ALL</span><span class="p">);</span>

	<span class="n">update_context_time</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * update cgrp time only if current cgrp</span>
<span class="cm">	 * matches event-&gt;cgrp. Must be done before</span>
<span class="cm">	 * calling add_event_to_ctx()</span>
<span class="cm">	 */</span>
	<span class="n">update_cgrp_time_from_event</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="n">add_event_to_ctx</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Schedule everything back in</span>
<span class="cm">	 */</span>
	<span class="n">perf_event_sched_in</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">task_ctx</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>

	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">perf_ctx_unlock</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">task_ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attach a performance event to a context</span>
<span class="cm"> *</span>
<span class="cm"> * First we add the event to the list with the hardware enable bit</span>
<span class="cm"> * in event-&gt;hw_config cleared.</span>
<span class="cm"> *</span>
<span class="cm"> * If the event is attached to a task which is on a CPU we use a smp</span>
<span class="cm"> * call to enable it in the task context. The task might have been</span>
<span class="cm"> * scheduled away, but we check this in the smp call again.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">perf_install_in_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>

	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Per cpu events are installed via an smp call and</span>
<span class="cm">		 * the install is always successful.</span>
<span class="cm">		 */</span>
		<span class="n">cpu_function_call</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">__perf_install_in_context</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_function_call</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">__perf_install_in_context</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we failed to find a running task, but find the context active now</span>
<span class="cm">	 * that we&#39;ve acquired the ctx-&gt;lock, retry.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">is_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since the task isn&#39;t running, its safe to add the event, us holding</span>
<span class="cm">	 * the ctx-&gt;lock ensures the task won&#39;t get scheduled in.</span>
<span class="cm">	 */</span>
	<span class="n">add_event_to_ctx</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Put a event into inactive state and update time fields.</span>
<span class="cm"> * Enabling the leader of a group effectively enables all</span>
<span class="cm"> * the group members that aren&#39;t explicitly disabled, so we</span>
<span class="cm"> * have to update their -&gt;tstamp_enabled also.</span>
<span class="cm"> * Note: this works for group members as well as group leaders</span>
<span class="cm"> * since the non-leader members&#39; sibling_lists will be empty.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__perf_event_mark_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">sub</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tstamp</span> <span class="o">=</span> <span class="n">perf_event_time</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_enabled</span> <span class="o">=</span> <span class="n">tstamp</span> <span class="o">-</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">total_time_enabled</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">)</span>
			<span class="n">sub</span><span class="o">-&gt;</span><span class="n">tstamp_enabled</span> <span class="o">=</span> <span class="n">tstamp</span> <span class="o">-</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">total_time_enabled</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cross CPU call to enable a performance event</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__perf_event_enable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">leader</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span> <span class="o">=</span> <span class="n">__get_cpu_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">is_active</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">update_context_time</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * set current task&#39;s cgroup time reference point</span>
<span class="cm">	 */</span>
	<span class="n">perf_cgroup_set_timestamp</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="n">__perf_event_mark_enabled</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event_filter_match</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_cgroup_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
			<span class="n">perf_cgroup_defer_enabled</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the event is in a group and isn&#39;t the group leader,</span>
<span class="cm">	 * then don&#39;t put it on unless the group is on.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">leader</span> <span class="o">!=</span> <span class="n">event</span> <span class="o">&amp;&amp;</span> <span class="n">leader</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">PERF_EVENT_STATE_ACTIVE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group_can_go_on</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">leader</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">group_sched_in</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">event_sched_in</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this event can&#39;t go on and it&#39;s part of a</span>
<span class="cm">		 * group, then the whole group has to come off.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">leader</span> <span class="o">!=</span> <span class="n">event</span><span class="p">)</span>
			<span class="n">group_sched_out</span><span class="p">(</span><span class="n">leader</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">leader</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">pinned</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">update_group_times</span><span class="p">(</span><span class="n">leader</span><span class="p">);</span>
			<span class="n">leader</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_EVENT_STATE_ERROR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">unlock:</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable a event.</span>
<span class="cm"> *</span>
<span class="cm"> * If event-&gt;ctx is a cloned context, callers must make sure that</span>
<span class="cm"> * every task struct that event-&gt;ctx-&gt;task could possibly point to</span>
<span class="cm"> * remains valid.  This condition is satisfied when called through</span>
<span class="cm"> * perf_event_for_each_child or perf_event_for_each as described</span>
<span class="cm"> * for perf_event_disable.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">perf_event_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Enable the event on the cpu that it&#39;s on</span>
<span class="cm">		 */</span>
		<span class="n">cpu_function_call</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">__perf_event_enable</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the event is in error state, clear that first.</span>
<span class="cm">	 * That way, if we see the event in error state below, we</span>
<span class="cm">	 * know that it has gone back into error state, as distinct</span>
<span class="cm">	 * from the task having been scheduled away before the</span>
<span class="cm">	 * cross-call arrived.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">PERF_EVENT_STATE_ERROR</span><span class="p">)</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">is_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__perf_event_mark_enabled</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_function_call</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">__perf_event_enable</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the context is active and the event is still off,</span>
<span class="cm">	 * we need to retry the cross-call.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">is_active</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * task could have been flipped by a concurrent</span>
<span class="cm">		 * perf_event_context_sched_out()</span>
<span class="cm">		 */</span>
		<span class="n">task</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">perf_event_enable</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">perf_event_refresh</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">refresh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * not supported on inherited events</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">inherit</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_sampling_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">atomic_add</span><span class="p">(</span><span class="n">refresh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event_limit</span><span class="p">);</span>
	<span class="n">perf_event_enable</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">perf_event_refresh</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ctx_sched_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">,</span>
			  <span class="k">enum</span> <span class="n">event_type_t</span> <span class="n">event_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_active</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">is_active</span><span class="p">;</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">is_active</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">event_type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">update_context_time</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">update_cgrp_time_from_cpuctx</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_active</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">is_active</span> <span class="o">&amp;</span> <span class="n">EVENT_PINNED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">event_type</span> <span class="o">&amp;</span> <span class="n">EVENT_PINNED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pinned_groups</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span>
			<span class="n">group_sched_out</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">is_active</span> <span class="o">&amp;</span> <span class="n">EVENT_FLEXIBLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">event_type</span> <span class="o">&amp;</span> <span class="n">EVENT_FLEXIBLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flexible_groups</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span>
			<span class="n">group_sched_out</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Test whether two contexts are equivalent, i.e. whether they</span>
<span class="cm"> * have both been cloned from the same version of the same context</span>
<span class="cm"> * and they both have the same number of enabled events.</span>
<span class="cm"> * If the number of enabled events is the same, then the set</span>
<span class="cm"> * of enabled events should be the same, because these are both</span>
<span class="cm"> * inherited contexts, therefore we can&#39;t access individual events</span>
<span class="cm"> * in them directly with an fd; we can only enable/disable all</span>
<span class="cm"> * events via prctl, or enable/disable all events in a family</span>
<span class="cm"> * via ioctl, which will have the same effect on both contexts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">context_equiv</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx1</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ctx1</span><span class="o">-&gt;</span><span class="n">parent_ctx</span> <span class="o">&amp;&amp;</span> <span class="n">ctx1</span><span class="o">-&gt;</span><span class="n">parent_ctx</span> <span class="o">==</span> <span class="n">ctx2</span><span class="o">-&gt;</span><span class="n">parent_ctx</span>
		<span class="o">&amp;&amp;</span> <span class="n">ctx1</span><span class="o">-&gt;</span><span class="n">parent_gen</span> <span class="o">==</span> <span class="n">ctx2</span><span class="o">-&gt;</span><span class="n">parent_gen</span>
		<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ctx1</span><span class="o">-&gt;</span><span class="n">pin_count</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ctx2</span><span class="o">-&gt;</span><span class="n">pin_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__perf_event_sync_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">next_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">inherit_stat</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the event value, we cannot use perf_event_read()</span>
<span class="cm">	 * because we&#39;re in the middle of a context switch and have IRQs</span>
<span class="cm">	 * disabled, which upsets smp_call_function_single(), however</span>
<span class="cm">	 * we know the event must be on the current CPU, therefore we</span>
<span class="cm">	 * don&#39;t need to use it.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PERF_EVENT_STATE_ACTIVE</span>:
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="cm">/* fall-through */</span>

	<span class="k">case</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span>:
		<span class="n">update_event_times</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * In order to keep per-task stats reliable we need to flip the event</span>
<span class="cm">	 * values when we flip the contexts.</span>
<span class="cm">	 */</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_event</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">local64_xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_event</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="n">swap</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">total_time_enabled</span><span class="p">,</span> <span class="n">next_event</span><span class="o">-&gt;</span><span class="n">total_time_enabled</span><span class="p">);</span>
	<span class="n">swap</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">total_time_running</span><span class="p">,</span> <span class="n">next_event</span><span class="o">-&gt;</span><span class="n">total_time_running</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we swizzled the values, update the user visible data too.</span>
<span class="cm">	 */</span>
	<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">next_event</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define list_next_entry(pos, member) \</span>
<span class="cp">	list_entry(pos-&gt;member.next, typeof(*pos), member)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_sync_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">next_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="o">*</span><span class="n">next_event</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_stat</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">update_context_time</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">perf_event</span><span class="p">,</span> <span class="n">event_entry</span><span class="p">);</span>

	<span class="n">next_event</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_ctx</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">perf_event</span><span class="p">,</span> <span class="n">event_entry</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event_entry</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">event_list</span> <span class="o">&amp;&amp;</span>
	       <span class="o">&amp;</span><span class="n">next_event</span><span class="o">-&gt;</span><span class="n">event_entry</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">next_ctx</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">__perf_event_sync_stat</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">next_event</span><span class="p">);</span>

		<span class="n">event</span> <span class="o">=</span> <span class="n">list_next_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">event_entry</span><span class="p">);</span>
		<span class="n">next_event</span> <span class="o">=</span> <span class="n">list_next_entry</span><span class="p">(</span><span class="n">next_event</span><span class="p">,</span> <span class="n">event_entry</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_context_sched_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ctxn</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">next_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_switch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpuctx</span> <span class="o">=</span> <span class="n">__get_cpu_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">);</span>
	<span class="n">next_ctx</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">next_ctx</span> <span class="o">&amp;&amp;</span>
	    <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">next_ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">)</span> <span class="o">==</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Looks like the two contexts are clones, so we might be</span>
<span class="cm">		 * able to optimize the context switch.  We lock both</span>
<span class="cm">		 * contexts and check that they are clones under the</span>
<span class="cm">		 * lock (including re-checking that neither has been</span>
<span class="cm">		 * uncloned in the meantime).  It doesn&#39;t matter which</span>
<span class="cm">		 * order we take the locks because no other cpu could</span>
<span class="cm">		 * be trying to lock both of these tasks.</span>
<span class="cm">		 */</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">raw_spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">context_equiv</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">next_ctx</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * XXX do we need a memory barrier of sorts</span>
<span class="cm">			 * wrt to rcu_dereference() of perf_event_ctxp</span>
<span class="cm">			 */</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_ctx</span><span class="p">;</span>
			<span class="n">next</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="n">next_ctx</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>
			<span class="n">do_switch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">perf_event_sync_stat</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">next_ctx</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">do_switch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">ctx_sched_out</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">EVENT_ALL</span><span class="p">);</span>
		<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define for_each_task_context_nr(ctxn)					\</span>
<span class="cp">	for ((ctxn) = 0; (ctxn) &lt; perf_nr_task_contexts; (ctxn)++)</span>

<span class="cm">/*</span>
<span class="cm"> * Called from scheduler to remove the events of the current task,</span>
<span class="cm"> * with interrupts disabled.</span>
<span class="cm"> *</span>
<span class="cm"> * We stop each event and update the event value in event-&gt;count.</span>
<span class="cm"> *</span>
<span class="cm"> * This does not protect us against NMI, but disable()</span>
<span class="cm"> * sets the disabled bit in the control field of event _before_</span>
<span class="cm"> * accessing the event control register. If a NMI hits, then it will</span>
<span class="cm"> * not restart the event.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__perf_event_task_sched_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ctxn</span><span class="p">;</span>

	<span class="n">for_each_task_context_nr</span><span class="p">(</span><span class="n">ctxn</span><span class="p">)</span>
		<span class="n">perf_event_context_sched_out</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ctxn</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if cgroup events exist on this CPU, then we need</span>
<span class="cm">	 * to check if we have to switch out PMU state.</span>
<span class="cm">	 * cgroup event are system-wide mode only</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">perf_cgroup_events</span><span class="p">)))</span>
		<span class="n">perf_cgroup_sched_out</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">task_ctx_sched_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span> <span class="o">=</span> <span class="n">__get_cpu_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ctx</span> <span class="o">!=</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ctx_sched_out</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">EVENT_ALL</span><span class="p">);</span>
	<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called with IRQs disabled</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_ctx_sched_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">event_type_t</span> <span class="n">event_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ctx_sched_out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">event_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ctx_pinned_sched_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pinned_groups</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;=</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event_filter_match</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* may need to reset tstamp_enabled */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_cgroup_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
			<span class="n">perf_cgroup_mark_enabled</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">group_can_go_on</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">group_sched_in</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If this pinned group hasn&#39;t been scheduled,</span>
<span class="cm">		 * put it in error state.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">update_group_times</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_EVENT_STATE_ERROR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ctx_flexible_sched_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">can_add_hw</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flexible_groups</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Ignore events in OFF or ERROR state */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;=</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Listen to the &#39;cpu&#39; scheduling filter constraint</span>
<span class="cm">		 * of events:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event_filter_match</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* may need to reset tstamp_enabled */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_cgroup_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
			<span class="n">perf_cgroup_mark_enabled</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">group_can_go_on</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">can_add_hw</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">group_sched_in</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">))</span>
				<span class="n">can_add_hw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ctx_sched_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">,</span>
	     <span class="k">enum</span> <span class="n">event_type_t</span> <span class="n">event_type</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_active</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">is_active</span><span class="p">;</span>

	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">is_active</span> <span class="o">|=</span> <span class="n">event_type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">perf_clock</span><span class="p">();</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
	<span class="n">perf_cgroup_set_timestamp</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * First go through the list and put on any pinned groups</span>
<span class="cm">	 * in order to give them the best chance of going on.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">is_active</span> <span class="o">&amp;</span> <span class="n">EVENT_PINNED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">event_type</span> <span class="o">&amp;</span> <span class="n">EVENT_PINNED</span><span class="p">))</span>
		<span class="n">ctx_pinned_sched_in</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">);</span>

	<span class="cm">/* Then walk through the lower prio flexible groups */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">is_active</span> <span class="o">&amp;</span> <span class="n">EVENT_FLEXIBLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">event_type</span> <span class="o">&amp;</span> <span class="n">EVENT_FLEXIBLE</span><span class="p">))</span>
		<span class="n">ctx_flexible_sched_in</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_ctx_sched_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">event_type_t</span> <span class="n">event_type</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>

	<span class="n">ctx_sched_in</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">event_type</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_context_sched_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">;</span>

	<span class="n">cpuctx</span> <span class="o">=</span> <span class="n">__get_cpu_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span> <span class="o">==</span> <span class="n">ctx</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">perf_ctx_lock</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We want to keep the following priority order:</span>
<span class="cm">	 * cpu pinned (that don&#39;t need to move), task pinned,</span>
<span class="cm">	 * cpu flexible, task flexible.</span>
<span class="cm">	 */</span>
	<span class="n">cpu_ctx_sched_out</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">EVENT_FLEXIBLE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="p">)</span>
		<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>

	<span class="n">perf_event_sched_in</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>

	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">perf_ctx_unlock</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since these rotations are per-cpu, we need to ensure the</span>
<span class="cm">	 * cpu-context we got scheduled on is actually rotating.</span>
<span class="cm">	 */</span>
	<span class="n">perf_pmu_rotate_start</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When sampling the branck stack in system-wide, it may be necessary</span>
<span class="cm"> * to flush the stack on context switch. This happens when the branch</span>
<span class="cm"> * stack does not tag its entries with the pid of the current task.</span>
<span class="cm"> * Otherwise it becomes impossible to associate a branch entry with a</span>
<span class="cm"> * task. This ambiguity is more likely to appear when the branch stack</span>
<span class="cm"> * supports priv level filtering and the user sets it to monitor only</span>
<span class="cm"> * at the user level (which could be a useful measurement in system-wide</span>
<span class="cm"> * mode). In that case, the risk is high of having a branch stack with</span>
<span class="cm"> * branch from multiple tasks. Flushing may mean dropping the existing</span>
<span class="cm"> * entries or stashing them somewhere in the PMU specific code layer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function provides the context switch callback to the lower code</span>
<span class="cm"> * layer. It is invoked ONLY when there is at least one system-wide context</span>
<span class="cm"> * with at least one active event using taken branch sampling.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_branch_stack_sched_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* no need to flush branch stack if not changing task */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">==</span> <span class="n">task</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">pmu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmus</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpuctx</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * check if the context has at least one</span>
<span class="cm">		 * event using PERF_SAMPLE_BRANCH_STACK</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">nr_branch_stack</span> <span class="o">&gt;</span> <span class="mi">0</span>
		    <span class="o">&amp;&amp;</span> <span class="n">pmu</span><span class="o">-&gt;</span><span class="n">flush_branch_stack</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">pmu</span> <span class="o">=</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">pmu</span><span class="p">;</span>

			<span class="n">perf_ctx_lock</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span><span class="p">);</span>

			<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>

			<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">flush_branch_stack</span><span class="p">();</span>

			<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>

			<span class="n">perf_ctx_unlock</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from scheduler to add the events of the current task</span>
<span class="cm"> * with interrupts disabled.</span>
<span class="cm"> *</span>
<span class="cm"> * We restore the event value and then enable it.</span>
<span class="cm"> *</span>
<span class="cm"> * This does not protect us against NMI, but enable()</span>
<span class="cm"> * sets the enabled bit in the control field of event _before_</span>
<span class="cm"> * accessing the event control register. If a NMI hits, then it will</span>
<span class="cm"> * keep the event running.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__perf_event_task_sched_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctxn</span><span class="p">;</span>

	<span class="n">for_each_task_context_nr</span><span class="p">(</span><span class="n">ctxn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">perf_event_context_sched_in</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * if cgroup events exist on this CPU, then we need</span>
<span class="cm">	 * to check if we have to switch in PMU state.</span>
<span class="cm">	 * cgroup event are system-wide mode only</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">perf_cgroup_events</span><span class="p">)))</span>
		<span class="n">perf_cgroup_sched_in</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>

	<span class="cm">/* check for system-wide branch_stack events */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">perf_branch_stack_events</span><span class="p">)))</span>
		<span class="n">perf_branch_stack_sched_in</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">perf_calculate_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nsec</span><span class="p">,</span> <span class="n">u64</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">frequency</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_freq</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">sec</span> <span class="o">=</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">divisor</span><span class="p">,</span> <span class="n">dividend</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">count_fls</span><span class="p">,</span> <span class="n">nsec_fls</span><span class="p">,</span> <span class="n">frequency_fls</span><span class="p">,</span> <span class="n">sec_fls</span><span class="p">;</span>

	<span class="n">count_fls</span> <span class="o">=</span> <span class="n">fls64</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
	<span class="n">nsec_fls</span> <span class="o">=</span> <span class="n">fls64</span><span class="p">(</span><span class="n">nsec</span><span class="p">);</span>
	<span class="n">frequency_fls</span> <span class="o">=</span> <span class="n">fls64</span><span class="p">(</span><span class="n">frequency</span><span class="p">);</span>
	<span class="n">sec_fls</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We got @count in @nsec, with a target of sample_freq HZ</span>
<span class="cm">	 * the target period becomes:</span>
<span class="cm">	 *</span>
<span class="cm">	 *             @count * 10^9</span>
<span class="cm">	 * period = -------------------</span>
<span class="cm">	 *          @nsec * sample_freq</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reduce accuracy by one bit such that @a and @b converge</span>
<span class="cm">	 * to a similar magnitude.</span>
<span class="cm">	 */</span>
<span class="cp">#define REDUCE_FLS(a, b)		\</span>
<span class="cp">do {					\</span>
<span class="cp">	if (a##_fls &gt; b##_fls) {	\</span>
<span class="cp">		a &gt;&gt;= 1;		\</span>
<span class="cp">		a##_fls--;		\</span>
<span class="cp">	} else {			\</span>
<span class="cp">		b &gt;&gt;= 1;		\</span>
<span class="cp">		b##_fls--;		\</span>
<span class="cp">	}				\</span>
<span class="cp">} while (0)</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reduce accuracy until either term fits in a u64, then proceed with</span>
<span class="cm">	 * the other, so that finally we can do a u64/u64 division.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count_fls</span> <span class="o">+</span> <span class="n">sec_fls</span> <span class="o">&gt;</span> <span class="mi">64</span> <span class="o">&amp;&amp;</span> <span class="n">nsec_fls</span> <span class="o">+</span> <span class="n">frequency_fls</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">REDUCE_FLS</span><span class="p">(</span><span class="n">nsec</span><span class="p">,</span> <span class="n">frequency</span><span class="p">);</span>
		<span class="n">REDUCE_FLS</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count_fls</span> <span class="o">+</span> <span class="n">sec_fls</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">divisor</span> <span class="o">=</span> <span class="n">nsec</span> <span class="o">*</span> <span class="n">frequency</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">count_fls</span> <span class="o">+</span> <span class="n">sec_fls</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">REDUCE_FLS</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">sec</span><span class="p">);</span>
			<span class="n">divisor</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dividend</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="n">sec</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dividend</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="n">sec</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">nsec_fls</span> <span class="o">+</span> <span class="n">frequency_fls</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">REDUCE_FLS</span><span class="p">(</span><span class="n">nsec</span><span class="p">,</span> <span class="n">frequency</span><span class="p">);</span>
			<span class="n">dividend</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">divisor</span> <span class="o">=</span> <span class="n">nsec</span> <span class="o">*</span> <span class="n">frequency</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">divisor</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dividend</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">div64_u64</span><span class="p">(</span><span class="n">dividend</span><span class="p">,</span> <span class="n">divisor</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">perf_throttled_count</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">perf_throttled_seq</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_adjust_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nsec</span><span class="p">,</span> <span class="n">u64</span> <span class="n">count</span><span class="p">,</span> <span class="n">bool</span> <span class="n">disable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">period</span><span class="p">,</span> <span class="n">sample_period</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">delta</span><span class="p">;</span>

	<span class="n">period</span> <span class="o">=</span> <span class="n">perf_calculate_period</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">nsec</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)(</span><span class="n">period</span> <span class="o">-</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span><span class="p">);</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span> <span class="cm">/* low pass filter */</span>

	<span class="n">sample_period</span> <span class="o">=</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span> <span class="o">+</span> <span class="n">delta</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sample_period</span><span class="p">)</span>
		<span class="n">sample_period</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span> <span class="o">=</span> <span class="n">sample_period</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="o">*</span><span class="n">sample_period</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">disable</span><span class="p">)</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">PERF_EF_UPDATE</span><span class="p">);</span>

		<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">disable</span><span class="p">)</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">PERF_EF_RELOAD</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * combine freq adjustment with unthrottling to avoid two passes over the</span>
<span class="cm"> * events. At the same time, make sure, having freq events does not change</span>
<span class="cm"> * the rate of unthrottling as that would introduce bias.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_adjust_freq_unthr_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">needs_unthr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">now</span><span class="p">,</span> <span class="n">period</span> <span class="o">=</span> <span class="n">TICK_NSEC</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">delta</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * only need to iterate over all events iff:</span>
<span class="cm">	 * - context have events in frequency mode (needs freq adjust)</span>
<span class="cm">	 * - there are events to unthrottle on this cpu</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_freq</span> <span class="o">||</span> <span class="n">needs_unthr</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">,</span> <span class="n">event_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">PERF_EVENT_STATE_ACTIVE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event_filter_match</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">needs_unthr</span> <span class="o">&amp;&amp;</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">interrupts</span> <span class="o">==</span> <span class="n">MAX_INTERRUPTS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">interrupts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">perf_log_throttle</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">freq</span> <span class="o">||</span> <span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_freq</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * stop the event and update event-&gt;count</span>
<span class="cm">		 */</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">PERF_EF_UPDATE</span><span class="p">);</span>

		<span class="n">now</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">freq_count_stamp</span><span class="p">;</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">freq_count_stamp</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * restart the event</span>
<span class="cm">		 * reload only if value has changed</span>
<span class="cm">		 * we have stopped the event so tell that</span>
<span class="cm">		 * to perf_adjust_period() to avoid stopping it</span>
<span class="cm">		 * twice.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">perf_adjust_period</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

		<span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">PERF_EF_RELOAD</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Round-robin a context&#39;s events:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rotate_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Rotate the first entry last of non-pinned groups. Rotation might be</span>
<span class="cm">	 * disabled by the inheritance code.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">rotate_disable</span><span class="p">)</span>
		<span class="n">list_rotate_left</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flexible_groups</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * perf_pmu_rotate_start() and perf_rotate_context() are fully serialized</span>
<span class="cm"> * because they&#39;re strictly cpu affine and rotate_start is called with IRQs</span>
<span class="cm"> * disabled, while rotate_context is called from IRQ context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_rotate_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rotate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">remove</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">nr_events</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">remove</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">nr_events</span> <span class="o">!=</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">nr_active</span><span class="p">)</span>
			<span class="n">rotate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">remove</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_events</span> <span class="o">!=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_active</span><span class="p">)</span>
			<span class="n">rotate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rotate</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">perf_ctx_lock</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span><span class="p">);</span>
	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">pmu</span><span class="p">);</span>

	<span class="n">cpu_ctx_sched_out</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">EVENT_FLEXIBLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
		<span class="n">ctx_sched_out</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cpuctx</span><span class="p">,</span> <span class="n">EVENT_FLEXIBLE</span><span class="p">);</span>

	<span class="n">rotate_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
		<span class="n">rotate_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="n">perf_event_sched_in</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">pmu</span><span class="p">);</span>
	<span class="n">perf_ctx_unlock</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">remove</span><span class="p">)</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">rotation_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">perf_event_task_tick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">rotation_list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">throttled</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">perf_throttled_seq</span><span class="p">);</span>
	<span class="n">throttled</span> <span class="o">=</span> <span class="n">__this_cpu_xchg</span><span class="p">(</span><span class="n">perf_throttled_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">rotation_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
		<span class="n">perf_adjust_freq_unthr_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">throttled</span><span class="p">);</span>

		<span class="n">ctx</span> <span class="o">=</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
			<span class="n">perf_adjust_freq_unthr_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">throttled</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">jiffies_interval</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span>
				<span class="o">!</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">%</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">jiffies_interval</span><span class="p">))</span>
			<span class="n">perf_rotate_context</span><span class="p">(</span><span class="n">cpuctx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">event_enable_on_exec</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">enable_on_exec</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">enable_on_exec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">__perf_event_mark_enabled</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable all of a task&#39;s events that have been marked enable-on-exec.</span>
<span class="cm"> * This expects task == current.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_enable_on_exec</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span> <span class="o">||</span> <span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must ctxsw out cgroup events to avoid conflict</span>
<span class="cm">	 * when invoking perf_task_event_sched_in() later on</span>
<span class="cm">	 * in this function. Otherwise we end up trying to</span>
<span class="cm">	 * ctxswin cgroup events which are already scheduled</span>
<span class="cm">	 * in.</span>
<span class="cm">	 */</span>
	<span class="n">perf_cgroup_sched_out</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">task_ctx_sched_out</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">,</span> <span class="n">event_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">event_enable_on_exec</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unclone this context if we enabled any event.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enabled</span><span class="p">)</span>
		<span class="n">unclone_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Also calls ctxswin for cgroup events, if any:</span>
<span class="cm">	 */</span>
	<span class="n">perf_event_context_sched_in</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cross CPU call to read the hardware event</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__perf_event_read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span> <span class="o">=</span> <span class="n">__get_cpu_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a task context, we need to check whether it is</span>
<span class="cm">	 * the current task context of this cpu.  If not it has been</span>
<span class="cm">	 * scheduled out before the smp call arrived.  In that case</span>
<span class="cm">	 * event-&gt;count would have been updated to a recent sample</span>
<span class="cm">	 * when the event was scheduled out.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">&amp;&amp;</span> <span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">task_ctx</span> <span class="o">!=</span> <span class="n">ctx</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">is_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">update_context_time</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">update_cgrp_time_from_event</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">update_event_times</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">PERF_EVENT_STATE_ACTIVE</span><span class="p">)</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">perf_event_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">+</span> <span class="n">atomic64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">child_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">perf_event_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If event is enabled and currently active on a CPU, update the</span>
<span class="cm">	 * value in the event structure:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">PERF_EVENT_STATE_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">oncpu</span><span class="p">,</span>
					 <span class="n">__perf_event_read</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * may read while context is not active</span>
<span class="cm">		 * (e.g., thread is blocked), in that case</span>
<span class="cm">		 * we cannot update context time</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">is_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">update_context_time</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
			<span class="n">update_cgrp_time_from_event</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">update_event_times</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">perf_event_count</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the perf_event context in a task_struct:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__perf_event_init_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pinned_groups</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flexible_groups</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span>
<span class="nf">alloc_perf_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">__perf_event_init_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>
		<span class="n">get_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pmu</span> <span class="o">=</span> <span class="n">pmu</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ctx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span>
<span class="nf">find_lively_task_by_vpid</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">vpid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vpid</span><span class="p">)</span>
		<span class="n">task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">task</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">vpid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span>
		<span class="n">get_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ESRCH</span><span class="p">);</span>

	<span class="cm">/* Reuse ptrace permission checks for now. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptrace_may_access</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PTRACE_MODE_READ</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">task</span><span class="p">;</span>
<span class="nl">errout:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns a matching context with refcount and pincount.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span>
<span class="nf">find_get_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctxn</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Must be root to operate on a CPU event: */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">perf_paranoid_cpu</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EACCES</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We could be clever and allow to attach a event to an</span>
<span class="cm">		 * offline CPU and activate it when the CPU comes up, but</span>
<span class="cm">		 * that&#39;s for later.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

		<span class="n">cpuctx</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
		<span class="n">get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="o">++</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pin_count</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">ctxn</span> <span class="o">=</span> <span class="n">pmu</span><span class="o">-&gt;</span><span class="n">task_ctx_nr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctxn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="n">perf_lock_task_context</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ctxn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unclone_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="o">++</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pin_count</span><span class="p">;</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="n">alloc_perf_context</span><span class="p">(</span><span class="n">pmu</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">perf_event_mutex</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If it has already passed perf_event_exit_task().</span>
<span class="cm">		 * we must see PF_EXITING, it takes this mutex too.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">])</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
			<span class="o">++</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pin_count</span><span class="p">;</span>
			<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">],</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">perf_event_mutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">put_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ctx</span><span class="p">;</span>

<span class="nl">errout:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">perf_event_free_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_event_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">perf_event</span><span class="p">,</span> <span class="n">rcu_head</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">)</span>
		<span class="n">put_pid_ns</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">);</span>
	<span class="n">perf_event_free_filter</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ring_buffer_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">rb</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attach_state</span> <span class="o">&amp;</span> <span class="n">PERF_ATTACH_TASK</span><span class="p">)</span>
			<span class="n">static_key_slow_dec_deferred</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perf_sched_events</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mmap</span> <span class="o">||</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mmap_data</span><span class="p">)</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_mmap_events</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">comm</span><span class="p">)</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_comm_events</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">task</span><span class="p">)</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_task_events</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_CALLCHAIN</span><span class="p">)</span>
			<span class="n">put_callchain_buffers</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_cgroup_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">perf_cgroup_events</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">));</span>
			<span class="n">static_key_slow_dec_deferred</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perf_sched_events</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">has_branch_stack</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">static_key_slow_dec_deferred</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perf_sched_events</span><span class="p">);</span>
			<span class="cm">/* is system-wide event */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attach_state</span> <span class="o">&amp;</span> <span class="n">PERF_ATTACH_TASK</span><span class="p">))</span>
				<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">perf_branch_stack_events</span><span class="p">,</span>
						    <span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ring_buffer_put</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_cgroup_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="n">perf_detach_cgroup</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">)</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">)</span>
		<span class="n">put_ctx</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">);</span>

	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rcu_head</span><span class="p">,</span> <span class="n">free_event_rcu</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">perf_event_release_kernel</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * There are two ways this annotation is useful:</span>
<span class="cm">	 *</span>
<span class="cm">	 *  1) there is a lock recursion from perf_event_exit_task</span>
<span class="cm">	 *     see the comment there.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  2) there is a lock-inversion with mmap_sem through</span>
<span class="cm">	 *     perf_event_read_group(), which takes faults while</span>
<span class="cm">	 *     holding ctx-&gt;mutex, however this is called after</span>
<span class="cm">	 *     the last filedesc died, so there is no possibility</span>
<span class="cm">	 *     to trigger the AB-BA case.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>
	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">perf_group_detach</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">perf_remove_from_context</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">free_event</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">perf_event_release_kernel</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Called when the last reference to the file is gone.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">owner</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Matches the smp_wmb() in perf_event_exit_task(). If we observe</span>
<span class="cm">	 * !owner it means the list deletion is complete and we can indeed</span>
<span class="cm">	 * free this event, otherwise we need to serialize on</span>
<span class="cm">	 * owner-&gt;perf_event_mutex.</span>
<span class="cm">	 */</span>
	<span class="n">smp_read_barrier_depends</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">owner</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Since delayed_put_task_struct() also drops the last</span>
<span class="cm">		 * task reference we can safely take a new reference</span>
<span class="cm">		 * while holding the rcu_read_lock().</span>
<span class="cm">		 */</span>
		<span class="n">get_task_struct</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">owner</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">perf_event_mutex</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We have to re-check the event-&gt;owner field, if it is cleared</span>
<span class="cm">		 * we raced with perf_event_exit_task(), acquiring the mutex</span>
<span class="cm">		 * ensured they&#39;re done, and we can proceed with freeing the</span>
<span class="cm">		 * event.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">)</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">owner_entry</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">perf_event_mutex</span><span class="p">);</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">perf_event_release_kernel</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="nf">perf_event_read_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">enabled</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">running</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">child_mutex</span><span class="p">);</span>
	<span class="n">total</span> <span class="o">+=</span> <span class="n">perf_event_read</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="o">*</span><span class="n">enabled</span> <span class="o">+=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">total_time_enabled</span> <span class="o">+</span>
			<span class="n">atomic64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">child_total_time_enabled</span><span class="p">);</span>
	<span class="o">*</span><span class="n">running</span> <span class="o">+=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">total_time_running</span> <span class="o">+</span>
			<span class="n">atomic64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">child_total_time_running</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">child_list</span><span class="p">,</span> <span class="n">child_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">perf_event_read</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
		<span class="o">*</span><span class="n">enabled</span> <span class="o">+=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">total_time_enabled</span><span class="p">;</span>
		<span class="o">*</span><span class="n">running</span> <span class="o">+=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">total_time_running</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">child_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">perf_event_read_value</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_event_read_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				   <span class="n">u64</span> <span class="n">read_format</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">leader</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">,</span> <span class="o">*</span><span class="n">sub</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">leader</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">values</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">count</span><span class="p">,</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">running</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">perf_event_read_value</span><span class="p">(</span><span class="n">leader</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">enabled</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">running</span><span class="p">);</span>

	<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">leader</span><span class="o">-&gt;</span><span class="n">nr_siblings</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_TOTAL_TIME_ENABLED</span><span class="p">)</span>
		<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">enabled</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_TOTAL_TIME_RUNNING</span><span class="p">)</span>
		<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">running</span><span class="p">;</span>
	<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_ID</span><span class="p">)</span>
		<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">primary_event_id</span><span class="p">(</span><span class="n">leader</span><span class="p">);</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">leader</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">perf_event_read_value</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">enabled</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">running</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_ID</span><span class="p">)</span>
			<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">primary_event_id</span><span class="p">(</span><span class="n">sub</span><span class="p">);</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">ret</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_event_read_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">read_format</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">running</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">values</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">perf_event_read_value</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">enabled</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">running</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_TOTAL_TIME_ENABLED</span><span class="p">)</span>
		<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">enabled</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_TOTAL_TIME_RUNNING</span><span class="p">)</span>
		<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">running</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_ID</span><span class="p">)</span>
		<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">primary_event_id</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read the performance event - simple non blocking version for now</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">perf_read_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">read_format</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">read_format</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return end-of-file for a read on a event that is in</span>
<span class="cm">	 * error state (i.e. because it was pinned but it couldn&#39;t be</span>
<span class="cm">	 * scheduled on to the CPU at some point).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">PERF_EVENT_STATE_ERROR</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">read_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_GROUP</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">perf_event_read_group</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">read_format</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">perf_event_read_one</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">read_format</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">perf_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">perf_read_hw</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">perf_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">rb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">events</span> <span class="o">=</span> <span class="n">POLL_HUP</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Race between perf_event_set_output() and perf_poll(): perf_poll()</span>
<span class="cm">	 * grabs the rb reference but perf_event_set_output() overrides it.</span>
<span class="cm">	 * Here is the timeline for two threads T1, T2:</span>
<span class="cm">	 * t0: T1, rb = rcu_dereference(event-&gt;rb)</span>
<span class="cm">	 * t1: T2, old_rb = event-&gt;rb</span>
<span class="cm">	 * t2: T2, event-&gt;rb = new rb</span>
<span class="cm">	 * t3: T2, ring_buffer_detach(old_rb)</span>
<span class="cm">	 * t4: T1, ring_buffer_attach(rb1)</span>
<span class="cm">	 * t5: T1, poll_wait(event-&gt;waitq)</span>
<span class="cm">	 *</span>
<span class="cm">	 * To avoid this problem, we grab mmap_mutex in perf_poll()</span>
<span class="cm">	 * thereby ensuring that the assignment of the new ring buffer</span>
<span class="cm">	 * and the detachment of the old buffer appear atomic to perf_poll()</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_mutex</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">rb</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ring_buffer_attach</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="n">events</span> <span class="o">=</span> <span class="n">atomic_xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_mutex</span><span class="p">);</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">events</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">perf_event_read</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Holding the top-level event&#39;s child_mutex means that any</span>
<span class="cm"> * descendant process that has inherited this event will block</span>
<span class="cm"> * in sync_child_event if it goes to exit, thus satisfying the</span>
<span class="cm"> * task existence requirements of perf_event_enable/disable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_for_each_child</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
					<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">child_mutex</span><span class="p">);</span>
	<span class="n">func</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">child_list</span><span class="p">,</span> <span class="n">child_list</span><span class="p">)</span>
		<span class="n">func</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">child_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_for_each</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">sibling</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">;</span>

	<span class="n">perf_event_for_each_child</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sibling</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span>
		<span class="n">perf_event_for_each_child</span><span class="p">(</span><span class="n">sibling</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_event_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">u64</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_sampling_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">value</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">sysctl_perf_event_sample_rate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_freq</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_period</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_period</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">unlock:</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">perf_fops</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="nf">perf_fget_light</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">fput_needed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">fget_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EBADF</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">perf_fops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fput_light</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">*</span><span class="n">fput_needed</span><span class="p">);</span>
		<span class="o">*</span><span class="n">fput_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EBADF</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">perf_event_set_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">output_event</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">perf_event_set_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">perf_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PERF_EVENT_IOC_ENABLE</span>:
		<span class="n">func</span> <span class="o">=</span> <span class="n">perf_event_enable</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PERF_EVENT_IOC_DISABLE</span>:
		<span class="n">func</span> <span class="o">=</span> <span class="n">perf_event_disable</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PERF_EVENT_IOC_RESET</span>:
		<span class="n">func</span> <span class="o">=</span> <span class="n">perf_event_reset</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PERF_EVENT_IOC_REFRESH</span>:
		<span class="k">return</span> <span class="n">perf_event_refresh</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">PERF_EVENT_IOC_PERIOD</span>:
		<span class="k">return</span> <span class="n">perf_event_period</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">PERF_EVENT_IOC_SET_OUTPUT</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">output_event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">fput_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">output_event</span> <span class="o">=</span> <span class="n">perf_fget_light</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">output_event</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">output_event</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">perf_event_set_output</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">output_event</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">output_event</span><span class="p">)</span>
			<span class="n">fput_light</span><span class="p">(</span><span class="n">output_event</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">PERF_EVENT_IOC_SET_FILTER</span>:
		<span class="k">return</span> <span class="n">perf_event_set_filter</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_IOC_FLAG_GROUP</span><span class="p">)</span>
		<span class="n">perf_event_for_each</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">perf_event_for_each_child</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">perf_event_task_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">perf_event_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">perf_event_list</span><span class="p">,</span> <span class="n">owner_entry</span><span class="p">)</span>
		<span class="n">perf_event_for_each_child</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">perf_event_enable</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">perf_event_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">perf_event_task_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">perf_event_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">perf_event_list</span><span class="p">,</span> <span class="n">owner_entry</span><span class="p">)</span>
		<span class="n">perf_event_for_each_child</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">perf_event_disable</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">perf_event_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_event_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">PERF_EVENT_STATE_ACTIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">event_idx</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">calc_timer_values</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				<span class="n">u64</span> <span class="o">*</span><span class="n">now</span><span class="p">,</span>
				<span class="n">u64</span> <span class="o">*</span><span class="n">enabled</span><span class="p">,</span>
				<span class="n">u64</span> <span class="o">*</span><span class="n">running</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ctx_time</span><span class="p">;</span>

	<span class="o">*</span><span class="n">now</span> <span class="o">=</span> <span class="n">perf_clock</span><span class="p">();</span>
	<span class="n">ctx_time</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">shadow_ctx_time</span> <span class="o">+</span> <span class="o">*</span><span class="n">now</span><span class="p">;</span>
	<span class="o">*</span><span class="n">enabled</span> <span class="o">=</span> <span class="n">ctx_time</span> <span class="o">-</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_enabled</span><span class="p">;</span>
	<span class="o">*</span><span class="n">running</span> <span class="o">=</span> <span class="n">ctx_time</span> <span class="o">-</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">tstamp_running</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__weak</span> <span class="nf">arch_perf_update_userpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_mmap_page</span> <span class="o">*</span><span class="n">userpg</span><span class="p">,</span> <span class="n">u64</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Callers need to ensure there can be no nesting of this function, otherwise</span>
<span class="cm"> * the seqlock logic goes bad. We can not serialize this because the arch</span>
<span class="cm"> * code calls this from NMI context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">perf_event_update_userpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_mmap_page</span> <span class="o">*</span><span class="n">userpg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">rb</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">running</span><span class="p">,</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * compute total_time_enabled, total_time_running</span>
<span class="cm">	 * based on snapshot values taken when the event</span>
<span class="cm">	 * was last scheduled in.</span>
<span class="cm">	 *</span>
<span class="cm">	 * we cannot simply called update_context_time()</span>
<span class="cm">	 * because of locking issue as we can be called in</span>
<span class="cm">	 * NMI context</span>
<span class="cm">	 */</span>
	<span class="n">calc_timer_values</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">enabled</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">running</span><span class="p">);</span>
	<span class="n">rb</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">userpg</span> <span class="o">=</span> <span class="n">rb</span><span class="o">-&gt;</span><span class="n">user_page</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable preemption so as to not let the corresponding user-space</span>
<span class="cm">	 * spin too long if we get preempted.</span>
<span class="cm">	 */</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="o">++</span><span class="n">userpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">barrier</span><span class="p">();</span>
	<span class="n">userpg</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">perf_event_index</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">userpg</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">perf_event_count</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">userpg</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span>
		<span class="n">userpg</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">-=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">);</span>

	<span class="n">userpg</span><span class="o">-&gt;</span><span class="n">time_enabled</span> <span class="o">=</span> <span class="n">enabled</span> <span class="o">+</span>
			<span class="n">atomic64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">child_total_time_enabled</span><span class="p">);</span>

	<span class="n">userpg</span><span class="o">-&gt;</span><span class="n">time_running</span> <span class="o">=</span> <span class="n">running</span> <span class="o">+</span>
			<span class="n">atomic64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">child_total_time_running</span><span class="p">);</span>

	<span class="n">arch_perf_update_userpage</span><span class="p">(</span><span class="n">userpg</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>

	<span class="n">barrier</span><span class="p">();</span>
	<span class="o">++</span><span class="n">userpg</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="nl">unlock:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_mmap_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">rb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_MKWRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pgoff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">rb</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pgoff</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">perf_mmap_to_page</span><span class="p">(</span><span class="n">rb</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pgoff</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">get_page</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
	<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span>   <span class="o">=</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pgoff</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">unlock:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ring_buffer_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">rb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb_entry</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb_entry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">);</span>
<span class="nl">unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ring_buffer_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">rb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb_entry</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb_entry</span><span class="p">);</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ring_buffer_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">rb</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">rb</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">,</span> <span class="n">rb_entry</span><span class="p">)</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">);</span>

<span class="nl">unlock:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rb_free_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rcu_head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">rb</span><span class="p">;</span>

	<span class="n">rb</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rcu_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ring_buffer</span><span class="p">,</span> <span class="n">rcu_head</span><span class="p">);</span>
	<span class="n">rb_free</span><span class="p">(</span><span class="n">rb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="nf">ring_buffer_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">rb</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">rb</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
			<span class="n">rb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">rb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ring_buffer_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">rb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">,</span> <span class="n">rb_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb_entry</span><span class="p">);</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">event_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">rcu_head</span><span class="p">,</span> <span class="n">rb_free_rcu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_mmap_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_mmap_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_mutex</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">perf_data_size</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_user</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">rb</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">;</span>

		<span class="n">atomic_long_sub</span><span class="p">((</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">locked_vm</span><span class="p">);</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">pinned_vm</span> <span class="o">-=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_locked</span><span class="p">;</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">ring_buffer_detach</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_mutex</span><span class="p">);</span>

		<span class="n">ring_buffer_put</span><span class="p">(</span><span class="n">rb</span><span class="p">);</span>
		<span class="n">free_uid</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">perf_mmap_vmops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">perf_mmap_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>		<span class="o">=</span> <span class="n">perf_mmap_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fault</span>		<span class="o">=</span> <span class="n">perf_mmap_fault</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_mkwrite</span>	<span class="o">=</span> <span class="n">perf_mmap_fault</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">user_locked</span><span class="p">,</span> <span class="n">user_lock_limit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span> <span class="o">=</span> <span class="n">current_user</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">locked</span><span class="p">,</span> <span class="n">lock_limit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">rb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vma_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">user_extra</span><span class="p">,</span> <span class="n">extra</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t allow mmap() of inherited per-task counters. This would</span>
<span class="cm">	 * create a performance issue due to all children writing to the</span>
<span class="cm">	 * same rb.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">inherit</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">vma_size</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="n">nr_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">vma_size</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have rb pages ensure they&#39;re a power-of-two number, so we</span>
<span class="cm">	 * can do bitmasks instead of modulo.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">nr_pages</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma_size</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nr_pages</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="n">nr_pages</span><span class="p">)</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">user_extra</span> <span class="o">=</span> <span class="n">nr_pages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">user_lock_limit</span> <span class="o">=</span> <span class="n">sysctl_perf_event_mlock</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">10</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Increase the limit linearly with more CPUs:</span>
<span class="cm">	 */</span>
	<span class="n">user_lock_limit</span> <span class="o">*=</span> <span class="n">num_online_cpus</span><span class="p">();</span>

	<span class="n">user_locked</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">locked_vm</span><span class="p">)</span> <span class="o">+</span> <span class="n">user_extra</span><span class="p">;</span>

	<span class="n">extra</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_locked</span> <span class="o">&gt;</span> <span class="n">user_lock_limit</span><span class="p">)</span>
		<span class="n">extra</span> <span class="o">=</span> <span class="n">user_locked</span> <span class="o">-</span> <span class="n">user_lock_limit</span><span class="p">;</span>

	<span class="n">lock_limit</span> <span class="o">=</span> <span class="n">rlimit</span><span class="p">(</span><span class="n">RLIMIT_MEMLOCK</span><span class="p">);</span>
	<span class="n">lock_limit</span> <span class="o">&gt;&gt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">locked</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">pinned_vm</span> <span class="o">+</span> <span class="n">extra</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">locked</span> <span class="o">&gt;</span> <span class="n">lock_limit</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">perf_paranoid_tracepoint_raw</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_IPC_LOCK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">RING_BUFFER_WRITABLE</span><span class="p">;</span>

	<span class="n">rb</span> <span class="o">=</span> <span class="n">rb_alloc</span><span class="p">(</span><span class="n">nr_pages</span><span class="p">,</span> 
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">watermark</span> <span class="o">?</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">wakeup_watermark</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>

	<span class="n">atomic_long_add</span><span class="p">(</span><span class="n">user_extra</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">locked_vm</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_locked</span> <span class="o">=</span> <span class="n">extra</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_user</span> <span class="o">=</span> <span class="n">get_current_user</span><span class="p">();</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">pinned_vm</span> <span class="o">+=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_locked</span><span class="p">;</span>

	<span class="n">perf_event_update_userpage</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

<span class="nl">unlock:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_count</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_mutex</span><span class="p">);</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_RESERVED</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">perf_mmap_vmops</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">fasync_helper</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">fasync</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">perf_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">llseek</span>			<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">perf_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>			<span class="o">=</span> <span class="n">perf_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>			<span class="o">=</span> <span class="n">perf_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>		<span class="o">=</span> <span class="n">perf_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>		<span class="o">=</span> <span class="n">perf_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>			<span class="o">=</span> <span class="n">perf_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fasync</span>			<span class="o">=</span> <span class="n">perf_fasync</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Perf event wakeup</span>
<span class="cm"> *</span>
<span class="cm"> * If there&#39;s data, ensure we set the poll() state and publish everything</span>
<span class="cm"> * to user-space before waking everybody up.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">perf_event_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ring_buffer_wakeup</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pending_kill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">fasync</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">pending_kill</span><span class="p">);</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">pending_kill</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_pending_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_work</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">perf_event</span><span class="p">,</span> <span class="n">pending</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pending_disable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">pending_disable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">__perf_event_disable</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pending_wakeup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">pending_wakeup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">perf_event_wakeup</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We assume there is only KVM supporting the callbacks.</span>
<span class="cm"> * Later on, we might change it to a list if there is</span>
<span class="cm"> * another virtualization implementation supporting the callbacks.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">perf_guest_info_callbacks</span> <span class="o">*</span><span class="n">perf_guest_cbs</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">perf_register_guest_info_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_guest_info_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">perf_guest_cbs</span> <span class="o">=</span> <span class="n">cbs</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">perf_register_guest_info_callbacks</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">perf_unregister_guest_info_callbacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_guest_info_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">perf_guest_cbs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">perf_unregister_guest_info_callbacks</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__perf_event_header__init_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_header</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">sample_type</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_type</span><span class="p">;</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">sample_type</span><span class="p">;</span>
	<span class="n">header</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">id_header_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_TID</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* namespace issues */</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">tid_entry</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">perf_event_pid</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">tid_entry</span><span class="p">.</span><span class="n">tid</span> <span class="o">=</span> <span class="n">perf_event_tid</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_TIME</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="n">perf_clock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_ID</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">primary_event_id</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_STREAM_ID</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">stream_id</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_CPU</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">cpu_entry</span><span class="p">.</span><span class="n">cpu</span>	 <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">cpu_entry</span><span class="p">.</span><span class="n">reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">perf_event_header__init_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_header</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_id_all</span><span class="p">)</span>
		<span class="n">__perf_event_header__init_id</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__perf_event__output_id_sample</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_output_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">sample_type</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_TID</span><span class="p">)</span>
		<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">tid_entry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_TIME</span><span class="p">)</span>
		<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_ID</span><span class="p">)</span>
		<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_STREAM_ID</span><span class="p">)</span>
		<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_CPU</span><span class="p">)</span>
		<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">cpu_entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">perf_event__output_id_sample</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">perf_output_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">sample</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_id_all</span><span class="p">)</span>
		<span class="n">__perf_event__output_id_sample</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">sample</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_output_read_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_output_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">u64</span> <span class="n">running</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">read_format</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">read_format</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">values</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">perf_event_count</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_TOTAL_TIME_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">enabled</span> <span class="o">+</span>
			<span class="n">atomic64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">child_total_time_enabled</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_TOTAL_TIME_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">running</span> <span class="o">+</span>
			<span class="n">atomic64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">child_total_time_running</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_ID</span><span class="p">)</span>
		<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">primary_event_id</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="n">__output_copy</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * XXX PERF_FORMAT_GROUP vs inherited events seems difficult.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_output_read_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_output_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			    <span class="n">u64</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">u64</span> <span class="n">running</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">leader</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">,</span> <span class="o">*</span><span class="n">sub</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">read_format</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">read_format</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">values</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">leader</span><span class="o">-&gt;</span><span class="n">nr_siblings</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_TOTAL_TIME_ENABLED</span><span class="p">)</span>
		<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">enabled</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_TOTAL_TIME_RUNNING</span><span class="p">)</span>
		<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">running</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">leader</span> <span class="o">!=</span> <span class="n">event</span><span class="p">)</span>
		<span class="n">leader</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">leader</span><span class="p">);</span>

	<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">perf_event_count</span><span class="p">(</span><span class="n">leader</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_ID</span><span class="p">)</span>
		<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">primary_event_id</span><span class="p">(</span><span class="n">leader</span><span class="p">);</span>

	<span class="n">__output_copy</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">leader</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sub</span> <span class="o">!=</span> <span class="n">event</span><span class="p">)</span>
			<span class="n">sub</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">sub</span><span class="p">);</span>

		<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">perf_event_count</span><span class="p">(</span><span class="n">sub</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_ID</span><span class="p">)</span>
			<span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">primary_event_id</span><span class="p">(</span><span class="n">sub</span><span class="p">);</span>

		<span class="n">__output_copy</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define PERF_FORMAT_TOTAL_TIMES (PERF_FORMAT_TOTAL_TIME_ENABLED|\</span>
<span class="cp">				 PERF_FORMAT_TOTAL_TIME_RUNNING)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_output_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_output_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">now</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">read_format</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">read_format</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * compute total_time_enabled, total_time_running</span>
<span class="cm">	 * based on snapshot values taken when the event</span>
<span class="cm">	 * was last scheduled in.</span>
<span class="cm">	 *</span>
<span class="cm">	 * we cannot simply called update_context_time()</span>
<span class="cm">	 * because of locking issue as we are called in</span>
<span class="cm">	 * NMI context</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_TOTAL_TIMES</span><span class="p">)</span>
		<span class="n">calc_timer_values</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">enabled</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">running</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_GROUP</span><span class="p">)</span>
		<span class="n">perf_output_read_group</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">running</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">perf_output_read_one</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">running</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">perf_output_sample</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_output_handle</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">perf_event_header</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">sample_type</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

	<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="o">*</span><span class="n">header</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_IP</span><span class="p">)</span>
		<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_TID</span><span class="p">)</span>
		<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">tid_entry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_TIME</span><span class="p">)</span>
		<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_ADDR</span><span class="p">)</span>
		<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_ID</span><span class="p">)</span>
		<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_STREAM_ID</span><span class="p">)</span>
		<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">stream_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_CPU</span><span class="p">)</span>
		<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">cpu_entry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_PERIOD</span><span class="p">)</span>
		<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_READ</span><span class="p">)</span>
		<span class="n">perf_output_read</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_CALLCHAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">callchain</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">callchain</span><span class="p">)</span>
				<span class="n">size</span> <span class="o">+=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">callchain</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span>

			<span class="n">size</span> <span class="o">*=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>

			<span class="n">__output_copy</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">callchain</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_RAW</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">raw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="n">__output_copy</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">raw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
					   <span class="n">data</span><span class="o">-&gt;</span><span class="n">raw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="p">{</span>
				<span class="n">u32</span>	<span class="n">size</span><span class="p">;</span>
				<span class="n">u32</span>	<span class="n">data</span><span class="p">;</span>
			<span class="p">}</span> <span class="n">raw</span> <span class="o">=</span> <span class="p">{</span>
				<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
				<span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">};</span>
			<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">raw</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">watermark</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">wakeup_events</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">wakeup_events</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wakeup_events</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">rb</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">events</span> <span class="o">=</span> <span class="n">local_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&gt;=</span> <span class="n">wakeup_events</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">local_sub</span><span class="p">(</span><span class="n">wakeup_events</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>
				<span class="n">local_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">wakeup</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_BRANCH_STACK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">br_stack</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

			<span class="n">size</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">br_stack</span><span class="o">-&gt;</span><span class="n">nr</span>
			     <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_branch_entry</span><span class="p">);</span>

			<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">br_stack</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
			<span class="n">perf_output_copy</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">br_stack</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * we always store at least the value of nr</span>
<span class="cm">			 */</span>
			<span class="n">u64</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">perf_output_put</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">perf_prepare_sample</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_header</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">sample_type</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_type</span><span class="p">;</span>

	<span class="n">header</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">PERF_RECORD_SAMPLE</span><span class="p">;</span>
	<span class="n">header</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">header</span><span class="p">)</span> <span class="o">+</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">header_size</span><span class="p">;</span>

	<span class="n">header</span><span class="o">-&gt;</span><span class="n">misc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">header</span><span class="o">-&gt;</span><span class="n">misc</span> <span class="o">|=</span> <span class="n">perf_misc_flags</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="n">__perf_event_header__init_id</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_IP</span><span class="p">)</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">perf_instruction_pointer</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_CALLCHAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">data</span><span class="o">-&gt;</span><span class="n">callchain</span> <span class="o">=</span> <span class="n">perf_callchain</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">callchain</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">+=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">callchain</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span>

		<span class="n">header</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_RAW</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">+=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">raw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>

		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
		<span class="n">header</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_BRANCH_STACK</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span> <span class="cm">/* nr */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">br_stack</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">size</span> <span class="o">+=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">br_stack</span><span class="o">-&gt;</span><span class="n">nr</span>
			      <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_branch_entry</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">header</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_output_handle</span> <span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_header</span> <span class="n">header</span><span class="p">;</span>

	<span class="cm">/* protect the callchain buffers */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">perf_prepare_sample</span><span class="p">(</span><span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">perf_output_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">perf_output_sample</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="n">perf_output_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>

<span class="nl">exit:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * read event_id</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">perf_read_event</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_header</span>	<span class="n">header</span><span class="p">;</span>

	<span class="n">u32</span>				<span class="n">pid</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">tid</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">perf_event_read_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_output_handle</span> <span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="n">sample</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_read_event</span> <span class="n">read_event</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">header</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">PERF_RECORD_READ</span><span class="p">,</span>
			<span class="p">.</span><span class="n">misc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">read_event</span><span class="p">)</span> <span class="o">+</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">read_size</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">perf_event_pid</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">task</span><span class="p">),</span>
		<span class="p">.</span><span class="n">tid</span> <span class="o">=</span> <span class="n">perf_event_tid</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">task</span><span class="p">),</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">perf_event_header__init_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">read_event</span><span class="p">.</span><span class="n">header</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">perf_output_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">read_event</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">perf_output_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">read_event</span><span class="p">);</span>
	<span class="n">perf_output_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
	<span class="n">perf_event__output_id_sample</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">);</span>

	<span class="n">perf_output_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * task tracking -- fork/exit</span>
<span class="cm"> *</span>
<span class="cm"> * enabled by: attr.comm | attr.mmap | attr.mmap_data | attr.task</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">perf_task_event</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span>		<span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span>	<span class="o">*</span><span class="n">task_ctx</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">perf_event_header</span>	<span class="n">header</span><span class="p">;</span>

		<span class="n">u32</span>				<span class="n">pid</span><span class="p">;</span>
		<span class="n">u32</span>				<span class="n">ppid</span><span class="p">;</span>
		<span class="n">u32</span>				<span class="n">tid</span><span class="p">;</span>
		<span class="n">u32</span>				<span class="n">ptid</span><span class="p">;</span>
		<span class="n">u64</span>				<span class="n">time</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">event_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_task_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">perf_task_event</span> <span class="o">*</span><span class="n">task_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_output_handle</span> <span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_sample_data</span>	<span class="n">sample</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">task_event</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">task_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>

	<span class="n">perf_event_header__init_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">header</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">perf_output_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span>
				<span class="n">task_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">task_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">perf_event_pid</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="n">task_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">ppid</span> <span class="o">=</span> <span class="n">perf_event_pid</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">task_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">tid</span> <span class="o">=</span> <span class="n">perf_event_tid</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="n">task_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">ptid</span> <span class="o">=</span> <span class="n">perf_event_tid</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">perf_output_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">task_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">);</span>

	<span class="n">perf_event__output_id_sample</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">);</span>

	<span class="n">perf_output_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">task_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_event_task_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event_filter_match</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">comm</span> <span class="o">||</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mmap</span> <span class="o">||</span>
	    <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mmap_data</span> <span class="o">||</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_task_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">perf_task_event</span> <span class="o">*</span><span class="n">task_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">,</span> <span class="n">event_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">perf_event_task_match</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
			<span class="n">perf_event_task_output</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">task_event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_task_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_task_event</span> <span class="o">*</span><span class="n">task_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctxn</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">pmu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmus</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpuctx</span> <span class="o">=</span> <span class="n">get_cpu_ptr</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">active_pmu</span> <span class="o">!=</span> <span class="n">pmu</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="n">perf_event_task_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">task_event</span><span class="p">);</span>

		<span class="n">ctx</span> <span class="o">=</span> <span class="n">task_event</span><span class="o">-&gt;</span><span class="n">task_ctx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ctxn</span> <span class="o">=</span> <span class="n">pmu</span><span class="o">-&gt;</span><span class="n">task_ctx_nr</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ctxn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
			<span class="n">ctx</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
			<span class="n">perf_event_task_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">task_event</span><span class="p">);</span>
<span class="nl">next:</span>
		<span class="n">put_cpu_ptr</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">task_ctx</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_task_event</span> <span class="n">task_event</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_comm_events</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_mmap_events</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_task_events</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">task_event</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">perf_task_event</span><span class="p">){</span>
		<span class="p">.</span><span class="n">task</span>	  <span class="o">=</span> <span class="n">task</span><span class="p">,</span>
		<span class="p">.</span><span class="n">task_ctx</span> <span class="o">=</span> <span class="n">task_ctx</span><span class="p">,</span>
		<span class="p">.</span><span class="n">event_id</span>    <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">header</span> <span class="o">=</span> <span class="p">{</span>
				<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">new</span> <span class="o">?</span> <span class="n">PERF_RECORD_FORK</span> <span class="o">:</span> <span class="n">PERF_RECORD_EXIT</span><span class="p">,</span>
				<span class="p">.</span><span class="n">misc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
				<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">task_event</span><span class="p">.</span><span class="n">event_id</span><span class="p">),</span>
			<span class="p">},</span>
			<span class="cm">/* .pid  */</span>
			<span class="cm">/* .ppid */</span>
			<span class="cm">/* .tid  */</span>
			<span class="cm">/* .ptid */</span>
			<span class="p">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">perf_clock</span><span class="p">(),</span>
		<span class="p">},</span>
	<span class="p">};</span>

	<span class="n">perf_event_task_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_event</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">perf_event_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">perf_event_task</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * comm tracking</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">perf_comm_event</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">comm</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">comm_size</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">perf_event_header</span>	<span class="n">header</span><span class="p">;</span>

		<span class="n">u32</span>				<span class="n">pid</span><span class="p">;</span>
		<span class="n">u32</span>				<span class="n">tid</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">event_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_comm_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">perf_comm_event</span> <span class="o">*</span><span class="n">comm_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_output_handle</span> <span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="n">sample</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">comm_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">perf_event_header__init_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">comm_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">header</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">perf_output_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span>
				<span class="n">comm_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">comm_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">perf_event_pid</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">comm_event</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
	<span class="n">comm_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">tid</span> <span class="o">=</span> <span class="n">perf_event_tid</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">comm_event</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>

	<span class="n">perf_output_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">comm_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">);</span>
	<span class="n">__output_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">comm_event</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span>
				   <span class="n">comm_event</span><span class="o">-&gt;</span><span class="n">comm_size</span><span class="p">);</span>

	<span class="n">perf_event__output_id_sample</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">);</span>

	<span class="n">perf_output_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">comm_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_event_comm_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event_filter_match</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">comm</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_comm_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">perf_comm_event</span> <span class="o">*</span><span class="n">comm_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">,</span> <span class="n">event_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">perf_event_comm_match</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
			<span class="n">perf_event_comm_output</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">comm_event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_comm_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_comm_event</span> <span class="o">*</span><span class="n">comm_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">comm</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctxn</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">comm</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">comm_event</span><span class="o">-&gt;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">comm</span><span class="p">));</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">comm</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>

	<span class="n">comm_event</span><span class="o">-&gt;</span><span class="n">comm</span> <span class="o">=</span> <span class="n">comm</span><span class="p">;</span>
	<span class="n">comm_event</span><span class="o">-&gt;</span><span class="n">comm_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">comm_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">comm_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">pmu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmus</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpuctx</span> <span class="o">=</span> <span class="n">get_cpu_ptr</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">active_pmu</span> <span class="o">!=</span> <span class="n">pmu</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="n">perf_event_comm_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">comm_event</span><span class="p">);</span>

		<span class="n">ctxn</span> <span class="o">=</span> <span class="n">pmu</span><span class="o">-&gt;</span><span class="n">task_ctx_nr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctxn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

		<span class="n">ctx</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
			<span class="n">perf_event_comm_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">comm_event</span><span class="p">);</span>
<span class="nl">next:</span>
		<span class="n">put_cpu_ptr</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">perf_event_comm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_comm_event</span> <span class="n">comm_event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctxn</span><span class="p">;</span>

	<span class="n">for_each_task_context_nr</span><span class="p">(</span><span class="n">ctxn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">perf_event_enable_on_exec</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_comm_events</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">comm_event</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">perf_comm_event</span><span class="p">){</span>
		<span class="p">.</span><span class="n">task</span>	<span class="o">=</span> <span class="n">task</span><span class="p">,</span>
		<span class="cm">/* .comm      */</span>
		<span class="cm">/* .comm_size */</span>
		<span class="p">.</span><span class="n">event_id</span>  <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">header</span> <span class="o">=</span> <span class="p">{</span>
				<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">PERF_RECORD_COMM</span><span class="p">,</span>
				<span class="p">.</span><span class="n">misc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
				<span class="cm">/* .size */</span>
			<span class="p">},</span>
			<span class="cm">/* .pid */</span>
			<span class="cm">/* .tid */</span>
		<span class="p">},</span>
	<span class="p">};</span>

	<span class="n">perf_event_comm_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">comm_event</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mmap tracking</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">perf_mmap_event</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span>	<span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">file_name</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">file_size</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">perf_event_header</span>	<span class="n">header</span><span class="p">;</span>

		<span class="n">u32</span>				<span class="n">pid</span><span class="p">;</span>
		<span class="n">u32</span>				<span class="n">tid</span><span class="p">;</span>
		<span class="n">u64</span>				<span class="n">start</span><span class="p">;</span>
		<span class="n">u64</span>				<span class="n">len</span><span class="p">;</span>
		<span class="n">u64</span>				<span class="n">pgoff</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">event_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_mmap_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">perf_mmap_event</span> <span class="o">*</span><span class="n">mmap_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_output_handle</span> <span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="n">sample</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">mmap_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">perf_event_header__init_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmap_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">header</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">perf_output_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span>
				<span class="n">mmap_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mmap_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">perf_event_pid</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="n">mmap_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">tid</span> <span class="o">=</span> <span class="n">perf_event_tid</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">perf_output_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">mmap_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">);</span>
	<span class="n">__output_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">mmap_event</span><span class="o">-&gt;</span><span class="n">file_name</span><span class="p">,</span>
				   <span class="n">mmap_event</span><span class="o">-&gt;</span><span class="n">file_size</span><span class="p">);</span>

	<span class="n">perf_event__output_id_sample</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">);</span>

	<span class="n">perf_output_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mmap_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_event_mmap_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">perf_mmap_event</span> <span class="o">*</span><span class="n">mmap_event</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">executable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event_filter_match</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">executable</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mmap_data</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">executable</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mmap</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_mmap_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">perf_mmap_event</span> <span class="o">*</span><span class="n">mmap_event</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">executable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">event_list</span><span class="p">,</span> <span class="n">event_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">perf_event_mmap_match</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">mmap_event</span><span class="p">,</span> <span class="n">executable</span><span class="p">))</span>
			<span class="n">perf_event_mmap_output</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">mmap_event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_mmap_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_mmap_event</span> <span class="o">*</span><span class="n">mmap_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="n">mmap_event</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctxn</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * d_path works from the end of the rb backwards, so we</span>
<span class="cm">		 * need to add enough zero bytes after the string to handle</span>
<span class="cm">		 * the 64bit alignment we do later.</span>
<span class="cm">		 */</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">PATH_MAX</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">name</span> <span class="o">=</span> <span class="n">strncpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;//enomem&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">got_name</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">d_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">PATH_MAX</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">name</span> <span class="o">=</span> <span class="n">strncpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;//toolong&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">got_name</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arch_vma_name</span><span class="p">(</span><span class="n">mmap_event</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">name</span> <span class="o">=</span> <span class="n">strncpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">arch_vma_name</span><span class="p">(</span><span class="n">mmap_event</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">),</span>
				       <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">got_name</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">name</span> <span class="o">=</span> <span class="n">strncpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;[vdso]&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">got_name</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">start_brk</span> <span class="o">&amp;&amp;</span>
				<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">name</span> <span class="o">=</span> <span class="n">strncpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;[heap]&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">got_name</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">start_stack</span> <span class="o">&amp;&amp;</span>
				<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">start_stack</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">name</span> <span class="o">=</span> <span class="n">strncpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;[stack]&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">got_name</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">name</span> <span class="o">=</span> <span class="n">strncpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;//anon&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">got_name</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">got_name:</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>

	<span class="n">mmap_event</span><span class="o">-&gt;</span><span class="n">file_name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">mmap_event</span><span class="o">-&gt;</span><span class="n">file_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">mmap_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mmap_event</span><span class="o">-&gt;</span><span class="n">event_id</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">pmu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmus</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpuctx</span> <span class="o">=</span> <span class="n">get_cpu_ptr</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">active_pmu</span> <span class="o">!=</span> <span class="n">pmu</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="n">perf_event_mmap_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">mmap_event</span><span class="p">,</span>
					<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXEC</span><span class="p">);</span>

		<span class="n">ctxn</span> <span class="o">=</span> <span class="n">pmu</span><span class="o">-&gt;</span><span class="n">task_ctx_nr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctxn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

		<span class="n">ctx</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">perf_event_mmap_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">mmap_event</span><span class="p">,</span>
					<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXEC</span><span class="p">);</span>
		<span class="p">}</span>
<span class="nl">next:</span>
		<span class="n">put_cpu_ptr</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">perf_event_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_mmap_event</span> <span class="n">mmap_event</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_mmap_events</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mmap_event</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">perf_mmap_event</span><span class="p">){</span>
		<span class="p">.</span><span class="n">vma</span>	<span class="o">=</span> <span class="n">vma</span><span class="p">,</span>
		<span class="cm">/* .file_name */</span>
		<span class="cm">/* .file_size */</span>
		<span class="p">.</span><span class="n">event_id</span>  <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">header</span> <span class="o">=</span> <span class="p">{</span>
				<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">PERF_RECORD_MMAP</span><span class="p">,</span>
				<span class="p">.</span><span class="n">misc</span> <span class="o">=</span> <span class="n">PERF_RECORD_MISC_USER</span><span class="p">,</span>
				<span class="cm">/* .size */</span>
			<span class="p">},</span>
			<span class="cm">/* .pid */</span>
			<span class="cm">/* .tid */</span>
			<span class="p">.</span><span class="n">start</span>  <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span>
			<span class="p">.</span><span class="n">len</span>    <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span>
			<span class="p">.</span><span class="n">pgoff</span>  <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">};</span>

	<span class="n">perf_event_mmap_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmap_event</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * IRQ throttle logging</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_log_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_output_handle</span> <span class="n">handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="n">sample</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">perf_event_header</span>	<span class="n">header</span><span class="p">;</span>
		<span class="n">u64</span>				<span class="n">time</span><span class="p">;</span>
		<span class="n">u64</span>				<span class="n">id</span><span class="p">;</span>
		<span class="n">u64</span>				<span class="n">stream_id</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">throttle_event</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">header</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">PERF_RECORD_THROTTLE</span><span class="p">,</span>
			<span class="p">.</span><span class="n">misc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">throttle_event</span><span class="p">),</span>
		<span class="p">},</span>
		<span class="p">.</span><span class="n">time</span>		<span class="o">=</span> <span class="n">perf_clock</span><span class="p">(),</span>
		<span class="p">.</span><span class="n">id</span>		<span class="o">=</span> <span class="n">primary_event_id</span><span class="p">(</span><span class="n">event</span><span class="p">),</span>
		<span class="p">.</span><span class="n">stream_id</span>	<span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">throttle_event</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">PERF_RECORD_UNTHROTTLE</span><span class="p">;</span>

	<span class="n">perf_event_header__init_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">throttle_event</span><span class="p">.</span><span class="n">header</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">perf_output_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span>
				<span class="n">throttle_event</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">perf_output_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">throttle_event</span><span class="p">);</span>
	<span class="n">perf_event__output_id_sample</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">);</span>
	<span class="n">perf_output_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Generic event overflow handling, sampling.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__perf_event_overflow</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">throttle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">events</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event_limit</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">seq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Non-sampling counters might still use the PMI to fold short</span>
<span class="cm">	 * hardware counters, ignore those.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">is_sampling_event</span><span class="p">(</span><span class="n">event</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">perf_throttled_seq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">seq</span> <span class="o">!=</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">interrupts_seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">interrupts_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">interrupts</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">interrupts</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">throttle</span>
			     <span class="o">&amp;&amp;</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">interrupts</span> <span class="o">&gt;=</span> <span class="n">max_samples_per_tick</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">perf_throttled_count</span><span class="p">);</span>
			<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">interrupts</span> <span class="o">=</span> <span class="n">MAX_INTERRUPTS</span><span class="p">;</span>
			<span class="n">perf_log_throttle</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">now</span> <span class="o">=</span> <span class="n">perf_clock</span><span class="p">();</span>
		<span class="n">s64</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">freq_time_stamp</span><span class="p">;</span>

		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">freq_time_stamp</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">TICK_NSEC</span><span class="p">)</span>
			<span class="n">perf_adjust_period</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_period</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX event_limit might not quite work as expected on inherited</span>
<span class="cm">	 * events</span>
<span class="cm">	 */</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">pending_kill</span> <span class="o">=</span> <span class="n">POLL_IN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event_limit</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">pending_kill</span> <span class="o">=</span> <span class="n">POLL_HUP</span><span class="p">;</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">pending_disable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">irq_work_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">overflow_handler</span><span class="p">)</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">overflow_handler</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">perf_event_output</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">fasync</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">pending_kill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">pending_wakeup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">irq_work_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">perf_event_overflow</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__perf_event_overflow</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Generic software event infrastructure</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">swevent_htable</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">swevent_hlist</span>		<span class="o">*</span><span class="n">swevent_hlist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>			<span class="n">hlist_mutex</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">hlist_refcount</span><span class="p">;</span>

	<span class="cm">/* Recursion avoidance in each contexts */</span>
	<span class="kt">int</span>				<span class="n">recursion</span><span class="p">[</span><span class="n">PERF_NR_CONTEXTS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">swevent_htable</span><span class="p">,</span> <span class="n">swevent_htable</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We directly increment event-&gt;count and keep a second value in</span>
<span class="cm"> * event-&gt;hw.period_left to count intervals. This period event</span>
<span class="cm"> * is kept in the range [-sample_period, 0] so that we can use the</span>
<span class="cm"> * sign as trigger.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">perf_swevent_set_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">period</span> <span class="o">=</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_period</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">nr</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">old</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_period</span> <span class="o">=</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">old</span> <span class="o">=</span> <span class="n">val</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nr</span> <span class="o">=</span> <span class="n">div64_u64</span><span class="p">(</span><span class="n">period</span> <span class="o">+</span> <span class="n">val</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">nr</span> <span class="o">*</span> <span class="n">period</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">local64_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="n">old</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_swevent_overflow</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">u64</span> <span class="n">overflow</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">throttle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">overflow</span><span class="p">)</span>
		<span class="n">overflow</span> <span class="o">=</span> <span class="n">perf_swevent_set_period</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">interrupts</span> <span class="o">==</span> <span class="n">MAX_INTERRUPTS</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">overflow</span><span class="p">;</span> <span class="n">overflow</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__perf_event_overflow</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">throttle</span><span class="p">,</span>
					    <span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We inhibit the overflow from happening when</span>
<span class="cm">			 * hwc-&gt;interrupts == MAX_INTERRUPTS.</span>
<span class="cm">			 */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">throttle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_swevent_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nr</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">local64_add</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">regs</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_sampling_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_PERIOD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">nr</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">perf_swevent_overflow</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">last_period</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">freq</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">perf_swevent_overflow</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">local64_add_negative</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">perf_swevent_overflow</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_exclude_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_user</span> <span class="o">&amp;&amp;</span> <span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_kernel</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_swevent_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">perf_type_id</span> <span class="n">type</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">event_id</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config</span> <span class="o">!=</span> <span class="n">event_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">perf_exclude_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">swevent_hash</span><span class="p">(</span><span class="n">u64</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">val</span> <span class="o">=</span> <span class="n">event_id</span> <span class="o">|</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">hash_64</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">SWEVENT_HLIST_BITS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span>
<span class="nf">__find_swevent_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">swevent_hlist</span> <span class="o">*</span><span class="n">hlist</span><span class="p">,</span> <span class="n">u64</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">swevent_hash</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">event_id</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">hlist</span><span class="o">-&gt;</span><span class="n">heads</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* For the read side: events when they trigger */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span>
<span class="nf">find_swevent_head_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">swevent_htable</span> <span class="o">*</span><span class="n">swhash</span><span class="p">,</span> <span class="n">u64</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swevent_hlist</span> <span class="o">*</span><span class="n">hlist</span><span class="p">;</span>

	<span class="n">hlist</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">swevent_hlist</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__find_swevent_head</span><span class="p">(</span><span class="n">hlist</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">event_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* For the event head insertion and removal in the hlist */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span>
<span class="nf">find_swevent_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">swevent_htable</span> <span class="o">*</span><span class="n">swhash</span><span class="p">,</span> <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swevent_hlist</span> <span class="o">*</span><span class="n">hlist</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">event_id</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">type</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Event scheduling is always serialized against hlist allocation</span>
<span class="cm">	 * and release. Which makes the protected version suitable here.</span>
<span class="cm">	 * The context lock guarantees that.</span>
<span class="cm">	 */</span>
	<span class="n">hlist</span> <span class="o">=</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">swevent_hlist</span><span class="p">,</span>
					  <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__find_swevent_head</span><span class="p">(</span><span class="n">hlist</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">event_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_perf_sw_event</span><span class="p">(</span><span class="k">enum</span> <span class="n">perf_type_id</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">event_id</span><span class="p">,</span>
				    <span class="n">u64</span> <span class="n">nr</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swevent_htable</span> <span class="o">*</span><span class="n">swhash</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">swevent_htable</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">find_swevent_head_rcu</span><span class="p">(</span><span class="n">swhash</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">event_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">perf_swevent_match</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">event_id</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span>
			<span class="n">perf_swevent_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">end:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">perf_swevent_get_recursion_context</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swevent_htable</span> <span class="o">*</span><span class="n">swhash</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">swevent_htable</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">get_recursion_context</span><span class="p">(</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">recursion</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">perf_swevent_get_recursion_context</span><span class="p">);</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_swevent_put_recursion_context</span><span class="p">(</span><span class="kt">int</span> <span class="n">rctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swevent_htable</span> <span class="o">*</span><span class="n">swhash</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">swevent_htable</span><span class="p">);</span>

	<span class="n">put_recursion_context</span><span class="p">(</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">recursion</span><span class="p">,</span> <span class="n">rctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__perf_sw_event</span><span class="p">(</span><span class="n">u32</span> <span class="n">event_id</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="n">u64</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rctx</span><span class="p">;</span>

	<span class="n">preempt_disable_notrace</span><span class="p">();</span>
	<span class="n">rctx</span> <span class="o">=</span> <span class="n">perf_swevent_get_recursion_context</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rctx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">perf_sample_data_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">do_perf_sw_event</span><span class="p">(</span><span class="n">PERF_TYPE_SOFTWARE</span><span class="p">,</span> <span class="n">event_id</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

	<span class="n">perf_swevent_put_recursion_context</span><span class="p">(</span><span class="n">rctx</span><span class="p">);</span>
	<span class="n">preempt_enable_notrace</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_swevent_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_swevent_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swevent_htable</span> <span class="o">*</span><span class="n">swhash</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">swevent_htable</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_sampling_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_period</span> <span class="o">=</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span><span class="p">;</span>
		<span class="n">perf_swevent_set_period</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_EF_START</span><span class="p">);</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">find_swevent_head</span><span class="p">(</span><span class="n">swhash</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">hlist_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hlist_entry</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_swevent_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hlist_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hlist_entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_swevent_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_swevent_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_HES_STOPPED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Deref the hlist from the update side */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">swevent_hlist</span> <span class="o">*</span>
<span class="nf">swevent_hlist_deref</span><span class="p">(</span><span class="k">struct</span> <span class="n">swevent_htable</span> <span class="o">*</span><span class="n">swhash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">swevent_hlist</span><span class="p">,</span>
					 <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">hlist_mutex</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swevent_hlist_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">swevent_htable</span> <span class="o">*</span><span class="n">swhash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swevent_hlist</span> <span class="o">*</span><span class="n">hlist</span> <span class="o">=</span> <span class="n">swevent_hlist_deref</span><span class="p">(</span><span class="n">swhash</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">swevent_hlist</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">hlist</span><span class="p">,</span> <span class="n">rcu_head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swevent_hlist_put_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swevent_htable</span> <span class="o">*</span><span class="n">swhash</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">swevent_htable</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">hlist_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">hlist_refcount</span><span class="p">)</span>
		<span class="n">swevent_hlist_release</span><span class="p">(</span><span class="n">swhash</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">hlist_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swevent_hlist_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">swevent_hlist_put_cpu</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">swevent_hlist_put_cpu</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">swevent_hlist_get_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swevent_htable</span> <span class="o">*</span><span class="n">swhash</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">swevent_htable</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">hlist_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">swevent_hlist_deref</span><span class="p">(</span><span class="n">swhash</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">swevent_hlist</span> <span class="o">*</span><span class="n">hlist</span><span class="p">;</span>

		<span class="n">hlist</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hlist</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">swevent_hlist</span><span class="p">,</span> <span class="n">hlist</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">swhash</span><span class="o">-&gt;</span><span class="n">hlist_refcount</span><span class="o">++</span><span class="p">;</span>
<span class="nl">exit:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">hlist_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">swevent_hlist_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">failed_cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">swevent_hlist_get_cpu</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">swevent_hlist_get_cpu</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">failed_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">failed_cpu</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">swevent_hlist_put_cpu</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">static_key</span> <span class="n">perf_swevent_enabled</span><span class="p">[</span><span class="n">PERF_COUNT_SW_MAX</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sw_perf_event_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">event_id</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

	<span class="n">static_key_slow_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perf_swevent_enabled</span><span class="p">[</span><span class="n">event_id</span><span class="p">]);</span>
	<span class="n">swevent_hlist_put</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_swevent_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">event_id</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PERF_TYPE_SOFTWARE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * no branch sampling for software events</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_branch_stack</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PERF_COUNT_SW_CPU_CLOCK</span>:
	<span class="k">case</span> <span class="n">PERF_COUNT_SW_TASK_CLOCK</span>:
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event_id</span> <span class="o">&gt;=</span> <span class="n">PERF_COUNT_SW_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">swevent_hlist_get</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">static_key_slow_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perf_swevent_enabled</span><span class="p">[</span><span class="n">event_id</span><span class="p">]);</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">sw_perf_event_destroy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_swevent_event_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pmu</span> <span class="n">perf_swevent</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">task_ctx_nr</span>	<span class="o">=</span> <span class="n">perf_sw_context</span><span class="p">,</span>

	<span class="p">.</span><span class="n">event_init</span>	<span class="o">=</span> <span class="n">perf_swevent_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">add</span>		<span class="o">=</span> <span class="n">perf_swevent_add</span><span class="p">,</span>
	<span class="p">.</span><span class="n">del</span>		<span class="o">=</span> <span class="n">perf_swevent_del</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>		<span class="o">=</span> <span class="n">perf_swevent_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">perf_swevent_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">perf_swevent_read</span><span class="p">,</span>

	<span class="p">.</span><span class="n">event_idx</span>	<span class="o">=</span> <span class="n">perf_swevent_event_idx</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_EVENT_TRACING</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_tp_filter_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">record</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">raw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">)</span> <span class="o">||</span> <span class="n">filter_match_preds</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">,</span> <span class="n">record</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_tp_event_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PERF_HES_STOPPED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * All tracepoints are from kernel-space.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_kernel</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">perf_tp_filter_match</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">perf_tp_event</span><span class="p">(</span><span class="n">u64</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">count</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">record</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entry_size</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">perf_raw_record</span> <span class="n">raw</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">entry_size</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">record</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">perf_sample_data_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">data</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">raw</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">perf_tp_event_match</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span>
			<span class="n">perf_swevent_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">perf_swevent_put_recursion_context</span><span class="p">(</span><span class="n">rctx</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">perf_tp_event</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tp_perf_event_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">perf_trace_destroy</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_tp_event_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PERF_TYPE_TRACEPOINT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * no branch sampling for tracepoint events</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_branch_stack</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">perf_trace_init</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">tp_perf_event_destroy</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pmu</span> <span class="n">perf_tracepoint</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">task_ctx_nr</span>	<span class="o">=</span> <span class="n">perf_sw_context</span><span class="p">,</span>

	<span class="p">.</span><span class="n">event_init</span>	<span class="o">=</span> <span class="n">perf_tp_event_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">add</span>		<span class="o">=</span> <span class="n">perf_trace_add</span><span class="p">,</span>
	<span class="p">.</span><span class="n">del</span>		<span class="o">=</span> <span class="n">perf_trace_del</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>		<span class="o">=</span> <span class="n">perf_swevent_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">perf_swevent_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">perf_swevent_read</span><span class="p">,</span>

	<span class="p">.</span><span class="n">event_idx</span>	<span class="o">=</span> <span class="n">perf_swevent_event_idx</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_tp_register</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">perf_pmu_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perf_tracepoint</span><span class="p">,</span> <span class="s">&quot;tracepoint&quot;</span><span class="p">,</span> <span class="n">PERF_TYPE_TRACEPOINT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_event_set_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">filter_str</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PERF_TYPE_TRACEPOINT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">filter_str</span> <span class="o">=</span> <span class="n">strndup_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">filter_str</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">filter_str</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ftrace_profile_set_filter</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config</span><span class="p">,</span> <span class="n">filter_str</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">filter_str</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_free_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ftrace_profile_free_filter</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_tp_register</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_event_set_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_free_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_EVENT_TRACING */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_HAVE_HW_BREAKPOINT</span>
<span class="kt">void</span> <span class="nf">perf_bp_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="n">sample</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">perf_sample_data_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sample</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">bp_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">perf_exclude_event</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span>
		<span class="n">perf_swevent_event</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * hrtimer based swevent callback</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">perf_swevent_hrtimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">hrtimer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">HRTIMER_RESTART</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">period</span><span class="p">;</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">hrtimer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">perf_event</span><span class="p">,</span> <span class="n">hw</span><span class="p">.</span><span class="n">hrtimer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">PERF_EVENT_STATE_ACTIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">HRTIMER_NORESTART</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="n">perf_sample_data_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">last_period</span><span class="p">);</span>
	<span class="n">regs</span> <span class="o">=</span> <span class="n">get_irq_regs</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">perf_exclude_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_idle</span> <span class="o">&amp;&amp;</span> <span class="n">is_idle_task</span><span class="p">(</span><span class="n">current</span><span class="p">)))</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__perf_event_overflow</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">HRTIMER_NORESTART</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">period</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_period</span><span class="p">);</span>
	<span class="n">hrtimer_forward_now</span><span class="p">(</span><span class="n">hrtimer</span><span class="p">,</span> <span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">period</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_swevent_start_hrtimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">period</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_sampling_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">period</span> <span class="o">=</span> <span class="n">local64_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">period</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">period</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>

		<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">__hrtimer_start_range_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">hrtimer</span><span class="p">,</span>
				<span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">period</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">HRTIMER_MODE_REL_PINNED</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_swevent_cancel_hrtimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_sampling_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ktime_t</span> <span class="n">remaining</span> <span class="o">=</span> <span class="n">hrtimer_get_remaining</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">hrtimer</span><span class="p">);</span>
		<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">,</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">remaining</span><span class="p">));</span>

		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">hrtimer</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_swevent_init_hrtimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_sampling_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">hrtimer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">hrtimer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">perf_swevent_hrtimer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since hrtimers have a fixed rate, we can do a static freq-&gt;period</span>
<span class="cm">	 * mapping and avoid the whole period adjust feedback stuff.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_freq</span><span class="p">;</span>

		<span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_period</span> <span class="o">=</span> <span class="n">NSEC_PER_SEC</span> <span class="o">/</span> <span class="n">freq</span><span class="p">;</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_period</span><span class="p">;</span>
		<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">,</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span><span class="p">);</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Software event: cpu wall time clock</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_clock_event_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">prev</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">local_clock</span><span class="p">();</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="n">local64_xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
	<span class="n">local64_add</span><span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_clock_event_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">,</span> <span class="n">local_clock</span><span class="p">());</span>
	<span class="n">perf_swevent_start_hrtimer</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_clock_event_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">perf_swevent_cancel_hrtimer</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">cpu_clock_event_update</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_clock_event_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_EF_START</span><span class="p">)</span>
		<span class="n">cpu_clock_event_start</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_clock_event_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpu_clock_event_stop</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_clock_event_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpu_clock_event_update</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_clock_event_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PERF_TYPE_SOFTWARE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config</span> <span class="o">!=</span> <span class="n">PERF_COUNT_SW_CPU_CLOCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * no branch sampling for software events</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_branch_stack</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">perf_swevent_init_hrtimer</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pmu</span> <span class="n">perf_cpu_clock</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">task_ctx_nr</span>	<span class="o">=</span> <span class="n">perf_sw_context</span><span class="p">,</span>

	<span class="p">.</span><span class="n">event_init</span>	<span class="o">=</span> <span class="n">cpu_clock_event_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">add</span>		<span class="o">=</span> <span class="n">cpu_clock_event_add</span><span class="p">,</span>
	<span class="p">.</span><span class="n">del</span>		<span class="o">=</span> <span class="n">cpu_clock_event_del</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>		<span class="o">=</span> <span class="n">cpu_clock_event_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">cpu_clock_event_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">cpu_clock_event_read</span><span class="p">,</span>

	<span class="p">.</span><span class="n">event_idx</span>	<span class="o">=</span> <span class="n">perf_swevent_event_idx</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Software event: task time clock</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">task_clock_event_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">u64</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">prev</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">delta</span><span class="p">;</span>

	<span class="n">prev</span> <span class="o">=</span> <span class="n">local64_xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">prev</span><span class="p">;</span>
	<span class="n">local64_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">task_clock_event_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">prev_count</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">);</span>
	<span class="n">perf_swevent_start_hrtimer</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">task_clock_event_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">perf_swevent_cancel_hrtimer</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">task_clock_event_update</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">task_clock_event_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_EF_START</span><span class="p">)</span>
		<span class="n">task_clock_event_start</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">task_clock_event_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">task_clock_event_stop</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">PERF_EF_UPDATE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">task_clock_event_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">now</span> <span class="o">=</span> <span class="n">perf_clock</span><span class="p">();</span>
	<span class="n">u64</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">time</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">+</span> <span class="n">delta</span><span class="p">;</span>

	<span class="n">task_clock_event_update</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">task_clock_event_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PERF_TYPE_SOFTWARE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">config</span> <span class="o">!=</span> <span class="n">PERF_COUNT_SW_TASK_CLOCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * no branch sampling for software events</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_branch_stack</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">perf_swevent_init_hrtimer</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pmu</span> <span class="n">perf_task_clock</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">task_ctx_nr</span>	<span class="o">=</span> <span class="n">perf_sw_context</span><span class="p">,</span>

	<span class="p">.</span><span class="n">event_init</span>	<span class="o">=</span> <span class="n">task_clock_event_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">add</span>		<span class="o">=</span> <span class="n">task_clock_event_add</span><span class="p">,</span>
	<span class="p">.</span><span class="n">del</span>		<span class="o">=</span> <span class="n">task_clock_event_del</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>		<span class="o">=</span> <span class="n">task_clock_event_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">task_clock_event_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">task_clock_event_read</span><span class="p">,</span>

	<span class="p">.</span><span class="n">event_idx</span>	<span class="o">=</span> <span class="n">perf_swevent_event_idx</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_pmu_nop_void</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_pmu_nop_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_pmu_start_txn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">perf_pmu_disable</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_pmu_commit_txn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_pmu_cancel_txn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">perf_pmu_enable</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_event_idx_default</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ensures all contexts with the same task_ctx_nr have the same</span>
<span class="cm"> * pmu_cpu_context too.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">find_pmu_context</span><span class="p">(</span><span class="kt">int</span> <span class="n">ctxn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctxn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pmu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmus</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">task_ctx_nr</span> <span class="o">==</span> <span class="n">ctxn</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_pmu_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">old_pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">;</span>

		<span class="n">cpuctx</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">active_pmu</span> <span class="o">==</span> <span class="n">old_pmu</span><span class="p">)</span>
			<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">active_pmu</span> <span class="o">=</span> <span class="n">pmu</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_pmu_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmus_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Like a real lame refcount.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmus</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span> <span class="o">==</span> <span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">update_pmu_context</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pmu</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">free_percpu</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmus_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">idr</span> <span class="n">pmu_idr</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">type_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pmu</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">pmu_dev_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
       <span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">type</span><span class="p">),</span>
       <span class="n">__ATTR_NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pmu_bus_running</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">pmu_bus</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;event_source&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_attrs</span>	<span class="o">=</span> <span class="n">pmu_dev_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pmu_dev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pmu_dev_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">groups</span> <span class="o">=</span> <span class="n">pmu</span><span class="o">-&gt;</span><span class="n">attr_groups</span><span class="p">;</span>
	<span class="n">device_initialize</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dev_set_name</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">pmu</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_dev</span><span class="p">;</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pmu</span><span class="p">);</span>
	<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmu_bus</span><span class="p">;</span>
	<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">=</span> <span class="n">pmu_dev_release</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">device_add</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_dev</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">free_dev:</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">cpuctx_mutex</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">cpuctx_lock</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">perf_pmu_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmus_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_disable_count</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_disable_count</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">skip_type</span><span class="p">;</span>
	<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmu_idr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_pdc</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">idr_get_new_above</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmu_idr</span><span class="p">,</span> <span class="n">pmu</span><span class="p">,</span> <span class="n">PERF_TYPE_MAX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_pdc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmu_bus_running</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pmu_dev_alloc</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_idr</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">skip_type:</span>
	<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span> <span class="o">=</span> <span class="n">find_pmu_context</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">task_ctx_nr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">got_cpu_context</span><span class="p">;</span>

	<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_cpu_context</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_dev</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span><span class="p">;</span>

		<span class="n">cpuctx</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">__perf_event_init_context</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuctx_mutex</span><span class="p">);</span>
		<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuctx_lock</span><span class="p">);</span>
		<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_context</span><span class="p">;</span>
		<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">.</span><span class="n">pmu</span> <span class="o">=</span> <span class="n">pmu</span><span class="p">;</span>
		<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">jiffies_interval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">rotation_list</span><span class="p">);</span>
		<span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">active_pmu</span> <span class="o">=</span> <span class="n">pmu</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">got_cpu_context:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">start_txn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_enable</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we have pmu_enable/pmu_disable calls, install</span>
<span class="cm">			 * transaction stubs that use that to try and batch</span>
<span class="cm">			 * hardware accesses.</span>
<span class="cm">			 */</span>
			<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">start_txn</span>  <span class="o">=</span> <span class="n">perf_pmu_start_txn</span><span class="p">;</span>
			<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">commit_txn</span> <span class="o">=</span> <span class="n">perf_pmu_commit_txn</span><span class="p">;</span>
			<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">cancel_txn</span> <span class="o">=</span> <span class="n">perf_pmu_cancel_txn</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">start_txn</span>  <span class="o">=</span> <span class="n">perf_pmu_nop_void</span><span class="p">;</span>
			<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">commit_txn</span> <span class="o">=</span> <span class="n">perf_pmu_nop_int</span><span class="p">;</span>
			<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">cancel_txn</span> <span class="o">=</span> <span class="n">perf_pmu_nop_void</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_enable</span>  <span class="o">=</span> <span class="n">perf_pmu_nop_void</span><span class="p">;</span>
		<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_disable</span> <span class="o">=</span> <span class="n">perf_pmu_nop_void</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">event_idx</span><span class="p">)</span>
		<span class="n">pmu</span><span class="o">-&gt;</span><span class="n">event_idx</span> <span class="o">=</span> <span class="n">perf_event_idx_default</span><span class="p">;</span>

	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmus</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmus_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">free_dev:</span>
	<span class="n">device_del</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

<span class="nl">free_idr:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">PERF_TYPE_MAX</span><span class="p">)</span>
		<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmu_idr</span><span class="p">,</span> <span class="n">pmu</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

<span class="nl">free_pdc:</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_disable_count</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">perf_pmu_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmus_lock</span><span class="p">);</span>
	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmus_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We dereference the pmu list under both SRCU and regular RCU, so</span>
<span class="cm">	 * synchronize against both of those.</span>
<span class="cm">	 */</span>
	<span class="n">synchronize_srcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmus_srcu</span><span class="p">);</span>
	<span class="n">synchronize_rcu</span><span class="p">();</span>

	<span class="n">free_percpu</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_disable_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">PERF_TYPE_MAX</span><span class="p">)</span>
		<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmu_idr</span><span class="p">,</span> <span class="n">pmu</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="n">device_del</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">free_pmu_context</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="nf">perf_init_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmus_srcu</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">pmu</span> <span class="o">=</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmu_idr</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span> <span class="o">=</span> <span class="n">pmu</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pmu</span><span class="o">-&gt;</span><span class="n">event_init</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">pmu</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">pmu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmus</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span> <span class="o">=</span> <span class="n">pmu</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pmu</span><span class="o">-&gt;</span><span class="n">event_init</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pmu</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">pmu</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
<span class="nl">unlock:</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmus_srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pmu</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate and initialize a event structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span>
<span class="nf">perf_event_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">group_leader</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">parent_event</span><span class="p">,</span>
		 <span class="n">perf_overflow_handler_t</span> <span class="n">overflow_handler</span><span class="p">,</span>
		 <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span> <span class="o">||</span> <span class="n">cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Single events are their own group leaders, with an</span>
<span class="cm">	 * empty sibling list:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group_leader</span><span class="p">)</span>
		<span class="n">group_leader</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">child_mutex</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">child_list</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">group_entry</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">event_entry</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb_entry</span><span class="p">);</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">);</span>
	<span class="n">init_irq_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">,</span> <span class="n">perf_pending_event</span><span class="p">);</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_mutex</span><span class="p">);</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span>		<span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span>		<span class="o">=</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">group_leader</span>	<span class="o">=</span> <span class="n">group_leader</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">oncpu</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">parent</span>		<span class="o">=</span> <span class="n">parent_event</span><span class="p">;</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">ns</span>		<span class="o">=</span> <span class="n">get_pid_ns</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">pid_ns</span><span class="p">);</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">id</span>		<span class="o">=</span> <span class="n">atomic64_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perf_event_id</span><span class="p">);</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span>		<span class="o">=</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">attach_state</span> <span class="o">=</span> <span class="n">PERF_ATTACH_TASK</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HAVE_HW_BREAKPOINT</span>
		<span class="cm">/*</span>
<span class="cm">		 * hw_breakpoint is a bit difficult here..</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PERF_TYPE_BREAKPOINT</span><span class="p">)</span>
			<span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">bp_target</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">overflow_handler</span> <span class="o">&amp;&amp;</span> <span class="n">parent_event</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">overflow_handler</span> <span class="o">=</span> <span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">overflow_handler</span><span class="p">;</span>
		<span class="n">context</span> <span class="o">=</span> <span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">overflow_handler_context</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">overflow_handler</span>	<span class="o">=</span> <span class="n">overflow_handler</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">overflow_handler_context</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">)</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">;</span>

	<span class="n">pmu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">sample_period</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">freq</span> <span class="o">&amp;&amp;</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">sample_freq</span><span class="p">)</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_period</span> <span class="o">=</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span><span class="p">;</span>

	<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">,</span> <span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we currently do not support PERF_FORMAT_GROUP on inherited events</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">inherit</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="n">PERF_FORMAT_GROUP</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">pmu</span> <span class="o">=</span> <span class="n">perf_init_event</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmu</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pmu</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">)</span>
			<span class="n">put_pid_ns</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attach_state</span> <span class="o">&amp;</span> <span class="n">PERF_ATTACH_TASK</span><span class="p">)</span>
			<span class="n">static_key_slow_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perf_sched_events</span><span class="p">.</span><span class="n">key</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mmap</span> <span class="o">||</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">mmap_data</span><span class="p">)</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_mmap_events</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">comm</span><span class="p">)</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_comm_events</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">task</span><span class="p">)</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_task_events</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_CALLCHAIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">get_callchain_buffers</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_event</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">has_branch_stack</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">static_key_slow_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perf_sched_events</span><span class="p">.</span><span class="n">key</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attach_state</span> <span class="o">&amp;</span> <span class="n">PERF_ATTACH_TASK</span><span class="p">))</span>
				<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">perf_branch_stack_events</span><span class="p">,</span>
						    <span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">perf_copy_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_attr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uattr</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">perf_event_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">uattr</span><span class="p">,</span> <span class="n">PERF_ATTR_SIZE_VER0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * zero the full structure, so that a short copy will be nice.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">attr</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uattr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>	<span class="cm">/* silly large */</span>
		<span class="k">goto</span> <span class="n">err_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>		<span class="cm">/* abi compat */</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">PERF_ATTR_SIZE_VER0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">PERF_ATTR_SIZE_VER0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re handed a bigger struct than we know of,</span>
<span class="cm">	 * ensure all the unknown bits are 0 - i.e. new</span>
<span class="cm">	 * user-space does not rely on any kernel feature</span>
<span class="cm">	 * extensions we dont know about yet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">attr</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">;</span>

		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">uattr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">attr</span><span class="p">);</span>
		<span class="n">end</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">uattr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_size</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">attr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">uattr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">__reserved_1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PERF_SAMPLE_MAX</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">read_format</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PERF_FORMAT_MAX</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">sample_type</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_BRANCH_STACK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">branch_sample_type</span><span class="p">;</span>

		<span class="cm">/* only using defined bits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PERF_SAMPLE_BRANCH_MAX</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/* at least one branch bit must be set */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PERF_SAMPLE_BRANCH_PLM_ALL</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/* kernel level capture: check permissions */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_BRANCH_PERM_PLM</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">perf_paranoid_kernel</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

		<span class="cm">/* propagate priv level, when not set for branch */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">PERF_SAMPLE_BRANCH_PLM_ALL</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* exclude_kernel checked on syscall entry */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">exclude_kernel</span><span class="p">)</span>
				<span class="n">mask</span> <span class="o">|=</span> <span class="n">PERF_SAMPLE_BRANCH_KERNEL</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">exclude_user</span><span class="p">)</span>
				<span class="n">mask</span> <span class="o">|=</span> <span class="n">PERF_SAMPLE_BRANCH_USER</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">exclude_hv</span><span class="p">)</span>
				<span class="n">mask</span> <span class="o">|=</span> <span class="n">PERF_SAMPLE_BRANCH_HV</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * adjust user setting (for HW filter setup)</span>
<span class="cm">			 */</span>
			<span class="n">attr</span><span class="o">-&gt;</span><span class="n">branch_sample_type</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">err_size:</span>
	<span class="n">put_user</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">attr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">uattr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">perf_event_set_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">output_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">rb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">old_rb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">output_event</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">set</span><span class="p">;</span>

	<span class="cm">/* don&#39;t allow circular references */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">output_event</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t allow cross-cpu buffers</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">output_event</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If its not a per-cpu rb, it must be the same task.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">output_event</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">output_event</span><span class="o">-&gt;</span><span class="n">ctx</span> <span class="o">!=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">set:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_mutex</span><span class="p">);</span>
	<span class="cm">/* Can&#39;t redirect output if we&#39;ve got an active mmap() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_count</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">output_event</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get the rb we want to redirect to */</span>
		<span class="n">rb</span> <span class="o">=</span> <span class="n">ring_buffer_get</span><span class="p">(</span><span class="n">output_event</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rb</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">old_rb</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_rb</span><span class="p">)</span>
		<span class="n">ring_buffer_detach</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">old_rb</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">mmap_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_rb</span><span class="p">)</span>
		<span class="n">ring_buffer_put</span><span class="p">(</span><span class="n">old_rb</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sys_perf_event_open - open a performance event, associate it to a task/cpu</span>
<span class="cm"> *</span>
<span class="cm"> * @attr_uptr:	event_id type attributes for monitoring/sampling</span>
<span class="cm"> * @pid:		target pid</span>
<span class="cm"> * @cpu:		target cpu</span>
<span class="cm"> * @group_fd:		group leader event fd</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">perf_event_open</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">perf_event_attr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">attr_uptr</span><span class="p">,</span>
		<span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">group_fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">group_leader</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">output_event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="o">*</span><span class="n">sibling</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_attr</span> <span class="n">attr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">event_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">group_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">event_fd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">move_group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fput_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* for future expandability... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PERF_FLAG_ALL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">perf_copy_attr</span><span class="p">(</span><span class="n">attr_uptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attr</span><span class="p">.</span><span class="n">exclude_kernel</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">perf_paranoid_kernel</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">sample_freq</span> <span class="o">&gt;</span> <span class="n">sysctl_perf_event_sample_rate</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * In cgroup mode, the pid argument is used to pass the fd</span>
<span class="cm">	 * opened to the cgroup directory in cgroupfs. The cpu argument</span>
<span class="cm">	 * designates the cpu on which to monitor threads from that</span>
<span class="cm">	 * cgroup.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_FLAG_PID_CGROUP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">cpu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">event_fd</span> <span class="o">=</span> <span class="n">get_unused_fd_flags</span><span class="p">(</span><span class="n">O_RDWR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">event_fd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">group_fd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">group_leader</span> <span class="o">=</span> <span class="n">perf_fget_light</span><span class="p">(</span><span class="n">group_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">group_leader</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">group_leader</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_fd</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">group_file</span> <span class="o">=</span> <span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_FLAG_FD_OUTPUT</span><span class="p">)</span>
			<span class="n">output_event</span> <span class="o">=</span> <span class="n">group_leader</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_FLAG_FD_NO_GROUP</span><span class="p">)</span>
			<span class="n">group_leader</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_FLAG_PID_CGROUP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">task</span> <span class="o">=</span> <span class="n">find_lively_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_group_fd</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">perf_event_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">group_leader</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_task</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PERF_FLAG_PID_CGROUP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">perf_cgroup_connect</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">group_leader</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_alloc</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * one more event:</span>
<span class="cm">		 * - that has cgroup constraint on event-&gt;cpu</span>
<span class="cm">		 * - that may need work on context switch</span>
<span class="cm">		 */</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">perf_cgroup_events</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">));</span>
		<span class="n">static_key_slow_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perf_sched_events</span><span class="p">.</span><span class="n">key</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Special case software events and allow them to be part of</span>
<span class="cm">	 * any hardware group.</span>
<span class="cm">	 */</span>
	<span class="n">pmu</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">group_leader</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">is_software_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">!=</span> <span class="n">is_software_event</span><span class="p">(</span><span class="n">group_leader</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_software_event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If event and group_leader are not both a software</span>
<span class="cm">			 * event, and event is, then group leader is not.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Allow the addition of software events to !software</span>
<span class="cm">			 * groups, this is safe because software events never</span>
<span class="cm">			 * fail to schedule.</span>
<span class="cm">			 */</span>
			<span class="n">pmu</span> <span class="o">=</span> <span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_software_event</span><span class="p">(</span><span class="n">group_leader</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="p">(</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">group_flags</span> <span class="o">&amp;</span> <span class="n">PERF_GROUP_SOFTWARE</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * In case the group is a pure software group, and we</span>
<span class="cm">			 * try to add a hardware event, move the whole group to</span>
<span class="cm">			 * the hardware context.</span>
<span class="cm">			 */</span>
			<span class="n">move_group</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the target context (task or percpu):</span>
<span class="cm">	 */</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="n">find_get_context</span><span class="p">(</span><span class="n">pmu</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_alloc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Look up the group leader (we will attach this event to it):</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group_leader</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do not allow a recursive hierarchy (this new sibling</span>
<span class="cm">		 * becoming part of another group-sibling):</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">!=</span> <span class="n">group_leader</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_context</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do not allow to attach to a group in a different</span>
<span class="cm">		 * task or CPU context:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">move_group</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_context</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">ctx</span> <span class="o">!=</span> <span class="n">ctx</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_context</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Only a group leader can be exclusive or pinned</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">exclusive</span> <span class="o">||</span> <span class="n">attr</span><span class="p">.</span><span class="n">pinned</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_context</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">output_event</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">perf_event_set_output</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">output_event</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_context</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event_file</span> <span class="o">=</span> <span class="n">anon_inode_getfile</span><span class="p">(</span><span class="s">&quot;[perf_event]&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">perf_fops</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">event_file</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">event_file</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_context</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">move_group</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">gctx</span> <span class="o">=</span> <span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">perf_remove_from_context</span><span class="p">(</span><span class="n">group_leader</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sibling</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span>
				    <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">perf_remove_from_context</span><span class="p">(</span><span class="n">sibling</span><span class="p">);</span>
			<span class="n">put_ctx</span><span class="p">(</span><span class="n">gctx</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">put_ctx</span><span class="p">(</span><span class="n">gctx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">filp</span> <span class="o">=</span> <span class="n">event_file</span><span class="p">;</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">move_group</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perf_install_in_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">group_leader</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sibling</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span>
				    <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">perf_install_in_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">sibling</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="n">get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">perf_install_in_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="o">++</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">;</span>
	<span class="n">perf_unpin_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">perf_event_mutex</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">owner_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">perf_event_list</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">perf_event_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Precalculate sample_data sizes</span>
<span class="cm">	 */</span>
	<span class="n">perf_event__header_size</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">perf_event__id_header_size</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Drop the reference on the group_event after placing the</span>
<span class="cm">	 * new event on the sibling_list. This ensures destruction</span>
<span class="cm">	 * of the group leader will find the pointer to itself in</span>
<span class="cm">	 * perf_group_detach().</span>
<span class="cm">	 */</span>
	<span class="n">fput_light</span><span class="p">(</span><span class="n">group_file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
	<span class="n">fd_install</span><span class="p">(</span><span class="n">event_fd</span><span class="p">,</span> <span class="n">event_file</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">event_fd</span><span class="p">;</span>

<span class="nl">err_context:</span>
	<span class="n">perf_unpin_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">put_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="nl">err_alloc:</span>
	<span class="n">free_event</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="nl">err_task:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="nl">err_group_fd:</span>
	<span class="n">fput_light</span><span class="p">(</span><span class="n">group_file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
<span class="nl">err_fd:</span>
	<span class="n">put_unused_fd</span><span class="p">(</span><span class="n">event_fd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * perf_event_create_kernel_counter</span>
<span class="cm"> *</span>
<span class="cm"> * @attr: attributes of the counter to create</span>
<span class="cm"> * @cpu: cpu in which the counter is bound</span>
<span class="cm"> * @task: task to profile (NULL for percpu)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span>
<span class="n">perf_event_create_kernel_counter</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				 <span class="n">perf_overflow_handler_t</span> <span class="n">overflow_handler</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the target context (task or percpu):</span>
<span class="cm">	 */</span>

	<span class="n">event</span> <span class="o">=</span> <span class="n">perf_event_alloc</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				 <span class="n">overflow_handler</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">find_get_context</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">filp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">perf_install_in_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="o">++</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">;</span>
	<span class="n">perf_unpin_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">event</span><span class="p">;</span>

<span class="nl">err_free:</span>
	<span class="n">free_event</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">perf_event_create_kernel_counter</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sync_child_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">child_event</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">parent_event</span> <span class="o">=</span> <span class="n">child_event</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">child_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">child_event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">inherit_stat</span><span class="p">)</span>
		<span class="n">perf_event_read_event</span><span class="p">(</span><span class="n">child_event</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

	<span class="n">child_val</span> <span class="o">=</span> <span class="n">perf_event_count</span><span class="p">(</span><span class="n">child_event</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add back the child&#39;s count to the parent&#39;s count:</span>
<span class="cm">	 */</span>
	<span class="n">atomic64_add</span><span class="p">(</span><span class="n">child_val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">child_count</span><span class="p">);</span>
	<span class="n">atomic64_add</span><span class="p">(</span><span class="n">child_event</span><span class="o">-&gt;</span><span class="n">total_time_enabled</span><span class="p">,</span>
		     <span class="o">&amp;</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">child_total_time_enabled</span><span class="p">);</span>
	<span class="n">atomic64_add</span><span class="p">(</span><span class="n">child_event</span><span class="o">-&gt;</span><span class="n">total_time_running</span><span class="p">,</span>
		     <span class="o">&amp;</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">child_total_time_running</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove this event from the parent&#39;s list</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">child_mutex</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_event</span><span class="o">-&gt;</span><span class="n">child_list</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">child_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Release the parent event, if this was the last</span>
<span class="cm">	 * reference to it.</span>
<span class="cm">	 */</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__perf_event_exit_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">child_event</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">child_ctx</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">child_event</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">perf_group_detach</span><span class="p">(</span><span class="n">child_event</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">perf_remove_from_context</span><span class="p">(</span><span class="n">child_event</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * It can happen that the parent exits first, and has events</span>
<span class="cm">	 * that are still around due to the child reference. These</span>
<span class="cm">	 * events need to be zapped.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">child_event</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sync_child_event</span><span class="p">(</span><span class="n">child_event</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
		<span class="n">free_event</span><span class="p">(</span><span class="n">child_event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_exit_task_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ctxn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">child_event</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">child_ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">perf_event_task</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t reschedule here because interrupts are disabled,</span>
<span class="cm">	 * and either child is current or it is a task that can&#39;t be</span>
<span class="cm">	 * scheduled, so we are now safe from rescheduling changing</span>
<span class="cm">	 * our context.</span>
<span class="cm">	 */</span>
	<span class="n">child_ctx</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Take the context lock here so that if find_get_context is</span>
<span class="cm">	 * reading child-&gt;perf_event_ctxp, we wait until it has</span>
<span class="cm">	 * incremented the context&#39;s refcount before we do put_ctx below.</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">task_ctx_sched_out</span><span class="p">(</span><span class="n">child_ctx</span><span class="p">);</span>
	<span class="n">child</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this context is a clone; unclone it so it can&#39;t get</span>
<span class="cm">	 * swapped to another process while we&#39;re removing all</span>
<span class="cm">	 * the events from it.</span>
<span class="cm">	 */</span>
	<span class="n">unclone_ctx</span><span class="p">(</span><span class="n">child_ctx</span><span class="p">);</span>
	<span class="n">update_context_time</span><span class="p">(</span><span class="n">child_ctx</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Report the task dead after unscheduling the events so that we</span>
<span class="cm">	 * won&#39;t get any samples after PERF_RECORD_EXIT. We can however still</span>
<span class="cm">	 * get a few PERF_RECORD_READ events.</span>
<span class="cm">	 */</span>
	<span class="n">perf_event_task</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">child_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can recurse on the same lock type through:</span>
<span class="cm">	 *</span>
<span class="cm">	 *   __perf_event_exit_task()</span>
<span class="cm">	 *     sync_child_event()</span>
<span class="cm">	 *       fput(parent_event-&gt;filp)</span>
<span class="cm">	 *         perf_release()</span>
<span class="cm">	 *           mutex_lock(&amp;ctx-&gt;mutex)</span>
<span class="cm">	 *</span>
<span class="cm">	 * But since its the parent context it won&#39;t be the same instance.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

<span class="nl">again:</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">child_event</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">pinned_groups</span><span class="p">,</span>
				 <span class="n">group_entry</span><span class="p">)</span>
		<span class="n">__perf_event_exit_task</span><span class="p">(</span><span class="n">child_event</span><span class="p">,</span> <span class="n">child_ctx</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">child_event</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">flexible_groups</span><span class="p">,</span>
				 <span class="n">group_entry</span><span class="p">)</span>
		<span class="n">__perf_event_exit_task</span><span class="p">(</span><span class="n">child_event</span><span class="p">,</span> <span class="n">child_ctx</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the last event was a group event, it will have appended all</span>
<span class="cm">	 * its siblings to the list, but we obtained &#39;tmp&#39; before that which</span>
<span class="cm">	 * will still point to the list head terminating the iteration.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">pinned_groups</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">flexible_groups</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">put_ctx</span><span class="p">(</span><span class="n">child_ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When a child task exits, feed back event values to parent events.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">perf_event_exit_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctxn</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">perf_event_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">perf_event_list</span><span class="p">,</span>
				 <span class="n">owner_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">owner_entry</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Ensure the list deletion is visible before we clear</span>
<span class="cm">		 * the owner, closes a race against perf_release() where</span>
<span class="cm">		 * we need to serialize on the owner-&gt;perf_event_mutex.</span>
<span class="cm">		 */</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">event</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">perf_event_mutex</span><span class="p">);</span>

	<span class="n">for_each_task_context_nr</span><span class="p">(</span><span class="n">ctxn</span><span class="p">)</span>
		<span class="n">perf_event_exit_task_context</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">ctxn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_free_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">child_mutex</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">child_list</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">child_mutex</span><span class="p">);</span>

	<span class="n">fput</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">);</span>

	<span class="n">perf_group_detach</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">list_del_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">free_event</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * free an unexposed, unused context as created by inheritance by</span>
<span class="cm"> * perf_event_init_task below, used by fork() in case of fail.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">perf_event_free_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctxn</span><span class="p">;</span>

	<span class="n">for_each_task_context_nr</span><span class="p">(</span><span class="n">ctxn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="nl">again:</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pinned_groups</span><span class="p">,</span>
				<span class="n">group_entry</span><span class="p">)</span>
			<span class="n">perf_free_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flexible_groups</span><span class="p">,</span>
				<span class="n">group_entry</span><span class="p">)</span>
			<span class="n">perf_free_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pinned_groups</span><span class="p">)</span> <span class="o">||</span>
				<span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flexible_groups</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

		<span class="n">put_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">perf_event_delayed_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ctxn</span><span class="p">;</span>

	<span class="n">for_each_task_context_nr</span><span class="p">(</span><span class="n">ctxn</span><span class="p">)</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * inherit a event from parent task to child task:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span>
<span class="nf">inherit_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">parent_event</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">parent_ctx</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">group_leader</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">child_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">child_event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Instead of creating recursive hierarchies of events,</span>
<span class="cm">	 * we link inherited events back to the original parent,</span>
<span class="cm">	 * which has a filp for sure, which we use as the reference</span>
<span class="cm">	 * count:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">parent_event</span> <span class="o">=</span> <span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">child_event</span> <span class="o">=</span> <span class="n">perf_event_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">,</span>
					   <span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span>
					   <span class="n">child</span><span class="p">,</span>
					   <span class="n">group_leader</span><span class="p">,</span> <span class="n">parent_event</span><span class="p">,</span>
				           <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">child_event</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">child_event</span><span class="p">;</span>
	<span class="n">get_ctx</span><span class="p">(</span><span class="n">child_ctx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make the child state follow the state of the parent event,</span>
<span class="cm">	 * not its attr.disabled bit.  We hold the parent&#39;s mutex,</span>
<span class="cm">	 * so we won&#39;t race with perf_event_{en, dis}able_family.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">)</span>
		<span class="n">child_event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_EVENT_STATE_INACTIVE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">child_event</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">PERF_EVENT_STATE_OFF</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">sample_period</span> <span class="o">=</span> <span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_period</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hw_perf_event</span> <span class="o">*</span><span class="n">hwc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">child_event</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">sample_period</span> <span class="o">=</span> <span class="n">sample_period</span><span class="p">;</span>
		<span class="n">hwc</span><span class="o">-&gt;</span><span class="n">last_period</span>   <span class="o">=</span> <span class="n">sample_period</span><span class="p">;</span>

		<span class="n">local64_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hwc</span><span class="o">-&gt;</span><span class="n">period_left</span><span class="p">,</span> <span class="n">sample_period</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">child_event</span><span class="o">-&gt;</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">child_ctx</span><span class="p">;</span>
	<span class="n">child_event</span><span class="o">-&gt;</span><span class="n">overflow_handler</span> <span class="o">=</span> <span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">overflow_handler</span><span class="p">;</span>
	<span class="n">child_event</span><span class="o">-&gt;</span><span class="n">overflow_handler_context</span>
		<span class="o">=</span> <span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">overflow_handler_context</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Precalculate sample_data sizes</span>
<span class="cm">	 */</span>
	<span class="n">perf_event__header_size</span><span class="p">(</span><span class="n">child_event</span><span class="p">);</span>
	<span class="n">perf_event__id_header_size</span><span class="p">(</span><span class="n">child_event</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Link it up in the child&#39;s context:</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">add_event_to_ctx</span><span class="p">(</span><span class="n">child_event</span><span class="p">,</span> <span class="n">child_ctx</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get a reference to the parent filp - we will fput it</span>
<span class="cm">	 * when the child event exits. This is safe to do because</span>
<span class="cm">	 * we are in the parent and we know that the filp still</span>
<span class="cm">	 * exists and has a nonzero count:</span>
<span class="cm">	 */</span>
	<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Link this into the parent event&#39;s child list</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">child_mutex</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_event</span><span class="o">-&gt;</span><span class="n">child_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">child_list</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">child_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">child_event</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">inherit_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">parent_event</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">parent_ctx</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">child_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">leader</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">sub</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">child_ctr</span><span class="p">;</span>

	<span class="n">leader</span> <span class="o">=</span> <span class="n">inherit_event</span><span class="p">(</span><span class="n">parent_event</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">parent_ctx</span><span class="p">,</span>
				 <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">child_ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">leader</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">leader</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_event</span><span class="o">-&gt;</span><span class="n">sibling_list</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">child_ctr</span> <span class="o">=</span> <span class="n">inherit_event</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">parent_ctx</span><span class="p">,</span>
					    <span class="n">child</span><span class="p">,</span> <span class="n">leader</span><span class="p">,</span> <span class="n">child_ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">child_ctr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">child_ctr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">inherit_task_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">parent_ctx</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ctxn</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="o">*</span><span class="n">inherited_all</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">child_ctx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">inherit</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">inherited_all</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">child_ctx</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is executed from the parent task context, so</span>
<span class="cm">		 * inherit events that have been marked for cloning.</span>
<span class="cm">		 * First allocate and initialize a context for the</span>
<span class="cm">		 * child.</span>
<span class="cm">		 */</span>

		<span class="n">child_ctx</span> <span class="o">=</span> <span class="n">alloc_perf_context</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child_ctx</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">child</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">]</span> <span class="o">=</span> <span class="n">child_ctx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">inherit_group</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">parent_ctx</span><span class="p">,</span>
			    <span class="n">child</span><span class="p">,</span> <span class="n">child_ctx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="o">*</span><span class="n">inherited_all</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the perf_event context in task_struct</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">perf_event_init_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ctxn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">child_ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">parent_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">cloned_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">inherited_all</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">]))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the parent&#39;s context is a clone, pin it so it won&#39;t get</span>
<span class="cm">	 * swapped under us.</span>
<span class="cm">	 */</span>
	<span class="n">parent_ctx</span> <span class="o">=</span> <span class="n">perf_pin_task_context</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">ctxn</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * No need to check if parent_ctx != NULL here; since we saw</span>
<span class="cm">	 * it non-NULL earlier, the only reason for it to become NULL</span>
<span class="cm">	 * is if we exit, and since we&#39;re currently in the middle of</span>
<span class="cm">	 * a fork we can&#39;t be exiting at the same time.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Lock the parent list. No need to lock the child - not PID</span>
<span class="cm">	 * hashed yet and not running, so nobody can access it.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We dont have to disable NMIs - we are only looking at</span>
<span class="cm">	 * the list, not manipulating it:</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_ctx</span><span class="o">-&gt;</span><span class="n">pinned_groups</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">inherit_task_group</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">parent_ctx</span><span class="p">,</span>
					 <span class="n">child</span><span class="p">,</span> <span class="n">ctxn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inherited_all</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t hold ctx-&gt;lock when iterating the -&gt;flexible_group list due</span>
<span class="cm">	 * to allocations, but we need to prevent rotation because</span>
<span class="cm">	 * rotate_ctx() will change the list from interrupt context.</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">parent_ctx</span><span class="o">-&gt;</span><span class="n">rotate_disable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_ctx</span><span class="o">-&gt;</span><span class="n">flexible_groups</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">inherit_task_group</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">parent_ctx</span><span class="p">,</span>
					 <span class="n">child</span><span class="p">,</span> <span class="n">ctxn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inherited_all</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">parent_ctx</span><span class="o">-&gt;</span><span class="n">rotate_disable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">child_ctx</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">ctxn</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">child_ctx</span> <span class="o">&amp;&amp;</span> <span class="n">inherited_all</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Mark the child context as a clone of the parent</span>
<span class="cm">		 * context, or of whatever the parent is a clone of.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note that if the parent is a clone, the holding of</span>
<span class="cm">		 * parent_ctx-&gt;lock avoids it from being uncloned.</span>
<span class="cm">		 */</span>
		<span class="n">cloned_ctx</span> <span class="o">=</span> <span class="n">parent_ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cloned_ctx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span> <span class="o">=</span> <span class="n">cloned_ctx</span><span class="p">;</span>
			<span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">parent_gen</span> <span class="o">=</span> <span class="n">parent_ctx</span><span class="o">-&gt;</span><span class="n">parent_gen</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span> <span class="o">=</span> <span class="n">parent_ctx</span><span class="p">;</span>
			<span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">parent_gen</span> <span class="o">=</span> <span class="n">parent_ctx</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">get_ctx</span><span class="p">(</span><span class="n">child_ctx</span><span class="o">-&gt;</span><span class="n">parent_ctx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_ctx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">perf_unpin_context</span><span class="p">(</span><span class="n">parent_ctx</span><span class="p">);</span>
	<span class="n">put_ctx</span><span class="p">(</span><span class="n">parent_ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the perf_event context in task_struct</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">perf_event_init_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ctxn</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">perf_event_ctxp</span><span class="p">));</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">perf_event_mutex</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">perf_event_list</span><span class="p">);</span>

	<span class="n">for_each_task_context_nr</span><span class="p">(</span><span class="n">ctxn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">perf_event_init_context</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">ctxn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">perf_event_init_all_cpus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swevent_htable</span> <span class="o">*</span><span class="n">swhash</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">swhash</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">swevent_htable</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">hlist_mutex</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">rotation_list</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">perf_event_init_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swevent_htable</span> <span class="o">*</span><span class="n">swhash</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">swevent_htable</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">hlist_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">hlist_refcount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">swevent_hlist</span> <span class="o">*</span><span class="n">hlist</span><span class="p">;</span>

		<span class="n">hlist</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hlist</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">hlist</span><span class="p">);</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">swevent_hlist</span><span class="p">,</span> <span class="n">hlist</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">hlist_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if defined CONFIG_HOTPLUG_CPU || defined CONFIG_KEXEC</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_pmu_rotate_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cpu_context</span> <span class="o">*</span><span class="n">cpuctx</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpuctx</span><span class="o">-&gt;</span><span class="n">rotation_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__perf_event_exit_context</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">__info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">perf_pmu_rotate_stop</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pmu</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pinned_groups</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span>
		<span class="n">__perf_remove_from_context</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flexible_groups</span><span class="p">,</span> <span class="n">group_entry</span><span class="p">)</span>
		<span class="n">__perf_remove_from_context</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_exit_cpu_context</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmus_srcu</span><span class="p">);</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">pmu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmus</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">pmu_cpu_context</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">__perf_event_exit_context</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmus_srcu</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_event_exit_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swevent_htable</span> <span class="o">*</span><span class="n">swhash</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">swevent_htable</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">hlist_mutex</span><span class="p">);</span>
	<span class="n">swevent_hlist_release</span><span class="p">(</span><span class="n">swhash</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swhash</span><span class="o">-&gt;</span><span class="n">hlist_mutex</span><span class="p">);</span>

	<span class="n">perf_event_exit_cpu_context</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">perf_event_exit_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">perf_reboot</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">notifier</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">perf_event_exit_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Run the perf reboot notifier at the very last possible moment so that</span>
<span class="cm"> * the generic watchdog code runs as long as possible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">perf_reboot_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">perf_reboot</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span>
<span class="nf">perf_cpu_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CPU_TASKS_FROZEN</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED</span>:
		<span class="n">perf_event_init_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_UP_CANCELED</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE</span>:
		<span class="n">perf_event_exit_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">perf_event_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">idr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmu_idr</span><span class="p">);</span>

	<span class="n">perf_event_init_all_cpus</span><span class="p">();</span>
	<span class="n">init_srcu_struct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmus_srcu</span><span class="p">);</span>
	<span class="n">perf_pmu_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perf_swevent</span><span class="p">,</span> <span class="s">&quot;software&quot;</span><span class="p">,</span> <span class="n">PERF_TYPE_SOFTWARE</span><span class="p">);</span>
	<span class="n">perf_pmu_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perf_cpu_clock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">perf_pmu_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perf_task_clock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">perf_tp_register</span><span class="p">();</span>
	<span class="n">perf_cpu_notifier</span><span class="p">(</span><span class="n">perf_cpu_notify</span><span class="p">);</span>
	<span class="n">register_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perf_reboot_notifier</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">init_hw_breakpoint</span><span class="p">();</span>
	<span class="n">WARN</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="s">&quot;hw_breakpoint initialization failed with: %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="cm">/* do not patch jump label more than once per second */</span>
	<span class="n">jump_label_rate_limit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perf_sched_events</span><span class="p">,</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Build time assertion that we keep the data_head at the intended</span>
<span class="cm">	 * location.  IOW, validation we got the __reserved[] size right.</span>
<span class="cm">	 */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">((</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event_mmap_page</span><span class="p">,</span> <span class="n">data_head</span><span class="p">))</span>
		     <span class="o">!=</span> <span class="mi">1024</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">perf_event_sysfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pmu</span> <span class="o">*</span><span class="n">pmu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmus_lock</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">bus_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmu_bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pmu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmus</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmu</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">||</span> <span class="n">pmu</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">pmu_dev_alloc</span><span class="p">(</span><span class="n">pmu</span><span class="p">);</span>
		<span class="n">WARN</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="s">&quot;Failed to register pmu: %s, reason %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pmu</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pmu_bus_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmus_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">device_initcall</span><span class="p">(</span><span class="n">perf_event_sysfs_init</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_CGROUP_PERF</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="nf">perf_cgroup_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cgroup</span> <span class="o">*</span><span class="n">jc</span><span class="p">;</span>

	<span class="n">jc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">jc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">jc</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_cgroup_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jc</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">jc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">jc</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_cgroup_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">perf_cgroup</span> <span class="o">*</span><span class="n">jc</span><span class="p">;</span>
	<span class="n">jc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cgroup_subsys_state</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">perf_subsys_id</span><span class="p">),</span>
			  <span class="k">struct</span> <span class="n">perf_cgroup</span><span class="p">,</span> <span class="n">css</span><span class="p">);</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">jc</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">jc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__perf_cgroup_move</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">perf_cgroup_switch</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PERF_CGROUP_SWOUT</span> <span class="o">|</span> <span class="n">PERF_CGROUP_SWIN</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_cgroup_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>

	<span class="n">cgroup_taskset_for_each</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">cgrp</span><span class="p">,</span> <span class="n">tset</span><span class="p">)</span>
		<span class="n">task_function_call</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">__perf_cgroup_move</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perf_cgroup_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">old_cgrp</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * cgroup_exit() is called in the copy_process() failure path.</span>
<span class="cm">	 * Ignore this case since the task hasn&#39;t ran yet, this avoids</span>
<span class="cm">	 * trying to poke a half freed task state from generic code.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">task_function_call</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">__perf_cgroup_move</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="n">perf_subsys</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;perf_event&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">subsys_id</span>	<span class="o">=</span> <span class="n">perf_subsys_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create</span>		<span class="o">=</span> <span class="n">perf_cgroup_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy</span>	<span class="o">=</span> <span class="n">perf_cgroup_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">exit</span>		<span class="o">=</span> <span class="n">perf_cgroup_exit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attach</span>		<span class="o">=</span> <span class="n">perf_cgroup_attach</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CGROUP_PERF */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
