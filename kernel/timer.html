<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › timer.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>timer.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/kernel/timer.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Kernel internal timers, basic process system calls</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  1997-01-28  Modified by Finn Arne Gangstad to make timers scale better.</span>
<span class="cm"> *</span>
<span class="cm"> *  1997-09-10  Updated NTP code according to technical memorandum Jan &#39;96</span>
<span class="cm"> *              &quot;A Kernel Model for Precision Timekeeping&quot; by Dave Mills</span>
<span class="cm"> *  1998-12-24  Fixed a xtime SMP race (we need the xtime_lock rw spinlock to</span>
<span class="cm"> *              serialize accesses to xtime/lost_ticks).</span>
<span class="cm"> *                              Copyright (C) 1998  Andrea Arcangeli</span>
<span class="cm"> *  1999-03-10  Improved NTP compatibility by Ulrich Windl</span>
<span class="cm"> *  2002-05-31	Move sys_sysinfo here and make its locking sane, Robert Love</span>
<span class="cm"> *  2000-10-05  Implemented scalable SMP per-CPU timer handling.</span>
<span class="cm"> *                              Copyright (C) 2000, 2001, 2002  Ingo Molnar</span>
<span class="cm"> *              Designed by David S. Miller, Alexey Kuznetsov and Ingo Molnar</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/pid_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/thread_info.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/posix-timers.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/tick.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/irq_work.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/unistd.h&gt;</span>
<span class="cp">#include &lt;asm/div64.h&gt;</span>
<span class="cp">#include &lt;asm/timex.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/timer.h&gt;</span>

<span class="n">u64</span> <span class="n">jiffies_64</span> <span class="n">__cacheline_aligned_in_smp</span> <span class="o">=</span> <span class="n">INITIAL_JIFFIES</span><span class="p">;</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jiffies_64</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * per-CPU timer vector definitions:</span>
<span class="cm"> */</span>
<span class="cp">#define TVN_BITS (CONFIG_BASE_SMALL ? 4 : 6)</span>
<span class="cp">#define TVR_BITS (CONFIG_BASE_SMALL ? 6 : 8)</span>
<span class="cp">#define TVN_SIZE (1 &lt;&lt; TVN_BITS)</span>
<span class="cp">#define TVR_SIZE (1 &lt;&lt; TVR_BITS)</span>
<span class="cp">#define TVN_MASK (TVN_SIZE - 1)</span>
<span class="cp">#define TVR_MASK (TVR_SIZE - 1)</span>

<span class="k">struct</span> <span class="n">tvec</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">vec</span><span class="p">[</span><span class="n">TVN_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tvec_root</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">vec</span><span class="p">[</span><span class="n">TVR_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tvec_base</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">running_timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timer_jiffies</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tvec_root</span> <span class="n">tv1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tvec</span> <span class="n">tv2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tvec</span> <span class="n">tv3</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tvec</span> <span class="n">tv4</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tvec</span> <span class="n">tv5</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">tvec_base</span> <span class="n">boot_tvec_bases</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">boot_tvec_bases</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="p">,</span> <span class="n">tvec_bases</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boot_tvec_bases</span><span class="p">;</span>

<span class="cm">/* Functions below help us manage &#39;deferrable&#39; flag */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tbase_get_deferrable</span><span class="p">(</span><span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">base</span> <span class="o">&amp;</span> <span class="n">TBASE_DEFERRABLE_FLAG</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="nf">tbase_get_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">base</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">TBASE_DEFERRABLE_FLAG</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">timer_set_deferrable</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">TBASE_MAKE_DEFERRED</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">timer_set_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">new_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">new_base</span><span class="p">)</span> <span class="o">|</span>
				      <span class="n">tbase_get_deferrable</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">round_jiffies_common</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
		<span class="n">bool</span> <span class="n">force_up</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rem</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">original</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t want all cpus firing their timers at once hitting the</span>
<span class="cm">	 * same lock or cachelines, so we skew each extra cpu with an extra</span>
<span class="cm">	 * 3 jiffies. This 3 jiffies came originally from the mm/ code which</span>
<span class="cm">	 * already did this.</span>
<span class="cm">	 * The skew is done by adding 3*cpunr, then round, then subtract this</span>
<span class="cm">	 * extra offset again.</span>
<span class="cm">	 */</span>
	<span class="n">j</span> <span class="o">+=</span> <span class="n">cpu</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">rem</span> <span class="o">=</span> <span class="n">j</span> <span class="o">%</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the target jiffie is just after a whole second (which can happen</span>
<span class="cm">	 * due to delays of the timer irq, long irq off times etc etc) then</span>
<span class="cm">	 * we should round down to the whole second, not up. Use 1/4th second</span>
<span class="cm">	 * as cutoff for this rounding as an extreme upper bound for this.</span>
<span class="cm">	 * But never round down if @force_up is set.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rem</span> <span class="o">&lt;</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">force_up</span><span class="p">)</span> <span class="cm">/* round down */</span>
		<span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">rem</span><span class="p">;</span>
	<span class="k">else</span> <span class="cm">/* round up */</span>
		<span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">rem</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="cm">/* now that we have rounded, subtract the extra skew again */</span>
	<span class="n">j</span> <span class="o">-=</span> <span class="n">cpu</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">jiffies</span><span class="p">)</span> <span class="cm">/* rounding ate our timeout entirely; */</span>
		<span class="k">return</span> <span class="n">original</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __round_jiffies - function to round jiffies to a full second</span>
<span class="cm"> * @j: the time in (absolute) jiffies that should be rounded</span>
<span class="cm"> * @cpu: the processor number on which the timeout will happen</span>
<span class="cm"> *</span>
<span class="cm"> * __round_jiffies() rounds an absolute time in the future (in jiffies)</span>
<span class="cm"> * up or down to (approximately) full seconds. This is useful for timers</span>
<span class="cm"> * for which the exact time they fire does not matter too much, as long as</span>
<span class="cm"> * they fire approximately every X seconds.</span>
<span class="cm"> *</span>
<span class="cm"> * By rounding these timers to whole seconds, all such timers will fire</span>
<span class="cm"> * at the same time, rather than at various times spread out. The goal</span>
<span class="cm"> * of this is to have the CPU wake up less, which saves power.</span>
<span class="cm"> *</span>
<span class="cm"> * The exact rounding is skewed for each processor to avoid all</span>
<span class="cm"> * processors firing at the exact same time, which could lead</span>
<span class="cm"> * to lock contention or spurious cache line bouncing.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the rounded version of the @j parameter.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__round_jiffies</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">round_jiffies_common</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__round_jiffies</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __round_jiffies_relative - function to round jiffies to a full second</span>
<span class="cm"> * @j: the time in (relative) jiffies that should be rounded</span>
<span class="cm"> * @cpu: the processor number on which the timeout will happen</span>
<span class="cm"> *</span>
<span class="cm"> * __round_jiffies_relative() rounds a time delta  in the future (in jiffies)</span>
<span class="cm"> * up or down to (approximately) full seconds. This is useful for timers</span>
<span class="cm"> * for which the exact time they fire does not matter too much, as long as</span>
<span class="cm"> * they fire approximately every X seconds.</span>
<span class="cm"> *</span>
<span class="cm"> * By rounding these timers to whole seconds, all such timers will fire</span>
<span class="cm"> * at the same time, rather than at various times spread out. The goal</span>
<span class="cm"> * of this is to have the CPU wake up less, which saves power.</span>
<span class="cm"> *</span>
<span class="cm"> * The exact rounding is skewed for each processor to avoid all</span>
<span class="cm"> * processors firing at the exact same time, which could lead</span>
<span class="cm"> * to lock contention or spurious cache line bouncing.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the rounded version of the @j parameter.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__round_jiffies_relative</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j0</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/* Use j0 because jiffies might change while we run */</span>
	<span class="k">return</span> <span class="n">round_jiffies_common</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">j0</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span> <span class="o">-</span> <span class="n">j0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__round_jiffies_relative</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * round_jiffies - function to round jiffies to a full second</span>
<span class="cm"> * @j: the time in (absolute) jiffies that should be rounded</span>
<span class="cm"> *</span>
<span class="cm"> * round_jiffies() rounds an absolute time in the future (in jiffies)</span>
<span class="cm"> * up or down to (approximately) full seconds. This is useful for timers</span>
<span class="cm"> * for which the exact time they fire does not matter too much, as long as</span>
<span class="cm"> * they fire approximately every X seconds.</span>
<span class="cm"> *</span>
<span class="cm"> * By rounding these timers to whole seconds, all such timers will fire</span>
<span class="cm"> * at the same time, rather than at various times spread out. The goal</span>
<span class="cm"> * of this is to have the CPU wake up less, which saves power.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the rounded version of the @j parameter.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">round_jiffies</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">round_jiffies_common</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">raw_smp_processor_id</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">round_jiffies</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * round_jiffies_relative - function to round jiffies to a full second</span>
<span class="cm"> * @j: the time in (relative) jiffies that should be rounded</span>
<span class="cm"> *</span>
<span class="cm"> * round_jiffies_relative() rounds a time delta  in the future (in jiffies)</span>
<span class="cm"> * up or down to (approximately) full seconds. This is useful for timers</span>
<span class="cm"> * for which the exact time they fire does not matter too much, as long as</span>
<span class="cm"> * they fire approximately every X seconds.</span>
<span class="cm"> *</span>
<span class="cm"> * By rounding these timers to whole seconds, all such timers will fire</span>
<span class="cm"> * at the same time, rather than at various times spread out. The goal</span>
<span class="cm"> * of this is to have the CPU wake up less, which saves power.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the rounded version of the @j parameter.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">round_jiffies_relative</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__round_jiffies_relative</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">raw_smp_processor_id</span><span class="p">());</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">round_jiffies_relative</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __round_jiffies_up - function to round jiffies up to a full second</span>
<span class="cm"> * @j: the time in (absolute) jiffies that should be rounded</span>
<span class="cm"> * @cpu: the processor number on which the timeout will happen</span>
<span class="cm"> *</span>
<span class="cm"> * This is the same as __round_jiffies() except that it will never</span>
<span class="cm"> * round down.  This is useful for timeouts for which the exact time</span>
<span class="cm"> * of firing does not matter too much, as long as they don&#39;t fire too</span>
<span class="cm"> * early.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__round_jiffies_up</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">round_jiffies_common</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__round_jiffies_up</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __round_jiffies_up_relative - function to round jiffies up to a full second</span>
<span class="cm"> * @j: the time in (relative) jiffies that should be rounded</span>
<span class="cm"> * @cpu: the processor number on which the timeout will happen</span>
<span class="cm"> *</span>
<span class="cm"> * This is the same as __round_jiffies_relative() except that it will never</span>
<span class="cm"> * round down.  This is useful for timeouts for which the exact time</span>
<span class="cm"> * of firing does not matter too much, as long as they don&#39;t fire too</span>
<span class="cm"> * early.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__round_jiffies_up_relative</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j0</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/* Use j0 because jiffies might change while we run */</span>
	<span class="k">return</span> <span class="n">round_jiffies_common</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">j0</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">-</span> <span class="n">j0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__round_jiffies_up_relative</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * round_jiffies_up - function to round jiffies up to a full second</span>
<span class="cm"> * @j: the time in (absolute) jiffies that should be rounded</span>
<span class="cm"> *</span>
<span class="cm"> * This is the same as round_jiffies() except that it will never</span>
<span class="cm"> * round down.  This is useful for timeouts for which the exact time</span>
<span class="cm"> * of firing does not matter too much, as long as they don&#39;t fire too</span>
<span class="cm"> * early.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">round_jiffies_up</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">round_jiffies_common</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">raw_smp_processor_id</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">round_jiffies_up</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * round_jiffies_up_relative - function to round jiffies up to a full second</span>
<span class="cm"> * @j: the time in (relative) jiffies that should be rounded</span>
<span class="cm"> *</span>
<span class="cm"> * This is the same as round_jiffies_relative() except that it will never</span>
<span class="cm"> * round down.  This is useful for timeouts for which the exact time</span>
<span class="cm"> * of firing does not matter too much, as long as they don&#39;t fire too</span>
<span class="cm"> * early.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">round_jiffies_up_relative</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__round_jiffies_up_relative</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">raw_smp_processor_id</span><span class="p">());</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">round_jiffies_up_relative</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * set_timer_slack - set the allowed slack for a timer</span>
<span class="cm"> * @timer: the timer to be modified</span>
<span class="cm"> * @slack_hz: the amount of time (in jiffies) allowed for rounding</span>
<span class="cm"> *</span>
<span class="cm"> * Set the amount of time, in jiffies, that a certain timer has</span>
<span class="cm"> * in terms of slack. By setting this value, the timer subsystem</span>
<span class="cm"> * will schedule the actual timer somewhere between</span>
<span class="cm"> * the time mod_timer() asks for, and that time plus the slack.</span>
<span class="cm"> *</span>
<span class="cm"> * By setting the slack to -1, a percentage of the delay is used</span>
<span class="cm"> * instead.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">set_timer_slack</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slack_hz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">slack</span> <span class="o">=</span> <span class="n">slack_hz</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">set_timer_slack</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">internal_add_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">expires</span> <span class="o">-</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">timer_jiffies</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">vec</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">TVR_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">expires</span> <span class="o">&amp;</span> <span class="n">TVR_MASK</span><span class="p">;</span>
		<span class="n">vec</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">tv1</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">TVR_BITS</span> <span class="o">+</span> <span class="n">TVN_BITS</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">expires</span> <span class="o">&gt;&gt;</span> <span class="n">TVR_BITS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TVN_MASK</span><span class="p">;</span>
		<span class="n">vec</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">tv2</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">TVR_BITS</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">TVN_BITS</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">expires</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">TVR_BITS</span> <span class="o">+</span> <span class="n">TVN_BITS</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">TVN_MASK</span><span class="p">;</span>
		<span class="n">vec</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">tv3</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">TVR_BITS</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">TVN_BITS</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">expires</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">TVR_BITS</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">TVN_BITS</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">TVN_MASK</span><span class="p">;</span>
		<span class="n">vec</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">tv4</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="kt">signed</span> <span class="kt">long</span><span class="p">)</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Can happen if you add a timer with expires == jiffies,</span>
<span class="cm">		 * or you set a timer to go off in the past</span>
<span class="cm">		 */</span>
		<span class="n">vec</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">tv1</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">timer_jiffies</span> <span class="o">&amp;</span> <span class="n">TVR_MASK</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/* If the timeout is larger than 0xffffffff on 64-bit</span>
<span class="cm">		 * architectures then we use the maximum timeout:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="mh">0xffffffffUL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="mh">0xffffffffUL</span><span class="p">;</span>
			<span class="n">expires</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">timer_jiffies</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">expires</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">TVR_BITS</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">TVN_BITS</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">TVN_MASK</span><span class="p">;</span>
		<span class="n">vec</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">tv5</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Timers are FIFO:</span>
<span class="cm">	 */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">vec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_TIMER_STATS</span>
<span class="kt">void</span> <span class="nf">__timer_stats_timer_set_start_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_site</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_site</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">TASK_COMM_LEN</span><span class="p">);</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">timer_stats_account_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_site</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tbase_get_deferrable</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)))</span>
		<span class="n">flag</span> <span class="o">|=</span> <span class="n">TIMER_STATS_FLAG_DEFERRABLE</span><span class="p">;</span>

	<span class="n">timer_stats_update_stats</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_pid</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_site</span><span class="p">,</span>
				 <span class="n">timer</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_comm</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">timer_stats_account_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_DEBUG_OBJECTS_TIMERS</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="n">timer_debug_descr</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">timer_debug_hint</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_init is called when:</span>
<span class="cm"> * - an active object is initialized</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">timer_fixup_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">debug_object_init</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer_debug_descr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Stub timer callback for improperly used timers. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">stub_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_activate is called when:</span>
<span class="cm"> * - an active object is activated</span>
<span class="cm"> * - an unknown object is activated (might be a statically initialized object)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">timer_fixup_activate</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">ODEBUG_STATE_NOTAVAILABLE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * This is not really a fixup. The timer was</span>
<span class="cm">		 * statically initialized. We just make sure that it</span>
<span class="cm">		 * is tracked in the object tracker.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">.</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
		    <span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">.</span><span class="n">prev</span> <span class="o">==</span> <span class="n">TIMER_ENTRY_STATIC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">debug_object_init</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer_debug_descr</span><span class="p">);</span>
			<span class="n">debug_object_activate</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer_debug_descr</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">setup_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">stub_timer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_free is called when:</span>
<span class="cm"> * - an active object is freed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">timer_fixup_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">debug_object_free</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer_debug_descr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_assert_init is called when:</span>
<span class="cm"> * - an untracked/uninit-ed object is found</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">timer_fixup_assert_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_NOTAVAILABLE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">.</span><span class="n">prev</span> <span class="o">==</span> <span class="n">TIMER_ENTRY_STATIC</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is not really a fixup. The timer was</span>
<span class="cm">			 * statically initialized. We just make sure that it</span>
<span class="cm">			 * is tracked in the object tracker.</span>
<span class="cm">			 */</span>
			<span class="n">debug_object_init</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer_debug_descr</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">setup_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">stub_timer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="n">timer_debug_descr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;timer_list&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">debug_hint</span>		<span class="o">=</span> <span class="n">timer_debug_hint</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_init</span>		<span class="o">=</span> <span class="n">timer_fixup_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_activate</span>		<span class="o">=</span> <span class="n">timer_fixup_activate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_free</span>		<span class="o">=</span> <span class="n">timer_fixup_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_assert_init</span>	<span class="o">=</span> <span class="n">timer_fixup_assert_init</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_timer_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_init</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer_debug_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_timer_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_activate</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer_debug_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_timer_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_deactivate</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer_debug_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_timer_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_free</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer_debug_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_timer_assert_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_assert_init</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer_debug_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">init_timer_on_stack_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_init_on_stack</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer_debug_descr</span><span class="p">);</span>
	<span class="n">__init_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">init_timer_on_stack_key</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">destroy_timer_on_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_free</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer_debug_descr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">destroy_timer_on_stack</span><span class="p">);</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_timer_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_timer_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_timer_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_timer_assert_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_timer_init</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">trace_timer_init</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">debug_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_timer_activate</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">trace_timer_start</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">expires</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_timer_deactivate</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">trace_timer_cancel</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_assert_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_timer_assert_init</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__init_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">__raw_get_cpu_var</span><span class="p">(</span><span class="n">tvec_bases</span><span class="p">);</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">slack</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_TIMER_STATS</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_site</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_pid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_comm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TASK_COMM_LEN</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">lockdep_init_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">setup_deferrable_timer_on_stack_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">init_timer_on_stack_key</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="n">timer_set_deferrable</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">setup_deferrable_timer_on_stack_key</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * init_timer_key - initialize a timer</span>
<span class="cm"> * @timer: the timer to be initialized</span>
<span class="cm"> * @name: name of the timer</span>
<span class="cm"> * @key: lockdep class key of the fake lock used for tracking timer</span>
<span class="cm"> *       sync lock dependencies</span>
<span class="cm"> *</span>
<span class="cm"> * init_timer_key() must be done to a timer prior calling *any* of the</span>
<span class="cm"> * other timer functions.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">init_timer_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_init</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">__init_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">init_timer_key</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">init_timer_deferrable_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">init_timer_key</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="n">timer_set_deferrable</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">init_timer_deferrable_key</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">detach_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">clear_pending</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">debug_deactivate</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">__list_del</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clear_pending</span><span class="p">)</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">LIST_POISON2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We are using hashed locking: holding per_cpu(tvec_bases).lock</span>
<span class="cm"> * means that all timers which are tied to this base via timer-&gt;base are</span>
<span class="cm"> * locked, and the base itself is locked too.</span>
<span class="cm"> *</span>
<span class="cm"> * So __run_timers/migrate_timers can safely modify all timers which could</span>
<span class="cm"> * be found on -&gt;tvX lists.</span>
<span class="cm"> *</span>
<span class="cm"> * When the timer&#39;s base is locked, and the timer removed from list, it is</span>
<span class="cm"> * possible to set timer-&gt;base = NULL and drop the lock: the timer remains</span>
<span class="cm"> * locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="nf">lock_timer_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">prelock_base</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">tbase_get_base</span><span class="p">(</span><span class="n">prelock_base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">base</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">prelock_base</span> <span class="o">==</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">base</span><span class="p">;</span>
			<span class="cm">/* The timer has migrated to another CPU */</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">__mod_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">,</span>
						<span class="n">bool</span> <span class="n">pending_only</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pinned</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="o">*</span><span class="n">new_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">timer_stats_timer_set_start_info</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">);</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">lock_timer_base</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">detach_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">==</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">next_timer</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">tbase_get_deferrable</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">))</span>
			<span class="n">base</span><span class="o">-&gt;</span><span class="n">next_timer</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">timer_jiffies</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pending_only</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">debug_activate</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">expires</span><span class="p">);</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

<span class="cp">#if defined(CONFIG_NO_HZ) &amp;&amp; defined(CONFIG_SMP)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinned</span> <span class="o">&amp;&amp;</span> <span class="n">get_sysctl_timer_migration</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_nohz_timer_target</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">new_base</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">tvec_bases</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">!=</span> <span class="n">new_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are trying to schedule the timer on the local CPU.</span>
<span class="cm">		 * However we can&#39;t change timer&#39;s base while it is running,</span>
<span class="cm">		 * otherwise del_timer_sync() can&#39;t detect that the timer&#39;s</span>
<span class="cm">		 * handler yet has not finished. This also guarantees that</span>
<span class="cm">		 * the timer is serialized wrt itself.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">running_timer</span> <span class="o">!=</span> <span class="n">timer</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* See the comment in lock_timer_base() */</span>
			<span class="n">timer_set_base</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">base</span> <span class="o">=</span> <span class="n">new_base</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">timer_set_base</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="n">expires</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">,</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">next_timer</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">tbase_get_deferrable</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">))</span>
		<span class="n">base</span><span class="o">-&gt;</span><span class="n">next_timer</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">;</span>
	<span class="n">internal_add_timer</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">timer</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mod_timer_pending - modify a pending timer&#39;s timeout</span>
<span class="cm"> * @timer: the pending timer to be modified</span>
<span class="cm"> * @expires: new timeout in jiffies</span>
<span class="cm"> *</span>
<span class="cm"> * mod_timer_pending() is the same for pending timers as mod_timer(),</span>
<span class="cm"> * but will not re-activate and modify already deleted timers.</span>
<span class="cm"> *</span>
<span class="cm"> * It is useful for unserialized use of timers.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mod_timer_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__mod_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">expires</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">TIMER_NOT_PINNED</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mod_timer_pending</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Decide where to put the timer while taking the slack into account</span>
<span class="cm"> *</span>
<span class="cm"> * Algorithm:</span>
<span class="cm"> *   1) calculate the maximum (absolute) time</span>
<span class="cm"> *   2) calculate the highest bit where the expires and new max are different</span>
<span class="cm"> *   3) use this bit to make a mask</span>
<span class="cm"> *   4) use the bitmask to round down the maximum time, so that all last</span>
<span class="cm"> *      bits are zeros</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">apply_slack</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires_limit</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">slack</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">expires_limit</span> <span class="o">=</span> <span class="n">expires</span> <span class="o">+</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">slack</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">expires</span> <span class="o">-</span> <span class="n">jiffies</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">expires</span><span class="p">;</span>

		<span class="n">expires_limit</span> <span class="o">=</span> <span class="n">expires</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">/</span> <span class="mi">256</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">expires</span> <span class="o">^</span> <span class="n">expires_limit</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">expires</span><span class="p">;</span>

	<span class="n">bit</span> <span class="o">=</span> <span class="n">find_last_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">BITS_PER_LONG</span><span class="p">);</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">expires_limit</span> <span class="o">=</span> <span class="n">expires_limit</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">expires_limit</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mod_timer - modify a timer&#39;s timeout</span>
<span class="cm"> * @timer: the timer to be modified</span>
<span class="cm"> * @expires: new timeout in jiffies</span>
<span class="cm"> *</span>
<span class="cm"> * mod_timer() is a more efficient way to update the expire field of an</span>
<span class="cm"> * active timer (if the timer is inactive it will be activated)</span>
<span class="cm"> *</span>
<span class="cm"> * mod_timer(timer, expires) is equivalent to:</span>
<span class="cm"> *</span>
<span class="cm"> *     del_timer(timer); timer-&gt;expires = expires; add_timer(timer);</span>
<span class="cm"> *</span>
<span class="cm"> * Note that if there are multiple unserialized concurrent users of the</span>
<span class="cm"> * same timer, then mod_timer() is the only safe way to modify the timeout,</span>
<span class="cm"> * since add_timer() cannot modify an already running timer.</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns whether it has modified a pending timer or not.</span>
<span class="cm"> * (ie. mod_timer() of an inactive timer returns 0, mod_timer() of an</span>
<span class="cm"> * active timer returns 1.)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mod_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">expires</span> <span class="o">=</span> <span class="n">apply_slack</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">expires</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a common optimization triggered by the</span>
<span class="cm">	 * networking code - if the timer is re-modified</span>
<span class="cm">	 * to be the same thing then just return:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">==</span> <span class="n">expires</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__mod_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">expires</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">TIMER_NOT_PINNED</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mod_timer</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * mod_timer_pinned - modify a timer&#39;s timeout</span>
<span class="cm"> * @timer: the timer to be modified</span>
<span class="cm"> * @expires: new timeout in jiffies</span>
<span class="cm"> *</span>
<span class="cm"> * mod_timer_pinned() is a way to update the expire field of an</span>
<span class="cm"> * active timer (if the timer is inactive it will be activated)</span>
<span class="cm"> * and to ensure that the timer is scheduled on the current CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this does not prevent the timer from being migrated</span>
<span class="cm"> * when the current CPU goes offline.  If this is a problem for</span>
<span class="cm"> * you, use CPU-hotplug notifiers to handle it correctly, for</span>
<span class="cm"> * example, cancelling the timer when the corresponding CPU goes</span>
<span class="cm"> * offline.</span>
<span class="cm"> *</span>
<span class="cm"> * mod_timer_pinned(timer, expires) is equivalent to:</span>
<span class="cm"> *</span>
<span class="cm"> *     del_timer(timer); timer-&gt;expires = expires; add_timer(timer);</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mod_timer_pinned</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">==</span> <span class="n">expires</span> <span class="o">&amp;&amp;</span> <span class="n">timer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__mod_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">expires</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">TIMER_PINNED</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mod_timer_pinned</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * add_timer - start a timer</span>
<span class="cm"> * @timer: the timer to be added</span>
<span class="cm"> *</span>
<span class="cm"> * The kernel will do a -&gt;function(-&gt;data) callback from the</span>
<span class="cm"> * timer interrupt at the -&gt;expires point in the future. The</span>
<span class="cm"> * current time is &#39;jiffies&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * The timer&#39;s -&gt;expires, -&gt;function (and if the handler uses it, -&gt;data)</span>
<span class="cm"> * fields must be set prior calling this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Timers with an -&gt;expires field in the past will be executed in the next</span>
<span class="cm"> * timer tick.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">add_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">));</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">add_timer</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * add_timer_on - start a timer on a particular CPU</span>
<span class="cm"> * @timer: the timer to be added</span>
<span class="cm"> * @cpu: the CPU to start it on</span>
<span class="cm"> *</span>
<span class="cm"> * This is not very scalable on SMP. Double adds are not possible.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">add_timer_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">tvec_bases</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">timer_stats_timer_set_start_info</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">timer_set_base</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="n">debug_activate</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">,</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">next_timer</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">tbase_get_deferrable</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">))</span>
		<span class="n">base</span><span class="o">-&gt;</span><span class="n">next_timer</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">;</span>
	<span class="n">internal_add_timer</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">timer</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check whether the other CPU is idle and needs to be</span>
<span class="cm">	 * triggered to reevaluate the timer wheel when nohz is</span>
<span class="cm">	 * active. We are protected against the other CPU fiddling</span>
<span class="cm">	 * with the timer by holding the timer base lock. This also</span>
<span class="cm">	 * makes sure that a CPU on the way to idle can not evaluate</span>
<span class="cm">	 * the timer wheel.</span>
<span class="cm">	 */</span>
	<span class="n">wake_up_idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">add_timer_on</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * del_timer - deactive a timer.</span>
<span class="cm"> * @timer: the timer to be deactivated</span>
<span class="cm"> *</span>
<span class="cm"> * del_timer() deactivates a timer - this works on both active and inactive</span>
<span class="cm"> * timers.</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns whether it has deactivated a pending timer or not.</span>
<span class="cm"> * (ie. del_timer() of an inactive timer returns 0, del_timer() of an</span>
<span class="cm"> * active timer returns 1.)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">del_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">debug_assert_init</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">timer_stats_timer_clear_start_info</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">lock_timer_base</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">detach_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">==</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">next_timer</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">tbase_get_deferrable</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">))</span>
				<span class="n">base</span><span class="o">-&gt;</span><span class="n">next_timer</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">timer_jiffies</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">del_timer</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * try_to_del_timer_sync - Try to deactivate a timer</span>
<span class="cm"> * @timer: timer do del</span>
<span class="cm"> *</span>
<span class="cm"> * This function tries to deactivate a timer. Upon successful (ret &gt;= 0)</span>
<span class="cm"> * exit the timer is not queued and the handler is not running on any CPU.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">try_to_del_timer_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">debug_assert_init</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">lock_timer_base</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">running_timer</span> <span class="o">==</span> <span class="n">timer</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">timer_stats_timer_clear_start_info</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">detach_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">==</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">next_timer</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">tbase_get_deferrable</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">))</span>
			<span class="n">base</span><span class="o">-&gt;</span><span class="n">next_timer</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">timer_jiffies</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">try_to_del_timer_sync</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/**</span>
<span class="cm"> * del_timer_sync - deactivate a timer and wait for the handler to finish.</span>
<span class="cm"> * @timer: the timer to be deactivated</span>
<span class="cm"> *</span>
<span class="cm"> * This function only differs from del_timer() on SMP: besides deactivating</span>
<span class="cm"> * the timer it also makes sure the handler has finished executing on other</span>
<span class="cm"> * CPUs.</span>
<span class="cm"> *</span>
<span class="cm"> * Synchronization rules: Callers must prevent restarting of the timer,</span>
<span class="cm"> * otherwise this function is meaningless. It must not be called from</span>
<span class="cm"> * interrupt contexts. The caller must not hold locks which would prevent</span>
<span class="cm"> * completion of the timer&#39;s handler. The timer&#39;s handler must not call</span>
<span class="cm"> * add_timer_on(). Upon exit the timer is not queued and the handler is</span>
<span class="cm"> * not running on any CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: You must not hold locks that are held in interrupt context</span>
<span class="cm"> *   while calling this function. Even if the lock has nothing to do</span>
<span class="cm"> *   with the timer in question.  Here&#39;s why:</span>
<span class="cm"> *</span>
<span class="cm"> *    CPU0                             CPU1</span>
<span class="cm"> *    ----                             ----</span>
<span class="cm"> *                                   &lt;SOFTIRQ&gt;</span>
<span class="cm"> *                                   call_timer_fn();</span>
<span class="cm"> *                                     base-&gt;running_timer = mytimer;</span>
<span class="cm"> *  spin_lock_irq(somelock);</span>
<span class="cm"> *                                     &lt;IRQ&gt;</span>
<span class="cm"> *                                        spin_lock(somelock);</span>
<span class="cm"> *  del_timer_sync(mytimer);</span>
<span class="cm"> *   while (base-&gt;running_timer == mytimer);</span>
<span class="cm"> *</span>
<span class="cm"> * Now del_timer_sync() will never return and never release somelock.</span>
<span class="cm"> * The interrupt on the other CPU is waiting to grab somelock but</span>
<span class="cm"> * it has interrupted the softirq that CPU0 is waiting to finish.</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns whether it has deactivated a pending timer or not.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">del_timer_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If lockdep gives a backtrace here, please reference</span>
<span class="cm">	 * the synchronization rules above.</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">lock_map_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>
	<span class="n">lock_map_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * don&#39;t use it in hardirq context, because it</span>
<span class="cm">	 * could lead to deadlock.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">in_irq</span><span class="p">());</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">try_to_del_timer_sync</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">del_timer_sync</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cascade</span><span class="p">(</span><span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tvec</span> <span class="o">*</span><span class="n">tv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* cascade all the timers from tv up one level */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tv_list</span><span class="p">;</span>

	<span class="n">list_replace_init</span><span class="p">(</span><span class="n">tv</span><span class="o">-&gt;</span><span class="n">vec</span> <span class="o">+</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv_list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are removing _all_ timers from the list, so we</span>
<span class="cm">	 * don&#39;t have to detach them individually.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv_list</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tbase_get_base</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">!=</span> <span class="n">base</span><span class="p">);</span>
		<span class="n">internal_add_timer</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">call_timer_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">preempt_count</span> <span class="o">=</span> <span class="n">preempt_count</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_LOCKDEP</span>
	<span class="cm">/*</span>
<span class="cm">	 * It is permissible to free the timer from inside the</span>
<span class="cm">	 * function that is called from it, this we need to take into</span>
<span class="cm">	 * account for lockdep too. To avoid bogus &quot;held lock freed&quot;</span>
<span class="cm">	 * warnings as well as problems when looking into</span>
<span class="cm">	 * timer-&gt;lockdep_map, make a copy and use that here.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">lockdep_map</span> <span class="n">lockdep_map</span><span class="p">;</span>

	<span class="n">lockdep_copy_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Couple the lock chain with the lock chain at</span>
<span class="cm">	 * del_timer_sync() by acquiring the lock_map around the fn()</span>
<span class="cm">	 * call here and in del_timer_sync().</span>
<span class="cm">	 */</span>
	<span class="n">lock_map_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_map</span><span class="p">);</span>

	<span class="n">trace_timer_expire_entry</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">fn</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="n">trace_timer_expire_exit</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">lock_map_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_map</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">preempt_count</span> <span class="o">!=</span> <span class="n">preempt_count</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;timer: %pF preempt leak: %08x -&gt; %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">fn</span><span class="p">,</span> <span class="n">preempt_count</span><span class="p">,</span> <span class="n">preempt_count</span><span class="p">());</span>
		<span class="cm">/*</span>
<span class="cm">		 * Restore the preempt count. That gives us a decent</span>
<span class="cm">		 * chance to survive and extract information. If the</span>
<span class="cm">		 * callback kept a lock held, bad luck, but not worse</span>
<span class="cm">		 * than the BUG() we had.</span>
<span class="cm">		 */</span>
		<span class="n">preempt_count</span><span class="p">()</span> <span class="o">=</span> <span class="n">preempt_count</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define INDEX(N) ((base-&gt;timer_jiffies &gt;&gt; (TVR_BITS + (N) * TVN_BITS)) &amp; TVN_MASK)</span>

<span class="cm">/**</span>
<span class="cm"> * __run_timers - run all expired timers (if any) on this CPU.</span>
<span class="cm"> * @base: the timer vector to be processed.</span>
<span class="cm"> *</span>
<span class="cm"> * This function cascades all vectors and executes all expired timer</span>
<span class="cm"> * vectors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__run_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">timer_jiffies</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="n">work_list</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">work_list</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">timer_jiffies</span> <span class="o">&amp;</span> <span class="n">TVR_MASK</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Cascade timers:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">index</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="o">!</span><span class="n">cascade</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tv2</span><span class="p">,</span> <span class="n">INDEX</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="o">!</span><span class="n">cascade</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tv3</span><span class="p">,</span> <span class="n">INDEX</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
					<span class="o">!</span><span class="n">cascade</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tv4</span><span class="p">,</span> <span class="n">INDEX</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
			<span class="n">cascade</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tv5</span><span class="p">,</span> <span class="n">INDEX</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
		<span class="o">++</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">timer_jiffies</span><span class="p">;</span>
		<span class="n">list_replace_init</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tv1</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work_list</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">;</span>

			<span class="n">timer</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timer_list</span><span class="p">,</span><span class="n">entry</span><span class="p">);</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">;</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

			<span class="n">timer_stats_account_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>

			<span class="n">base</span><span class="o">-&gt;</span><span class="n">running_timer</span> <span class="o">=</span> <span class="n">timer</span><span class="p">;</span>
			<span class="n">detach_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">call_timer_fn</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">base</span><span class="o">-&gt;</span><span class="n">running_timer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NO_HZ</span>
<span class="cm">/*</span>
<span class="cm"> * Find out when the next timer event is due to happen. This</span>
<span class="cm"> * is used on S/390 to stop all activity when a CPU is idle.</span>
<span class="cm"> * This function needs to be called with interrupts disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__next_timer_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timer_jiffies</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">timer_jiffies</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span> <span class="o">=</span> <span class="n">timer_jiffies</span> <span class="o">+</span> <span class="n">NEXT_TIMER_MAX_DELTA</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">nte</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tvec</span> <span class="o">*</span><span class="n">varray</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="cm">/* Look for timer events in tv1. */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">timer_jiffies</span> <span class="o">&amp;</span> <span class="n">TVR_MASK</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">nte</span><span class="p">,</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">tv1</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">slot</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tbase_get_deferrable</span><span class="p">(</span><span class="n">nte</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">expires</span> <span class="o">=</span> <span class="n">nte</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">;</span>
			<span class="cm">/* Look at the cascade bucket(s)? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">index</span> <span class="o">||</span> <span class="n">slot</span> <span class="o">&lt;</span> <span class="n">index</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">cascade</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">expires</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="p">(</span><span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TVR_MASK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">slot</span> <span class="o">!=</span> <span class="n">index</span><span class="p">);</span>

<span class="nl">cascade:</span>
	<span class="cm">/* Calculate the next cascade event */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span><span class="p">)</span>
		<span class="n">timer_jiffies</span> <span class="o">+=</span> <span class="n">TVR_SIZE</span> <span class="o">-</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">timer_jiffies</span> <span class="o">&gt;&gt;=</span> <span class="n">TVR_BITS</span><span class="p">;</span>

	<span class="cm">/* Check tv2-tv5. */</span>
	<span class="n">varray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tv2</span><span class="p">;</span>
	<span class="n">varray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tv3</span><span class="p">;</span>
	<span class="n">varray</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tv4</span><span class="p">;</span>
	<span class="n">varray</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tv5</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">array</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">array</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">array</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tvec</span> <span class="o">*</span><span class="n">varp</span> <span class="o">=</span> <span class="n">varray</span><span class="p">[</span><span class="n">array</span><span class="p">];</span>

		<span class="n">index</span> <span class="o">=</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">timer_jiffies</span> <span class="o">&amp;</span> <span class="n">TVN_MASK</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">nte</span><span class="p">,</span> <span class="n">varp</span><span class="o">-&gt;</span><span class="n">vec</span> <span class="o">+</span> <span class="n">slot</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tbase_get_deferrable</span><span class="p">(</span><span class="n">nte</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">nte</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">,</span> <span class="n">expires</span><span class="p">))</span>
					<span class="n">expires</span> <span class="o">=</span> <span class="n">nte</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Do we still search for the first timer or are</span>
<span class="cm">			 * we looking up the cascade buckets ?</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Look at the cascade bucket(s)? */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">index</span> <span class="o">||</span> <span class="n">slot</span> <span class="o">&lt;</span> <span class="n">index</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">expires</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">slot</span> <span class="o">=</span> <span class="p">(</span><span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TVN_MASK</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">slot</span> <span class="o">!=</span> <span class="n">index</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">index</span><span class="p">)</span>
			<span class="n">timer_jiffies</span> <span class="o">+=</span> <span class="n">TVN_SIZE</span> <span class="o">-</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">timer_jiffies</span> <span class="o">&gt;&gt;=</span> <span class="n">TVN_BITS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">expires</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check, if the next hrtimer event is before the next timer wheel</span>
<span class="cm"> * event:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">cmp_next_hrtimer_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span> <span class="n">hr_delta</span> <span class="o">=</span> <span class="n">hrtimer_get_next_event</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">tsdelta</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hr_delta</span><span class="p">.</span><span class="n">tv64</span> <span class="o">==</span> <span class="n">KTIME_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">expires</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Expired timer available, let it expire in the next tick</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hr_delta</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">now</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">tsdelta</span> <span class="o">=</span> <span class="n">ktime_to_timespec</span><span class="p">(</span><span class="n">hr_delta</span><span class="p">);</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">timespec_to_jiffies</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsdelta</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Limit the delta to the max value, which is checked in</span>
<span class="cm">	 * tick_nohz_stop_sched_tick():</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">NEXT_TIMER_MAX_DELTA</span><span class="p">)</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">NEXT_TIMER_MAX_DELTA</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Take rounding errors in to account and make sure, that it</span>
<span class="cm">	 * expires in the next tick. Otherwise we go into an endless</span>
<span class="cm">	 * ping pong due to tick_nohz_stop_sched_tick() retriggering</span>
<span class="cm">	 * the timer softirq</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">now</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">expires</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">now</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">expires</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_next_timer_interrupt - return the jiffy of the next pending timer</span>
<span class="cm"> * @now: current time (in jiffies)</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_next_timer_interrupt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">tvec_bases</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Pretend that there is no timer pending if the cpu is offline.</span>
<span class="cm">	 * Possible pending timers will be migrated later to an active cpu.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_offline</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()))</span>
		<span class="k">return</span> <span class="n">now</span> <span class="o">+</span> <span class="n">NEXT_TIMER_MAX_DELTA</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_before_eq</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">next_timer</span><span class="p">,</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">timer_jiffies</span><span class="p">))</span>
		<span class="n">base</span><span class="o">-&gt;</span><span class="n">next_timer</span> <span class="o">=</span> <span class="n">__next_timer_interrupt</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
	<span class="n">expires</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">next_timer</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_before_eq</span><span class="p">(</span><span class="n">expires</span><span class="p">,</span> <span class="n">now</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">now</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cmp_next_hrtimer_event</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">expires</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Called from the timer interrupt handler to charge one tick to the current</span>
<span class="cm"> * process.  user_tick is 1 if the tick is user time, 0 for system.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">update_process_times</span><span class="p">(</span><span class="kt">int</span> <span class="n">user_tick</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/* Note: this timer irq context must be accounted for as well. */</span>
	<span class="n">account_process_tick</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">user_tick</span><span class="p">);</span>
	<span class="n">run_local_timers</span><span class="p">();</span>
	<span class="n">rcu_check_callbacks</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">user_tick</span><span class="p">);</span>
	<span class="n">printk_tick</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_IRQ_WORK</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_irq</span><span class="p">())</span>
		<span class="n">irq_work_run</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">scheduler_tick</span><span class="p">();</span>
	<span class="n">run_posix_cpu_timers</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function runs timers and the timer-tq in bottom half context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">run_timer_softirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">softirq_action</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">tvec_bases</span><span class="p">);</span>

	<span class="n">hrtimer_run_pending</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">timer_jiffies</span><span class="p">))</span>
		<span class="n">__run_timers</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called by the local, per-CPU timer interrupt on SMP.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">run_local_timers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hrtimer_run_queues</span><span class="p">();</span>
	<span class="n">raise_softirq</span><span class="p">(</span><span class="n">TIMER_SOFTIRQ</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef __ARCH_WANT_SYS_ALARM</span>

<span class="cm">/*</span>
<span class="cm"> * For backwards compatibility?  This can be done in libc so Alpha</span>
<span class="cm"> * and all newer ports shouldn&#39;t need it.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">alarm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">seconds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">alarm_setitimer</span><span class="p">(</span><span class="n">seconds</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cp">#ifndef __alpha__</span>

<span class="cm">/*</span>
<span class="cm"> * The Alpha uses getxpid, getxuid, and getxgid instead.  Maybe this</span>
<span class="cm"> * should be moved into arch/i386 instead?</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * sys_getpid - return the thread group id of the current process</span>
<span class="cm"> *</span>
<span class="cm"> * Note, despite the name, this returns the tgid not the pid.  The tgid and</span>
<span class="cm"> * the pid are identical unless CLONE_THREAD was specified on clone() in</span>
<span class="cm"> * which case the tgid is the same in all threads of the same group.</span>
<span class="cm"> *</span>
<span class="cm"> * This is SMP safe as current-&gt;tgid does not change.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">getpid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task_tgid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Accessing -&gt;real_parent is not SMP-safe, it could</span>
<span class="cm"> * change from under us. However, we can use a stale</span>
<span class="cm"> * value of -&gt;real_parent under rcu_read_lock(), see</span>
<span class="cm"> * release_task()-&gt;call_rcu(delayed_put_task_struct).</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">getppid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">pid</span> <span class="o">=</span> <span class="n">task_tgid_vnr</span><span class="p">(</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">));</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">getuid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Only we change this so SMP safe */</span>
	<span class="k">return</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span> <span class="n">current_uid</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">geteuid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Only we change this so SMP safe */</span>
	<span class="k">return</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span> <span class="n">current_euid</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">getgid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Only we change this so SMP safe */</span>
	<span class="k">return</span> <span class="n">from_kgid_munged</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span> <span class="n">current_gid</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">getegid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Only we change this so SMP safe */</span>
	<span class="k">return</span> <span class="n">from_kgid_munged</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span> <span class="n">current_egid</span><span class="p">());</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">process_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wake_up_process</span><span class="p">((</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">)</span><span class="n">__data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * schedule_timeout - sleep until timeout</span>
<span class="cm"> * @timeout: timeout value in jiffies</span>
<span class="cm"> *</span>
<span class="cm"> * Make the current task sleep until @timeout jiffies have</span>
<span class="cm"> * elapsed. The routine will return immediately unless</span>
<span class="cm"> * the current task state has been set (see set_current_state()).</span>
<span class="cm"> *</span>
<span class="cm"> * You can set the task state as follows -</span>
<span class="cm"> *</span>
<span class="cm"> * %TASK_UNINTERRUPTIBLE - at least @timeout jiffies are guaranteed to</span>
<span class="cm"> * pass before the routine returns. The routine will return 0</span>
<span class="cm"> *</span>
<span class="cm"> * %TASK_INTERRUPTIBLE - the routine may return early if a signal is</span>
<span class="cm"> * delivered to the current task. In this case the remaining time</span>
<span class="cm"> * in jiffies will be returned, or 0 if the timer expired in time</span>
<span class="cm"> *</span>
<span class="cm"> * The current task state is guaranteed to be TASK_RUNNING when this</span>
<span class="cm"> * routine returns.</span>
<span class="cm"> *</span>
<span class="cm"> * Specifying a @timeout value of %MAX_SCHEDULE_TIMEOUT will schedule</span>
<span class="cm"> * the CPU away without a bound on the timeout. In this case the return</span>
<span class="cm"> * value will be %MAX_SCHEDULE_TIMEOUT.</span>
<span class="cm"> *</span>
<span class="cm"> * In all cases the return value is guaranteed to be non-negative.</span>
<span class="cm"> */</span>
<span class="kt">signed</span> <span class="kt">long</span> <span class="n">__sched</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expire</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="k">case</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span>:
		<span class="cm">/*</span>
<span class="cm">		 * These two special cases are useful to be comfortable</span>
<span class="cm">		 * in the caller. Nothing more. We could take</span>
<span class="cm">		 * MAX_SCHEDULE_TIMEOUT from one of the negative value</span>
<span class="cm">		 * but I&#39; d like to return a valid offset (&gt;=0) to allow</span>
<span class="cm">		 * the caller to do everything it want with the retval.</span>
<span class="cm">		 */</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/*</span>
<span class="cm">		 * Another bit of PARANOID. Note that the retval will be</span>
<span class="cm">		 * 0 since no piece of kernel is supposed to do a check</span>
<span class="cm">		 * for a negative retval of schedule_timeout() (since it</span>
<span class="cm">		 * should never happens anyway). You just have the printk()</span>
<span class="cm">		 * that will tell you if something is gone wrong and where.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;schedule_timeout: wrong timeout &quot;</span>
				<span class="s">&quot;value %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
			<span class="n">dump_stack</span><span class="p">();</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">expire</span> <span class="o">=</span> <span class="n">timeout</span> <span class="o">+</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">setup_timer_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">,</span> <span class="n">process_timeout</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">current</span><span class="p">);</span>
	<span class="n">__mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">,</span> <span class="n">expire</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">TIMER_NOT_PINNED</span><span class="p">);</span>
	<span class="n">schedule</span><span class="p">();</span>
	<span class="n">del_singleshot_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>

	<span class="cm">/* Remove the timer from the object tracker */</span>
	<span class="n">destroy_timer_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">expire</span> <span class="o">-</span> <span class="n">jiffies</span><span class="p">;</span>

 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">timeout</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">schedule_timeout</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We can use __set_current_state() here because schedule_timeout() calls</span>
<span class="cm"> * schedule() unconditionally.</span>
<span class="cm"> */</span>
<span class="kt">signed</span> <span class="kt">long</span> <span class="n">__sched</span> <span class="nf">schedule_timeout_interruptible</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">schedule_timeout_interruptible</span><span class="p">);</span>

<span class="kt">signed</span> <span class="kt">long</span> <span class="n">__sched</span> <span class="nf">schedule_timeout_killable</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_KILLABLE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">schedule_timeout_killable</span><span class="p">);</span>

<span class="kt">signed</span> <span class="kt">long</span> <span class="n">__sched</span> <span class="nf">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">schedule_timeout_uninterruptible</span><span class="p">);</span>

<span class="cm">/* Thread ID - the internal kernel &quot;pid&quot; */</span>
<span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">gettid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_sysinfo - fill in sysinfo struct</span>
<span class="cm"> * @info: pointer to buffer to fill</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">do_sysinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">sysinfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mem_total</span><span class="p">,</span> <span class="n">sav_total</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mem_unit</span><span class="p">,</span> <span class="n">bitcount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">tp</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sysinfo</span><span class="p">));</span>

	<span class="n">ktime_get_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">);</span>
	<span class="n">monotonic_to_bootbased</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">uptime</span> <span class="o">=</span> <span class="n">tp</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="p">(</span><span class="n">tp</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">get_avenrun</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">loads</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SI_LOAD_SHIFT</span> <span class="o">-</span> <span class="n">FSHIFT</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">procs</span> <span class="o">=</span> <span class="n">nr_threads</span><span class="p">;</span>

	<span class="n">si_meminfo</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">si_swapinfo</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the sum of all the available memory (i.e. ram + swap)</span>
<span class="cm">	 * is less than can be stored in a 32 bit unsigned long then</span>
<span class="cm">	 * we can be binary compatible with 2.2.x kernels.  If not,</span>
<span class="cm">	 * well, in that case 2.2.x was broken anyways...</span>
<span class="cm">	 *</span>
<span class="cm">	 *  -Erik Andersen &lt;andersee@debian.org&gt;</span>
<span class="cm">	 */</span>

	<span class="n">mem_total</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">totalram</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">totalswap</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_total</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">totalram</span> <span class="o">||</span> <span class="n">mem_total</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">totalswap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">bitcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mem_unit</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mem_unit</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">mem_unit</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bitcount</span><span class="o">++</span><span class="p">;</span>
		<span class="n">mem_unit</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sav_total</span> <span class="o">=</span> <span class="n">mem_total</span><span class="p">;</span>
		<span class="n">mem_total</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mem_total</span> <span class="o">&lt;</span> <span class="n">sav_total</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If mem_total did not overflow, multiply all memory values by</span>
<span class="cm">	 * info-&gt;mem_unit and set it to 1.  This leaves things compatible</span>
<span class="cm">	 * with 2.2.x, and also retains compatibility with earlier 2.4.x</span>
<span class="cm">	 * kernels...</span>
<span class="cm">	 */</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">mem_unit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">totalram</span> <span class="o">&lt;&lt;=</span> <span class="n">bitcount</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">freeram</span> <span class="o">&lt;&lt;=</span> <span class="n">bitcount</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">sharedram</span> <span class="o">&lt;&lt;=</span> <span class="n">bitcount</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">bufferram</span> <span class="o">&lt;&lt;=</span> <span class="n">bitcount</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">totalswap</span> <span class="o">&lt;&lt;=</span> <span class="n">bitcount</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">freeswap</span> <span class="o">&lt;&lt;=</span> <span class="n">bitcount</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">totalhigh</span> <span class="o">&lt;&lt;=</span> <span class="n">bitcount</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">freehigh</span> <span class="o">&lt;&lt;=</span> <span class="n">bitcount</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">sysinfo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sysinfo</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sysinfo</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">do_sysinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sysinfo</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="n">init_timers_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">__cpuinitdata</span> <span class="n">tvec_base_done</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tvec_base_done</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">static</span> <span class="kt">char</span> <span class="n">boot_done</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">boot_done</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The APs use this path later in boot</span>
<span class="cm">			 */</span>
			<span class="n">base</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">base</span><span class="p">),</span>
						<span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">,</span>
						<span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="cm">/* Make sure that tvec_base is 2 byte aligned */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tbase_get_deferrable</span><span class="p">(</span><span class="n">base</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">tvec_bases</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is for the boot CPU - we use compile-time</span>
<span class="cm">			 * static initialisation because per-cpu memory isn&#39;t</span>
<span class="cm">			 * ready yet and because the memory allocators are not</span>
<span class="cm">			 * initialised either.</span>
<span class="cm">			 */</span>
			<span class="n">boot_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">boot_tvec_bases</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tvec_base_done</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">tvec_bases</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">TVN_SIZE</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tv5</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tv4</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tv3</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tv2</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">TVR_SIZE</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tv1</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>

	<span class="n">base</span><span class="o">-&gt;</span><span class="n">timer_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">base</span><span class="o">-&gt;</span><span class="n">next_timer</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">timer_jiffies</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">migrate_timer_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">new_base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">timer</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timer_list</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">detach_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">timer_set_base</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">new_base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">,</span> <span class="n">new_base</span><span class="o">-&gt;</span><span class="n">next_timer</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">tbase_get_deferrable</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">))</span>
			<span class="n">new_base</span><span class="o">-&gt;</span><span class="n">next_timer</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">;</span>
		<span class="n">internal_add_timer</span><span class="p">(</span><span class="n">new_base</span><span class="p">,</span> <span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="n">migrate_timers</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">old_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">new_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="n">old_base</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">tvec_bases</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">new_base</span> <span class="o">=</span> <span class="n">get_cpu_var</span><span class="p">(</span><span class="n">tvec_bases</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The caller is globally serialized and nobody else</span>
<span class="cm">	 * takes two locks at once, deadlock is not possible.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">old_base</span><span class="o">-&gt;</span><span class="n">running_timer</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TVR_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">migrate_timer_list</span><span class="p">(</span><span class="n">new_base</span><span class="p">,</span> <span class="n">old_base</span><span class="o">-&gt;</span><span class="n">tv1</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TVN_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">migrate_timer_list</span><span class="p">(</span><span class="n">new_base</span><span class="p">,</span> <span class="n">old_base</span><span class="o">-&gt;</span><span class="n">tv2</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">migrate_timer_list</span><span class="p">(</span><span class="n">new_base</span><span class="p">,</span> <span class="n">old_base</span><span class="o">-&gt;</span><span class="n">tv3</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">migrate_timer_list</span><span class="p">(</span><span class="n">new_base</span><span class="p">,</span> <span class="n">old_base</span><span class="o">-&gt;</span><span class="n">tv4</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">migrate_timer_list</span><span class="p">(</span><span class="n">new_base</span><span class="p">,</span> <span class="n">old_base</span><span class="o">-&gt;</span><span class="n">tv5</span><span class="p">.</span><span class="n">vec</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">put_cpu_var</span><span class="p">(</span><span class="n">tvec_bases</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="n">timer_cpu_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE_FROZEN</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">init_timers_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="k">case</span> <span class="n">CPU_DEAD</span>:
	<span class="k">case</span> <span class="n">CPU_DEAD_FROZEN</span>:
		<span class="n">migrate_timers</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">__cpuinitdata</span> <span class="n">timers_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span>	<span class="o">=</span> <span class="n">timer_cpu_notify</span><span class="p">,</span>
<span class="p">};</span>


<span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_timers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">timer_cpu_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timers_nb</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">CPU_UP_PREPARE</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="n">init_timer_stats</span><span class="p">();</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">NOTIFY_OK</span><span class="p">);</span>
	<span class="n">register_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timers_nb</span><span class="p">);</span>
	<span class="n">open_softirq</span><span class="p">(</span><span class="n">TIMER_SOFTIRQ</span><span class="p">,</span> <span class="n">run_timer_softirq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * msleep - sleep safely even with waitqueue interruptions</span>
<span class="cm"> * @msecs: Time in milliseconds to sleep for</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">msleep</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">msecs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">msleep</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * msleep_interruptible - sleep waiting for signals</span>
<span class="cm"> * @msecs: Time in milliseconds to sleep for</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">msleep_interruptible</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">msecs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">msleep_interruptible</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__sched</span> <span class="nf">do_usleep_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span> <span class="n">kmin</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">;</span>

	<span class="n">kmin</span> <span class="o">=</span> <span class="n">ktime_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">min</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">);</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">max</span> <span class="o">-</span> <span class="n">min</span><span class="p">)</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">schedule_hrtimeout_range</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmin</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usleep_range - Drop in replacement for udelay where wakeup is flexible</span>
<span class="cm"> * @min: Minimum time in usecs to sleep</span>
<span class="cm"> * @max: Maximum time in usecs to sleep</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">usleep_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">do_usleep_range</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">usleep_range</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
