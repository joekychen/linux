<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › user_namespace.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>user_namespace.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or</span>
<span class="cm"> *  modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *  published by the Free Software Foundation, version 2 of the</span>
<span class="cm"> *  License.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/user_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/highuid.h&gt;</span>
<span class="cp">#include &lt;linux/cred.h&gt;</span>
<span class="cp">#include &lt;linux/securebits.h&gt;</span>
<span class="cp">#include &lt;linux/keyctl.h&gt;</span>
<span class="cp">#include &lt;linux/key-type.h&gt;</span>
<span class="cp">#include &lt;keys/user-type.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">user_ns_cachep</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">new_idmap_permitted</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap_setid</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">uid_gid_map</span> <span class="o">*</span><span class="n">map</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Create a new user namespace, deriving the creator from the user in the</span>
<span class="cm"> * passed credentials, and replacing that user with the new root user for the</span>
<span class="cm"> * new namespace.</span>
<span class="cm"> *</span>
<span class="cm"> * This is called by copy_creds(), which will finish setting the target task&#39;s</span>
<span class="cm"> * credentials.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">create_user_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="o">*</span><span class="n">parent_ns</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">;</span>
	<span class="n">kuid_t</span> <span class="n">owner</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">;</span>
	<span class="n">kgid_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">egid</span><span class="p">;</span>

	<span class="cm">/* The creator needs a mapping in the parent user namespace</span>
<span class="cm">	 * or else we won&#39;t be able to reasonably tell userspace who</span>
<span class="cm">	 * created a user_namespace.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kuid_has_mapping</span><span class="p">(</span><span class="n">parent_ns</span><span class="p">,</span> <span class="n">owner</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">kgid_has_mapping</span><span class="p">(</span><span class="n">parent_ns</span><span class="p">,</span> <span class="n">group</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">ns</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">user_ns_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent_ns</span><span class="p">;</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span><span class="p">;</span>
	<span class="n">ns</span><span class="o">-&gt;</span><span class="n">group</span> <span class="o">=</span> <span class="n">group</span><span class="p">;</span>

	<span class="cm">/* Start with the same capabilities as init but useless for doing</span>
<span class="cm">	 * anything as the capabilities are bound to the new user namespace.</span>
<span class="cm">	 */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">securebits</span> <span class="o">=</span> <span class="n">SECUREBITS_DEFAULT</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_inheritable</span> <span class="o">=</span> <span class="n">CAP_EMPTY_SET</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_permitted</span> <span class="o">=</span> <span class="n">CAP_FULL_SET</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_effective</span> <span class="o">=</span> <span class="n">CAP_FULL_SET</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">cap_bset</span> <span class="o">=</span> <span class="n">CAP_FULL_SET</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_KEYS</span>
	<span class="n">key_put</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">request_key_auth</span><span class="p">);</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">request_key_auth</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* tgcred will be cleared in our caller bc CLONE_THREAD won&#39;t be set */</span>

	<span class="cm">/* Leave the new-&gt;user_ns reference with the new user namespace. */</span>
	<span class="cm">/* Leave the reference to our user_ns with the new cred. */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">user_ns</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_user_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_namespace</span><span class="p">,</span> <span class="n">kref</span><span class="p">);</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">ns</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">user_ns_cachep</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
	<span class="n">put_user_ns</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">free_user_ns</span><span class="p">);</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">map_id_range_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">uid_gid_map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">idx</span><span class="p">,</span> <span class="n">extents</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">id2</span><span class="p">;</span>

	<span class="n">id2</span> <span class="o">=</span> <span class="n">id</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Find the matching extent */</span>
	<span class="n">extents</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">nr_extents</span><span class="p">;</span>
	<span class="n">smp_read_barrier_depends</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">extents</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">first</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">extent</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">extent</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">id</span> <span class="o">&lt;=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">id2</span> <span class="o">&gt;=</span> <span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">id2</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Map the id or note failure */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">extents</span><span class="p">)</span>
		<span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span> <span class="o">-</span> <span class="n">first</span><span class="p">)</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">extent</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">lower_first</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">map_id_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">uid_gid_map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">idx</span><span class="p">,</span> <span class="n">extents</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">;</span>

	<span class="cm">/* Find the matching extent */</span>
	<span class="n">extents</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">nr_extents</span><span class="p">;</span>
	<span class="n">smp_read_barrier_depends</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">extents</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">first</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">extent</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">extent</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">id</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Map the id or note failure */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">extents</span><span class="p">)</span>
		<span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span> <span class="o">-</span> <span class="n">first</span><span class="p">)</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">extent</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">lower_first</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">map_id_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">uid_gid_map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">idx</span><span class="p">,</span> <span class="n">extents</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">;</span>

	<span class="cm">/* Find the matching extent */</span>
	<span class="n">extents</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">nr_extents</span><span class="p">;</span>
	<span class="n">smp_read_barrier_depends</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">extents</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">first</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">extent</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">lower_first</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">extent</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">id</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Map the id or note failure */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">extents</span><span class="p">)</span>
		<span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span> <span class="o">-</span> <span class="n">first</span><span class="p">)</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">extent</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	make_kuid - Map a user-namespace uid pair into a kuid.</span>
<span class="cm"> *	@ns:  User namespace that the uid is in</span>
<span class="cm"> *	@uid: User identifier</span>
<span class="cm"> *</span>
<span class="cm"> *	Maps a user-namespace uid pair into a kernel internal kuid,</span>
<span class="cm"> *	and returns that kuid.</span>
<span class="cm"> *</span>
<span class="cm"> *	When there is no mapping defined for the user-namespace uid</span>
<span class="cm"> *	pair INVALID_UID is returned.  Callers are expected to test</span>
<span class="cm"> *	for and handle handle INVALID_UID being returned.  INVALID_UID</span>
<span class="cm"> *	may be tested for using uid_valid().</span>
<span class="cm"> */</span>
<span class="n">kuid_t</span> <span class="nf">make_kuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">uid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Map the uid to a global kernel uid */</span>
	<span class="k">return</span> <span class="n">KUIDT_INIT</span><span class="p">(</span><span class="n">map_id_down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">uid_map</span><span class="p">,</span> <span class="n">uid</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">make_kuid</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	from_kuid - Create a uid from a kuid user-namespace pair.</span>
<span class="cm"> *	@targ: The user namespace we want a uid in.</span>
<span class="cm"> *	@kuid: The kernel internal uid to start with.</span>
<span class="cm"> *</span>
<span class="cm"> *	Map @kuid into the user-namespace specified by @targ and</span>
<span class="cm"> *	return the resulting uid.</span>
<span class="cm"> *</span>
<span class="cm"> *	There is always a mapping into the initial user_namespace.</span>
<span class="cm"> *</span>
<span class="cm"> *	If @kuid has no mapping in @targ (uid_t)-1 is returned.</span>
<span class="cm"> */</span>
<span class="n">uid_t</span> <span class="nf">from_kuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">targ</span><span class="p">,</span> <span class="n">kuid_t</span> <span class="n">kuid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Map the uid from a global kernel uid */</span>
	<span class="k">return</span> <span class="n">map_id_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">targ</span><span class="o">-&gt;</span><span class="n">uid_map</span><span class="p">,</span> <span class="n">__kuid_val</span><span class="p">(</span><span class="n">kuid</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">from_kuid</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	from_kuid_munged - Create a uid from a kuid user-namespace pair.</span>
<span class="cm"> *	@targ: The user namespace we want a uid in.</span>
<span class="cm"> *	@kuid: The kernel internal uid to start with.</span>
<span class="cm"> *</span>
<span class="cm"> *	Map @kuid into the user-namespace specified by @targ and</span>
<span class="cm"> *	return the resulting uid.</span>
<span class="cm"> *</span>
<span class="cm"> *	There is always a mapping into the initial user_namespace.</span>
<span class="cm"> *</span>
<span class="cm"> *	Unlike from_kuid from_kuid_munged never fails and always</span>
<span class="cm"> *	returns a valid uid.  This makes from_kuid_munged appropriate</span>
<span class="cm"> *	for use in syscalls like stat and getuid where failing the</span>
<span class="cm"> *	system call and failing to provide a valid uid are not an</span>
<span class="cm"> *	options.</span>
<span class="cm"> *</span>
<span class="cm"> *	If @kuid has no mapping in @targ overflowuid is returned.</span>
<span class="cm"> */</span>
<span class="n">uid_t</span> <span class="nf">from_kuid_munged</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">targ</span><span class="p">,</span> <span class="n">kuid_t</span> <span class="n">kuid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uid_t</span> <span class="n">uid</span><span class="p">;</span>
	<span class="n">uid</span> <span class="o">=</span> <span class="n">from_kuid</span><span class="p">(</span><span class="n">targ</span><span class="p">,</span> <span class="n">kuid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uid</span> <span class="o">==</span> <span class="p">(</span><span class="n">uid_t</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">uid</span> <span class="o">=</span> <span class="n">overflowuid</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">uid</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">from_kuid_munged</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	make_kgid - Map a user-namespace gid pair into a kgid.</span>
<span class="cm"> *	@ns:  User namespace that the gid is in</span>
<span class="cm"> *	@uid: group identifier</span>
<span class="cm"> *</span>
<span class="cm"> *	Maps a user-namespace gid pair into a kernel internal kgid,</span>
<span class="cm"> *	and returns that kgid.</span>
<span class="cm"> *</span>
<span class="cm"> *	When there is no mapping defined for the user-namespace gid</span>
<span class="cm"> *	pair INVALID_GID is returned.  Callers are expected to test</span>
<span class="cm"> *	for and handle INVALID_GID being returned.  INVALID_GID may be</span>
<span class="cm"> *	tested for using gid_valid().</span>
<span class="cm"> */</span>
<span class="n">kgid_t</span> <span class="nf">make_kgid</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="n">gid_t</span> <span class="n">gid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Map the gid to a global kernel gid */</span>
	<span class="k">return</span> <span class="n">KGIDT_INIT</span><span class="p">(</span><span class="n">map_id_down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">gid_map</span><span class="p">,</span> <span class="n">gid</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">make_kgid</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	from_kgid - Create a gid from a kgid user-namespace pair.</span>
<span class="cm"> *	@targ: The user namespace we want a gid in.</span>
<span class="cm"> *	@kgid: The kernel internal gid to start with.</span>
<span class="cm"> *</span>
<span class="cm"> *	Map @kgid into the user-namespace specified by @targ and</span>
<span class="cm"> *	return the resulting gid.</span>
<span class="cm"> *</span>
<span class="cm"> *	There is always a mapping into the initial user_namespace.</span>
<span class="cm"> *</span>
<span class="cm"> *	If @kgid has no mapping in @targ (gid_t)-1 is returned.</span>
<span class="cm"> */</span>
<span class="n">gid_t</span> <span class="nf">from_kgid</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">targ</span><span class="p">,</span> <span class="n">kgid_t</span> <span class="n">kgid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Map the gid from a global kernel gid */</span>
	<span class="k">return</span> <span class="n">map_id_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">targ</span><span class="o">-&gt;</span><span class="n">gid_map</span><span class="p">,</span> <span class="n">__kgid_val</span><span class="p">(</span><span class="n">kgid</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">from_kgid</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	from_kgid_munged - Create a gid from a kgid user-namespace pair.</span>
<span class="cm"> *	@targ: The user namespace we want a gid in.</span>
<span class="cm"> *	@kgid: The kernel internal gid to start with.</span>
<span class="cm"> *</span>
<span class="cm"> *	Map @kgid into the user-namespace specified by @targ and</span>
<span class="cm"> *	return the resulting gid.</span>
<span class="cm"> *</span>
<span class="cm"> *	There is always a mapping into the initial user_namespace.</span>
<span class="cm"> *</span>
<span class="cm"> *	Unlike from_kgid from_kgid_munged never fails and always</span>
<span class="cm"> *	returns a valid gid.  This makes from_kgid_munged appropriate</span>
<span class="cm"> *	for use in syscalls like stat and getgid where failing the</span>
<span class="cm"> *	system call and failing to provide a valid gid are not options.</span>
<span class="cm"> *</span>
<span class="cm"> *	If @kgid has no mapping in @targ overflowgid is returned.</span>
<span class="cm"> */</span>
<span class="n">gid_t</span> <span class="nf">from_kgid_munged</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">targ</span><span class="p">,</span> <span class="n">kgid_t</span> <span class="n">kgid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gid_t</span> <span class="n">gid</span><span class="p">;</span>
	<span class="n">gid</span> <span class="o">=</span> <span class="n">from_kgid</span><span class="p">(</span><span class="n">targ</span><span class="p">,</span> <span class="n">kgid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gid</span> <span class="o">==</span> <span class="p">(</span><span class="n">gid_t</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">gid</span> <span class="o">=</span> <span class="n">overflowgid</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">gid</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">from_kgid_munged</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uid_m_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uid_gid_extent</span> <span class="o">*</span><span class="n">extent</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">lower_ns</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">lower</span><span class="p">;</span>

	<span class="n">lower_ns</span> <span class="o">=</span> <span class="n">current_user_ns</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">lower_ns</span> <span class="o">==</span> <span class="n">ns</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">lower_ns</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">lower_ns</span> <span class="o">=</span> <span class="n">lower_ns</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">lower</span> <span class="o">=</span> <span class="n">from_kuid</span><span class="p">(</span><span class="n">lower_ns</span><span class="p">,</span> <span class="n">KUIDT_INIT</span><span class="p">(</span><span class="n">extent</span><span class="o">-&gt;</span><span class="n">lower_first</span><span class="p">));</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%10u %10u %10u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">extent</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span>
		<span class="n">lower</span><span class="p">,</span>
		<span class="n">extent</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gid_m_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uid_gid_extent</span> <span class="o">*</span><span class="n">extent</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">lower_ns</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">lower</span><span class="p">;</span>

	<span class="n">lower_ns</span> <span class="o">=</span> <span class="n">current_user_ns</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">lower_ns</span> <span class="o">==</span> <span class="n">ns</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">lower_ns</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">lower_ns</span> <span class="o">=</span> <span class="n">lower_ns</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">lower</span> <span class="o">=</span> <span class="n">from_kgid</span><span class="p">(</span><span class="n">lower_ns</span><span class="p">,</span> <span class="n">KGIDT_INIT</span><span class="p">(</span><span class="n">extent</span><span class="o">-&gt;</span><span class="n">lower_first</span><span class="p">));</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%10u %10u %10u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">extent</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span>
		<span class="n">lower</span><span class="p">,</span>
		<span class="n">extent</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">m_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uid_gid_map</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uid_gid_extent</span> <span class="o">*</span><span class="n">extent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">nr_extents</span><span class="p">)</span>
		<span class="n">extent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">extent</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">extent</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">uid_m_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">m_start</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">uid_map</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">gid_m_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">m_start</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">gid_map</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">m_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">m_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">proc_uid_seq_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">uid_m_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">m_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">m_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">uid_m_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">proc_gid_seq_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">gid_m_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">m_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">m_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">gid_m_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">id_map_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">map_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">cap_setid</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">uid_gid_map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">uid_gid_map</span> <span class="o">*</span><span class="n">parent_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uid_gid_map</span> <span class="n">new_map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uid_gid_extent</span> <span class="o">*</span><span class="n">extent</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kbuf</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">next_line</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The id_map_mutex serializes all writes to any given map.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Any map is only ever written once.</span>
<span class="cm">	 *</span>
<span class="cm">	 * An id map fits within 1 cache line on most architectures.</span>
<span class="cm">	 *</span>
<span class="cm">	 * On read nothing needs to be done unless you are on an</span>
<span class="cm">	 * architecture with a crazy cache coherency model like alpha.</span>
<span class="cm">	 *</span>
<span class="cm">	 * There is a one time data dependency between reading the</span>
<span class="cm">	 * count of the extents and the values of the extents.  The</span>
<span class="cm">	 * desired behavior is to see the values of the extents that</span>
<span class="cm">	 * were written before the count of the extents.</span>
<span class="cm">	 *</span>
<span class="cm">	 * To achieve this smp_wmb() is used on guarantee the write</span>
<span class="cm">	 * order and smp_read_barrier_depends() is guaranteed that we</span>
<span class="cm">	 * don&#39;t have crazy architectures returning stale data.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id_map_mutex</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="cm">/* Only allow one successful write to the map */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">nr_extents</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Require the appropriate privilege CAP_SETUID or CAP_SETGID</span>
<span class="cm">	 * over the user namespace in order to set the id mapping.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns_capable</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">cap_setid</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Get a buffer */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_TEMPORARY</span><span class="p">);</span>
	<span class="n">kbuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Only allow &lt;= page size writes at the beginning of the file */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">ppos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Slurp in the user data */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">kbuf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">kbuf</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="cm">/* Parse the user data */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">kbuf</span><span class="p">;</span>
	<span class="n">new_map</span><span class="p">.</span><span class="n">nr_extents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span><span class="n">pos</span><span class="p">;</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">next_line</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">extent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">new_map</span><span class="p">.</span><span class="n">extent</span><span class="p">[</span><span class="n">new_map</span><span class="p">.</span><span class="n">nr_extents</span><span class="p">];</span>

		<span class="cm">/* Find the end of line and ensure I don&#39;t look past it */</span>
		<span class="n">next_line</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_line</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">next_line</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="n">next_line</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">next_line</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
				<span class="n">next_line</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pos</span> <span class="o">=</span> <span class="n">skip_spaces</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="n">extent</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isspace</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">pos</span> <span class="o">=</span> <span class="n">skip_spaces</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="n">extent</span><span class="o">-&gt;</span><span class="n">lower_first</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isspace</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">pos</span> <span class="o">=</span> <span class="n">skip_spaces</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="n">extent</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isspace</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* Verify there is not trailing junk on the line */</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">skip_spaces</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* Verify we have been given valid starting values */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">extent</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">extent</span><span class="o">-&gt;</span><span class="n">lower_first</span> <span class="o">==</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span> <span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* Verify count is not zero and does not cause the extent to wrap */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">extent</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">+</span> <span class="n">extent</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">extent</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">extent</span><span class="o">-&gt;</span><span class="n">lower_first</span> <span class="o">+</span> <span class="n">extent</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">extent</span><span class="o">-&gt;</span><span class="n">lower_first</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* For now only accept extents that are strictly in order */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(((</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">+</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">extent</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">((</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">lower_first</span> <span class="o">+</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">extent</span><span class="o">-&gt;</span><span class="n">lower_first</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">new_map</span><span class="p">.</span><span class="n">nr_extents</span><span class="o">++</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">extent</span><span class="p">;</span>

		<span class="cm">/* Fail if the file contains too many extents */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">new_map</span><span class="p">.</span><span class="n">nr_extents</span> <span class="o">==</span> <span class="n">UID_GID_MAP_MAX_EXTENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">next_line</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Be very certaint the new map actually exists */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_map</span><span class="p">.</span><span class="n">nr_extents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="cm">/* Validate the user is allowed to use user id&#39;s mapped to. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_idmap_permitted</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">cap_setid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_map</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Map the lower ids from the parent user namespace to the</span>
<span class="cm">	 * kernel global id space.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">new_map</span><span class="p">.</span><span class="n">nr_extents</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">lower_first</span><span class="p">;</span>
		<span class="n">extent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">new_map</span><span class="p">.</span><span class="n">extent</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

		<span class="n">lower_first</span> <span class="o">=</span> <span class="n">map_id_range_down</span><span class="p">(</span><span class="n">parent_map</span><span class="p">,</span>
						<span class="n">extent</span><span class="o">-&gt;</span><span class="n">lower_first</span><span class="p">,</span>
						<span class="n">extent</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

		<span class="cm">/* Fail if we can not map the specified extent to</span>
<span class="cm">		 * the kernel global id space.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lower_first</span> <span class="o">==</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">extent</span><span class="o">-&gt;</span><span class="n">lower_first</span> <span class="o">=</span> <span class="n">lower_first</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Install the map */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">extent</span><span class="p">,</span> <span class="n">new_map</span><span class="p">.</span><span class="n">extent</span><span class="p">,</span>
		<span class="n">new_map</span><span class="p">.</span><span class="n">nr_extents</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">new_map</span><span class="p">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">nr_extents</span> <span class="o">=</span> <span class="n">new_map</span><span class="p">.</span><span class="n">nr_extents</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id_map_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
		<span class="n">free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">ssize_t</span> <span class="nf">proc_uid_map_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">map_write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">CAP_SETUID</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">uid_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">uid_map</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">ssize_t</span> <span class="nf">proc_gid_map_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">map_write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">CAP_SETGID</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">gid_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">gid_map</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">new_idmap_permitted</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap_setid</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">uid_gid_map</span> <span class="o">*</span><span class="n">new_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Allow the specified ids if we have the appropriate capability</span>
<span class="cm">	 * (CAP_SETUID or CAP_SETGID) over the parent user namespace.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ns_capable</span><span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">cap_setid</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">user_namespaces_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">user_ns_cachep</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">user_namespace</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">user_namespaces_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
