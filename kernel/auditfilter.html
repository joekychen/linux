<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › auditfilter.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>auditfilter.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* auditfilter.c -- filtering of audit events</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2003-2004 Red Hat, Inc.</span>
<span class="cm"> * Copyright 2005 Hewlett-Packard Development Company, L.P.</span>
<span class="cm"> * Copyright 2005 IBM Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/netlink.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &quot;audit.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Locking model:</span>
<span class="cm"> *</span>
<span class="cm"> * audit_filter_mutex:</span>
<span class="cm"> * 		Synchronizes writes and blocking reads of audit&#39;s filterlist</span>
<span class="cm"> * 		data.  Rcu is used to traverse the filterlist and access</span>
<span class="cm"> * 		contents of structs audit_entry, audit_watch and opaque</span>
<span class="cm"> * 		LSM rules during filtering.  If modified, these structures</span>
<span class="cm"> * 		must be copied and replace their counterparts in the filterlist.</span>
<span class="cm"> * 		An audit_parent struct is not accessed during filtering, so may</span>
<span class="cm"> * 		be written directly provided audit_filter_mutex is held.</span>
<span class="cm"> */</span>

<span class="cm">/* Audit filter lists, defined in &lt;linux/audit.h&gt; */</span>
<span class="k">struct</span> <span class="n">list_head</span> <span class="n">audit_filter_list</span><span class="p">[</span><span class="n">AUDIT_NR_FILTERS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">audit_filter_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
	<span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">audit_filter_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
	<span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">audit_filter_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
	<span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">audit_filter_list</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
	<span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">audit_filter_list</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span>
	<span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">audit_filter_list</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span>
<span class="cp">#if AUDIT_NR_FILTERS != 6</span>
<span class="cp">#error Fix audit_filter_list initialiser</span>
<span class="cp">#endif</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">audit_rules_list</span><span class="p">[</span><span class="n">AUDIT_NR_FILTERS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">audit_rules_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
	<span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">audit_rules_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
	<span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">audit_rules_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
	<span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">audit_rules_list</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
	<span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">audit_rules_list</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span>
	<span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">audit_rules_list</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span>
<span class="p">};</span>

<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">audit_filter_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">audit_free_rule</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">erule</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">;</span>

	<span class="cm">/* some rules don&#39;t have associated watches */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">erule</span><span class="o">-&gt;</span><span class="n">watch</span><span class="p">)</span>
		<span class="n">audit_put_watch</span><span class="p">(</span><span class="n">erule</span><span class="o">-&gt;</span><span class="n">watch</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">erule</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">erule</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">audit_field</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">erule</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">lsm_str</span><span class="p">);</span>
			<span class="n">security_audit_rule_free</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">lsm_rule</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">erule</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">erule</span><span class="o">-&gt;</span><span class="n">filterkey</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">audit_free_rule_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audit_entry</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
	<span class="n">audit_free_rule</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Initialize an audit filterlist entry. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="nf">audit_init_entry</span><span class="p">(</span><span class="n">u32</span> <span class="n">field_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_field</span> <span class="o">*</span><span class="n">fields</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">fields</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fields</span><span class="p">)</span> <span class="o">*</span> <span class="n">field_count</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">fields</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">fields</span> <span class="o">=</span> <span class="n">fields</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Unpack a filter field&#39;s string representation from user-space</span>
<span class="cm"> * buffer. */</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">audit_unpack_string</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">bufp</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">remain</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">bufp</span> <span class="o">||</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">remain</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="cm">/* Of the currently implemented string fields, PATH_MAX</span>
<span class="cm">	 * defines the longest valid length.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">PATH_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>

	<span class="n">str</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="o">*</span><span class="n">bufp</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">str</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">bufp</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="o">*</span><span class="n">remain</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">str</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Translate an inode field to kernel respresentation. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">audit_to_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">krule</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">audit_field</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">krule</span><span class="o">-&gt;</span><span class="n">listnr</span> <span class="o">!=</span> <span class="n">AUDIT_FILTER_EXIT</span> <span class="o">||</span>
	    <span class="n">krule</span><span class="o">-&gt;</span><span class="n">watch</span> <span class="o">||</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">inode_f</span> <span class="o">||</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">tree</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">!=</span> <span class="n">Audit_equal</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">!=</span> <span class="n">Audit_not_equal</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">krule</span><span class="o">-&gt;</span><span class="n">inode_f</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">classes</span><span class="p">[</span><span class="n">AUDIT_SYSCALL_CLASSES</span><span class="p">];</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">audit_register_class</span><span class="p">(</span><span class="kt">int</span> <span class="n">class</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">AUDIT_BITMASK_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">list</span> <span class="o">!=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">list</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">AUDIT_BITMASK_SIZE</span> <span class="o">*</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">AUDIT_SYSCALL_CLASSES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">p</span><span class="p">[</span><span class="n">AUDIT_WORD</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">|=</span> <span class="n">AUDIT_BIT</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">class</span> <span class="o">&gt;=</span> <span class="n">AUDIT_SYSCALL_CLASSES</span> <span class="o">||</span> <span class="n">classes</span><span class="p">[</span><span class="n">class</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">classes</span><span class="p">[</span><span class="n">class</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">audit_match_class</span><span class="p">(</span><span class="kt">int</span> <span class="n">class</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">syscall</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">syscall</span> <span class="o">&gt;=</span> <span class="n">AUDIT_BITMASK_SIZE</span> <span class="o">*</span> <span class="mi">32</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">class</span> <span class="o">&gt;=</span> <span class="n">AUDIT_SYSCALL_CLASSES</span> <span class="o">||</span> <span class="o">!</span><span class="n">classes</span><span class="p">[</span><span class="n">class</span><span class="p">]))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">classes</span><span class="p">[</span><span class="n">class</span><span class="p">][</span><span class="n">AUDIT_WORD</span><span class="p">(</span><span class="n">syscall</span><span class="p">)]</span> <span class="o">&amp;</span> <span class="n">AUDIT_BIT</span><span class="p">(</span><span class="n">syscall</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_AUDITSYSCALL</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">audit_match_class_bits</span><span class="p">(</span><span class="kt">int</span> <span class="n">class</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="n">class</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AUDIT_BITMASK_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">classes</span><span class="p">[</span><span class="n">class</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">audit_match_signal</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_field</span> <span class="o">*</span><span class="n">arch</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">arch_f</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* When arch is unspecified, we must check both masks on biarch</span>
<span class="cm">		 * as syscall number alone is ambiguous. */</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">audit_match_class_bits</span><span class="p">(</span><span class="n">AUDIT_CLASS_SIGNAL</span><span class="p">,</span>
					       <span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">mask</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">audit_match_class_bits</span><span class="p">(</span><span class="n">AUDIT_CLASS_SIGNAL_32</span><span class="p">,</span>
					       <span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">mask</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">audit_classify_arch</span><span class="p">(</span><span class="n">arch</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* native */</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">audit_match_class_bits</span><span class="p">(</span><span class="n">AUDIT_CLASS_SIGNAL</span><span class="p">,</span>
					       <span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">mask</span><span class="p">));</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="cm">/* 32bit on biarch */</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">audit_match_class_bits</span><span class="p">(</span><span class="n">AUDIT_CLASS_SIGNAL_32</span><span class="p">,</span>
					       <span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">mask</span><span class="p">));</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Common user-space to kernel rule translation. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="nf">audit_to_entry_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_rule</span> <span class="o">*</span><span class="n">rule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">listnr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">listnr</span> <span class="o">=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AUDIT_FILTER_PREPEND</span><span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">listnr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">exit_err</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_AUDITSYSCALL</span>
	<span class="k">case</span> <span class="n">AUDIT_FILTER_ENTRY</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">==</span> <span class="n">AUDIT_ALWAYS</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit_err</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_FILTER_EXIT</span>:
	<span class="k">case</span> <span class="n">AUDIT_FILTER_TASK</span>:
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">AUDIT_FILTER_USER</span>:
	<span class="k">case</span> <span class="n">AUDIT_FILTER_TYPE</span>:
		<span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">==</span> <span class="n">AUDIT_POSSIBLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;AUDIT_POSSIBLE is deprecated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">!=</span> <span class="n">AUDIT_NEVER</span> <span class="o">&amp;&amp;</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">!=</span> <span class="n">AUDIT_ALWAYS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">field_count</span> <span class="o">&gt;</span> <span class="n">AUDIT_MAX_FIELDS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">audit_init_entry</span><span class="p">(</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_err</span><span class="p">;</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AUDIT_FILTER_PREPEND</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">listnr</span> <span class="o">=</span> <span class="n">listnr</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">action</span> <span class="o">=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">field_count</span> <span class="o">=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AUDIT_BITMASK_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AUDIT_SYSCALL_CLASSES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">AUDIT_BITMASK_SIZE</span> <span class="o">*</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">__u32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">mask</span><span class="p">[</span><span class="n">AUDIT_WORD</span><span class="p">(</span><span class="n">bit</span><span class="p">)];</span>
		<span class="n">__u32</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">AUDIT_BIT</span><span class="p">(</span><span class="n">bit</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AUDIT_BIT</span><span class="p">(</span><span class="n">bit</span><span class="p">);</span>
		<span class="n">class</span> <span class="o">=</span> <span class="n">classes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">AUDIT_BITMASK_SIZE</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">mask</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">|=</span> <span class="n">class</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>

<span class="nl">exit_err:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">audit_ops</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">Audit_equal</span><span class="p">]</span> <span class="o">=</span> <span class="n">AUDIT_EQUAL</span><span class="p">,</span>
	<span class="p">[</span><span class="n">Audit_not_equal</span><span class="p">]</span> <span class="o">=</span> <span class="n">AUDIT_NOT_EQUAL</span><span class="p">,</span>
	<span class="p">[</span><span class="n">Audit_bitmask</span><span class="p">]</span> <span class="o">=</span> <span class="n">AUDIT_BIT_MASK</span><span class="p">,</span>
	<span class="p">[</span><span class="n">Audit_bittest</span><span class="p">]</span> <span class="o">=</span> <span class="n">AUDIT_BIT_TEST</span><span class="p">,</span>
	<span class="p">[</span><span class="n">Audit_lt</span><span class="p">]</span> <span class="o">=</span> <span class="n">AUDIT_LESS_THAN</span><span class="p">,</span>
	<span class="p">[</span><span class="n">Audit_gt</span><span class="p">]</span> <span class="o">=</span> <span class="n">AUDIT_GREATER_THAN</span><span class="p">,</span>
	<span class="p">[</span><span class="n">Audit_le</span><span class="p">]</span> <span class="o">=</span> <span class="n">AUDIT_LESS_THAN_OR_EQUAL</span><span class="p">,</span>
	<span class="p">[</span><span class="n">Audit_ge</span><span class="p">]</span> <span class="o">=</span> <span class="n">AUDIT_GREATER_THAN_OR_EQUAL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">audit_to_op</span><span class="p">(</span><span class="n">u32</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">Audit_equal</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">Audit_bad</span> <span class="o">&amp;&amp;</span> <span class="n">audit_ops</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="n">op</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Translate struct audit_rule to kernel&#39;s rule respresentation.</span>
<span class="cm"> * Exists for backward compatibility with userspace. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="nf">audit_rule_to_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_rule</span> <span class="o">*</span><span class="n">rule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">audit_to_entry_common</span><span class="p">(</span><span class="n">rule</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit_nofree</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">audit_field</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">u32</span> <span class="n">n</span><span class="p">;</span>

		<span class="n">n</span> <span class="o">=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AUDIT_NEGATE</span><span class="o">|</span><span class="n">AUDIT_OPERATORS</span><span class="p">);</span>

		<span class="cm">/* Support for legacy operators where</span>
<span class="cm">		 * AUDIT_NEGATE bit signifies != and otherwise assumes == */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">AUDIT_NEGATE</span><span class="p">)</span>
			<span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">Audit_not_equal</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
			<span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">Audit_equal</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">audit_to_op</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">vers_ops</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">AUDIT_OPERATORS</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">AUDIT_NEGATE</span><span class="o">|</span><span class="n">AUDIT_OPERATORS</span><span class="p">);</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">Audit_bad</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>

		<span class="k">switch</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_PID</span>:
		<span class="k">case</span> <span class="n">AUDIT_UID</span>:
		<span class="k">case</span> <span class="n">AUDIT_EUID</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUID</span>:
		<span class="k">case</span> <span class="n">AUDIT_FSUID</span>:
		<span class="k">case</span> <span class="n">AUDIT_GID</span>:
		<span class="k">case</span> <span class="n">AUDIT_EGID</span>:
		<span class="k">case</span> <span class="n">AUDIT_SGID</span>:
		<span class="k">case</span> <span class="n">AUDIT_FSGID</span>:
		<span class="k">case</span> <span class="n">AUDIT_LOGINUID</span>:
		<span class="k">case</span> <span class="n">AUDIT_PERS</span>:
		<span class="k">case</span> <span class="n">AUDIT_MSGTYPE</span>:
		<span class="k">case</span> <span class="n">AUDIT_PPID</span>:
		<span class="k">case</span> <span class="n">AUDIT_DEVMAJOR</span>:
		<span class="k">case</span> <span class="n">AUDIT_DEVMINOR</span>:
		<span class="k">case</span> <span class="n">AUDIT_EXIT</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUCCESS</span>:
			<span class="cm">/* bit ops are only useful on syscall args */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">Audit_bitmask</span> <span class="o">||</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">Audit_bittest</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_ARG0</span>:
		<span class="k">case</span> <span class="n">AUDIT_ARG1</span>:
		<span class="k">case</span> <span class="n">AUDIT_ARG2</span>:
		<span class="k">case</span> <span class="n">AUDIT_ARG3</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* arch is only allowed to be = or != */</span>
		<span class="k">case</span> <span class="n">AUDIT_ARCH</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">!=</span> <span class="n">Audit_not_equal</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">!=</span> <span class="n">Audit_equal</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">arch_f</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_PERM</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">15</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_FILETYPE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">S_IFMT</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_INODE</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="n">audit_to_inode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">inode_f</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">inode_f</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">Audit_not_equal</span><span class="p">)</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">inode_f</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">exit_nofree:</span>
	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>

<span class="nl">exit_free:</span>
	<span class="n">audit_free_rule</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Translate struct audit_rule_data to kernel&#39;s rule respresentation. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="nf">audit_data_to_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_rule_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					       <span class="kt">size_t</span> <span class="n">datasz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">bufp</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">remain</span> <span class="o">=</span> <span class="n">datasz</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_rule_data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">audit_to_entry_common</span><span class="p">((</span><span class="k">struct</span> <span class="n">audit_rule</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit_nofree</span><span class="p">;</span>

	<span class="n">bufp</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">vers_ops</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">audit_field</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">audit_to_op</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">fieldflags</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">Audit_bad</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>

		<span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">lsm_str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">lsm_rule</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AUDIT_PID</span>:
		<span class="k">case</span> <span class="n">AUDIT_UID</span>:
		<span class="k">case</span> <span class="n">AUDIT_EUID</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUID</span>:
		<span class="k">case</span> <span class="n">AUDIT_FSUID</span>:
		<span class="k">case</span> <span class="n">AUDIT_GID</span>:
		<span class="k">case</span> <span class="n">AUDIT_EGID</span>:
		<span class="k">case</span> <span class="n">AUDIT_SGID</span>:
		<span class="k">case</span> <span class="n">AUDIT_FSGID</span>:
		<span class="k">case</span> <span class="n">AUDIT_LOGINUID</span>:
		<span class="k">case</span> <span class="n">AUDIT_PERS</span>:
		<span class="k">case</span> <span class="n">AUDIT_MSGTYPE</span>:
		<span class="k">case</span> <span class="n">AUDIT_PPID</span>:
		<span class="k">case</span> <span class="n">AUDIT_DEVMAJOR</span>:
		<span class="k">case</span> <span class="n">AUDIT_DEVMINOR</span>:
		<span class="k">case</span> <span class="n">AUDIT_EXIT</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUCCESS</span>:
		<span class="k">case</span> <span class="n">AUDIT_ARG0</span>:
		<span class="k">case</span> <span class="n">AUDIT_ARG1</span>:
		<span class="k">case</span> <span class="n">AUDIT_ARG2</span>:
		<span class="k">case</span> <span class="n">AUDIT_ARG3</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_UID</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_GID</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_ARCH</span>:
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">arch_f</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_USER</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_ROLE</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_TYPE</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_SEN</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_CLR</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_USER</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_ROLE</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_TYPE</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_LEV_LOW</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_LEV_HIGH</span>:
			<span class="n">str</span> <span class="o">=</span> <span class="n">audit_unpack_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remain</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">str</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">buflen</span> <span class="o">+=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">security_audit_rule_init</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span>
						       <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">lsm_rule</span><span class="p">);</span>
			<span class="cm">/* Keep currently invalid fields around in case they</span>
<span class="cm">			 * become valid after a policy reload. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;audit rule for LSM &quot;</span>
				       <span class="s">&quot;</span><span class="se">\&#39;</span><span class="s">%s</span><span class="se">\&#39;</span><span class="s"> is invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">str</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">f</span><span class="o">-&gt;</span><span class="n">lsm_str</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_WATCH</span>:
			<span class="n">str</span> <span class="o">=</span> <span class="n">audit_unpack_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remain</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">str</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">buflen</span> <span class="o">+=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">audit_to_watch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_DIR</span>:
			<span class="n">str</span> <span class="o">=</span> <span class="n">audit_unpack_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remain</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">str</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">buflen</span> <span class="o">+=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">audit_make_tree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_INODE</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="n">audit_to_inode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_FILTERKEY</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">filterkey</span> <span class="o">||</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">AUDIT_MAX_KEY_LEN</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="n">str</span> <span class="o">=</span> <span class="n">audit_unpack_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">remain</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">str</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">buflen</span> <span class="o">+=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">filterkey</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_PERM</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">15</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_FILETYPE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">S_IFMT</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_FIELD_COMPARE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">AUDIT_MAX_FIELD_COMPARE</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">exit_free</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">inode_f</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">inode_f</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">Audit_not_equal</span><span class="p">)</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">inode_f</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">exit_nofree:</span>
	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>

<span class="nl">exit_free:</span>
	<span class="n">audit_free_rule</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Pack a filter field&#39;s string representation into data block. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">audit_pack_string</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">bufp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">bufp</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="o">*</span><span class="n">bufp</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Translate kernel rule respresentation to struct audit_rule.</span>
<span class="cm"> * Exists for backward compatibility with userspace. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">audit_rule</span> <span class="o">*</span><span class="nf">audit_krule_to_rule</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">krule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_rule</span> <span class="o">*</span><span class="n">rule</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">rule</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rule</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">rule</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rule</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">listnr</span><span class="p">;</span>
	<span class="n">rule</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">=</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">;</span>
	<span class="n">rule</span><span class="o">-&gt;</span><span class="n">field_count</span> <span class="o">=</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rule</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span><span class="p">;</span>
		<span class="n">rule</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">krule</span><span class="o">-&gt;</span><span class="n">vers_ops</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">krule</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">op</span> <span class="o">==</span> <span class="n">Audit_not_equal</span><span class="p">)</span>
				<span class="n">rule</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">AUDIT_NEGATE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rule</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">audit_ops</span><span class="p">[</span><span class="n">krule</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">op</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AUDIT_BITMASK_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">rule</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Translate kernel rule respresentation to struct audit_rule_data. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">audit_rule_data</span> <span class="o">*</span><span class="nf">audit_krule_to_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">krule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_rule_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">bufp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">buflen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">));</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">listnr</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">=</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">field_count</span> <span class="o">=</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">;</span>
	<span class="n">bufp</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">audit_field</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">krule</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">data</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">fieldflags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">audit_ops</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">];</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_USER</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_ROLE</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_TYPE</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_SEN</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_CLR</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_USER</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_ROLE</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_TYPE</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_LEV_LOW</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_LEV_HIGH</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">buflen</span> <span class="o">+=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">audit_pack_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufp</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">lsm_str</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_WATCH</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">buflen</span> <span class="o">+=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">audit_pack_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufp</span><span class="p">,</span>
						  <span class="n">audit_watch_path</span><span class="p">(</span><span class="n">krule</span><span class="o">-&gt;</span><span class="n">watch</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_DIR</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">buflen</span> <span class="o">+=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">audit_pack_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufp</span><span class="p">,</span>
						  <span class="n">audit_tree_path</span><span class="p">(</span><span class="n">krule</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_FILTERKEY</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">buflen</span> <span class="o">+=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">audit_pack_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufp</span><span class="p">,</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">filterkey</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AUDIT_BITMASK_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">krule</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Compare two rules in kernel format.  Considered success if rules</span>
<span class="cm"> * don&#39;t match. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">audit_compare_rule</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">!=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">||</span>
	    <span class="n">a</span><span class="o">-&gt;</span><span class="n">listnr</span> <span class="o">!=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">listnr</span> <span class="o">||</span>
	    <span class="n">a</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">!=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">||</span>
	    <span class="n">a</span><span class="o">-&gt;</span><span class="n">field_count</span> <span class="o">!=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">!=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">||</span>
		    <span class="n">a</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">op</span> <span class="o">!=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">op</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">switch</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_USER</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_ROLE</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_TYPE</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_SEN</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_CLR</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_USER</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_ROLE</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_TYPE</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_LEV_LOW</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_LEV_HIGH</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lsm_str</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lsm_str</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_WATCH</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">audit_watch_path</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">watch</span><span class="p">),</span>
				   <span class="n">audit_watch_path</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">watch</span><span class="p">)))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_DIR</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">audit_tree_path</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">),</span>
				   <span class="n">audit_tree_path</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">)))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_FILTERKEY</span>:
			<span class="cm">/* both filterkeys exist based on above type compare */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">filterkey</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">filterkey</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span> <span class="o">!=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AUDIT_BITMASK_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Duplicate LSM field information.  The lsm_rule is opaque, so must be</span>
<span class="cm"> * re-initialized. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">audit_dupe_lsm_field</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_field</span> <span class="o">*</span><span class="n">df</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">audit_field</span> <span class="o">*</span><span class="n">sf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">lsm_str</span><span class="p">;</span>

	<span class="cm">/* our own copy of lsm_str */</span>
	<span class="n">lsm_str</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">lsm_str</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">lsm_str</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">df</span><span class="o">-&gt;</span><span class="n">lsm_str</span> <span class="o">=</span> <span class="n">lsm_str</span><span class="p">;</span>

	<span class="cm">/* our own (refreshed) copy of lsm_rule */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">security_audit_rule_init</span><span class="p">(</span><span class="n">df</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">df</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">,</span> <span class="n">df</span><span class="o">-&gt;</span><span class="n">lsm_str</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">df</span><span class="o">-&gt;</span><span class="n">lsm_rule</span><span class="p">);</span>
	<span class="cm">/* Keep currently invalid fields around in case they</span>
<span class="cm">	 * become valid after a policy reload. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;audit rule for LSM </span><span class="se">\&#39;</span><span class="s">%s</span><span class="se">\&#39;</span><span class="s"> is &quot;</span>
		       <span class="s">&quot;invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">df</span><span class="o">-&gt;</span><span class="n">lsm_str</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Duplicate an audit rule.  This will be a deep copy with the exception</span>
<span class="cm"> * of the watch - that pointer is carried over.  The LSM specific fields</span>
<span class="cm"> * will be updated in the copy.  The point is to be able to replace the old</span>
<span class="cm"> * rule with the new rule in the filterlist, then free the old rule.</span>
<span class="cm"> * The rlist element is undefined; list manipulations are handled apart from</span>
<span class="cm"> * the initial copy. */</span>
<span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="nf">audit_dupe_rule</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">fcount</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">fk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">audit_init_entry</span><span class="p">(</span><span class="n">fcount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">new</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">vers_ops</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">vers_ops</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">listnr</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">listnr</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AUDIT_BITMASK_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">buflen</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">buflen</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">inode_f</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">inode_f</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">field_count</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * note that we are OK with not refcounting here; audit_match_tree()</span>
<span class="cm">	 * never dereferences tree and we can&#39;t get false positives there</span>
<span class="cm">	 * since we&#39;d have to have rule gone from the list *and* removed</span>
<span class="cm">	 * before the chunks found by lookup had been allocated, i.e. before</span>
<span class="cm">	 * the beginning of list scan.</span>
<span class="cm">	 */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">tree</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_field</span><span class="p">)</span> <span class="o">*</span> <span class="n">fcount</span><span class="p">);</span>

	<span class="cm">/* deep copy this information, updating the lsm_rule fields, because</span>
<span class="cm">	 * the originals will all be freed when the old rule is freed. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fcount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_USER</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_ROLE</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_TYPE</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_SEN</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_CLR</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_USER</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_ROLE</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_TYPE</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_LEV_LOW</span>:
		<span class="k">case</span> <span class="n">AUDIT_OBJ_LEV_HIGH</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="n">audit_dupe_lsm_field</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						       <span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_FILTERKEY</span>:
			<span class="n">fk</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">filterkey</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">fk</span><span class="p">))</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">new</span><span class="o">-&gt;</span><span class="n">filterkey</span> <span class="o">=</span> <span class="n">fk</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">audit_free_rule</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">watch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">audit_get_watch</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">watch</span><span class="p">);</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">watch</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">watch</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find an existing audit rule.</span>
<span class="cm"> * Caller must hold audit_filter_mutex to prevent stale rule data. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="nf">audit_find_rule</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">list_head</span> <span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="n">found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">h</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">inode_f</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">h</span> <span class="o">=</span> <span class="n">audit_hash_ino</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">inode_f</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">audit_inode_hash</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">watch</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we don&#39;t know the inode number, so must walk entire hash */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">AUDIT_INODE_BUCKETS</span><span class="p">;</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">audit_inode_hash</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">audit_compare_rule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">found</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">audit_filter_list</span><span class="p">[</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">listnr</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">audit_compare_rule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="n">prio_low</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0ULL</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">prio_high</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0ULL</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/* Add rule to given filterlist if not a duplicate. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">audit_add_rule</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_watch</span> <span class="o">*</span><span class="n">watch</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">watch</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_tree</span> <span class="o">*</span><span class="n">tree</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_AUDITSYSCALL</span>
	<span class="kt">int</span> <span class="n">dont_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If either of these, don&#39;t count towards total */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">listnr</span> <span class="o">==</span> <span class="n">AUDIT_FILTER_USER</span> <span class="o">||</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">listnr</span> <span class="o">==</span> <span class="n">AUDIT_FILTER_TYPE</span><span class="p">)</span>
		<span class="n">dont_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_filter_mutex</span><span class="p">);</span>
	<span class="n">e</span> <span class="o">=</span> <span class="n">audit_find_rule</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_filter_mutex</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="cm">/* normally audit_add_tree_rule() will free it on failure */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="p">)</span>
			<span class="n">audit_put_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">watch</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* audit_filter_mutex is dropped and re-taken during this call */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">audit_add_watch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_filter_mutex</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">audit_add_tree_rule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_filter_mutex</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">prio</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0ULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">listnr</span> <span class="o">==</span> <span class="n">AUDIT_FILTER_EXIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AUDIT_FILTER_PREPEND</span><span class="p">)</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">prio</span> <span class="o">=</span> <span class="o">++</span><span class="n">prio_high</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">prio</span> <span class="o">=</span> <span class="o">--</span><span class="n">prio_low</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AUDIT_FILTER_PREPEND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">list</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">audit_rules_list</span><span class="p">[</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">listnr</span><span class="p">]);</span>
		<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AUDIT_FILTER_PREPEND</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">list</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">audit_rules_list</span><span class="p">[</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">listnr</span><span class="p">]);</span>
		<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_AUDITSYSCALL</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dont_count</span><span class="p">)</span>
		<span class="n">audit_n_rules</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">audit_match_signal</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
		<span class="n">audit_signals</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_filter_mutex</span><span class="p">);</span>

 	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">watch</span><span class="p">)</span>
		<span class="n">audit_put_watch</span><span class="p">(</span><span class="n">watch</span><span class="p">);</span> <span class="cm">/* tmp watch, matches initial get */</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remove an existing rule from filterlist. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">audit_del_rule</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_entry</span>  <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_watch</span> <span class="o">*</span><span class="n">watch</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">watch</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_tree</span> <span class="o">*</span><span class="n">tree</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_AUDITSYSCALL</span>
	<span class="kt">int</span> <span class="n">dont_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If either of these, don&#39;t count towards total */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">listnr</span> <span class="o">==</span> <span class="n">AUDIT_FILTER_USER</span> <span class="o">||</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">listnr</span> <span class="o">==</span> <span class="n">AUDIT_FILTER_TYPE</span><span class="p">)</span>
		<span class="n">dont_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_filter_mutex</span><span class="p">);</span>
	<span class="n">e</span> <span class="o">=</span> <span class="n">audit_find_rule</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_filter_mutex</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">watch</span><span class="p">)</span>
		<span class="n">audit_remove_watch_rule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">tree</span><span class="p">)</span>
		<span class="n">audit_remove_tree_rule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">);</span>

	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">audit_free_rule_rcu</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_AUDITSYSCALL</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dont_count</span><span class="p">)</span>
		<span class="n">audit_n_rules</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">audit_match_signal</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
		<span class="n">audit_signals</span><span class="o">--</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_filter_mutex</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">watch</span><span class="p">)</span>
		<span class="n">audit_put_watch</span><span class="p">(</span><span class="n">watch</span><span class="p">);</span> <span class="cm">/* match initial get */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="p">)</span>
		<span class="n">audit_put_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>	<span class="cm">/* that&#39;s the temporary one */</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* List rules using struct audit_rule.  Exists for backward</span>
<span class="cm"> * compatibility with userspace. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">audit_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* This is a blocking read, so use audit_filter_mutex instead of rcu</span>
<span class="cm">	 * iterator to sync with list writers. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">AUDIT_NR_FILTERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_rules_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">audit_rule</span> <span class="o">*</span><span class="n">rule</span><span class="p">;</span>

			<span class="n">rule</span> <span class="o">=</span> <span class="n">audit_krule_to_rule</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">rule</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">audit_make_reply</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">AUDIT_LIST</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					 <span class="n">rule</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rule</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
				<span class="n">skb_queue_tail</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">rule</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">audit_make_reply</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">AUDIT_LIST</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">skb_queue_tail</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* List rules using struct audit_rule_data. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">audit_list_rules</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* This is a blocking read, so use audit_filter_mutex instead of rcu</span>
<span class="cm">	 * iterator to sync with list writers. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">AUDIT_NR_FILTERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_rules_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">audit_rule_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

			<span class="n">data</span> <span class="o">=</span> <span class="n">audit_krule_to_data</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">audit_make_reply</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">AUDIT_LIST_RULES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					 <span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">buflen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
				<span class="n">skb_queue_tail</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">audit_make_reply</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">AUDIT_LIST_RULES</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">skb_queue_tail</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Log rule additions and removals */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">audit_log_rule_change</span><span class="p">(</span><span class="n">uid_t</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sid</span><span class="p">,</span>
				  <span class="kt">char</span> <span class="o">*</span><span class="n">action</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">rule</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_buffer</span> <span class="o">*</span><span class="n">ab</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">audit_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ab</span> <span class="o">=</span> <span class="n">audit_log_start</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">AUDIT_CONFIG_CHANGE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ab</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot;auid=%u ses=%u&quot;</span><span class="p">,</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sid</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">security_secid_to_secctx</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">))</span>
			<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; ssid=%u&quot;</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; subj=%s&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
			<span class="n">security_release_secctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; op=&quot;</span><span class="p">);</span>
	<span class="n">audit_log_string</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
	<span class="n">audit_log_key</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">filterkey</span><span class="p">);</span>
	<span class="n">audit_log_format</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="s">&quot; list=%d res=%d&quot;</span><span class="p">,</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">listnr</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="n">audit_log_end</span><span class="p">(</span><span class="n">ab</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * audit_receive_filter - apply all rules to the specified message type</span>
<span class="cm"> * @type: audit message type</span>
<span class="cm"> * @pid: target pid for netlink audit messages</span>
<span class="cm"> * @uid: target uid for netlink audit messages</span>
<span class="cm"> * @seq: netlink audit message sequence (serial) number</span>
<span class="cm"> * @data: payload data</span>
<span class="cm"> * @datasz: size of payload data</span>
<span class="cm"> * @loginuid: loginuid of sender</span>
<span class="cm"> * @sessionid: sessionid for netlink audit message</span>
<span class="cm"> * @sid: SE Linux Security ID of sender</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">audit_receive_filter</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">datasz</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_netlink_list</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AUDIT_LIST</span>:
	<span class="k">case</span> <span class="n">AUDIT_LIST_RULES</span>:
		<span class="cm">/* We can&#39;t just spew out the rules here because we might fill</span>
<span class="cm">		 * the available socket buffer space and deadlock waiting for</span>
<span class="cm">		 * auditctl to read from it... which isn&#39;t ever going to</span>
<span class="cm">		 * happen if we&#39;re actually running in the context of auditctl</span>
<span class="cm">		 * trying to _send_ the stuff */</span>

		<span class="n">dest</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_netlink_list</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dest</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">dest</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
		<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">);</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_filter_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">AUDIT_LIST</span><span class="p">)</span>
			<span class="n">audit_list</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">audit_list_rules</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_filter_mutex</span><span class="p">);</span>

		<span class="n">tsk</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">audit_send_list</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="s">&quot;audit_send_list&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_ADD</span>:
	<span class="k">case</span> <span class="n">AUDIT_ADD_RULE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">AUDIT_ADD</span><span class="p">)</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">audit_rule_to_entry</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">audit_data_to_entry</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">datasz</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">audit_add_rule</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">audit_log_rule_change</span><span class="p">(</span><span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="s">&quot;add rule&quot;</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">,</span> <span class="o">!</span><span class="n">err</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">audit_free_rule</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_DEL</span>:
	<span class="k">case</span> <span class="n">AUDIT_DEL_RULE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">AUDIT_DEL</span><span class="p">)</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">audit_rule_to_entry</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">audit_data_to_entry</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">datasz</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">audit_del_rule</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">audit_log_rule_change</span><span class="p">(</span><span class="n">loginuid</span><span class="p">,</span> <span class="n">sessionid</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="s">&quot;remove rule&quot;</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">,</span> <span class="o">!</span><span class="n">err</span><span class="p">);</span>

		<span class="n">audit_free_rule</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">audit_comparator</span><span class="p">(</span><span class="n">u32</span> <span class="n">left</span><span class="p">,</span> <span class="n">u32</span> <span class="n">op</span><span class="p">,</span> <span class="n">u32</span> <span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">Audit_equal</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">Audit_not_equal</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="n">right</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">Audit_lt</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">Audit_le</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">Audit_gt</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">Audit_ge</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">Audit_bitmask</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;</span> <span class="n">right</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">Audit_bittest</span>:
		<span class="k">return</span> <span class="p">((</span><span class="n">left</span> <span class="o">&amp;</span> <span class="n">right</span><span class="p">)</span> <span class="o">==</span> <span class="n">right</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Compare given dentry name with last component in given path,</span>
<span class="cm"> * return of 0 indicates a match. */</span>
<span class="kt">int</span> <span class="nf">audit_compare_dname_path</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="o">*</span><span class="n">dirlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dlen</span><span class="p">,</span> <span class="n">plen</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dname</span> <span class="o">||</span> <span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dlen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">dname</span><span class="p">);</span>
	<span class="n">plen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">&lt;</span> <span class="n">dlen</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* disregard trailing slashes */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="n">plen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">path</span><span class="p">))</span>
		<span class="n">p</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* find last path component */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">dlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*--</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* return length of path&#39;s directory component */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dirlen</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dirlen</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">path</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dname</span><span class="p">,</span> <span class="n">dlen</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">audit_filter_user_rules</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlink_skb_parms</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">rule</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">audit_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">audit_field</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">sid</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AUDIT_PID</span>:
			<span class="n">result</span> <span class="o">=</span> <span class="n">audit_comparator</span><span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">creds</span><span class="p">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_UID</span>:
			<span class="n">result</span> <span class="o">=</span> <span class="n">audit_comparator</span><span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">creds</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_GID</span>:
			<span class="n">result</span> <span class="o">=</span> <span class="n">audit_comparator</span><span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">creds</span><span class="p">.</span><span class="n">gid</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_LOGINUID</span>:
			<span class="n">result</span> <span class="o">=</span> <span class="n">audit_comparator</span><span class="p">(</span><span class="n">audit_get_loginuid</span><span class="p">(</span><span class="n">current</span><span class="p">),</span>
						  <span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_USER</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_ROLE</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_TYPE</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_SEN</span>:
		<span class="k">case</span> <span class="n">AUDIT_SUBJ_CLR</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">lsm_rule</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">security_task_getsecid</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sid</span><span class="p">);</span>
				<span class="n">result</span> <span class="o">=</span> <span class="n">security_audit_rule_match</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span>
								   <span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
								   <span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">,</span>
								   <span class="n">f</span><span class="o">-&gt;</span><span class="n">lsm_rule</span><span class="p">,</span>
								   <span class="nb">NULL</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">rule</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AUDIT_NEVER</span>:    <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">AUDIT_DISABLED</span><span class="p">;</span>	    <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AUDIT_ALWAYS</span>:   <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">AUDIT_RECORD_CONTEXT</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">audit_filter_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">netlink_skb_parms</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">audit_state</span> <span class="n">state</span> <span class="o">=</span> <span class="n">AUDIT_DISABLED</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_filter_list</span><span class="p">[</span><span class="n">AUDIT_FILTER_USER</span><span class="p">],</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">audit_filter_user_rules</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">AUDIT_DISABLED</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span> <span class="cm">/* Audit by default */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">audit_filter_type</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_filter_list</span><span class="p">[</span><span class="n">AUDIT_FILTER_TYPE</span><span class="p">]))</span>
		<span class="k">goto</span> <span class="n">unlock_and_return</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_filter_list</span><span class="p">[</span><span class="n">AUDIT_FILTER_TYPE</span><span class="p">],</span>
				<span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">field_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">audit_field</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">AUDIT_MSGTYPE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">result</span> <span class="o">=</span> <span class="n">audit_comparator</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock_and_return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">unlock_and_return:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_lsm_rule</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audit_entry</span><span class="p">,</span> <span class="n">rule</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">audit_entry</span> <span class="o">*</span><span class="n">nentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">security_audit_rule_known</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nentry</span> <span class="o">=</span> <span class="n">audit_dupe_rule</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">nentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* save the first error encountered for the</span>
<span class="cm">		 * return value */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">nentry</span><span class="p">);</span>
		<span class="n">audit_panic</span><span class="p">(</span><span class="s">&quot;error updating LSM filters&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">watch</span><span class="p">)</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">rlist</span><span class="p">);</span>
		<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">watch</span> <span class="o">||</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">)</span>
			<span class="n">list_replace_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">rlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nentry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">rlist</span><span class="p">);</span>
		<span class="n">list_replace_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nentry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">list_replace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nentry</span><span class="o">-&gt;</span><span class="n">rule</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">audit_free_rule_rcu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function will re-initialize the lsm_rule field of all applicable rules.</span>
<span class="cm"> * It will traverse the filter lists serarching for rules that contain LSM</span>
<span class="cm"> * specific filter fields.  When such a rule is found, it is copied, the</span>
<span class="cm"> * LSM field is re-initialized, and the old rule is replaced with the</span>
<span class="cm"> * updated rule. */</span>
<span class="kt">int</span> <span class="nf">audit_update_lsm_rules</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* audit_filter_mutex synchronizes the writers */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_filter_mutex</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AUDIT_NR_FILTERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">audit_rules_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">update_lsm_rule</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audit_filter_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
