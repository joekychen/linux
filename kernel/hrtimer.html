<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › hrtimer.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>hrtimer.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/kernel/hrtimer.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright(C) 2005-2006, Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="cm"> *  Copyright(C) 2005-2007, Red Hat, Inc., Ingo Molnar</span>
<span class="cm"> *  Copyright(C) 2006-2007  Timesys Corp., Thomas Gleixner</span>
<span class="cm"> *</span>
<span class="cm"> *  High-resolution kernel timers</span>
<span class="cm"> *</span>
<span class="cm"> *  In contrast to the low-resolution timeout API implemented in</span>
<span class="cm"> *  kernel/timer.c, hrtimers provide finer resolution and accuracy</span>
<span class="cm"> *  depending on system configuration and capabilities.</span>
<span class="cm"> *</span>
<span class="cm"> *  These timers are currently used for:</span>
<span class="cm"> *   - itimers</span>
<span class="cm"> *   - POSIX timers</span>
<span class="cm"> *   - nanosleep</span>
<span class="cm"> *   - precise in-kernel timing</span>
<span class="cm"> *</span>
<span class="cm"> *  Started by: Thomas Gleixner and Ingo Molnar</span>
<span class="cm"> *</span>
<span class="cm"> *  Credits:</span>
<span class="cm"> *	based on kernel/timer.c</span>
<span class="cm"> *</span>
<span class="cm"> *	Help, testing, suggestions, bugfixes, improvements were</span>
<span class="cm"> *	provided by:</span>
<span class="cm"> *</span>
<span class="cm"> *	George Anzinger, Andrew Morton, Steven Rostedt, Roman Zippel</span>
<span class="cm"> *	et. al.</span>
<span class="cm"> *</span>
<span class="cm"> *  For licencing details see kernel-base/COPYING</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/hrtimer.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/tick.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/debugobjects.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &lt;trace/events/timer.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * The timer bases:</span>
<span class="cm"> *</span>
<span class="cm"> * There are more clockids then hrtimer bases. Thus, we index</span>
<span class="cm"> * into the timer bases by the hrtimer_base_type enum. When trying</span>
<span class="cm"> * to reach a base using a clockid, hrtimer_clockid_to_base()</span>
<span class="cm"> * is used to convert from clockid to the proper hrtimer_base_type.</span>
<span class="cm"> */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer_cpu_base</span><span class="p">,</span> <span class="n">hrtimer_bases</span><span class="p">)</span> <span class="o">=</span>
<span class="p">{</span>

	<span class="p">.</span><span class="n">clock_base</span> <span class="o">=</span>
	<span class="p">{</span>
		<span class="p">{</span>
			<span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">HRTIMER_BASE_MONOTONIC</span><span class="p">,</span>
			<span class="p">.</span><span class="n">clockid</span> <span class="o">=</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span>
			<span class="p">.</span><span class="n">get_time</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ktime_get</span><span class="p">,</span>
			<span class="p">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">KTIME_LOW_RES</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">{</span>
			<span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">HRTIMER_BASE_REALTIME</span><span class="p">,</span>
			<span class="p">.</span><span class="n">clockid</span> <span class="o">=</span> <span class="n">CLOCK_REALTIME</span><span class="p">,</span>
			<span class="p">.</span><span class="n">get_time</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ktime_get_real</span><span class="p">,</span>
			<span class="p">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">KTIME_LOW_RES</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">{</span>
			<span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">HRTIMER_BASE_BOOTTIME</span><span class="p">,</span>
			<span class="p">.</span><span class="n">clockid</span> <span class="o">=</span> <span class="n">CLOCK_BOOTTIME</span><span class="p">,</span>
			<span class="p">.</span><span class="n">get_time</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ktime_get_boottime</span><span class="p">,</span>
			<span class="p">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">KTIME_LOW_RES</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">hrtimer_clock_to_base_table</span><span class="p">[</span><span class="n">MAX_CLOCKS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">CLOCK_REALTIME</span><span class="p">]</span>	<span class="o">=</span> <span class="n">HRTIMER_BASE_REALTIME</span><span class="p">,</span>
	<span class="p">[</span><span class="n">CLOCK_MONOTONIC</span><span class="p">]</span>	<span class="o">=</span> <span class="n">HRTIMER_BASE_MONOTONIC</span><span class="p">,</span>
	<span class="p">[</span><span class="n">CLOCK_BOOTTIME</span><span class="p">]</span>	<span class="o">=</span> <span class="n">HRTIMER_BASE_BOOTTIME</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hrtimer_clockid_to_base</span><span class="p">(</span><span class="n">clockid_t</span> <span class="n">clock_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hrtimer_clock_to_base_table</span><span class="p">[</span><span class="n">clock_id</span><span class="p">];</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Get the coarse grained time at the softirq based on xtime and</span>
<span class="cm"> * wall_to_monotonic.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hrtimer_get_softirq_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span> <span class="n">xtim</span><span class="p">,</span> <span class="n">mono</span><span class="p">,</span> <span class="n">boot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">xts</span><span class="p">,</span> <span class="n">tom</span><span class="p">,</span> <span class="n">slp</span><span class="p">;</span>

	<span class="n">get_xtime_and_monotonic_and_sleep_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xts</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tom</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slp</span><span class="p">);</span>

	<span class="n">xtim</span> <span class="o">=</span> <span class="n">timespec_to_ktime</span><span class="p">(</span><span class="n">xts</span><span class="p">);</span>
	<span class="n">mono</span> <span class="o">=</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">xtim</span><span class="p">,</span> <span class="n">timespec_to_ktime</span><span class="p">(</span><span class="n">tom</span><span class="p">));</span>
	<span class="n">boot</span> <span class="o">=</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">mono</span><span class="p">,</span> <span class="n">timespec_to_ktime</span><span class="p">(</span><span class="n">slp</span><span class="p">));</span>
	<span class="n">base</span><span class="o">-&gt;</span><span class="n">clock_base</span><span class="p">[</span><span class="n">HRTIMER_BASE_REALTIME</span><span class="p">].</span><span class="n">softirq_time</span> <span class="o">=</span> <span class="n">xtim</span><span class="p">;</span>
	<span class="n">base</span><span class="o">-&gt;</span><span class="n">clock_base</span><span class="p">[</span><span class="n">HRTIMER_BASE_MONOTONIC</span><span class="p">].</span><span class="n">softirq_time</span> <span class="o">=</span> <span class="n">mono</span><span class="p">;</span>
	<span class="n">base</span><span class="o">-&gt;</span><span class="n">clock_base</span><span class="p">[</span><span class="n">HRTIMER_BASE_BOOTTIME</span><span class="p">].</span><span class="n">softirq_time</span> <span class="o">=</span> <span class="n">boot</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Functions and macros which are different for UP/SMP systems are kept in a</span>
<span class="cm"> * single place</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SMP</span>

<span class="cm">/*</span>
<span class="cm"> * We are using hashed locking: holding per_cpu(hrtimer_bases)[n].lock</span>
<span class="cm"> * means that all timers which are tied to this base via timer-&gt;base are</span>
<span class="cm"> * locked, and the base itself is locked too.</span>
<span class="cm"> *</span>
<span class="cm"> * So __run_timers/migrate_timers can safely modify all timers which could</span>
<span class="cm"> * be found on the lists/queues.</span>
<span class="cm"> *</span>
<span class="cm"> * When the timer&#39;s base is locked, and the timer removed from list, it is</span>
<span class="cm"> * possible to set timer-&gt;base = NULL and drop the lock: the timer remains</span>
<span class="cm"> * locked.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="nf">lock_hrtimer_base</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">base</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">base</span><span class="p">;</span>
			<span class="cm">/* The timer has migrated to another CPU: */</span>
			<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Get the preferred target CPU for NOHZ</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hrtimer_get_target</span><span class="p">(</span><span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pinned</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NO_HZ</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinned</span> <span class="o">&amp;&amp;</span> <span class="n">get_sysctl_timer_migration</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">idle_cpu</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">get_nohz_timer_target</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">this_cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * With HIGHRES=y we do not migrate the timer when it is expiring</span>
<span class="cm"> * before the next event on the target cpu because we cannot reprogram</span>
<span class="cm"> * the target cpu hardware and we would cause it to fire late.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with cpu_base-&gt;lock of target cpu held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">hrtimer_check_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">new_base</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_HIGH_RES_TIMERS</span>
	<span class="n">ktime_t</span> <span class="n">expires</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">hres_active</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">expires</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">hrtimer_get_expires</span><span class="p">(</span><span class="n">timer</span><span class="p">),</span> <span class="n">new_base</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">expires</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;=</span> <span class="n">new_base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">expires_next</span><span class="p">.</span><span class="n">tv64</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Switch the timer base to the current CPU when possible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span>
<span class="nf">switch_hrtimer_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">pinned</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">new_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">new_cpu_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">hrtimer_get_target</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span> <span class="n">pinned</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">basenum</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">new_cpu_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">hrtimer_bases</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">new_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">new_cpu_base</span><span class="o">-&gt;</span><span class="n">clock_base</span><span class="p">[</span><span class="n">basenum</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">!=</span> <span class="n">new_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are trying to move timer to new_base.</span>
<span class="cm">		 * However we can&#39;t change timer&#39;s base while it is running,</span>
<span class="cm">		 * so we keep it on the same CPU. No hassle vs. reprogramming</span>
<span class="cm">		 * the event source in the high resolution case. The softirq</span>
<span class="cm">		 * code will take care of this when the timer function has</span>
<span class="cm">		 * completed. There is no conflict as we hold the lock until</span>
<span class="cm">		 * the timer is enqueued.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">hrtimer_callback_running</span><span class="p">(</span><span class="n">timer</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">base</span><span class="p">;</span>

		<span class="cm">/* See the comment in lock_timer_base() */</span>
		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">this_cpu</span> <span class="o">&amp;&amp;</span> <span class="n">hrtimer_check_target</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">new_base</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cpu</span> <span class="o">=</span> <span class="n">this_cpu</span><span class="p">;</span>
			<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">new_base</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">new_base</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span>
<span class="nf">lock_hrtimer_base</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">base</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp"># define switch_hrtimer_base(t, b, p)	(b)</span>

<span class="cp">#endif	</span><span class="cm">/* !CONFIG_SMP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Functions for the union type storage format of ktime_t which are</span>
<span class="cm"> * too large for inlining:</span>
<span class="cm"> */</span>
<span class="cp">#if BITS_PER_LONG &lt; 64</span>
<span class="cp"># ifndef CONFIG_KTIME_SCALAR</span>
<span class="cm">/**</span>
<span class="cm"> * ktime_add_ns - Add a scalar nanoseconds value to a ktime_t variable</span>
<span class="cm"> * @kt:		addend</span>
<span class="cm"> * @nsec:	the scalar nsec value to add</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the sum of kt and nsec in ktime_t format</span>
<span class="cm"> */</span>
<span class="n">ktime_t</span> <span class="nf">ktime_add_ns</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">kt</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nsec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">nsec</span> <span class="o">&lt;</span> <span class="n">NSEC_PER_SEC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">nsec</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rem</span> <span class="o">=</span> <span class="n">do_div</span><span class="p">(</span><span class="n">nsec</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span><span class="p">);</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">ktime_set</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">nsec</span><span class="p">,</span> <span class="n">rem</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">kt</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ktime_add_ns</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ktime_sub_ns - Subtract a scalar nanoseconds value from a ktime_t variable</span>
<span class="cm"> * @kt:		minuend</span>
<span class="cm"> * @nsec:	the scalar nsec value to subtract</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the subtraction of @nsec from @kt in ktime_t format</span>
<span class="cm"> */</span>
<span class="n">ktime_t</span> <span class="nf">ktime_sub_ns</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">kt</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nsec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">nsec</span> <span class="o">&lt;</span> <span class="n">NSEC_PER_SEC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">nsec</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rem</span> <span class="o">=</span> <span class="n">do_div</span><span class="p">(</span><span class="n">nsec</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span><span class="p">);</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">ktime_set</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">nsec</span><span class="p">,</span> <span class="n">rem</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">kt</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ktime_sub_ns</span><span class="p">);</span>
<span class="cp"># endif </span><span class="cm">/* !CONFIG_KTIME_SCALAR */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Divide a ktime value by a nanosecond value</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">ktime_divns</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">kt</span><span class="p">,</span> <span class="n">s64</span> <span class="n">div</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">dclc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sft</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dclc</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">kt</span><span class="p">);</span>
	<span class="cm">/* Make sure the divisor is less than 2^32: */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">div</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sft</span><span class="o">++</span><span class="p">;</span>
		<span class="n">div</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dclc</span> <span class="o">&gt;&gt;=</span> <span class="n">sft</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">dclc</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">div</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dclc</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* BITS_PER_LONG &gt;= 64 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Add two ktime values and do a safety check for overflow:</span>
<span class="cm"> */</span>
<span class="n">ktime_t</span> <span class="nf">ktime_add_safe</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">ktime_t</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span> <span class="n">res</span> <span class="o">=</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We use KTIME_SEC_MAX here, the maximum timeout which we can</span>
<span class="cm">	 * return to user space in a timespec:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">res</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;</span> <span class="n">lhs</span><span class="p">.</span><span class="n">tv64</span> <span class="o">||</span> <span class="n">res</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">ktime_set</span><span class="p">(</span><span class="n">KTIME_SEC_MAX</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ktime_add_safe</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_OBJECTS_TIMERS</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="n">hrtimer_debug_descr</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">hrtimer_debug_hint</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_init is called when:</span>
<span class="cm"> * - an active object is initialized</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hrtimer_fixup_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">debug_object_init</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hrtimer_debug_descr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_activate is called when:</span>
<span class="cm"> * - an active object is activated</span>
<span class="cm"> * - an unknown object is activated (might be a statically initialized object)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hrtimer_fixup_activate</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">ODEBUG_STATE_NOTAVAILABLE</span>:
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_free is called when:</span>
<span class="cm"> * - an active object is freed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hrtimer_fixup_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">debug_object_free</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hrtimer_debug_descr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="n">hrtimer_debug_descr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;hrtimer&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">debug_hint</span>	<span class="o">=</span> <span class="n">hrtimer_debug_hint</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_init</span>	<span class="o">=</span> <span class="n">hrtimer_fixup_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_activate</span>	<span class="o">=</span> <span class="n">hrtimer_fixup_activate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_free</span>	<span class="o">=</span> <span class="n">hrtimer_fixup_free</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_hrtimer_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_init</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hrtimer_debug_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_hrtimer_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_activate</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hrtimer_debug_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_hrtimer_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_deactivate</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hrtimer_debug_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_hrtimer_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_free</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hrtimer_debug_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__hrtimer_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">clockid_t</span> <span class="n">clock_id</span><span class="p">,</span>
			   <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">hrtimer_init_on_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">clockid_t</span> <span class="n">clock_id</span><span class="p">,</span>
			   <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_init_on_stack</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hrtimer_debug_descr</span><span class="p">);</span>
	<span class="n">__hrtimer_init</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">clock_id</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">hrtimer_init_on_stack</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">destroy_hrtimer_on_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_free</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hrtimer_debug_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_hrtimer_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_hrtimer_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_hrtimer_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">debug_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">clockid_t</span> <span class="n">clockid</span><span class="p">,</span>
	   <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_hrtimer_init</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">trace_hrtimer_init</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">clockid</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_hrtimer_activate</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">trace_hrtimer_start</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_hrtimer_deactivate</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">trace_hrtimer_cancel</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* High resolution timer related functions */</span>
<span class="cp">#ifdef CONFIG_HIGH_RES_TIMERS</span>

<span class="cm">/*</span>
<span class="cm"> * High resolution timer enabled ?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hrtimer_hres_enabled</span> <span class="n">__read_mostly</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Enable / Disable high resolution mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_hrtimer_hres</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">))</span>
		<span class="n">hrtimer_hres_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">))</span>
		<span class="n">hrtimer_hres_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;highres=&quot;</span><span class="p">,</span> <span class="n">setup_hrtimer_hres</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * hrtimer_high_res_enabled - query, if the highres mode is enabled</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hrtimer_is_hres_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hrtimer_hres_enabled</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Is the high resolution mode active ?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hrtimer_hres_active</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">hrtimer_bases</span><span class="p">.</span><span class="n">hres_active</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reprogram the event source with checking both queues for the</span>
<span class="cm"> * next event</span>
<span class="cm"> * Called with interrupts disabled and base-&gt;lock held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">hrtimer_force_reprogram</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">cpu_base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">skip_equal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">clock_base</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">expires</span><span class="p">,</span> <span class="n">expires_next</span><span class="p">;</span>

	<span class="n">expires_next</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">KTIME_MAX</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HRTIMER_MAX_CLOCK_BASES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">base</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">timerqueue_node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

		<span class="n">next</span> <span class="o">=</span> <span class="n">timerqueue_getnext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">timer</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hrtimer</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="n">expires</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">hrtimer_get_expires</span><span class="p">(</span><span class="n">timer</span><span class="p">),</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * clock_was_set() has changed base-&gt;offset so the</span>
<span class="cm">		 * result might be negative. Fix it up to prevent a</span>
<span class="cm">		 * false positive in clockevents_program_event()</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">expires</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">expires</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">expires</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;</span> <span class="n">expires_next</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
			<span class="n">expires_next</span> <span class="o">=</span> <span class="n">expires</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skip_equal</span> <span class="o">&amp;&amp;</span> <span class="n">expires_next</span><span class="p">.</span><span class="n">tv64</span> <span class="o">==</span> <span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">expires_next</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">expires_next</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">expires_next</span><span class="p">.</span><span class="n">tv64</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">expires_next</span><span class="p">.</span><span class="n">tv64</span> <span class="o">!=</span> <span class="n">KTIME_MAX</span><span class="p">)</span>
		<span class="n">tick_program_event</span><span class="p">(</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">expires_next</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Shared reprogramming for clock_realtime and clock_monotonic</span>
<span class="cm"> *</span>
<span class="cm"> * When a timer is enqueued and expires earlier than the already enqueued</span>
<span class="cm"> * timers, we have to check, whether it expires earlier than the timer for</span>
<span class="cm"> * which the clock event device was armed.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with interrupts disabled and base-&gt;cpu_base.lock held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hrtimer_reprogram</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">cpu_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">hrtimer_bases</span><span class="p">);</span>
	<span class="n">ktime_t</span> <span class="n">expires</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">hrtimer_get_expires</span><span class="p">(</span><span class="n">timer</span><span class="p">),</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">hrtimer_get_expires_tv64</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * When the callback is running, we do not reprogram the clock event</span>
<span class="cm">	 * device. The timer callback is either running on a different CPU or</span>
<span class="cm">	 * the callback is executed in the hrtimer_interrupt context. The</span>
<span class="cm">	 * reprogramming is handled either by the softirq, which called the</span>
<span class="cm">	 * callback or at the end of the hrtimer_interrupt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hrtimer_callback_running</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * CLOCK_REALTIME timer might be requested with an absolute</span>
<span class="cm">	 * expiry time which is less than base-&gt;offset. Nothing wrong</span>
<span class="cm">	 * about that, just avoid to call into the tick code, which</span>
<span class="cm">	 * has now objections against negative expiry values.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expires</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">expires</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&gt;=</span> <span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">expires_next</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a hang was detected in the last timer interrupt then we</span>
<span class="cm">	 * do not schedule a timer which is earlier than the expiry</span>
<span class="cm">	 * which we enforced in the hang detection. We want the system</span>
<span class="cm">	 * to make progress.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">hang_detected</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clockevents returns -ETIME, when the event was in the past.</span>
<span class="cm">	 */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">tick_program_event</span><span class="p">(</span><span class="n">expires</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
		<span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">expires_next</span> <span class="o">=</span> <span class="n">expires</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the high resolution related parts of cpu_base</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hrtimer_init_hres</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">base</span><span class="o">-&gt;</span><span class="n">expires_next</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">KTIME_MAX</span><span class="p">;</span>
	<span class="n">base</span><span class="o">-&gt;</span><span class="n">hres_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When High resolution timers are active, try to reprogram. Note, that in case</span>
<span class="cm"> * the state has HRTIMER_STATE_CALLBACK set, no reprogramming and no expiry</span>
<span class="cm"> * check happens. The timer gets enqueued into the rbtree. The reprogramming</span>
<span class="cm"> * and expiry check is done in the hrtimer_interrupt or in the softirq.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hrtimer_enqueue_reprogram</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">wakeup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">hres_active</span> <span class="o">&amp;&amp;</span> <span class="n">hrtimer_reprogram</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">base</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wakeup</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">raise_softirq_irqoff</span><span class="p">(</span><span class="n">HRTIMER_SOFTIRQ</span><span class="p">);</span>
			<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">__raise_softirq_irqoff</span><span class="p">(</span><span class="n">HRTIMER_SOFTIRQ</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Retrigger next event is called after clock was set</span>
<span class="cm"> *</span>
<span class="cm"> * Called with interrupts disabled via on_each_cpu()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">retrigger_next_event</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">hrtimer_bases</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">realtime_offset</span><span class="p">,</span> <span class="n">xtim</span><span class="p">,</span> <span class="n">wtm</span><span class="p">,</span> <span class="n">sleep</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hrtimer_hres_active</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Optimized out for !HIGH_RES */</span>
	<span class="n">get_xtime_and_monotonic_and_sleep_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xtim</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wtm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sleep</span><span class="p">);</span>
	<span class="n">set_normalized_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">realtime_offset</span><span class="p">,</span> <span class="o">-</span><span class="n">wtm</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="o">-</span><span class="n">wtm</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>

	<span class="cm">/* Adjust CLOCK_REALTIME offset */</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">base</span><span class="o">-&gt;</span><span class="n">clock_base</span><span class="p">[</span><span class="n">HRTIMER_BASE_REALTIME</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span>
		<span class="n">timespec_to_ktime</span><span class="p">(</span><span class="n">realtime_offset</span><span class="p">);</span>
	<span class="n">base</span><span class="o">-&gt;</span><span class="n">clock_base</span><span class="p">[</span><span class="n">HRTIMER_BASE_BOOTTIME</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span>
		<span class="n">timespec_to_ktime</span><span class="p">(</span><span class="n">sleep</span><span class="p">);</span>

	<span class="n">hrtimer_force_reprogram</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Switch to high resolution mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hrtimer_switch_to_hres</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">hrtimer_bases</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">hres_active</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tick_init_highres</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Could not switch to high resolution &quot;</span>
				    <span class="s">&quot;mode on CPU %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">base</span><span class="o">-&gt;</span><span class="n">hres_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HRTIMER_MAX_CLOCK_BASES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">base</span><span class="o">-&gt;</span><span class="n">clock_base</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">KTIME_HIGH_RES</span><span class="p">;</span>

	<span class="n">tick_setup_sched_timer</span><span class="p">();</span>

	<span class="cm">/* &quot;Retrigger&quot; the interrupt to get things going */</span>
	<span class="n">retrigger_next_event</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hrtimer_hres_active</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hrtimer_is_hres_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hrtimer_switch_to_hres</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">hrtimer_force_reprogram</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">skip_equal</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hrtimer_enqueue_reprogram</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">wakeup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hrtimer_init_hres</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">retrigger_next_event</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_HIGH_RES_TIMERS */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Clock realtime was set</span>
<span class="cm"> *</span>
<span class="cm"> * Change the offset of the realtime clock vs. the monotonic</span>
<span class="cm"> * clock.</span>
<span class="cm"> *</span>
<span class="cm"> * We might have to reprogram the high resolution timer interrupt. On</span>
<span class="cm"> * SMP we call the architecture specific code to retrigger _all_ high</span>
<span class="cm"> * resolution timer interrupts. On UP we just disable interrupts and</span>
<span class="cm"> * call the high resolution interrupt code.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clock_was_set</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_HIGH_RES_TIMERS</span>
	<span class="cm">/* Retrigger the CPU local events everywhere */</span>
	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">retrigger_next_event</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">timerfd_clock_was_set</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * During resume we might have to reprogram the high resolution timer</span>
<span class="cm"> * interrupt (on the local CPU):</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">hrtimers_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">(),</span>
		  <span class="n">KERN_INFO</span> <span class="s">&quot;hrtimers_resume() called with IRQs enabled!&quot;</span><span class="p">);</span>

	<span class="n">retrigger_next_event</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="n">timerfd_clock_was_set</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">timer_stats_hrtimer_set_start_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_TIMER_STATS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_site</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_site</span> <span class="o">=</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">TASK_COMM_LEN</span><span class="p">);</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">timer_stats_hrtimer_clear_start_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_TIMER_STATS</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_site</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">timer_stats_account_hrtimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_TIMER_STATS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">timer_stats_active</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">timer_stats_update_stats</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_pid</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_site</span><span class="p">,</span>
				 <span class="n">timer</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_comm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Counterpart to lock_hrtimer_base above:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">unlock_hrtimer_base</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hrtimer_forward - forward the timer expiry</span>
<span class="cm"> * @timer:	hrtimer to forward</span>
<span class="cm"> * @now:	forward past this time</span>
<span class="cm"> * @interval:	the interval to forward</span>
<span class="cm"> *</span>
<span class="cm"> * Forward the timer expiry so it will expire in the future.</span>
<span class="cm"> * Returns the number of overruns.</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">hrtimer_forward</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">now</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">interval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">orun</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">delta</span><span class="p">;</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">hrtimer_get_expires</span><span class="p">(</span><span class="n">timer</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">interval</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">resolution</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
		<span class="n">interval</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">resolution</span><span class="p">.</span><span class="n">tv64</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">delta</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&gt;=</span> <span class="n">interval</span><span class="p">.</span><span class="n">tv64</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">s64</span> <span class="n">incr</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">interval</span><span class="p">);</span>

		<span class="n">orun</span> <span class="o">=</span> <span class="n">ktime_divns</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">incr</span><span class="p">);</span>
		<span class="n">hrtimer_add_expires_ns</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">incr</span> <span class="o">*</span> <span class="n">orun</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hrtimer_get_expires_tv64</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">now</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">orun</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * This (and the ktime_add() below) is the</span>
<span class="cm">		 * correction for exact:</span>
<span class="cm">		 */</span>
		<span class="n">orun</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hrtimer_add_expires</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">orun</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">hrtimer_forward</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * enqueue_hrtimer - internal function to (re)start a timer</span>
<span class="cm"> *</span>
<span class="cm"> * The timer is inserted in expiry order. Insertion into the</span>
<span class="cm"> * red black tree is O(log(n)). Must hold the base lock.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 when the new timer is the leftmost timer in the tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">enqueue_hrtimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_activate</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">timerqueue_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">active_bases</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * HRTIMER_STATE_ENQUEUED is or&#39;ed to the current state to preserve the</span>
<span class="cm">	 * state of a possibly running callback.</span>
<span class="cm">	 */</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">HRTIMER_STATE_ENQUEUED</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">==</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __remove_hrtimer - internal function to remove a timer</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold the base lock.</span>
<span class="cm"> *</span>
<span class="cm"> * High resolution timer mode reprograms the clock event device when the</span>
<span class="cm"> * timer is the one which expires next. The caller can disable this by setting</span>
<span class="cm"> * reprogram to zero. This is useful, when the context does a reprogramming</span>
<span class="cm"> * anyway (e.g. timer interrupt)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__remove_hrtimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newstate</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reprogram</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timerqueue_node</span> <span class="o">*</span><span class="n">next_timer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">HRTIMER_STATE_ENQUEUED</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">next_timer</span> <span class="o">=</span> <span class="n">timerqueue_getnext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">);</span>
	<span class="n">timerqueue_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">==</span> <span class="n">next_timer</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_HIGH_RES_TIMERS</span>
		<span class="cm">/* Reprogram the clock event device. if enabled */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reprogram</span> <span class="o">&amp;&amp;</span> <span class="n">hrtimer_hres_active</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">ktime_t</span> <span class="n">expires</span><span class="p">;</span>

			<span class="n">expires</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">hrtimer_get_expires</span><span class="p">(</span><span class="n">timer</span><span class="p">),</span>
					    <span class="n">base</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">expires_next</span><span class="p">.</span><span class="n">tv64</span> <span class="o">==</span> <span class="n">expires</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
				<span class="n">hrtimer_force_reprogram</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timerqueue_getnext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">))</span>
		<span class="n">base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">active_bases</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">newstate</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * remove hrtimer, called with base lock held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">remove_hrtimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hrtimer_is_queued</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">reprogram</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Remove the timer and force reprogramming when high</span>
<span class="cm">		 * resolution mode is active and the timer is on the current</span>
<span class="cm">		 * CPU. If we remove a timer on another CPU, reprogramming is</span>
<span class="cm">		 * skipped. The interrupt event on this CPU is fired and</span>
<span class="cm">		 * reprogramming happens in the interrupt handler. This is a</span>
<span class="cm">		 * rare case and less expensive than a smp call.</span>
<span class="cm">		 */</span>
		<span class="n">debug_deactivate</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">timer_stats_hrtimer_clear_start_info</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">reprogram</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">cpu_base</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">hrtimer_bases</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We must preserve the CALLBACK state flag here,</span>
<span class="cm">		 * otherwise we could move the timer base in</span>
<span class="cm">		 * switch_hrtimer_base.</span>
<span class="cm">		 */</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">HRTIMER_STATE_CALLBACK</span><span class="p">;</span>
		<span class="n">__remove_hrtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">reprogram</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__hrtimer_start_range_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">tim</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta_ns</span><span class="p">,</span> <span class="k">const</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">wakeup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="o">*</span><span class="n">new_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">leftmost</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">lock_hrtimer_base</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Remove an active timer from the queue: */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">remove_hrtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>

	<span class="cm">/* Switch the timer base, if necessary: */</span>
	<span class="n">new_base</span> <span class="o">=</span> <span class="n">switch_hrtimer_base</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">HRTIMER_MODE_PINNED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tim</span> <span class="o">=</span> <span class="n">ktime_add_safe</span><span class="p">(</span><span class="n">tim</span><span class="p">,</span> <span class="n">new_base</span><span class="o">-&gt;</span><span class="n">get_time</span><span class="p">());</span>
		<span class="cm">/*</span>
<span class="cm">		 * CONFIG_TIME_LOW_RES is a temporary way for architectures</span>
<span class="cm">		 * to signal that they simply return xtime in</span>
<span class="cm">		 * do_gettimeoffset(). In this case we want to round up by</span>
<span class="cm">		 * resolution when starting a relative timer, to avoid short</span>
<span class="cm">		 * timeouts. This will go away with the GTOD framework.</span>
<span class="cm">		 */</span>
<span class="cp">#ifdef CONFIG_TIME_LOW_RES</span>
		<span class="n">tim</span> <span class="o">=</span> <span class="n">ktime_add_safe</span><span class="p">(</span><span class="n">tim</span><span class="p">,</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">resolution</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">hrtimer_set_expires_range_ns</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">tim</span><span class="p">,</span> <span class="n">delta_ns</span><span class="p">);</span>

	<span class="n">timer_stats_hrtimer_set_start_info</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">leftmost</span> <span class="o">=</span> <span class="n">enqueue_hrtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">new_base</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only allow reprogramming if the new base is on this CPU.</span>
<span class="cm">	 * (it might still be on another CPU if the timer was pending)</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX send_remote_softirq() ?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">leftmost</span> <span class="o">&amp;&amp;</span> <span class="n">new_base</span><span class="o">-&gt;</span><span class="n">cpu_base</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">hrtimer_bases</span><span class="p">))</span>
		<span class="n">hrtimer_enqueue_reprogram</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">new_base</span><span class="p">,</span> <span class="n">wakeup</span><span class="p">);</span>

	<span class="n">unlock_hrtimer_base</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hrtimer_start_range_ns - (re)start an hrtimer on the current CPU</span>
<span class="cm"> * @timer:	the timer to be added</span>
<span class="cm"> * @tim:	expiry time</span>
<span class="cm"> * @delta_ns:	&quot;slack&quot; range for the timer</span>
<span class="cm"> * @mode:	expiry mode: absolute (HRTIMER_ABS) or relative (HRTIMER_REL)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  0 on success</span>
<span class="cm"> *  1 when the timer was active</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">hrtimer_start_range_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">tim</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta_ns</span><span class="p">,</span> <span class="k">const</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__hrtimer_start_range_ns</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">tim</span><span class="p">,</span> <span class="n">delta_ns</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">hrtimer_start_range_ns</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * hrtimer_start - (re)start an hrtimer on the current CPU</span>
<span class="cm"> * @timer:	the timer to be added</span>
<span class="cm"> * @tim:	expiry time</span>
<span class="cm"> * @mode:	expiry mode: absolute (HRTIMER_ABS) or relative (HRTIMER_REL)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  0 on success</span>
<span class="cm"> *  1 when the timer was active</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">hrtimer_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">tim</span><span class="p">,</span> <span class="k">const</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__hrtimer_start_range_ns</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">tim</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">hrtimer_start</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * hrtimer_try_to_cancel - try to deactivate a timer</span>
<span class="cm"> * @timer:	hrtimer to stop</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  0 when the timer was not active</span>
<span class="cm"> *  1 when the timer was active</span>
<span class="cm"> * -1 when the timer is currently excuting the callback function and</span>
<span class="cm"> *    cannot be stopped</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">hrtimer_try_to_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">lock_hrtimer_base</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hrtimer_callback_running</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">remove_hrtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>

	<span class="n">unlock_hrtimer_base</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">hrtimer_try_to_cancel</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * hrtimer_cancel - cancel a timer and wait for the handler to finish.</span>
<span class="cm"> * @timer:	the timer to be cancelled</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  0 when the timer was not active</span>
<span class="cm"> *  1 when the timer was active</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">hrtimer_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">hrtimer_try_to_cancel</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">hrtimer_cancel</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * hrtimer_get_remaining - get remaining time for the timer</span>
<span class="cm"> * @timer:	the timer to read</span>
<span class="cm"> */</span>
<span class="n">ktime_t</span> <span class="nf">hrtimer_get_remaining</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">rem</span><span class="p">;</span>

	<span class="n">lock_hrtimer_base</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">rem</span> <span class="o">=</span> <span class="n">hrtimer_expires_remaining</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">unlock_hrtimer_base</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rem</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">hrtimer_get_remaining</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NO_HZ</span>
<span class="cm">/**</span>
<span class="cm"> * hrtimer_get_next_event - get the time until next expiry event</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the delta to the next expiry event or KTIME_MAX if no timer</span>
<span class="cm"> * is pending.</span>
<span class="cm"> */</span>
<span class="n">ktime_t</span> <span class="nf">hrtimer_get_next_event</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">cpu_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">hrtimer_bases</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">clock_base</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">delta</span><span class="p">,</span> <span class="n">mindelta</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">KTIME_MAX</span> <span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hrtimer_hres_active</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HRTIMER_MAX_CLOCK_BASES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">base</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">timerqueue_node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

			<span class="n">next</span> <span class="o">=</span> <span class="n">timerqueue_getnext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">timer</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hrtimer</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
			<span class="n">delta</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">hrtimer_get_expires_tv64</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">get_time</span><span class="p">());</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">delta</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;</span> <span class="n">mindelta</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
				<span class="n">mindelta</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">delta</span><span class="p">.</span><span class="n">tv64</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mindelta</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mindelta</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mindelta</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__hrtimer_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">clockid_t</span> <span class="n">clock_id</span><span class="p">,</span>
			   <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">cpu_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span><span class="p">));</span>

	<span class="n">cpu_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__raw_get_cpu_var</span><span class="p">(</span><span class="n">hrtimer_bases</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clock_id</span> <span class="o">==</span> <span class="n">CLOCK_REALTIME</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span> <span class="o">!=</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">)</span>
		<span class="n">clock_id</span> <span class="o">=</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">hrtimer_clockid_to_base</span><span class="p">(</span><span class="n">clock_id</span><span class="p">);</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">clock_base</span><span class="p">[</span><span class="n">base</span><span class="p">];</span>
	<span class="n">timerqueue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_TIMER_STATS</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_site</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_pid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_comm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TASK_COMM_LEN</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hrtimer_init - initialize a timer to the given clock</span>
<span class="cm"> * @timer:	the timer to be initialized</span>
<span class="cm"> * @clock_id:	the clock to be used</span>
<span class="cm"> * @mode:	timer mode abs/rel</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">hrtimer_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">clockid_t</span> <span class="n">clock_id</span><span class="p">,</span>
		  <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_init</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">clock_id</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">__hrtimer_init</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">clock_id</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">hrtimer_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * hrtimer_get_res - get the timer resolution for a clock</span>
<span class="cm"> * @which_clock: which clock to query</span>
<span class="cm"> * @tp:		 pointer to timespec variable to store the resolution</span>
<span class="cm"> *</span>
<span class="cm"> * Store the resolution of the clock selected by @which_clock in the</span>
<span class="cm"> * variable pointed to by @tp.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">hrtimer_get_res</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">cpu_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">hrtimer_clockid_to_base</span><span class="p">(</span><span class="n">which_clock</span><span class="p">);</span>

	<span class="n">cpu_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__raw_get_cpu_var</span><span class="p">(</span><span class="n">hrtimer_bases</span><span class="p">);</span>
	<span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">ktime_to_timespec</span><span class="p">(</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">clock_base</span><span class="p">[</span><span class="n">base</span><span class="p">].</span><span class="n">resolution</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">hrtimer_get_res</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__run_hrtimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="o">*</span><span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">cpu_base</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">restart</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="n">debug_deactivate</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">__remove_hrtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">HRTIMER_STATE_CALLBACK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">timer_stats_account_hrtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">fn</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Because we run timers from hardirq context, there is no chance</span>
<span class="cm">	 * they get migrated to another cpu, therefore its safe to unlock</span>
<span class="cm">	 * the timer base.</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">trace_hrtimer_expire_entry</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
	<span class="n">restart</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">trace_hrtimer_expire_exit</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note: We clear the CALLBACK bit after enqueue_hrtimer and</span>
<span class="cm">	 * we do not reprogramm the event hardware. Happens either in</span>
<span class="cm">	 * hrtimer_start_range_ns() or in hrtimer_interrupt()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">restart</span> <span class="o">!=</span> <span class="n">HRTIMER_NORESTART</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">HRTIMER_STATE_CALLBACK</span><span class="p">);</span>
		<span class="n">enqueue_hrtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">HRTIMER_STATE_CALLBACK</span><span class="p">));</span>

	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HRTIMER_STATE_CALLBACK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HIGH_RES_TIMERS</span>

<span class="cm">/*</span>
<span class="cm"> * High resolution timer interrupt</span>
<span class="cm"> * Called with interrupts disabled</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">hrtimer_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">cpu_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">hrtimer_bases</span><span class="p">);</span>
	<span class="n">ktime_t</span> <span class="n">expires_next</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">entry_time</span><span class="p">,</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">hres_active</span><span class="p">);</span>
	<span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">next_event</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">KTIME_MAX</span><span class="p">;</span>

	<span class="n">entry_time</span> <span class="o">=</span> <span class="n">now</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
<span class="nl">retry:</span>
	<span class="n">expires_next</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">KTIME_MAX</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We set expires_next to KTIME_MAX here with cpu_base-&gt;lock</span>
<span class="cm">	 * held to prevent that a timer is enqueued in our queue via</span>
<span class="cm">	 * the migration code. This does not affect enqueueing of</span>
<span class="cm">	 * timers which run their callback and need to be requeued on</span>
<span class="cm">	 * this CPU.</span>
<span class="cm">	 */</span>
	<span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">expires_next</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">KTIME_MAX</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HRTIMER_MAX_CLOCK_BASES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">timerqueue_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
		<span class="n">ktime_t</span> <span class="n">basenow</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">active_bases</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">base</span> <span class="o">=</span> <span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">clock_base</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">basenow</span> <span class="o">=</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">((</span><span class="n">node</span> <span class="o">=</span> <span class="n">timerqueue_getnext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">;</span>

			<span class="n">timer</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hrtimer</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * The immediate goal for using the softexpires is</span>
<span class="cm">			 * minimizing wakeups, not running timers at the</span>
<span class="cm">			 * earliest interrupt after their soft expiration.</span>
<span class="cm">			 * This allows us to avoid using a Priority Search</span>
<span class="cm">			 * Tree, which can answer a stabbing querry for</span>
<span class="cm">			 * overlapping intervals and instead use the simple</span>
<span class="cm">			 * BST we already have.</span>
<span class="cm">			 * We don&#39;t add extra wakeups by delaying timers that</span>
<span class="cm">			 * are right-of a not yet expired timer, because that</span>
<span class="cm">			 * timer will have to trigger a wakeup anyway.</span>
<span class="cm">			 */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">basenow</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;</span> <span class="n">hrtimer_get_softexpires_tv64</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ktime_t</span> <span class="n">expires</span><span class="p">;</span>

				<span class="n">expires</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">hrtimer_get_expires</span><span class="p">(</span><span class="n">timer</span><span class="p">),</span>
						    <span class="n">base</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">expires</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;</span> <span class="n">expires_next</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
					<span class="n">expires_next</span> <span class="o">=</span> <span class="n">expires</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">__run_hrtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">basenow</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Store the new expiry value so the migration code can verify</span>
<span class="cm">	 * against it.</span>
<span class="cm">	 */</span>
	<span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">expires_next</span> <span class="o">=</span> <span class="n">expires_next</span><span class="p">;</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Reprogramming necessary ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expires_next</span><span class="p">.</span><span class="n">tv64</span> <span class="o">==</span> <span class="n">KTIME_MAX</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">tick_program_event</span><span class="p">(</span><span class="n">expires_next</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">hang_detected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The next timer was already expired due to:</span>
<span class="cm">	 * - tracing</span>
<span class="cm">	 * - long lasting callbacks</span>
<span class="cm">	 * - being scheduled away when running in a VM</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need to prevent that we loop forever in the hrtimer</span>
<span class="cm">	 * interrupt routine. We give it 3 attempts to avoid</span>
<span class="cm">	 * overreacting on some spurious event.</span>
<span class="cm">	 */</span>
	<span class="n">now</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
	<span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">nr_retries</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">retries</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Give the system a chance to do something else than looping</span>
<span class="cm">	 * here. We stored the entry time, so we know exactly how long</span>
<span class="cm">	 * we spent here. We schedule the next event this amount of</span>
<span class="cm">	 * time away.</span>
<span class="cm">	 */</span>
	<span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">nr_hangs</span><span class="o">++</span><span class="p">;</span>
	<span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">hang_detected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">entry_time</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&gt;</span> <span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">max_hang_time</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
		<span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">max_hang_time</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Limit it to a sensible value as we enforce a longer</span>
<span class="cm">	 * delay. Give the CPU at least 100ms to catch up.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">NSEC_PER_MSEC</span><span class="p">)</span>
		<span class="n">expires_next</span> <span class="o">=</span> <span class="n">ktime_add_ns</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">NSEC_PER_MSEC</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">expires_next</span> <span class="o">=</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
	<span class="n">tick_program_event</span><span class="p">(</span><span class="n">expires_next</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;hrtimer: interrupt took %llu ns</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">delta</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * local version of hrtimer_peek_ahead_timers() called with interrupts</span>
<span class="cm"> * disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__hrtimer_peek_ahead_timers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tick_device</span> <span class="o">*</span><span class="n">td</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hrtimer_hres_active</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">td</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tick_cpu_device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">td</span> <span class="o">&amp;&amp;</span> <span class="n">td</span><span class="o">-&gt;</span><span class="n">evtdev</span><span class="p">)</span>
		<span class="n">hrtimer_interrupt</span><span class="p">(</span><span class="n">td</span><span class="o">-&gt;</span><span class="n">evtdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hrtimer_peek_ahead_timers -- run soft-expired timers now</span>
<span class="cm"> *</span>
<span class="cm"> * hrtimer_peek_ahead_timers will peek at the timer queue of</span>
<span class="cm"> * the current cpu and check if there are any timers for which</span>
<span class="cm"> * the soft expires time has passed. If any such timers exist,</span>
<span class="cm"> * they are run immediately and then removed from the timer queue.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">hrtimer_peek_ahead_timers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">__hrtimer_peek_ahead_timers</span><span class="p">();</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">run_hrtimer_softirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">softirq_action</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hrtimer_peek_ahead_timers</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_HIGH_RES_TIMERS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__hrtimer_peek_ahead_timers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* !CONFIG_HIGH_RES_TIMERS */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Called from timer softirq every jiffy, expire hrtimers:</span>
<span class="cm"> *</span>
<span class="cm"> * For HRT its the fall back code to run the softirq in the timer</span>
<span class="cm"> * softirq context in case the hrtimer initialization failed or has</span>
<span class="cm"> * not been done yet.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">hrtimer_run_pending</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hrtimer_hres_active</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This _is_ ugly: We have to check in the softirq context,</span>
<span class="cm">	 * whether we can switch to highres and / or nohz mode. The</span>
<span class="cm">	 * clocksource switch happens in the timer interrupt with</span>
<span class="cm">	 * xtime_lock held. Notification from there only sets the</span>
<span class="cm">	 * check bit in the tick_oneshot code, otherwise we might</span>
<span class="cm">	 * deadlock vs. xtime_lock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tick_check_oneshot_change</span><span class="p">(</span><span class="o">!</span><span class="n">hrtimer_is_hres_enabled</span><span class="p">()))</span>
		<span class="n">hrtimer_switch_to_hres</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from hardirq context every jiffy</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">hrtimer_run_queues</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timerqueue_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">cpu_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">hrtimer_bases</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">gettime</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hrtimer_hres_active</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">HRTIMER_MAX_CLOCK_BASES</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">clock_base</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timerqueue_getnext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">gettime</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hrtimer_get_softirq_time</span><span class="p">(</span><span class="n">cpu_base</span><span class="p">);</span>
			<span class="n">gettime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">((</span><span class="n">node</span> <span class="o">=</span> <span class="n">timerqueue_getnext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">;</span>

			<span class="n">timer</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hrtimer</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">softirq_time</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;=</span>
					<span class="n">hrtimer_get_expires_tv64</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">__run_hrtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">softirq_time</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sleep related functions:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">hrtimer_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hrtimer_sleeper</span><span class="p">,</span> <span class="n">timer</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">HRTIMER_NORESTART</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">hrtimer_init_sleeper</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="o">*</span><span class="n">sl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">hrtimer_wakeup</span><span class="p">;</span>
	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">hrtimer_init_sleeper</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__sched</span> <span class="nf">do_nanosleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hrtimer_init_sleeper</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">hrtimer_start_expires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hrtimer_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">))</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">))</span>
			<span class="n">schedule</span><span class="p">();</span>

		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>

	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_rmtp</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="n">rmtp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">rmt</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">rem</span><span class="p">;</span>

	<span class="n">rem</span> <span class="o">=</span> <span class="n">hrtimer_expires_remaining</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rem</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rmt</span> <span class="o">=</span> <span class="n">ktime_to_timespec</span><span class="p">(</span><span class="n">rem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">rmtp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rmtp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="n">__sched</span> <span class="nf">hrtimer_nanosleep_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">restart_block</span> <span class="o">*</span><span class="n">restart</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span>  <span class="o">*</span><span class="n">rmtp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hrtimer_init_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">restart</span><span class="o">-&gt;</span><span class="n">nanosleep</span><span class="p">.</span><span class="n">clockid</span><span class="p">,</span>
				<span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
	<span class="n">hrtimer_set_expires_tv64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">restart</span><span class="o">-&gt;</span><span class="n">nanosleep</span><span class="p">.</span><span class="n">expires</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">do_nanosleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rmtp</span> <span class="o">=</span> <span class="n">restart</span><span class="o">-&gt;</span><span class="n">nanosleep</span><span class="p">.</span><span class="n">rmtp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rmtp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">update_rmtp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">rmtp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The other values in restart are already filled in */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTART_RESTARTBLOCK</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">destroy_hrtimer_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">hrtimer_nanosleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">rqtp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="n">rmtp</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">,</span> <span class="k">const</span> <span class="n">clockid_t</span> <span class="n">clockid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">restart_block</span> <span class="o">*</span><span class="n">restart</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">slack</span><span class="p">;</span>

	<span class="n">slack</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">timer_slack_ns</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt_task</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="n">slack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hrtimer_init_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">clockid</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">hrtimer_set_expires_range_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">timespec_to_ktime</span><span class="p">(</span><span class="o">*</span><span class="n">rqtp</span><span class="p">),</span> <span class="n">slack</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_nanosleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">mode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Absolute timers do not update the rmtp value and restart: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTNOHAND</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rmtp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">update_rmtp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">rmtp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">restart</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">restart_block</span><span class="p">;</span>
	<span class="n">restart</span><span class="o">-&gt;</span><span class="n">fn</span> <span class="o">=</span> <span class="n">hrtimer_nanosleep_restart</span><span class="p">;</span>
	<span class="n">restart</span><span class="o">-&gt;</span><span class="n">nanosleep</span><span class="p">.</span><span class="n">clockid</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">timer</span><span class="p">.</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">clockid</span><span class="p">;</span>
	<span class="n">restart</span><span class="o">-&gt;</span><span class="n">nanosleep</span><span class="p">.</span><span class="n">rmtp</span> <span class="o">=</span> <span class="n">rmtp</span><span class="p">;</span>
	<span class="n">restart</span><span class="o">-&gt;</span><span class="n">nanosleep</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">hrtimer_get_expires_tv64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTART_RESTARTBLOCK</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">destroy_hrtimer_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">nanosleep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">rqtp</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">rmtp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">tu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tu</span><span class="p">,</span> <span class="n">rqtp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tu</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timespec_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tu</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">hrtimer_nanosleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tu</span><span class="p">,</span> <span class="n">rmtp</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Functions related to boot-time initialization:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="n">init_hrtimers_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">cpu_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">hrtimer_bases</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HRTIMER_MAX_CLOCK_BASES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">clock_base</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cpu_base</span> <span class="o">=</span> <span class="n">cpu_base</span><span class="p">;</span>
		<span class="n">timerqueue_init_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">clock_base</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">active</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hrtimer_init_hres</span><span class="p">(</span><span class="n">cpu_base</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">migrate_hrtimer_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">old_base</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="o">*</span><span class="n">new_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timerqueue_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">node</span> <span class="o">=</span> <span class="n">timerqueue_getnext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_base</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">timer</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hrtimer</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">hrtimer_callback_running</span><span class="p">(</span><span class="n">timer</span><span class="p">));</span>
		<span class="n">debug_deactivate</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Mark it as STATE_MIGRATE not INACTIVE otherwise the</span>
<span class="cm">		 * timer could be seen as !active and just vanish away</span>
<span class="cm">		 * under us on another CPU</span>
<span class="cm">		 */</span>
		<span class="n">__remove_hrtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">old_base</span><span class="p">,</span> <span class="n">HRTIMER_STATE_MIGRATE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">new_base</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Enqueue the timers on the new cpu. This does not</span>
<span class="cm">		 * reprogram the event device in case the timer</span>
<span class="cm">		 * expires before the earliest on this CPU, but we run</span>
<span class="cm">		 * hrtimer_interrupt after we migrated everything to</span>
<span class="cm">		 * sort out already expired timers and reprogram the</span>
<span class="cm">		 * event device.</span>
<span class="cm">		 */</span>
		<span class="n">enqueue_hrtimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">new_base</span><span class="p">);</span>

		<span class="cm">/* Clear the migration state bit */</span>
		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HRTIMER_STATE_MIGRATE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">migrate_hrtimers</span><span class="p">(</span><span class="kt">int</span> <span class="n">scpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="o">*</span><span class="n">old_base</span><span class="p">,</span> <span class="o">*</span><span class="n">new_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">scpu</span><span class="p">));</span>
	<span class="n">tick_cancel_sched_timer</span><span class="p">(</span><span class="n">scpu</span><span class="p">);</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">old_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">hrtimer_bases</span><span class="p">,</span> <span class="n">scpu</span><span class="p">);</span>
	<span class="n">new_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">hrtimer_bases</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The caller is globally serialized and nobody else</span>
<span class="cm">	 * takes two locks at once, deadlock is not possible.</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">raw_spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HRTIMER_MAX_CLOCK_BASES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">migrate_hrtimer_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_base</span><span class="o">-&gt;</span><span class="n">clock_base</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				     <span class="o">&amp;</span><span class="n">new_base</span><span class="o">-&gt;</span><span class="n">clock_base</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_base</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Check, if we got expired work to do */</span>
	<span class="n">__hrtimer_peek_ahead_timers</span><span class="p">();</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="n">hrtimer_cpu_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">scpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE_FROZEN</span>:
		<span class="n">init_hrtimers_cpu</span><span class="p">(</span><span class="n">scpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="k">case</span> <span class="n">CPU_DYING</span>:
	<span class="k">case</span> <span class="n">CPU_DYING_FROZEN</span>:
		<span class="n">clockevents_notify</span><span class="p">(</span><span class="n">CLOCK_EVT_NOTIFY_CPU_DYING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_DEAD</span>:
	<span class="k">case</span> <span class="n">CPU_DEAD_FROZEN</span>:
	<span class="p">{</span>
		<span class="n">clockevents_notify</span><span class="p">(</span><span class="n">CLOCK_EVT_NOTIFY_CPU_DEAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scpu</span><span class="p">);</span>
		<span class="n">migrate_hrtimers</span><span class="p">(</span><span class="n">scpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">__cpuinitdata</span> <span class="n">hrtimers_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">hrtimer_cpu_notify</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">hrtimers_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hrtimer_cpu_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hrtimers_nb</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">CPU_UP_PREPARE</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="n">register_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hrtimers_nb</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_HIGH_RES_TIMERS</span>
	<span class="n">open_softirq</span><span class="p">(</span><span class="n">HRTIMER_SOFTIRQ</span><span class="p">,</span> <span class="n">run_hrtimer_softirq</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * schedule_hrtimeout_range_clock - sleep until timeout</span>
<span class="cm"> * @expires:	timeout value (ktime_t)</span>
<span class="cm"> * @delta:	slack in expires timeout (ktime_t)</span>
<span class="cm"> * @mode:	timer mode, HRTIMER_MODE_ABS or HRTIMER_MODE_REL</span>
<span class="cm"> * @clock:	timer clock, CLOCK_MONOTONIC or CLOCK_REALTIME</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__sched</span>
<span class="nf">schedule_hrtimeout_range_clock</span><span class="p">(</span><span class="n">ktime_t</span> <span class="o">*</span><span class="n">expires</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="n">t</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Optimize when a zero timeout value is given. It does not</span>
<span class="cm">	 * matter whether this is an absolute or a relative time.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expires</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">expires</span><span class="o">-&gt;</span><span class="n">tv64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * A NULL parameter means &quot;infinite&quot;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">expires</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hrtimer_init_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">hrtimer_set_expires_range_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="o">*</span><span class="n">expires</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>

	<span class="n">hrtimer_init_sleeper</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">hrtimer_start_expires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hrtimer_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">timer</span><span class="p">))</span>
		<span class="n">t</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">task</span><span class="p">))</span>
		<span class="n">schedule</span><span class="p">();</span>

	<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">destroy_hrtimer_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">t</span><span class="p">.</span><span class="n">task</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * schedule_hrtimeout_range - sleep until timeout</span>
<span class="cm"> * @expires:	timeout value (ktime_t)</span>
<span class="cm"> * @delta:	slack in expires timeout (ktime_t)</span>
<span class="cm"> * @mode:	timer mode, HRTIMER_MODE_ABS or HRTIMER_MODE_REL</span>
<span class="cm"> *</span>
<span class="cm"> * Make the current task sleep until the given expiry time has</span>
<span class="cm"> * elapsed. The routine will return immediately unless</span>
<span class="cm"> * the current task state has been set (see set_current_state()).</span>
<span class="cm"> *</span>
<span class="cm"> * The @delta argument gives the kernel the freedom to schedule the</span>
<span class="cm"> * actual wakeup to a time that is both power and performance friendly.</span>
<span class="cm"> * The kernel give the normal best effort behavior for &quot;@expires+@delta&quot;,</span>
<span class="cm"> * but may decide to fire the timer earlier, but no earlier than @expires.</span>
<span class="cm"> *</span>
<span class="cm"> * You can set the task state as follows -</span>
<span class="cm"> *</span>
<span class="cm"> * %TASK_UNINTERRUPTIBLE - at least @timeout time is guaranteed to</span>
<span class="cm"> * pass before the routine returns.</span>
<span class="cm"> *</span>
<span class="cm"> * %TASK_INTERRUPTIBLE - the routine may return early if a signal is</span>
<span class="cm"> * delivered to the current task.</span>
<span class="cm"> *</span>
<span class="cm"> * The current task state is guaranteed to be TASK_RUNNING when this</span>
<span class="cm"> * routine returns.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 when the timer has expired otherwise -EINTR</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__sched</span> <span class="nf">schedule_hrtimeout_range</span><span class="p">(</span><span class="n">ktime_t</span> <span class="o">*</span><span class="n">expires</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">schedule_hrtimeout_range_clock</span><span class="p">(</span><span class="n">expires</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
					      <span class="n">CLOCK_MONOTONIC</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">schedule_hrtimeout_range</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * schedule_hrtimeout - sleep until timeout</span>
<span class="cm"> * @expires:	timeout value (ktime_t)</span>
<span class="cm"> * @mode:	timer mode, HRTIMER_MODE_ABS or HRTIMER_MODE_REL</span>
<span class="cm"> *</span>
<span class="cm"> * Make the current task sleep until the given expiry time has</span>
<span class="cm"> * elapsed. The routine will return immediately unless</span>
<span class="cm"> * the current task state has been set (see set_current_state()).</span>
<span class="cm"> *</span>
<span class="cm"> * You can set the task state as follows -</span>
<span class="cm"> *</span>
<span class="cm"> * %TASK_UNINTERRUPTIBLE - at least @timeout time is guaranteed to</span>
<span class="cm"> * pass before the routine returns.</span>
<span class="cm"> *</span>
<span class="cm"> * %TASK_INTERRUPTIBLE - the routine may return early if a signal is</span>
<span class="cm"> * delivered to the current task.</span>
<span class="cm"> *</span>
<span class="cm"> * The current task state is guaranteed to be TASK_RUNNING when this</span>
<span class="cm"> * routine returns.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 when the timer has expired otherwise -EINTR</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__sched</span> <span class="nf">schedule_hrtimeout</span><span class="p">(</span><span class="n">ktime_t</span> <span class="o">*</span><span class="n">expires</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">schedule_hrtimeout_range</span><span class="p">(</span><span class="n">expires</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">schedule_hrtimeout</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
