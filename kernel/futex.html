<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › futex.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>futex.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Fast Userspace Mutexes (which I call &quot;Futexes!&quot;).</span>
<span class="cm"> *  (C) Rusty Russell, IBM 2002</span>
<span class="cm"> *</span>
<span class="cm"> *  Generalized futexes, futex requeueing, misc fixes by Ingo Molnar</span>
<span class="cm"> *  (C) Copyright 2003 Red Hat Inc, All Rights Reserved</span>
<span class="cm"> *</span>
<span class="cm"> *  Removed page pinning, fix privately mapped COW pages and other cleanups</span>
<span class="cm"> *  (C) Copyright 2003, 2004 Jamie Lokier</span>
<span class="cm"> *</span>
<span class="cm"> *  Robust futex support started by Ingo Molnar</span>
<span class="cm"> *  (C) Copyright 2006 Red Hat Inc, All Rights Reserved</span>
<span class="cm"> *  Thanks to Thomas Gleixner for suggestions, analysis and fixes.</span>
<span class="cm"> *</span>
<span class="cm"> *  PI-futex support started by Ingo Molnar and Thomas Gleixner</span>
<span class="cm"> *  Copyright (C) 2006 Red Hat, Inc., Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="cm"> *  Copyright (C) 2006 Timesys Corp., Thomas Gleixner &lt;tglx@timesys.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  PRIVATE futexes by Eric Dumazet</span>
<span class="cm"> *  Copyright (C) 2007 Eric Dumazet &lt;dada1@cosmosbay.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Requeue-PI support by Darren Hart &lt;dvhltc@us.ibm.com&gt;</span>
<span class="cm"> *  Copyright (C) IBM Corporation, 2009</span>
<span class="cm"> *  Thanks to Thomas Gleixner for conceptual design and careful reviews.</span>
<span class="cm"> *</span>
<span class="cm"> *  Thanks to Ben LaHaise for yelling &quot;hashed waitqueues&quot; loudly</span>
<span class="cm"> *  enough at me, Linus for the original (flawed) idea, Matthew</span>
<span class="cm"> *  Kirkwood for proof-of-concept implementation.</span>
<span class="cm"> *</span>
<span class="cm"> *  &quot;The futexes are also cursed.&quot;</span>
<span class="cm"> *  &quot;But they come in a choice of three flavours!&quot;</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/jhash.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/futex.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/magic.h&gt;</span>
<span class="cp">#include &lt;linux/pid.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>

<span class="cp">#include &lt;asm/futex.h&gt;</span>

<span class="cp">#include &quot;rtmutex_common.h&quot;</span>

<span class="kt">int</span> <span class="n">__read_mostly</span> <span class="n">futex_cmpxchg_enabled</span><span class="p">;</span>

<span class="cp">#define FUTEX_HASHBITS (CONFIG_BASE_SMALL ? 4 : 8)</span>

<span class="cm">/*</span>
<span class="cm"> * Futex flags used to encode options to functions and preserve them across</span>
<span class="cm"> * restarts.</span>
<span class="cm"> */</span>
<span class="cp">#define FLAGS_SHARED		0x01</span>
<span class="cp">#define FLAGS_CLOCKRT		0x02</span>
<span class="cp">#define FLAGS_HAS_TIMEOUT	0x04</span>

<span class="cm">/*</span>
<span class="cm"> * Priority Inheritance state:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * list of &#39;owned&#39; pi_state instances - these have to be</span>
<span class="cm">	 * cleaned up in do_exit() if the task exits prematurely:</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The PI object:</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">rt_mutex</span> <span class="n">pi_mutex</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">refcount</span><span class="p">;</span>

	<span class="k">union</span> <span class="n">futex_key</span> <span class="n">key</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct futex_q - The hashed futex queue entry, one per waiting task</span>
<span class="cm"> * @list:		priority-sorted list of tasks waiting on this futex</span>
<span class="cm"> * @task:		the task waiting on the futex</span>
<span class="cm"> * @lock_ptr:		the hash bucket lock</span>
<span class="cm"> * @key:		the key the futex is hashed on</span>
<span class="cm"> * @pi_state:		optional priority inheritance state</span>
<span class="cm"> * @rt_waiter:		rt_waiter storage for use with requeue_pi</span>
<span class="cm"> * @requeue_pi_key:	the requeue_pi target futex key</span>
<span class="cm"> * @bitset:		bitset for the optional bitmasked wakeup</span>
<span class="cm"> *</span>
<span class="cm"> * We use this hashed waitqueue, instead of a normal wait_queue_t, so</span>
<span class="cm"> * we can wake only the relevant ones (hashed queues may be shared).</span>
<span class="cm"> *</span>
<span class="cm"> * A futex_q has a woken state, just like tasks have TASK_RUNNING.</span>
<span class="cm"> * It is considered woken when plist_node_empty(&amp;q-&gt;list) || q-&gt;lock_ptr == 0.</span>
<span class="cm"> * The order of wakeup is always to make the first condition true, then</span>
<span class="cm"> * the second.</span>
<span class="cm"> *</span>
<span class="cm"> * PI futexes are typically woken before they are removed from the hash list via</span>
<span class="cm"> * the rt_mutex code. See unqueue_me_pi().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">futex_q</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">plist_node</span> <span class="n">list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock_ptr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">futex_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="o">*</span><span class="n">pi_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">rt_waiter</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">requeue_pi_key</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bitset</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">futex_q</span> <span class="n">futex_q_init</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* list gets initialized in queue_me()*/</span>
	<span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">FUTEX_KEY_INIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bitset</span> <span class="o">=</span> <span class="n">FUTEX_BITSET_MATCH_ANY</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Hash buckets are shared by all the futex_keys that hash to the same</span>
<span class="cm"> * location.  Each key may have multiple futex_q structures, one for each task</span>
<span class="cm"> * waiting on a futex.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">plist_head</span> <span class="n">chain</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="n">futex_queues</span><span class="p">[</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">FUTEX_HASHBITS</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * We hash on the keys returned from get_futex_key (see below).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="nf">hash_futex</span><span class="p">(</span><span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">jhash2</span><span class="p">((</span><span class="n">u32</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">word</span><span class="p">,</span>
			  <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">word</span><span class="p">)</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">ptr</span><span class="p">))</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span>
			  <span class="n">key</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">futex_queues</span><span class="p">[</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">FUTEX_HASHBITS</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return 1 if two futex_keys are equal, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">match_futex</span><span class="p">(</span><span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">key2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">key1</span> <span class="o">&amp;&amp;</span> <span class="n">key2</span>
		<span class="o">&amp;&amp;</span> <span class="n">key1</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">word</span> <span class="o">==</span> <span class="n">key2</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">word</span>
		<span class="o">&amp;&amp;</span> <span class="n">key1</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">ptr</span> <span class="o">==</span> <span class="n">key2</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">ptr</span>
		<span class="o">&amp;&amp;</span> <span class="n">key1</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">offset</span> <span class="o">==</span> <span class="n">key2</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Take a reference to the resource addressed by a key.</span>
<span class="cm"> * Can be called while holding spinlocks.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_futex_key_refs</span><span class="p">(</span><span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FUT_OFF_INODE</span><span class="o">|</span><span class="n">FUT_OFF_MMSHARED</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FUT_OFF_INODE</span>:
		<span class="n">ihold</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">.</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FUT_OFF_MMSHARED</span>:
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">.</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_count</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Drop a reference to the resource addressed by a key.</span>
<span class="cm"> * The hash bucket spinlock must not be held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">drop_futex_key_refs</span><span class="p">(</span><span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If we&#39;re here then we tried to put a key we failed to get */</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FUT_OFF_INODE</span><span class="o">|</span><span class="n">FUT_OFF_MMSHARED</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FUT_OFF_INODE</span>:
		<span class="n">iput</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">.</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FUT_OFF_MMSHARED</span>:
		<span class="n">mmdrop</span><span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">.</span><span class="n">mm</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_futex_key() - Get parameters which are the keys for a futex</span>
<span class="cm"> * @uaddr:	virtual address of the futex</span>
<span class="cm"> * @fshared:	0 for a PROCESS_PRIVATE futex, 1 for PROCESS_SHARED</span>
<span class="cm"> * @key:	address where result is stored.</span>
<span class="cm"> * @rw:		mapping needs to be read/write (values: VERIFY_READ,</span>
<span class="cm"> *              VERIFY_WRITE)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a negative error code or 0</span>
<span class="cm"> * The key words are stored in *key on success.</span>
<span class="cm"> *</span>
<span class="cm"> * For shared mappings, it&#39;s (page-&gt;index, vma-&gt;vm_file-&gt;f_path.dentry-&gt;d_inode,</span>
<span class="cm"> * offset_within_page).  For private mappings, it&#39;s (uaddr, current-&gt;mm).</span>
<span class="cm"> * We can usually work out the index without swapping in the page.</span>
<span class="cm"> *</span>
<span class="cm"> * lock_page() might sleep, the caller should not hold a spinlock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">get_futex_key</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fshared</span><span class="p">,</span> <span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">uaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">page_head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">ro</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The futex address must be &quot;naturally&quot; aligned.</span>
<span class="cm">	 */</span>
	<span class="n">key</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">address</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">address</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">address</span> <span class="o">-=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * PROCESS_PRIVATE futexes are fast.</span>
<span class="cm">	 * As the mm cannot disappear under us and the &#39;key&#39; only needs</span>
<span class="cm">	 * virtual address, we dont even have to find the underlying vma.</span>
<span class="cm">	 * Note : We do have to check &#39;uaddr&#39; is a valid user address,</span>
<span class="cm">	 *        but access_ok() should be faster than find_vma()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fshared</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">.</span><span class="n">mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span><span class="p">;</span>
		<span class="n">get_futex_key_refs</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">again:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">get_user_pages_fast</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If write access is not required (eg. FUTEX_WAIT), try</span>
<span class="cm">	 * and get read-only access.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">&amp;&amp;</span> <span class="n">rw</span> <span class="o">==</span> <span class="n">VERIFY_READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">get_user_pages_fast</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ro</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
	<span class="n">page_head</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageTail</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/* serialize against __split_huge_page_splitting() */</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">__get_user_pages_fast</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">page_head</span> <span class="o">=</span> <span class="n">compound_head</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * page_head is valid pointer but we must pin</span>
<span class="cm">			 * it before taking the PG_lock and/or</span>
<span class="cm">			 * PG_compound_lock. The moment we re-enable</span>
<span class="cm">			 * irqs __split_huge_page_splitting() can</span>
<span class="cm">			 * return and the head page can be freed from</span>
<span class="cm">			 * under us. We can&#39;t take the PG_lock and/or</span>
<span class="cm">			 * PG_compound_lock on a page that could be</span>
<span class="cm">			 * freed from under us.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="n">page_head</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">get_page</span><span class="p">(</span><span class="n">page_head</span><span class="p">);</span>
				<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">page_head</span> <span class="o">=</span> <span class="n">compound_head</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="n">page_head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">get_page</span><span class="p">(</span><span class="n">page_head</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">lock_page</span><span class="p">(</span><span class="n">page_head</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If page_head-&gt;mapping is NULL, then it cannot be a PageAnon</span>
<span class="cm">	 * page; but it might be the ZERO_PAGE or in the gate area or</span>
<span class="cm">	 * in a special mapping (all cases which we are happy to fail);</span>
<span class="cm">	 * or it may have been a good file page when get_user_pages_fast</span>
<span class="cm">	 * found it, but truncated or holepunched or subjected to</span>
<span class="cm">	 * invalidate_complete_page2 before we got the page lock (also</span>
<span class="cm">	 * cases which we are happy to fail).  And we hold a reference,</span>
<span class="cm">	 * so refcount care in invalidate_complete_page&#39;s remove_mapping</span>
<span class="cm">	 * prevents drop_caches from setting mapping to NULL beneath us.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The case we do have to guard against is when memory pressure made</span>
<span class="cm">	 * shmem_writepage move it from filecache to swapcache beneath us:</span>
<span class="cm">	 * an unlikely race, but we do need to retry for page_head-&gt;mapping.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_head</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">shmem_swizzled</span> <span class="o">=</span> <span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page_head</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page_head</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page_head</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shmem_swizzled</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Private mappings are handled in a simple way.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: When userspace waits on a MAP_SHARED mapping, even if</span>
<span class="cm">	 * it&#39;s a read-only handle, it&#39;s expected that futexes attach to</span>
<span class="cm">	 * the object not the particular process.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page_head</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * A RO anonymous page will never change and thus doesn&#39;t make</span>
<span class="cm">		 * sense for futex operations.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ro</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">key</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">offset</span> <span class="o">|=</span> <span class="n">FUT_OFF_MMSHARED</span><span class="p">;</span> <span class="cm">/* ref taken on mm */</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">.</span><span class="n">mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">offset</span> <span class="o">|=</span> <span class="n">FUT_OFF_INODE</span><span class="p">;</span> <span class="cm">/* inode-based key */</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">.</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page_head</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">.</span><span class="n">pgoff</span> <span class="o">=</span> <span class="n">page_head</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">get_futex_key_refs</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page_head</span><span class="p">);</span>
	<span class="n">put_page</span><span class="p">(</span><span class="n">page_head</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_futex_key</span><span class="p">(</span><span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">drop_futex_key_refs</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fault_in_user_writeable() - Fault in user address and verify RW access</span>
<span class="cm"> * @uaddr:	pointer to faulting user space address</span>
<span class="cm"> *</span>
<span class="cm"> * Slow path to fixup the fault we just took in the atomic write</span>
<span class="cm"> * access to @uaddr.</span>
<span class="cm"> *</span>
<span class="cm"> * We have no generic implementation of a non-destructive write to the</span>
<span class="cm"> * user address. We know that we faulted in the atomic pagefault</span>
<span class="cm"> * disabled section so we can as well avoid the #PF overhead by</span>
<span class="cm"> * calling get_user_pages() right away.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fault_in_user_writeable</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">fixup_user_fault</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">uaddr</span><span class="p">,</span>
			       <span class="n">FAULT_FLAG_WRITE</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * futex_top_waiter() - Return the highest priority waiter on a futex</span>
<span class="cm"> * @hb:		the hash bucket the futex_q&#39;s reside in</span>
<span class="cm"> * @key:	the futex key (to distinguish it from other futex futex_q&#39;s)</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with the hb lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="nf">futex_top_waiter</span><span class="p">(</span><span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb</span><span class="p">,</span>
					<span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>

	<span class="n">plist_for_each_entry</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_futex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">this</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmpxchg_futex_value_locked</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">curval</span><span class="p">,</span> <span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">uval</span><span class="p">,</span> <span class="n">u32</span> <span class="n">newval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pagefault_disable</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">futex_atomic_cmpxchg_inatomic</span><span class="p">(</span><span class="n">curval</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span> <span class="n">uval</span><span class="p">,</span> <span class="n">newval</span><span class="p">);</span>
	<span class="n">pagefault_enable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_futex_value_locked</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pagefault_disable</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__copy_from_user_inatomic</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
	<span class="n">pagefault_enable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * PI code:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">refill_pi_state_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="o">*</span><span class="n">pi_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pi_state_cache</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pi_state</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pi_state</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pi_state</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="cm">/* pi_mutex gets initialized later */</span>
	<span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">FUTEX_KEY_INIT</span><span class="p">;</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">pi_state_cache</span> <span class="o">=</span> <span class="n">pi_state</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="o">*</span> <span class="nf">alloc_pi_state</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="o">*</span><span class="n">pi_state</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pi_state_cache</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pi_state</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">pi_state_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pi_state</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_pi_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="o">*</span><span class="n">pi_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If pi_state-&gt;owner is NULL, the owner is most probably dying</span>
<span class="cm">	 * and has cleaned up the pi_state already</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>

		<span class="n">rt_mutex_proxy_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">,</span> <span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pi_state_cache</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pi_state</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * pi_state-&gt;list is already empty.</span>
<span class="cm">		 * clear pi_state-&gt;owner.</span>
<span class="cm">		 * refcount is at 0 - put it back to 1.</span>
<span class="cm">		 */</span>
		<span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pi_state_cache</span> <span class="o">=</span> <span class="n">pi_state</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up the task based on what TID userspace gave us.</span>
<span class="cm"> * We dont trust it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span> <span class="nf">futex_find_get_task</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="n">get_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This task is holding PI mutexes at exit time =&gt; bad.</span>
<span class="cm"> * Kernel cleans up PI-state, but userspace is likely hosed.</span>
<span class="cm"> * (Robust-futex cleanup is separate and might save the day for userspace.)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">exit_pi_state_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">pi_state_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="o">*</span><span class="n">pi_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">futex_key</span> <span class="n">key</span> <span class="o">=</span> <span class="n">FUTEX_KEY_INIT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">futex_cmpxchg_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We are a ZOMBIE and nobody can enqueue itself on</span>
<span class="cm">	 * pi_state_list anymore, but we have to be careful</span>
<span class="cm">	 * versus waiters unqueueing themselves:</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">pi_state</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">futex_pi_state</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
		<span class="n">hb</span> <span class="o">=</span> <span class="n">hash_futex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We dropped the pi-lock, so re-check whether this</span>
<span class="cm">		 * task still owns the PI-state:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">curr</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">));</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>

		<span class="n">rt_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">);</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lookup_pi_state</span><span class="p">(</span><span class="n">u32</span> <span class="n">uval</span><span class="p">,</span> <span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="o">**</span><span class="n">ps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="o">*</span><span class="n">pi_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">plist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">uval</span> <span class="o">&amp;</span> <span class="n">FUTEX_TID_MASK</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">;</span>

	<span class="n">plist_for_each_entry_safe</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_futex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Another waiter already exists - bump up</span>
<span class="cm">			 * the refcount and return its pi_state:</span>
<span class="cm">			 */</span>
			<span class="n">pi_state</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">pi_state</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Userspace might have messed up non-PI and PI futexes</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pi_state</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">));</span>

			<span class="cm">/*</span>
<span class="cm">			 * When pi_state-&gt;owner is NULL then the owner died</span>
<span class="cm">			 * and another waiter is on the fly. pi_state-&gt;owner</span>
<span class="cm">			 * is fixed up by the task which acquires</span>
<span class="cm">			 * pi_state-&gt;rt_mutex.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We do not check for pid == 0 which can happen when</span>
<span class="cm">			 * the owner died and robust_list_exit() cleared the</span>
<span class="cm">			 * TID.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&amp;&amp;</span> <span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Bail out if user space manipulated the</span>
<span class="cm">				 * futex value.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">!=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
			<span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="n">pi_state</span><span class="p">;</span>

			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are the first waiter - try to look up the real owner and attach</span>
<span class="cm">	 * the new pi_state to it, but bail out when TID = 0</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pid</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">futex_find_get_task</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to look at the task state flags to figure out,</span>
<span class="cm">	 * whether the task is exiting. To protect against the do_exit</span>
<span class="cm">	 * change of the task flags, we do this protected by</span>
<span class="cm">	 * p-&gt;pi_lock:</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The task is on the way out. When PF_EXITPIDONE is</span>
<span class="cm">		 * set, we know that the task has finished the</span>
<span class="cm">		 * cleanup:</span>
<span class="cm">		 */</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITPIDONE</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">ESRCH</span> <span class="o">:</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pi_state</span> <span class="o">=</span> <span class="n">alloc_pi_state</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the pi_mutex in locked state and make &#39;p&#39;</span>
<span class="cm">	 * the owner of it:</span>
<span class="cm">	 */</span>
	<span class="n">rt_mutex_init_proxy_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="cm">/* Store the key for possible exit cleanups: */</span>
	<span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">));</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_state_list</span><span class="p">);</span>
	<span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>

	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="n">pi_state</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * futex_lock_pi_atomic() - Atomic work required to acquire a pi aware futex</span>
<span class="cm"> * @uaddr:		the pi futex user address</span>
<span class="cm"> * @hb:			the pi futex hash bucket</span>
<span class="cm"> * @key:		the futex key associated with uaddr and hb</span>
<span class="cm"> * @ps:			the pi_state pointer where we store the result of the</span>
<span class="cm"> *			lookup</span>
<span class="cm"> * @task:		the task to perform the atomic lock work for.  This will</span>
<span class="cm"> *			be &quot;current&quot; except in the case of requeue pi.</span>
<span class="cm"> * @set_waiters:	force setting the FUTEX_WAITERS bit (1) or not (0)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  0 - ready to wait</span>
<span class="cm"> *  1 - acquired the lock</span>
<span class="cm"> * &lt;0 - error</span>
<span class="cm"> *</span>
<span class="cm"> * The hb-&gt;lock and futex_key refs shall be held by the caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">futex_lock_pi_atomic</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb</span><span class="p">,</span>
				<span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="o">**</span><span class="n">ps</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set_waiters</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lock_taken</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">ownerdied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">uval</span><span class="p">,</span> <span class="n">newval</span><span class="p">,</span> <span class="n">curval</span><span class="p">,</span> <span class="n">vpid</span> <span class="o">=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">lock_taken</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * To avoid races, we attempt to take the lock here again</span>
<span class="cm">	 * (by doing a 0 -&gt; TID atomic cmpxchg), while holding all</span>
<span class="cm">	 * the locks. It will most likely not succeed.</span>
<span class="cm">	 */</span>
	<span class="n">newval</span> <span class="o">=</span> <span class="n">vpid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set_waiters</span><span class="p">)</span>
		<span class="n">newval</span> <span class="o">|=</span> <span class="n">FUTEX_WAITERS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cmpxchg_futex_value_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curval</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">newval</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Detect deadlocks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">unlikely</span><span class="p">((</span><span class="n">curval</span> <span class="o">&amp;</span> <span class="n">FUTEX_TID_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">vpid</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EDEADLK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Surprise - we got the lock. Just return to userspace:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">curval</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">uval</span> <span class="o">=</span> <span class="n">curval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the FUTEX_WAITERS flag, so the owner will know it has someone</span>
<span class="cm">	 * to wake at the next unlock.</span>
<span class="cm">	 */</span>
	<span class="n">newval</span> <span class="o">=</span> <span class="n">curval</span> <span class="o">|</span> <span class="n">FUTEX_WAITERS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There are two cases, where a futex might have no owner (the</span>
<span class="cm">	 * owner TID is 0): OWNER_DIED. We take over the futex in this</span>
<span class="cm">	 * case. We also do an unconditional take over, when the owner</span>
<span class="cm">	 * of the futex died.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is safe as we are protected by the hash bucket lock !</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ownerdied</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">curval</span> <span class="o">&amp;</span> <span class="n">FUTEX_TID_MASK</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Keep the OWNER_DIED bit */</span>
		<span class="n">newval</span> <span class="o">=</span> <span class="p">(</span><span class="n">curval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FUTEX_TID_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">vpid</span><span class="p">;</span>
		<span class="n">ownerdied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lock_taken</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cmpxchg_futex_value_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curval</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span> <span class="n">uval</span><span class="p">,</span> <span class="n">newval</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">curval</span> <span class="o">!=</span> <span class="n">uval</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We took the lock due to owner died take over.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">lock_taken</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We dont have the lock. Look up the PI state (or create it if</span>
<span class="cm">	 * we are the first waiter):</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">lookup_pi_state</span><span class="p">(</span><span class="n">uval</span><span class="p">,</span> <span class="n">hb</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">ps</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ESRCH</span>:
			<span class="cm">/*</span>
<span class="cm">			 * No owner found for this futex. Check if the</span>
<span class="cm">			 * OWNER_DIED bit is set to figure out whether</span>
<span class="cm">			 * this is a robust futex or not.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">get_futex_value_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curval</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * We simply start over in case of a robust</span>
<span class="cm">			 * futex. The code above will take the futex</span>
<span class="cm">			 * and return happy.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curval</span> <span class="o">&amp;</span> <span class="n">FUTEX_OWNER_DIED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ownerdied</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __unqueue_futex() - Remove the futex_q from its futex_hash_bucket</span>
<span class="cm"> * @q:	The futex_q to unqueue</span>
<span class="cm"> *</span>
<span class="cm"> * The q-&gt;lock_ptr must not be NULL and must be held by the caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__unqueue_futex</span><span class="p">(</span><span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_SMP</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock_ptr</span> <span class="o">||</span> <span class="o">!</span><span class="n">spin_is_locked</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock_ptr</span><span class="p">))</span>
	    <span class="o">||</span> <span class="n">WARN_ON</span><span class="p">(</span><span class="n">plist_node_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">hb</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock_ptr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">futex_hash_bucket</span><span class="p">,</span> <span class="n">lock</span><span class="p">);</span>
	<span class="n">plist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The hash bucket lock must be held when this is called.</span>
<span class="cm"> * Afterwards, the futex_q must not be accessed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wake_futex</span><span class="p">(</span><span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We set q-&gt;lock_ptr = NULL _before_ we wake up the task. If</span>
<span class="cm">	 * a non-futex wake up happens on another CPU then the task</span>
<span class="cm">	 * might exit and p would dereference a non-existing task</span>
<span class="cm">	 * struct. Prevent this by holding a reference on p across the</span>
<span class="cm">	 * wake up.</span>
<span class="cm">	 */</span>
	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">__unqueue_futex</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The waiting task can free the futex_q as soon as</span>
<span class="cm">	 * q-&gt;lock_ptr = NULL is written, without taking any locks. A</span>
<span class="cm">	 * memory barrier is required here to prevent the following</span>
<span class="cm">	 * store to lock_ptr from getting ahead of the plist_del.</span>
<span class="cm">	 */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">lock_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">wake_up_state</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">TASK_NORMAL</span><span class="p">);</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wake_futex_pi</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">uval</span><span class="p">,</span> <span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">new_owner</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="o">*</span><span class="n">pi_state</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">pi_state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">curval</span><span class="p">),</span> <span class="n">newval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pi_state</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If current does not own the pi_state then the futex is</span>
<span class="cm">	 * inconsistent and user space fiddled with the futex value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">.</span><span class="n">wait_lock</span><span class="p">);</span>
	<span class="n">new_owner</span> <span class="o">=</span> <span class="n">rt_mutex_next_owner</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is possible that the next waiter (the one that brought</span>
<span class="cm">	 * this owner to the kernel) timed out and is no longer</span>
<span class="cm">	 * waiting on the lock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_owner</span><span class="p">)</span>
		<span class="n">new_owner</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We pass it to the next owner. (The WAITERS bit is always</span>
<span class="cm">	 * kept enabled while there is PI state around. We must also</span>
<span class="cm">	 * preserve the owner died bit.)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">uval</span> <span class="o">&amp;</span> <span class="n">FUTEX_OWNER_DIED</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">newval</span> <span class="o">=</span> <span class="n">FUTEX_WAITERS</span> <span class="o">|</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">new_owner</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg_futex_value_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curval</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span> <span class="n">uval</span><span class="p">,</span> <span class="n">newval</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">curval</span> <span class="o">!=</span> <span class="n">uval</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">.</span><span class="n">wait_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">));</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_owner</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">));</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_owner</span><span class="o">-&gt;</span><span class="n">pi_state_list</span><span class="p">);</span>
	<span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">new_owner</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_owner</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">.</span><span class="n">wait_lock</span><span class="p">);</span>
	<span class="n">rt_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unlock_futex_pi</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">uval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">oldval</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is no waiter, so we unlock the futex. The owner died</span>
<span class="cm">	 * bit has not to be preserved here. We are the owner:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg_futex_value_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldval</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span> <span class="n">uval</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldval</span> <span class="o">!=</span> <span class="n">uval</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Express the locking dependencies for lockdep:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">double_lock_hb</span><span class="p">(</span><span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hb1</span> <span class="o">&lt;=</span> <span class="n">hb2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb1</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hb1</span> <span class="o">&lt;</span> <span class="n">hb2</span><span class="p">)</span>
			<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb2</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* hb1 &gt; hb2 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb2</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb1</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">double_unlock_hb</span><span class="p">(</span><span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb1</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hb1</span> <span class="o">!=</span> <span class="n">hb2</span><span class="p">)</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb2</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wake up waiters matching bitset queued on this futex (uaddr).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">futex_wake</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_wake</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bitset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">plist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">futex_key</span> <span class="n">key</span> <span class="o">=</span> <span class="n">FUTEX_KEY_INIT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitset</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_futex_key</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_SHARED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">VERIFY_READ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">hb</span> <span class="o">=</span> <span class="n">hash_futex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">;</span>

	<span class="n">plist_for_each_entry_safe</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_futex</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">pi_state</span> <span class="o">||</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rt_waiter</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Check if one of the bits is set in both bitsets */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">bitset</span> <span class="o">&amp;</span> <span class="n">bitset</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">wake_futex</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="n">nr_wake</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wake up all waiters hashed on the physical page that is mapped</span>
<span class="cm"> * to this virtual address:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">futex_wake_op</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr2</span><span class="p">,</span>
	      <span class="kt">int</span> <span class="n">nr_wake</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_wake2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">futex_key</span> <span class="n">key1</span> <span class="o">=</span> <span class="n">FUTEX_KEY_INIT</span><span class="p">,</span> <span class="n">key2</span> <span class="o">=</span> <span class="n">FUTEX_KEY_INIT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb1</span><span class="p">,</span> <span class="o">*</span><span class="n">hb2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">plist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">op_ret</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_futex_key</span><span class="p">(</span><span class="n">uaddr1</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_SHARED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">,</span> <span class="n">VERIFY_READ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_futex_key</span><span class="p">(</span><span class="n">uaddr2</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_SHARED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">,</span> <span class="n">VERIFY_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_put_key1</span><span class="p">;</span>

	<span class="n">hb1</span> <span class="o">=</span> <span class="n">hash_futex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key1</span><span class="p">);</span>
	<span class="n">hb2</span> <span class="o">=</span> <span class="n">hash_futex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key2</span><span class="p">);</span>

<span class="nl">retry_private:</span>
	<span class="n">double_lock_hb</span><span class="p">(</span><span class="n">hb1</span><span class="p">,</span> <span class="n">hb2</span><span class="p">);</span>
	<span class="n">op_ret</span> <span class="o">=</span> <span class="n">futex_atomic_op_inuser</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">uaddr2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">op_ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">double_unlock_hb</span><span class="p">(</span><span class="n">hb1</span><span class="p">,</span> <span class="n">hb2</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_MMU</span>
		<span class="cm">/*</span>
<span class="cm">		 * we don&#39;t get EFAULT from MMU faults if we don&#39;t have an MMU,</span>
<span class="cm">		 * but we might get them from range checking</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">op_ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_put_keys</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">op_ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">op_ret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_put_keys</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">fault_in_user_writeable</span><span class="p">(</span><span class="n">uaddr2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_put_keys</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_SHARED</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">retry_private</span><span class="p">;</span>

		<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key2</span><span class="p">);</span>
		<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key1</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hb1</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">;</span>

	<span class="n">plist_for_each_entry_safe</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_futex</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">wake_futex</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="n">nr_wake</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op_ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hb2</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">;</span>

		<span class="n">op_ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">plist_for_each_entry_safe</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">match_futex</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">wake_futex</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">op_ret</span> <span class="o">&gt;=</span> <span class="n">nr_wake2</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">op_ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">double_unlock_hb</span><span class="p">(</span><span class="n">hb1</span><span class="p">,</span> <span class="n">hb2</span><span class="p">);</span>
<span class="nl">out_put_keys:</span>
	<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key2</span><span class="p">);</span>
<span class="nl">out_put_key1:</span>
	<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key1</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * requeue_futex() - Requeue a futex_q from one hb to another</span>
<span class="cm"> * @q:		the futex_q to requeue</span>
<span class="cm"> * @hb1:	the source hash_bucket</span>
<span class="cm"> * @hb2:	the target hash_bucket</span>
<span class="cm"> * @key2:	the new key for the requeued futex_q</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">requeue_futex</span><span class="p">(</span><span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb1</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb2</span><span class="p">,</span> <span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">key2</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/*</span>
<span class="cm">	 * If key1 and key2 hash to the same bucket, no need to</span>
<span class="cm">	 * requeue.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb1</span><span class="o">-&gt;</span><span class="n">chain</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">hb2</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">plist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hb1</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">);</span>
		<span class="n">plist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hb2</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">lock_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hb2</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">get_futex_key_refs</span><span class="p">(</span><span class="n">key2</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="o">*</span><span class="n">key2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * requeue_pi_wake_futex() - Wake a task that acquired the lock during requeue</span>
<span class="cm"> * @q:		the futex_q</span>
<span class="cm"> * @key:	the key of the requeue target futex</span>
<span class="cm"> * @hb:		the hash_bucket of the requeue target futex</span>
<span class="cm"> *</span>
<span class="cm"> * During futex_requeue, with requeue_pi=1, it is possible to acquire the</span>
<span class="cm"> * target futex if it is uncontended or via a lock steal.  Set the futex_q key</span>
<span class="cm"> * to the requeue target futex so the waiter can detect the wakeup on the right</span>
<span class="cm"> * futex, but remove it from the hb and NULL the rt_waiter so it can detect</span>
<span class="cm"> * atomic lock acquisition.  Set the q-&gt;lock_ptr to the requeue target hb-&gt;lock</span>
<span class="cm"> * to protect access to the pi_state to fixup the owner later.  Must be called</span>
<span class="cm"> * with both q-&gt;lock_ptr and hb-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">requeue_pi_wake_futex</span><span class="p">(</span><span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_futex_key_refs</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>

	<span class="n">__unqueue_futex</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rt_waiter</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">rt_waiter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">lock_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

	<span class="n">wake_up_state</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="n">TASK_NORMAL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * futex_proxy_trylock_atomic() - Attempt an atomic lock for the top waiter</span>
<span class="cm"> * @pifutex:		the user address of the to futex</span>
<span class="cm"> * @hb1:		the from futex hash bucket, must be locked by the caller</span>
<span class="cm"> * @hb2:		the to futex hash bucket, must be locked by the caller</span>
<span class="cm"> * @key1:		the from futex key</span>
<span class="cm"> * @key2:		the to futex key</span>
<span class="cm"> * @ps:			address to store the pi_state pointer</span>
<span class="cm"> * @set_waiters:	force setting the FUTEX_WAITERS bit (1) or not (0)</span>
<span class="cm"> *</span>
<span class="cm"> * Try and get the lock on behalf of the top waiter if we can do it atomically.</span>
<span class="cm"> * Wake the top waiter if we succeed.  If the caller specified set_waiters,</span>
<span class="cm"> * then direct futex_lock_pi_atomic() to force setting the FUTEX_WAITERS bit.</span>
<span class="cm"> * hb1 and hb2 must be held by the caller.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  0 - failed to acquire the lock atomicly</span>
<span class="cm"> *  1 - acquired the lock</span>
<span class="cm"> * &lt;0 - error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">futex_proxy_trylock_atomic</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">pifutex</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb1</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb2</span><span class="p">,</span>
				 <span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">key2</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="o">**</span><span class="n">ps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set_waiters</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">top_waiter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">curval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_futex_value_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curval</span><span class="p">,</span> <span class="n">pifutex</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find the top_waiter and determine if there are additional waiters.</span>
<span class="cm">	 * If the caller intends to requeue more than 1 waiter to pifutex,</span>
<span class="cm">	 * force futex_lock_pi_atomic() to set the FUTEX_WAITERS bit now,</span>
<span class="cm">	 * as we have means to handle the possible fault.  If not, don&#39;t set</span>
<span class="cm">	 * the bit unecessarily as it will force the subsequent unlock to enter</span>
<span class="cm">	 * the kernel.</span>
<span class="cm">	 */</span>
	<span class="n">top_waiter</span> <span class="o">=</span> <span class="n">futex_top_waiter</span><span class="p">(</span><span class="n">hb1</span><span class="p">,</span> <span class="n">key1</span><span class="p">);</span>

	<span class="cm">/* There are no waiters, nothing for us to do. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">top_waiter</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Ensure we requeue to the expected futex. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match_futex</span><span class="p">(</span><span class="n">top_waiter</span><span class="o">-&gt;</span><span class="n">requeue_pi_key</span><span class="p">,</span> <span class="n">key2</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to take the lock for top_waiter.  Set the FUTEX_WAITERS bit in</span>
<span class="cm">	 * the contended case or if set_waiters is 1.  The pi_state is returned</span>
<span class="cm">	 * in ps in contended cases.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">futex_lock_pi_atomic</span><span class="p">(</span><span class="n">pifutex</span><span class="p">,</span> <span class="n">hb2</span><span class="p">,</span> <span class="n">key2</span><span class="p">,</span> <span class="n">ps</span><span class="p">,</span> <span class="n">top_waiter</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span>
				   <span class="n">set_waiters</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">requeue_pi_wake_futex</span><span class="p">(</span><span class="n">top_waiter</span><span class="p">,</span> <span class="n">key2</span><span class="p">,</span> <span class="n">hb2</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * futex_requeue() - Requeue waiters from uaddr1 to uaddr2</span>
<span class="cm"> * @uaddr1:	source futex user address</span>
<span class="cm"> * @flags:	futex flags (FLAGS_SHARED, etc.)</span>
<span class="cm"> * @uaddr2:	target futex user address</span>
<span class="cm"> * @nr_wake:	number of waiters to wake (must be 1 for requeue_pi)</span>
<span class="cm"> * @nr_requeue:	number of waiters to requeue (0-INT_MAX)</span>
<span class="cm"> * @cmpval:	@uaddr1 expected value (or %NULL)</span>
<span class="cm"> * @requeue_pi:	if we are attempting to requeue from a non-pi futex to a</span>
<span class="cm"> *		pi futex (pi to pi requeue is not supported)</span>
<span class="cm"> *</span>
<span class="cm"> * Requeue waiters on uaddr1 to uaddr2. In the requeue_pi case, try to acquire</span>
<span class="cm"> * uaddr2 atomically on behalf of the top waiter.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * &gt;=0 - on success, the number of tasks requeued or woken</span>
<span class="cm"> *  &lt;0 - on error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">futex_requeue</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_wake</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_requeue</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="o">*</span><span class="n">cmpval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">requeue_pi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">futex_key</span> <span class="n">key1</span> <span class="o">=</span> <span class="n">FUTEX_KEY_INIT</span><span class="p">,</span> <span class="n">key2</span> <span class="o">=</span> <span class="n">FUTEX_KEY_INIT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drop_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">task_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="o">*</span><span class="n">pi_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb1</span><span class="p">,</span> <span class="o">*</span><span class="n">hb2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">plist_head</span> <span class="o">*</span><span class="n">head1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">curval2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">requeue_pi</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * requeue_pi requires a pi_state, try to allocate it now</span>
<span class="cm">		 * without any locks in case it fails.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">refill_pi_state_cache</span><span class="p">())</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * requeue_pi must wake as many tasks as it can, up to nr_wake</span>
<span class="cm">		 * + nr_requeue, since it acquires the rt_mutex prior to</span>
<span class="cm">		 * returning to userspace, so as to not leave the rt_mutex with</span>
<span class="cm">		 * waiters and no owner.  However, second and third wake-ups</span>
<span class="cm">		 * cannot be predicted as they involve race conditions with the</span>
<span class="cm">		 * first wake and a fault while looking up the pi_state.  Both</span>
<span class="cm">		 * pthread_cond_signal() and pthread_cond_broadcast() should</span>
<span class="cm">		 * use nr_wake=1.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_wake</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pi_state</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We will have to lookup the pi_state again, so free this one</span>
<span class="cm">		 * to keep the accounting correct.</span>
<span class="cm">		 */</span>
		<span class="n">free_pi_state</span><span class="p">(</span><span class="n">pi_state</span><span class="p">);</span>
		<span class="n">pi_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_futex_key</span><span class="p">(</span><span class="n">uaddr1</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_SHARED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">,</span> <span class="n">VERIFY_READ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_futex_key</span><span class="p">(</span><span class="n">uaddr2</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_SHARED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">,</span>
			    <span class="n">requeue_pi</span> <span class="o">?</span> <span class="n">VERIFY_WRITE</span> <span class="o">:</span> <span class="n">VERIFY_READ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_put_key1</span><span class="p">;</span>

	<span class="n">hb1</span> <span class="o">=</span> <span class="n">hash_futex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key1</span><span class="p">);</span>
	<span class="n">hb2</span> <span class="o">=</span> <span class="n">hash_futex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key2</span><span class="p">);</span>

<span class="nl">retry_private:</span>
	<span class="n">double_lock_hb</span><span class="p">(</span><span class="n">hb1</span><span class="p">,</span> <span class="n">hb2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cmpval</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">curval</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">get_futex_value_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curval</span><span class="p">,</span> <span class="n">uaddr1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">double_unlock_hb</span><span class="p">(</span><span class="n">hb1</span><span class="p">,</span> <span class="n">hb2</span><span class="p">);</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">curval</span><span class="p">,</span> <span class="n">uaddr1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_put_keys</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_SHARED</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">retry_private</span><span class="p">;</span>

			<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key2</span><span class="p">);</span>
			<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key1</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curval</span> <span class="o">!=</span> <span class="o">*</span><span class="n">cmpval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">requeue_pi</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">task_count</span> <span class="o">-</span> <span class="n">nr_wake</span> <span class="o">&lt;</span> <span class="n">nr_requeue</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Attempt to acquire uaddr2 and wake the top waiter. If we</span>
<span class="cm">		 * intend to requeue waiters, force setting the FUTEX_WAITERS</span>
<span class="cm">		 * bit.  We force this here where we are able to easily handle</span>
<span class="cm">		 * faults rather in the requeue loop below.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">futex_proxy_trylock_atomic</span><span class="p">(</span><span class="n">uaddr2</span><span class="p">,</span> <span class="n">hb1</span><span class="p">,</span> <span class="n">hb2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">key2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi_state</span><span class="p">,</span> <span class="n">nr_requeue</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * At this point the top_waiter has either taken uaddr2 or is</span>
<span class="cm">		 * waiting on it.  If the former, then the pi_state will not</span>
<span class="cm">		 * exist yet, look it up one more time to ensure we have a</span>
<span class="cm">		 * reference to it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">pi_state</span><span class="p">);</span>
			<span class="n">drop_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">task_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">get_futex_value_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curval2</span><span class="p">,</span> <span class="n">uaddr2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">lookup_pi_state</span><span class="p">(</span><span class="n">curval2</span><span class="p">,</span> <span class="n">hb2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">pi_state</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EFAULT</span>:
			<span class="n">double_unlock_hb</span><span class="p">(</span><span class="n">hb1</span><span class="p">,</span> <span class="n">hb2</span><span class="p">);</span>
			<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key2</span><span class="p">);</span>
			<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key1</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">fault_in_user_writeable</span><span class="p">(</span><span class="n">uaddr2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
			<span class="cm">/* The owner was exiting, try again. */</span>
			<span class="n">double_unlock_hb</span><span class="p">(</span><span class="n">hb1</span><span class="p">,</span> <span class="n">hb2</span><span class="p">);</span>
			<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key2</span><span class="p">);</span>
			<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key1</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">head1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hb1</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">;</span>
	<span class="n">plist_for_each_entry_safe</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">head1</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task_count</span> <span class="o">-</span> <span class="n">nr_wake</span> <span class="o">&gt;=</span> <span class="n">nr_requeue</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match_futex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always</span>
<span class="cm">		 * be paired with each other and no other futex ops.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">requeue_pi</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rt_waiter</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">requeue_pi</span> <span class="o">&amp;&amp;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rt_waiter</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Wake nr_wake waiters.  For requeue_pi, if we acquired the</span>
<span class="cm">		 * lock, we already woke the top_waiter.  If not, it will be</span>
<span class="cm">		 * woken by futex_unlock_pi().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">task_count</span> <span class="o">&lt;=</span> <span class="n">nr_wake</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">requeue_pi</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wake_futex</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Ensure we requeue to the expected futex for requeue_pi. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">requeue_pi</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">match_futex</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">requeue_pi_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Requeue nr_requeue waiters and possibly one more in the case</span>
<span class="cm">		 * of requeue_pi if we couldn&#39;t acquire the lock atomically.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">requeue_pi</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Prepare the waiter to take the rt_mutex. */</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">pi_state</span> <span class="o">=</span> <span class="n">pi_state</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">rt_mutex_start_proxy_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">,</span>
							<span class="n">this</span><span class="o">-&gt;</span><span class="n">rt_waiter</span><span class="p">,</span>
							<span class="n">this</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* We got the lock. */</span>
				<span class="n">requeue_pi_wake_futex</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">,</span> <span class="n">hb2</span><span class="p">);</span>
				<span class="n">drop_count</span><span class="o">++</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* -EDEADLK */</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">pi_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">free_pi_state</span><span class="p">(</span><span class="n">pi_state</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">requeue_futex</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">hb1</span><span class="p">,</span> <span class="n">hb2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">);</span>
		<span class="n">drop_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">double_unlock_hb</span><span class="p">(</span><span class="n">hb1</span><span class="p">,</span> <span class="n">hb2</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * drop_futex_key_refs() must be called outside the spinlocks. During</span>
<span class="cm">	 * the requeue we moved futex_q&#39;s from the hash bucket at key1 to the</span>
<span class="cm">	 * one at key2 and updated their key pointer.  We no longer need to</span>
<span class="cm">	 * hold the references to key1.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">drop_count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">drop_futex_key_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key1</span><span class="p">);</span>

<span class="nl">out_put_keys:</span>
	<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key2</span><span class="p">);</span>
<span class="nl">out_put_key1:</span>
	<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key1</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pi_state</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">free_pi_state</span><span class="p">(</span><span class="n">pi_state</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">task_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The key must be already stored in q-&gt;key. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="nf">queue_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb</span><span class="p">;</span>

	<span class="n">hb</span> <span class="o">=</span> <span class="n">hash_futex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">lock_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">hb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">queue_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * queue_me() - Enqueue the futex_q on the futex_hash_bucket</span>
<span class="cm"> * @q:	The futex_q to enqueue</span>
<span class="cm"> * @hb:	The destination hash bucket</span>
<span class="cm"> *</span>
<span class="cm"> * The hb-&gt;lock must be held by the caller, and is released here. A call to</span>
<span class="cm"> * queue_me() is typically paired with exactly one call to unqueue_me().  The</span>
<span class="cm"> * exceptions involve the PI related operations, which may use unqueue_me_pi()</span>
<span class="cm"> * or nothing if the unqueue is done as part of the wake process and the unqueue</span>
<span class="cm"> * state is implicit in the state of woken task (see futex_wait_requeue_pi() for</span>
<span class="cm"> * an example).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">queue_me</span><span class="p">(</span><span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">prio</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The priority used to register this element is</span>
<span class="cm">	 * - either the real thread-priority for the real-time threads</span>
<span class="cm">	 * (i.e. threads with a priority lower than MAX_RT_PRIO)</span>
<span class="cm">	 * - or MAX_RT_PRIO for non-RT threads.</span>
<span class="cm">	 * Thus, all RT-threads are woken first in priority order, and</span>
<span class="cm">	 * the others are woken last, in FIFO order.</span>
<span class="cm">	 */</span>
	<span class="n">prio</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">normal_prio</span><span class="p">,</span> <span class="n">MAX_RT_PRIO</span><span class="p">);</span>

	<span class="n">plist_node_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">prio</span><span class="p">);</span>
	<span class="n">plist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * unqueue_me() - Remove the futex_q from its futex_hash_bucket</span>
<span class="cm"> * @q:	The futex_q to unqueue</span>
<span class="cm"> *</span>
<span class="cm"> * The q-&gt;lock_ptr must not be held by the caller. A call to unqueue_me() must</span>
<span class="cm"> * be paired with exactly one earlier call to queue_me().</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   1 - if the futex_q was still queued (and we removed unqueued it)</span>
<span class="cm"> *   0 - if the futex_q was already removed by the waking thread</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">unqueue_me</span><span class="p">(</span><span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* In the common case we don&#39;t take the spinlock, which is nice. */</span>
<span class="nl">retry:</span>
	<span class="n">lock_ptr</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">lock_ptr</span><span class="p">;</span>
	<span class="n">barrier</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lock_ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock_ptr</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * q-&gt;lock_ptr can change between reading it and</span>
<span class="cm">		 * spin_lock(), causing us to take the wrong lock.  This</span>
<span class="cm">		 * corrects the race condition.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Reasoning goes like this: if we have the wrong lock,</span>
<span class="cm">		 * q-&gt;lock_ptr must have changed (maybe several times)</span>
<span class="cm">		 * between reading it and the spin_lock().  It can</span>
<span class="cm">		 * change again after the spin_lock() but only if it was</span>
<span class="cm">		 * already changed before the spin_lock().  It cannot,</span>
<span class="cm">		 * however, change back to the original value.  Therefore</span>
<span class="cm">		 * we can detect whether we acquired the correct lock.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">lock_ptr</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">lock_ptr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock_ptr</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__unqueue_futex</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pi_state</span><span class="p">);</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock_ptr</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">drop_futex_key_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * PI futexes can not be requeued and must remove themself from the</span>
<span class="cm"> * hash bucket. The hash bucket lock (i.e. lock_ptr) is held on entry</span>
<span class="cm"> * and dropped here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unqueue_me_pi</span><span class="p">(</span><span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__unqueue_futex</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pi_state</span><span class="p">);</span>
	<span class="n">free_pi_state</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pi_state</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">pi_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock_ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fixup the pi_state owner with the new owner.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with hash bucket lock held and mm-&gt;sem held for non</span>
<span class="cm"> * private futexes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fixup_pi_state_owner</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">newowner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">newtid</span> <span class="o">=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">newowner</span><span class="p">)</span> <span class="o">|</span> <span class="n">FUTEX_WAITERS</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="o">*</span><span class="n">pi_state</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pi_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">oldowner</span> <span class="o">=</span> <span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">uval</span><span class="p">,</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">curval</span><span class="p">),</span> <span class="n">newval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Owner died? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">)</span>
		<span class="n">newtid</span> <span class="o">|=</span> <span class="n">FUTEX_OWNER_DIED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are here either because we stole the rtmutex from the</span>
<span class="cm">	 * previous highest priority waiter or we are the highest priority</span>
<span class="cm">	 * waiter but failed to get the rtmutex the first time.</span>
<span class="cm">	 * We have to replace the newowner TID in the user space variable.</span>
<span class="cm">	 * This must be atomic as we have to preserve the owner died bit here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: We write the user space value _before_ changing the pi_state</span>
<span class="cm">	 * because we can fault here. Imagine swapped out pages or a fork</span>
<span class="cm">	 * that marked all the anonymous memory readonly for cow.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Modifying pi_state _before_ the user space value would</span>
<span class="cm">	 * leave the pi_state in an inconsistent state when we fault</span>
<span class="cm">	 * here, because we need to drop the hash bucket lock to</span>
<span class="cm">	 * handle the fault. This might be observed in the PID check</span>
<span class="cm">	 * in lookup_pi_state.</span>
<span class="cm">	 */</span>
<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_futex_value_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uval</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">handle_fault</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">newval</span> <span class="o">=</span> <span class="p">(</span><span class="n">uval</span> <span class="o">&amp;</span> <span class="n">FUTEX_OWNER_DIED</span><span class="p">)</span> <span class="o">|</span> <span class="n">newtid</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg_futex_value_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curval</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span> <span class="n">uval</span><span class="p">,</span> <span class="n">newval</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">handle_fault</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curval</span> <span class="o">==</span> <span class="n">uval</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">uval</span> <span class="o">=</span> <span class="n">curval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We fixed up user space. Now we need to fix the pi_state</span>
<span class="cm">	 * itself.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">));</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">newowner</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newowner</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">));</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newowner</span><span class="o">-&gt;</span><span class="n">pi_state_list</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newowner</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * To handle the page fault we need to drop the hash bucket</span>
<span class="cm">	 * lock here. That gives the other task (either the highest priority</span>
<span class="cm">	 * waiter itself or the task which stole the rtmutex) the</span>
<span class="cm">	 * chance to try the fixup of the pi_state. So once we are</span>
<span class="cm">	 * back from handling the fault we need to check the pi_state</span>
<span class="cm">	 * after reacquiring the hash bucket lock and before trying to</span>
<span class="cm">	 * do another fixup. When the fixup has been done already we</span>
<span class="cm">	 * simply return.</span>
<span class="cm">	 */</span>
<span class="nl">handle_fault:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock_ptr</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">fault_in_user_writeable</span><span class="p">(</span><span class="n">uaddr</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock_ptr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if someone else fixed it for us:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">oldowner</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="n">futex_wait_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">restart_block</span> <span class="o">*</span><span class="n">restart</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fixup_owner() - Post lock pi_state and corner case management</span>
<span class="cm"> * @uaddr:	user address of the futex</span>
<span class="cm"> * @q:		futex_q (contains pi_state and access to the rt_mutex)</span>
<span class="cm"> * @locked:	if the attempt to take the rt_mutex succeeded (1) or not (0)</span>
<span class="cm"> *</span>
<span class="cm"> * After attempting to lock an rt_mutex, this function is called to cleanup</span>
<span class="cm"> * the pi_state owner as well as handle race conditions that may allow us to</span>
<span class="cm"> * acquire the lock. Must be called with the hb lock held.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  1 - success, lock taken</span>
<span class="cm"> *  0 - success, lock not taken</span>
<span class="cm"> * &lt;0 - on error (-EFAULT)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fixup_owner</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">locked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">locked</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Got the lock. We might not be the anticipated owner if we</span>
<span class="cm">		 * did a lock-steal - fix up the PI-state in that case:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">fixup_pi_state_owner</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Catch the rare case, where the lock was released when we were on the</span>
<span class="cm">	 * way back before we locked the hash bucket.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Try to get the rt_mutex now. This might fail as some other</span>
<span class="cm">		 * task acquired the rt_mutex after we removed ourself from the</span>
<span class="cm">		 * rt_mutex waiters list.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt_mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * pi_state is incorrect, some other task did a lock steal and</span>
<span class="cm">		 * we returned due to timeout or signal without taking the</span>
<span class="cm">		 * rt_mutex. Too late.</span>
<span class="cm">		 */</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">.</span><span class="n">wait_lock</span><span class="p">);</span>
		<span class="n">owner</span> <span class="o">=</span> <span class="n">rt_mutex_owner</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">owner</span><span class="p">)</span>
			<span class="n">owner</span> <span class="o">=</span> <span class="n">rt_mutex_next_owner</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">);</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">.</span><span class="n">wait_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">fixup_pi_state_owner</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">owner</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Paranoia check. If we did not take the lock, then we should not be</span>
<span class="cm">	 * the owner of the rt_mutex.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt_mutex_owner</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">)</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;fixup_owner: ret = %d pi-mutex: %p &quot;</span>
				<span class="s">&quot;pi-state %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">.</span><span class="n">owner</span><span class="p">,</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">locked</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * futex_wait_queue_me() - queue_me() and wait for wakeup, timeout, or signal</span>
<span class="cm"> * @hb:		the futex hash bucket, must be locked by the caller</span>
<span class="cm"> * @q:		the futex_q to queue up on</span>
<span class="cm"> * @timeout:	the prepared hrtimer_sleeper, or null for no timeout</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">futex_wait_queue_me</span><span class="p">(</span><span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="o">*</span><span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The task state is guaranteed to be set before another task can</span>
<span class="cm">	 * wake it. set_current_state() is implemented using set_mb() and</span>
<span class="cm">	 * queue_me() calls spin_unlock() upon completion, both serializing</span>
<span class="cm">	 * access to the hash list and forcing another memory barrier.</span>
<span class="cm">	 */</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">queue_me</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">hb</span><span class="p">);</span>

	<span class="cm">/* Arm the timer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hrtimer_start_expires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timeout</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hrtimer_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timeout</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">))</span>
			<span class="n">timeout</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have been removed from the hash list, then another task</span>
<span class="cm">	 * has tried to wake us, and we can skip the call to schedule().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">plist_node_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the timer has already expired, current will already be</span>
<span class="cm">		 * flagged for rescheduling. Only call schedule if there</span>
<span class="cm">		 * is no timeout, or if it has yet to expire.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeout</span> <span class="o">||</span> <span class="n">timeout</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">)</span>
			<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * futex_wait_setup() - Prepare to wait on a futex</span>
<span class="cm"> * @uaddr:	the futex userspace address</span>
<span class="cm"> * @val:	the expected value</span>
<span class="cm"> * @flags:	futex flags (FLAGS_SHARED, etc.)</span>
<span class="cm"> * @q:		the associated futex_q</span>
<span class="cm"> * @hb:		storage for hash_bucket pointer to be returned to caller</span>
<span class="cm"> *</span>
<span class="cm"> * Setup the futex_q and locate the hash_bucket.  Get the futex value and</span>
<span class="cm"> * compare it with the expected value.  Handle atomic faults internally.</span>
<span class="cm"> * Return with the hb lock held and a q.key reference on success, and unlocked</span>
<span class="cm"> * with no q.key reference on failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  0 - uaddr contains val and hb has been locked</span>
<span class="cm"> * &lt;1 - -EFAULT or -EWOULDBLOCK (uaddr does not contain val) and hb is unlocked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">futex_wait_setup</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">**</span><span class="n">hb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">uval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Access the page AFTER the hash-bucket is locked.</span>
<span class="cm">	 * Order is important:</span>
<span class="cm">	 *</span>
<span class="cm">	 *   Userspace waiter: val = var; if (cond(val)) futex_wait(&amp;var, val);</span>
<span class="cm">	 *   Userspace waker:  if (cond(var)) { var = new; futex_wake(&amp;var); }</span>
<span class="cm">	 *</span>
<span class="cm">	 * The basic logical guarantee of a futex is that it blocks ONLY</span>
<span class="cm">	 * if cond(var) is known to be true at the time of blocking, for</span>
<span class="cm">	 * any cond.  If we locked the hash-bucket after testing *uaddr, that</span>
<span class="cm">	 * would open a race condition where we could block indefinitely with</span>
<span class="cm">	 * cond(var) false, which would violate the guarantee.</span>
<span class="cm">	 *</span>
<span class="cm">	 * On the other hand, we insert q and release the hash-bucket only</span>
<span class="cm">	 * after testing *uaddr.  This guarantees that futex_wait() will NOT</span>
<span class="cm">	 * absorb a wakeup if *uaddr does not match the desired values</span>
<span class="cm">	 * while the syscall executes.</span>
<span class="cm">	 */</span>
<span class="nl">retry:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_futex_key</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_SHARED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">VERIFY_READ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">retry_private:</span>
	<span class="o">*</span><span class="n">hb</span> <span class="o">=</span> <span class="n">queue_lock</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_futex_value_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uval</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue_unlock</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">hb</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">uval</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_SHARED</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">retry_private</span><span class="p">;</span>

		<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uval</span> <span class="o">!=</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue_unlock</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">hb</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">futex_wait</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">,</span>
		      <span class="n">ktime_t</span> <span class="o">*</span><span class="n">abs_time</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bitset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="n">timeout</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">restart_block</span> <span class="o">*</span><span class="n">restart</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_q</span> <span class="n">q</span> <span class="o">=</span> <span class="n">futex_q_init</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitset</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">q</span><span class="p">.</span><span class="n">bitset</span> <span class="o">=</span> <span class="n">bitset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">abs_time</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">;</span>

		<span class="n">hrtimer_init_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_CLOCKRT</span><span class="p">)</span> <span class="o">?</span>
				      <span class="n">CLOCK_REALTIME</span> <span class="o">:</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span>
				      <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
		<span class="n">hrtimer_init_sleeper</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="n">hrtimer_set_expires_range_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="o">*</span><span class="n">abs_time</span><span class="p">,</span>
					     <span class="n">current</span><span class="o">-&gt;</span><span class="n">timer_slack_ns</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">retry:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Prepare to wait on uaddr. On success, holds hb lock and increments</span>
<span class="cm">	 * q.key refs.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">futex_wait_setup</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* queue_me and wait for wakeup, timeout, or a signal. */</span>
	<span class="n">futex_wait_queue_me</span><span class="p">(</span><span class="n">hb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>

	<span class="cm">/* If we were woken (and unqueued), we succeeded, whatever. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* unqueue_me() drops q.key ref */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unqueue_me</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We expect signal_pending(current), but we might be the</span>
<span class="cm">	 * victim of a spurious wakeup as well.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">abs_time</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">restart</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">restart_block</span><span class="p">;</span>
	<span class="n">restart</span><span class="o">-&gt;</span><span class="n">fn</span> <span class="o">=</span> <span class="n">futex_wait_restart</span><span class="p">;</span>
	<span class="n">restart</span><span class="o">-&gt;</span><span class="n">futex</span><span class="p">.</span><span class="n">uaddr</span> <span class="o">=</span> <span class="n">uaddr</span><span class="p">;</span>
	<span class="n">restart</span><span class="o">-&gt;</span><span class="n">futex</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">restart</span><span class="o">-&gt;</span><span class="n">futex</span><span class="p">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">abs_time</span><span class="o">-&gt;</span><span class="n">tv64</span><span class="p">;</span>
	<span class="n">restart</span><span class="o">-&gt;</span><span class="n">futex</span><span class="p">.</span><span class="n">bitset</span> <span class="o">=</span> <span class="n">bitset</span><span class="p">;</span>
	<span class="n">restart</span><span class="o">-&gt;</span><span class="n">futex</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">FLAGS_HAS_TIMEOUT</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTART_RESTARTBLOCK</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">destroy_hrtimer_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">long</span> <span class="nf">futex_wait_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">restart_block</span> <span class="o">*</span><span class="n">restart</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span> <span class="o">=</span> <span class="n">restart</span><span class="o">-&gt;</span><span class="n">futex</span><span class="p">.</span><span class="n">uaddr</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">restart</span><span class="o">-&gt;</span><span class="n">futex</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_HAS_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">restart</span><span class="o">-&gt;</span><span class="n">futex</span><span class="p">.</span><span class="n">time</span><span class="p">;</span>
		<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">restart</span><span class="o">-&gt;</span><span class="n">fn</span> <span class="o">=</span> <span class="n">do_no_restart_syscall</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">futex_wait</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">restart</span><span class="o">-&gt;</span><span class="n">futex</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span>
				<span class="n">restart</span><span class="o">-&gt;</span><span class="n">futex</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">restart</span><span class="o">-&gt;</span><span class="n">futex</span><span class="p">.</span><span class="n">bitset</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Userspace tried a 0 -&gt; TID atomic transition of the futex value</span>
<span class="cm"> * and failed. The kernel side here does the whole locking operation:</span>
<span class="cm"> * if there are waiters then it will block, it does PI, etc. (Due to</span>
<span class="cm"> * races the kernel might see a 0 value of the futex too.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">futex_lock_pi</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">detect</span><span class="p">,</span>
			 <span class="n">ktime_t</span> <span class="o">*</span><span class="n">time</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trylock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="n">timeout</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_q</span> <span class="n">q</span> <span class="o">=</span> <span class="n">futex_q_init</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">refill_pi_state_cache</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">;</span>
		<span class="n">hrtimer_init_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">CLOCK_REALTIME</span><span class="p">,</span>
				      <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
		<span class="n">hrtimer_init_sleeper</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="n">hrtimer_set_expires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="o">*</span><span class="n">time</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">retry:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_futex_key</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_SHARED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">key</span><span class="p">,</span> <span class="n">VERIFY_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">retry_private:</span>
	<span class="n">hb</span> <span class="o">=</span> <span class="n">queue_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">futex_lock_pi_atomic</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">hb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">pi_state</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="cm">/* We got the lock. */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock_put_key</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EFAULT</span>:
			<span class="k">goto</span> <span class="n">uaddr_faulted</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EAGAIN</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Task is exiting and we just wait for the</span>
<span class="cm">			 * exit to complete.</span>
<span class="cm">			 */</span>
			<span class="n">queue_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">hb</span><span class="p">);</span>
			<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">key</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">out_unlock_put_key</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only actually queue now that the atomic ops are done:</span>
<span class="cm">	 */</span>
	<span class="n">queue_me</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">hb</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">pi_state</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Block on the PI mutex:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rt_mutex_timed_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rt_mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">);</span>
		<span class="cm">/* Fixup the trylock return value: */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">lock_ptr</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fixup the pi_state owner and possibly acquire the lock if we</span>
<span class="cm">	 * haven&#39;t already.</span>
<span class="cm">	 */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">fixup_owner</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="o">!</span><span class="n">ret</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If fixup_owner() returned an error, proprogate that.  If it acquired</span>
<span class="cm">	 * the lock, clear our -ETIMEDOUT or -EINTR.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">res</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If fixup_owner() faulted and was unable to handle the fault, unlock</span>
<span class="cm">	 * it and return the fault to userspace.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rt_mutex_owner</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">)</span> <span class="o">==</span> <span class="n">current</span><span class="p">))</span>
		<span class="n">rt_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">);</span>

	<span class="cm">/* Unqueue and drop the lock */</span>
	<span class="n">unqueue_me_pi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>

	<span class="k">goto</span> <span class="n">out_put_key</span><span class="p">;</span>

<span class="nl">out_unlock_put_key:</span>
	<span class="n">queue_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">hb</span><span class="p">);</span>

<span class="nl">out_put_key:</span>
	<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">key</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to</span><span class="p">)</span>
		<span class="n">destroy_hrtimer_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINTR</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="o">-</span><span class="n">ERESTARTNOINTR</span><span class="p">;</span>

<span class="nl">uaddr_faulted:</span>
	<span class="n">queue_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">hb</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">fault_in_user_writeable</span><span class="p">(</span><span class="n">uaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put_key</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_SHARED</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry_private</span><span class="p">;</span>

	<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">key</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Userspace attempted a TID -&gt; 0 atomic transition, and failed.</span>
<span class="cm"> * This is the in-kernel slowpath: we look up the PI state (if any),</span>
<span class="cm"> * and do the rt-mutex unlock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">futex_unlock_pi</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">plist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">futex_key</span> <span class="n">key</span> <span class="o">=</span> <span class="n">FUTEX_KEY_INIT</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">uval</span><span class="p">,</span> <span class="n">vpid</span> <span class="o">=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">uval</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We release only a lock we actually own:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">uval</span> <span class="o">&amp;</span> <span class="n">FUTEX_TID_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">vpid</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_futex_key</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_SHARED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">VERIFY_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">hb</span> <span class="o">=</span> <span class="n">hash_futex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * To avoid races, try to do the TID -&gt; 0 atomic transition</span>
<span class="cm">	 * again. If it succeeds then we can return without waking</span>
<span class="cm">	 * anyone else up:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">uval</span> <span class="o">&amp;</span> <span class="n">FUTEX_OWNER_DIED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cmpxchg_futex_value_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uval</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span> <span class="n">vpid</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">pi_faulted</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Rare case: we managed to release the lock atomically,</span>
<span class="cm">	 * no need to wake anyone else up:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">uval</span> <span class="o">==</span> <span class="n">vpid</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ok, other tasks may need to be woken up - check waiters</span>
<span class="cm">	 * and do the wakeup if necessary:</span>
<span class="cm">	 */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">;</span>

	<span class="n">plist_for_each_entry_safe</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match_futex</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wake_futex_pi</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">uval</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * The atomic access to the futex value</span>
<span class="cm">		 * generated a pagefault, so retry the</span>
<span class="cm">		 * user-access and the wakeup:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">pi_faulted</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * No waiters - kernel unlocks the futex:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">uval</span> <span class="o">&amp;</span> <span class="n">FUTEX_OWNER_DIED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">unlock_futex_pi</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">uval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">pi_faulted</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">pi_faulted:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">fault_in_user_writeable</span><span class="p">(</span><span class="n">uaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * handle_early_requeue_pi_wakeup() - Detect early wakeup on the initial futex</span>
<span class="cm"> * @hb:		the hash_bucket futex_q was original enqueued on</span>
<span class="cm"> * @q:		the futex_q woken while waiting to be requeued</span>
<span class="cm"> * @key2:	the futex_key of the requeue target futex</span>
<span class="cm"> * @timeout:	the timeout associated with the wait (NULL if none)</span>
<span class="cm"> *</span>
<span class="cm"> * Detect if the task was woken on the initial futex as opposed to the requeue</span>
<span class="cm"> * target futex.  If so, determine if it was a timeout or a signal that caused</span>
<span class="cm"> * the wakeup and return the appropriate error code to the caller.  Must be</span>
<span class="cm"> * called with the hb lock held.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns</span>
<span class="cm"> *  0 - no early wakeup detected</span>
<span class="cm"> * &lt;0 - -ETIMEDOUT or -ERESTARTNOINTR</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">handle_early_requeue_pi_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">futex_q</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">key2</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="o">*</span><span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * With the hb lock held, we avoid races while we process the wakeup.</span>
<span class="cm">	 * We only need to hold hb (and not hb2) to ensure atomicity as the</span>
<span class="cm">	 * wakeup code can&#39;t change q.key from uaddr to uaddr2 if we hold hb.</span>
<span class="cm">	 * It can&#39;t be requeued from uaddr2 to something else since we don&#39;t</span>
<span class="cm">	 * support a PI aware source futex for requeue.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match_futex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">key2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock_ptr</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">lock_ptr</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * We were woken prior to requeue by a timeout or a signal.</span>
<span class="cm">		 * Unqueue the futex_q and determine which it was.</span>
<span class="cm">		 */</span>
		<span class="n">plist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">chain</span><span class="p">);</span>

		<span class="cm">/* Handle spurious wakeups gracefully */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timeout</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTNOINTR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * futex_wait_requeue_pi() - Wait on uaddr and take uaddr2</span>
<span class="cm"> * @uaddr:	the futex we initially wait on (non-pi)</span>
<span class="cm"> * @flags:	futex flags (FLAGS_SHARED, FLAGS_CLOCKRT, etc.), they must be</span>
<span class="cm"> * 		the same type, no requeueing from private to shared, etc.</span>
<span class="cm"> * @val:	the expected value of uaddr</span>
<span class="cm"> * @abs_time:	absolute timeout</span>
<span class="cm"> * @bitset:	32 bit wakeup bitset set by userspace, defaults to all</span>
<span class="cm"> * @clockrt:	whether to use CLOCK_REALTIME (1) or CLOCK_MONOTONIC (0)</span>
<span class="cm"> * @uaddr2:	the pi futex we will take prior to returning to user-space</span>
<span class="cm"> *</span>
<span class="cm"> * The caller will wait on uaddr and will be requeued by futex_requeue() to</span>
<span class="cm"> * uaddr2 which must be PI aware.  Normal wakeup will wake on uaddr2 and</span>
<span class="cm"> * complete the acquisition of the rt_mutex prior to returning to userspace.</span>
<span class="cm"> * This ensures the rt_mutex maintains an owner when it has waiters; without</span>
<span class="cm"> * one, the pi logic wouldn&#39;t know which task to boost/deboost, if there was a</span>
<span class="cm"> * need to.</span>
<span class="cm"> *</span>
<span class="cm"> * We call schedule in futex_wait_queue_me() when we enqueue and return there</span>
<span class="cm"> * via the following:</span>
<span class="cm"> * 1) wakeup on uaddr2 after an atomic lock acquisition by futex_requeue()</span>
<span class="cm"> * 2) wakeup on uaddr2 after a requeue</span>
<span class="cm"> * 3) signal</span>
<span class="cm"> * 4) timeout</span>
<span class="cm"> *</span>
<span class="cm"> * If 3, cleanup and return -ERESTARTNOINTR.</span>
<span class="cm"> *</span>
<span class="cm"> * If 2, we may then block on trying to take the rt_mutex and return via:</span>
<span class="cm"> * 5) successful lock</span>
<span class="cm"> * 6) signal</span>
<span class="cm"> * 7) timeout</span>
<span class="cm"> * 8) other lock acquisition failure</span>
<span class="cm"> *</span>
<span class="cm"> * If 6, return -EWOULDBLOCK (restarting the syscall would do the same).</span>
<span class="cm"> *</span>
<span class="cm"> * If 4 or 7, we cleanup and return with -ETIMEDOUT.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  0 - On success</span>
<span class="cm"> * &lt;0 - On error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">futex_wait_requeue_pi</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="o">*</span><span class="n">abs_time</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bitset</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="n">timeout</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="n">rt_waiter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">pi_mutex</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_hash_bucket</span> <span class="o">*</span><span class="n">hb</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">futex_key</span> <span class="n">key2</span> <span class="o">=</span> <span class="n">FUTEX_KEY_INIT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_q</span> <span class="n">q</span> <span class="o">=</span> <span class="n">futex_q_init</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitset</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">abs_time</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">;</span>
		<span class="n">hrtimer_init_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_CLOCKRT</span><span class="p">)</span> <span class="o">?</span>
				      <span class="n">CLOCK_REALTIME</span> <span class="o">:</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span>
				      <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
		<span class="n">hrtimer_init_sleeper</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="n">hrtimer_set_expires_range_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="o">*</span><span class="n">abs_time</span><span class="p">,</span>
					     <span class="n">current</span><span class="o">-&gt;</span><span class="n">timer_slack_ns</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The waiter is allocated on our stack, manipulated by the requeue</span>
<span class="cm">	 * code while we sleep on uaddr.</span>
<span class="cm">	 */</span>
	<span class="n">debug_rt_mutex_init_waiter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_waiter</span><span class="p">);</span>
	<span class="n">rt_waiter</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_futex_key</span><span class="p">(</span><span class="n">uaddr2</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAGS_SHARED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">,</span> <span class="n">VERIFY_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">q</span><span class="p">.</span><span class="n">bitset</span> <span class="o">=</span> <span class="n">bitset</span><span class="p">;</span>
	<span class="n">q</span><span class="p">.</span><span class="n">rt_waiter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_waiter</span><span class="p">;</span>
	<span class="n">q</span><span class="p">.</span><span class="n">requeue_pi_key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prepare to wait on uaddr. On success, increments q.key (key1) ref</span>
<span class="cm">	 * count.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">futex_wait_setup</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_key2</span><span class="p">;</span>

	<span class="cm">/* Queue the futex_q, drop the hb lock, wait for wakeup. */</span>
	<span class="n">futex_wait_queue_me</span><span class="p">(</span><span class="n">hb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">handle_early_requeue_pi_wakeup</span><span class="p">(</span><span class="n">hb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put_keys</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In order for us to be here, we know our q.key == key2, and since</span>
<span class="cm">	 * we took the hb-&gt;lock above, we also know that futex_requeue() has</span>
<span class="cm">	 * completed and we no longer have to concern ourselves with a wakeup</span>
<span class="cm">	 * race with the atomic proxy lock acquisition by the requeue code. The</span>
<span class="cm">	 * futex_requeue dropped our key1 reference and incremented our key2</span>
<span class="cm">	 * reference count.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Check if the requeue code acquired the second futex for us. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">rt_waiter</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Got the lock. We might not be the anticipated owner if we</span>
<span class="cm">		 * did a lock-steal - fix up the PI-state in that case.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">pi_state</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">lock_ptr</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">fixup_pi_state_owner</span><span class="p">(</span><span class="n">uaddr2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">lock_ptr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We have been woken up by futex_unlock_pi(), a timeout, or a</span>
<span class="cm">		 * signal.  futex_unlock_pi() will not destroy the lock_ptr nor</span>
<span class="cm">		 * the pi_state.</span>
<span class="cm">		 */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">pi_state</span><span class="p">);</span>
		<span class="n">pi_mutex</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">pi_state</span><span class="o">-&gt;</span><span class="n">pi_mutex</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">rt_mutex_finish_proxy_lock</span><span class="p">(</span><span class="n">pi_mutex</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rt_waiter</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">debug_rt_mutex_free_waiter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_waiter</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">lock_ptr</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Fixup the pi_state owner and possibly acquire the lock if we</span>
<span class="cm">		 * haven&#39;t already.</span>
<span class="cm">		 */</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">fixup_owner</span><span class="p">(</span><span class="n">uaddr2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="o">!</span><span class="n">ret</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If fixup_owner() returned an error, proprogate that.  If it</span>
<span class="cm">		 * acquired the lock, clear -ETIMEDOUT or -EINTR.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">res</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Unqueue and drop the lock. */</span>
		<span class="n">unqueue_me_pi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If fixup_pi_state_owner() faulted and was unable to handle the</span>
<span class="cm">	 * fault, unlock the rt_mutex and return the fault to userspace.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt_mutex_owner</span><span class="p">(</span><span class="n">pi_mutex</span><span class="p">)</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span>
			<span class="n">rt_mutex_unlock</span><span class="p">(</span><span class="n">pi_mutex</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;ve already been requeued, but cannot restart by calling</span>
<span class="cm">		 * futex_lock_pi() directly. We could restart this syscall, but</span>
<span class="cm">		 * it would detect that the user space &quot;val&quot; changed and return</span>
<span class="cm">		 * -EWOULDBLOCK.  Save the overhead of the restart and return</span>
<span class="cm">		 * -EWOULDBLOCK directly.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_put_keys:</span>
	<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">.</span><span class="n">key</span><span class="p">);</span>
<span class="nl">out_key2:</span>
	<span class="n">put_futex_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key2</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">destroy_hrtimer_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Support for robust futexes: the kernel cleans up held futexes at</span>
<span class="cm"> * thread exit time.</span>
<span class="cm"> *</span>
<span class="cm"> * Implementation: user-space maintains a per-thread list of locks it</span>
<span class="cm"> * is holding. Upon do_exit(), the kernel carefully walks this list,</span>
<span class="cm"> * and marks all locks that are owned by this thread with the</span>
<span class="cm"> * FUTEX_OWNER_DIED bit, and wakes up a waiter (if any). The list is</span>
<span class="cm"> * always manipulated with the lock held, so the list is private and</span>
<span class="cm"> * per-thread. Userspace also maintains a per-thread &#39;list_op_pending&#39;</span>
<span class="cm"> * field, to allow the kernel to clean up if the thread dies after</span>
<span class="cm"> * acquiring the lock, but just before it could have added itself to</span>
<span class="cm"> * the list. There can only be one such pending lock.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * sys_set_robust_list() - Set the robust-futex list head of a task</span>
<span class="cm"> * @head:	pointer to the list-head</span>
<span class="cm"> * @len:	length of the list-head, as userspace expects</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">set_robust_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">robust_list_head</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span>
		<span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">futex_cmpxchg_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The kernel knows only one size for now:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">head</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">robust_list</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sys_get_robust_list() - Get the robust-futex list head of a task</span>
<span class="cm"> * @pid:	pid of the process [zero for current task]</span>
<span class="cm"> * @head_ptr:	pointer to a list-head pointer, the kernel fills it in</span>
<span class="cm"> * @len_ptr:	pointer to a length field, the kernel fills in the header size</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">get_robust_list</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">robust_list_head</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">head_ptr</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">len_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">robust_list_head</span> <span class="n">__user</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">futex_cmpxchg_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;deprecated: get_robust_list will be deleted in 2013.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pid</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptrace_may_access</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PTRACE_MODE_READ</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_unlock</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">robust_list</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">head</span><span class="p">),</span> <span class="n">len_ptr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">head_ptr</span><span class="p">);</span>

<span class="nl">err_unlock:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process a futex-list entry, check whether it&#39;s owned by the</span>
<span class="cm"> * dying task, and do notification if so:</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">handle_futex_death</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">uval</span><span class="p">,</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">nval</span><span class="p">),</span> <span class="n">mval</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">uval</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">uval</span> <span class="o">&amp;</span> <span class="n">FUTEX_TID_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">curr</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Ok, this dying thread is truly holding a futex</span>
<span class="cm">		 * of interest. Set the OWNER_DIED bit atomically</span>
<span class="cm">		 * via cmpxchg, and if the value had FUTEX_WAITERS</span>
<span class="cm">		 * set, wake up a waiter (if any). (We have to do a</span>
<span class="cm">		 * futex_wake() even if OWNER_DIED is already set -</span>
<span class="cm">		 * to handle the rare but possible case of recursive</span>
<span class="cm">		 * thread-death.) The rest of the cleanup is done in</span>
<span class="cm">		 * userspace.</span>
<span class="cm">		 */</span>
		<span class="n">mval</span> <span class="o">=</span> <span class="p">(</span><span class="n">uval</span> <span class="o">&amp;</span> <span class="n">FUTEX_WAITERS</span><span class="p">)</span> <span class="o">|</span> <span class="n">FUTEX_OWNER_DIED</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are not holding a lock here, but we want to have</span>
<span class="cm">		 * the pagefault_disable/enable() protection because</span>
<span class="cm">		 * we want to handle the fault gracefully. If the</span>
<span class="cm">		 * access fails we try to fault in the futex with R/W</span>
<span class="cm">		 * verification via get_user_pages. get_user() above</span>
<span class="cm">		 * does not guarantee R/W access. If that fails we</span>
<span class="cm">		 * give up and leave the futex locked.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg_futex_value_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nval</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span> <span class="n">uval</span><span class="p">,</span> <span class="n">mval</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fault_in_user_writeable</span><span class="p">(</span><span class="n">uaddr</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nval</span> <span class="o">!=</span> <span class="n">uval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Wake robust non-PI futexes here. The wakeup of</span>
<span class="cm">		 * PI futexes happens in exit_pi_state():</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pi</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uval</span> <span class="o">&amp;</span> <span class="n">FUTEX_WAITERS</span><span class="p">))</span>
			<span class="n">futex_wake</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">FUTEX_BITSET_MATCH_ANY</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fetch a robust-list pointer. Bit 0 signals PI futexes:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">fetch_robust_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">robust_list</span> <span class="n">__user</span> <span class="o">**</span><span class="n">entry</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">robust_list</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">__user</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uentry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">uentry</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">head</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="n">uentry</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1UL</span><span class="p">);</span>
	<span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">uentry</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Walk curr-&gt;robust_list (very carefully, it&#39;s a userspace list!)</span>
<span class="cm"> * and mark any locks found there dead, and notify any waiters.</span>
<span class="cm"> *</span>
<span class="cm"> * We silently return on any sign of list-walking problem.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">exit_robust_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">robust_list_head</span> <span class="n">__user</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">robust_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">robust_list</span> <span class="n">__user</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">next_entry</span><span class="p">,</span> <span class="o">*</span><span class="n">pending</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">ROBUST_LIST_LIMIT</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">pip</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">next_pi</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">futex_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">futex_cmpxchg_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fetch the list head (which was registered earlier, via</span>
<span class="cm">	 * sys_set_robust_list()):</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fetch_robust_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fetch the relative futex offset:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">futex_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">futex_offset</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fetch any possibly pending lock-add first, and handle it</span>
<span class="cm">	 * if it exists:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fetch_robust_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">list_op_pending</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pip</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">next_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* avoid warning with gcc */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Fetch the next entry in the list before calling</span>
<span class="cm">		 * handle_futex_death:</span>
<span class="cm">		 */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">fetch_robust_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next_pi</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * A pending lock might already be on the list, so</span>
<span class="cm">		 * don&#39;t process it twice:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="n">pending</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">handle_futex_death</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">entry</span> <span class="o">+</span> <span class="n">futex_offset</span><span class="p">,</span>
						<span class="n">curr</span><span class="p">,</span> <span class="n">pi</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">next_entry</span><span class="p">;</span>
		<span class="n">pi</span> <span class="o">=</span> <span class="n">next_pi</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Avoid excessively long or circular lists:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">limit</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pending</span><span class="p">)</span>
		<span class="n">handle_futex_death</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">pending</span> <span class="o">+</span> <span class="n">futex_offset</span><span class="p">,</span>
				   <span class="n">curr</span><span class="p">,</span> <span class="n">pip</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="n">do_futex</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="o">*</span><span class="n">timeout</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr2</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val2</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">op</span> <span class="o">&amp;</span> <span class="n">FUTEX_CMD_MASK</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">op</span> <span class="o">&amp;</span> <span class="n">FUTEX_PRIVATE_FLAG</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FLAGS_SHARED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">&amp;</span> <span class="n">FUTEX_CLOCK_REALTIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FLAGS_CLOCKRT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">FUTEX_WAIT_BITSET</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span> <span class="o">!=</span> <span class="n">FUTEX_WAIT_REQUEUE_PI</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FUTEX_LOCK_PI</span>:
	<span class="k">case</span> <span class="n">FUTEX_UNLOCK_PI</span>:
	<span class="k">case</span> <span class="n">FUTEX_TRYLOCK_PI</span>:
	<span class="k">case</span> <span class="n">FUTEX_WAIT_REQUEUE_PI</span>:
	<span class="k">case</span> <span class="n">FUTEX_CMP_REQUEUE_PI</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">futex_cmpxchg_enabled</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FUTEX_WAIT</span>:
		<span class="n">val3</span> <span class="o">=</span> <span class="n">FUTEX_BITSET_MATCH_ANY</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FUTEX_WAIT_BITSET</span>:
		<span class="k">return</span> <span class="n">futex_wait</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">val3</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FUTEX_WAKE</span>:
		<span class="n">val3</span> <span class="o">=</span> <span class="n">FUTEX_BITSET_MATCH_ANY</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FUTEX_WAKE_BITSET</span>:
		<span class="k">return</span> <span class="n">futex_wake</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">val3</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FUTEX_REQUEUE</span>:
		<span class="k">return</span> <span class="n">futex_requeue</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">uaddr2</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">val2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FUTEX_CMP_REQUEUE</span>:
		<span class="k">return</span> <span class="n">futex_requeue</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">uaddr2</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">val2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FUTEX_WAKE_OP</span>:
		<span class="k">return</span> <span class="n">futex_wake_op</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">uaddr2</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">val2</span><span class="p">,</span> <span class="n">val3</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FUTEX_LOCK_PI</span>:
		<span class="k">return</span> <span class="n">futex_lock_pi</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FUTEX_UNLOCK_PI</span>:
		<span class="k">return</span> <span class="n">futex_unlock_pi</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FUTEX_TRYLOCK_PI</span>:
		<span class="k">return</span> <span class="n">futex_lock_pi</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FUTEX_WAIT_REQUEUE_PI</span>:
		<span class="n">val3</span> <span class="o">=</span> <span class="n">FUTEX_BITSET_MATCH_ANY</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">futex_wait_requeue_pi</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">val3</span><span class="p">,</span>
					     <span class="n">uaddr2</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FUTEX_CMP_REQUEUE_PI</span>:
		<span class="k">return</span> <span class="n">futex_requeue</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">uaddr2</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">val2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">SYSCALL_DEFINE6</span><span class="p">(</span><span class="n">futex</span><span class="p">,</span> <span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">utime</span><span class="p">,</span> <span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">uaddr2</span><span class="p">,</span>
		<span class="n">u32</span><span class="p">,</span> <span class="n">val3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">op</span> <span class="o">&amp;</span> <span class="n">FUTEX_CMD_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">utime</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">FUTEX_WAIT</span> <span class="o">||</span> <span class="n">cmd</span> <span class="o">==</span> <span class="n">FUTEX_LOCK_PI</span> <span class="o">||</span>
		      <span class="n">cmd</span> <span class="o">==</span> <span class="n">FUTEX_WAIT_BITSET</span> <span class="o">||</span>
		      <span class="n">cmd</span> <span class="o">==</span> <span class="n">FUTEX_WAIT_REQUEUE_PI</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">,</span> <span class="n">utime</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timespec_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">t</span> <span class="o">=</span> <span class="n">timespec_to_ktime</span><span class="p">(</span><span class="n">ts</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">FUTEX_WAIT</span><span class="p">)</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">ktime_add_safe</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">(),</span> <span class="n">t</span><span class="p">);</span>
		<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * requeue parameter in &#39;utime&#39; if cmd == FUTEX_*_REQUEUE_*.</span>
<span class="cm">	 * number of waiters to wake in &#39;utime&#39; if cmd == FUTEX_WAKE_OP.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">FUTEX_REQUEUE</span> <span class="o">||</span> <span class="n">cmd</span> <span class="o">==</span> <span class="n">FUTEX_CMP_REQUEUE</span> <span class="o">||</span>
	    <span class="n">cmd</span> <span class="o">==</span> <span class="n">FUTEX_CMP_REQUEUE_PI</span> <span class="o">||</span> <span class="n">cmd</span> <span class="o">==</span> <span class="n">FUTEX_WAKE_OP</span><span class="p">)</span>
		<span class="n">val2</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">utime</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">do_futex</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">uaddr2</span><span class="p">,</span> <span class="n">val2</span><span class="p">,</span> <span class="n">val3</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">futex_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">curval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This will fail and we want it. Some arch implementations do</span>
<span class="cm">	 * runtime detection of the futex_atomic_cmpxchg_inatomic()</span>
<span class="cm">	 * functionality. We want to know that before we call in any</span>
<span class="cm">	 * of the complex code paths. Also we want to prevent</span>
<span class="cm">	 * registration of robust lists in that case. NULL is</span>
<span class="cm">	 * guaranteed to fault and we get -EFAULT on functional</span>
<span class="cm">	 * implementation, the non-functional ones will return</span>
<span class="cm">	 * -ENOSYS.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg_futex_value_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curval</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
		<span class="n">futex_cmpxchg_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">futex_queues</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">plist_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">futex_queues</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">chain</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">futex_queues</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__initcall</span><span class="p">(</span><span class="n">futex_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
