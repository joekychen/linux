<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › kprobes.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>kprobes.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Kernel Probes (KProbes)</span>
<span class="cm"> *  kernel/kprobes.c</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) IBM Corporation, 2002, 2004</span>
<span class="cm"> *</span>
<span class="cm"> * 2002-Oct	Created by Vamsi Krishna S &lt;vamsi_krishna@in.ibm.com&gt; Kernel</span>
<span class="cm"> *		Probes initial implementation (includes suggestions from</span>
<span class="cm"> *		Rusty Russell).</span>
<span class="cm"> * 2004-Aug	Updated by Prasanna S Panchamukhi &lt;prasanna@in.ibm.com&gt; with</span>
<span class="cm"> *		hlists and exceptions notifier as suggested by Andi Kleen.</span>
<span class="cm"> * 2004-July	Suparna Bhattacharya &lt;suparna@in.ibm.com&gt; added jumper probes</span>
<span class="cm"> *		interface to access function arguments.</span>
<span class="cm"> * 2004-Sep	Prasanna S Panchamukhi &lt;prasanna@in.ibm.com&gt; Changed Kprobes</span>
<span class="cm"> *		exceptions notifier to be first on the priority list.</span>
<span class="cm"> * 2005-May	Hien Nguyen &lt;hien@us.ibm.com&gt;, Jim Keniston</span>
<span class="cm"> *		&lt;jkenisto@us.ibm.com&gt; and Prasanna S Panchamukhi</span>
<span class="cm"> *		&lt;prasanna@in.ibm.com&gt; added function-return probes.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kprobes.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/moduleloader.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/kdebug.h&gt;</span>
<span class="cp">#include &lt;linux/memory.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/jump_label.h&gt;</span>

<span class="cp">#include &lt;asm-generic/sections.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/errno.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#define KPROBE_HASH_BITS 6</span>
<span class="cp">#define KPROBE_TABLE_SIZE (1 &lt;&lt; KPROBE_HASH_BITS)</span>


<span class="cm">/*</span>
<span class="cm"> * Some oddball architectures like 64bit powerpc have function descriptors</span>
<span class="cm"> * so this must be overridable.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef kprobe_lookup_name</span>
<span class="cp">#define kprobe_lookup_name(name, addr) \</span>
<span class="cp">	addr = ((kprobe_opcode_t *)(kallsyms_lookup_name(name)))</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">kprobes_initialized</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">kprobe_table</span><span class="p">[</span><span class="n">KPROBE_TABLE_SIZE</span><span class="p">];</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">kretprobe_inst_table</span><span class="p">[</span><span class="n">KPROBE_TABLE_SIZE</span><span class="p">];</span>

<span class="cm">/* NOTE: change this value only with kprobe_mutex held */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">kprobes_all_disarmed</span><span class="p">;</span>

<span class="cm">/* This protects kprobe_table and optimizing_list */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">kprobe_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="p">,</span> <span class="n">kprobe_instance</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">raw_spinlock_t</span> <span class="n">lock</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
<span class="p">}</span> <span class="n">kretprobe_table_locks</span><span class="p">[</span><span class="n">KPROBE_TABLE_SIZE</span><span class="p">];</span>

<span class="k">static</span> <span class="n">raw_spinlock_t</span> <span class="o">*</span><span class="nf">kretprobe_table_lock_ptr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">kretprobe_table_locks</span><span class="p">[</span><span class="n">hash</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Normally, functions that we&#39;d want to prohibit kprobes in, are marked</span>
<span class="cm"> * __kprobes. But, there are cases where such functions already belong to</span>
<span class="cm"> * a different section (__sched for preempt_schedule)</span>
<span class="cm"> *</span>
<span class="cm"> * For such cases, we now have a blacklist</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kprobe_blackpoint</span> <span class="n">kprobe_blacklist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="s">&quot;preempt_schedule&quot;</span><span class="p">,},</span>
	<span class="p">{</span><span class="s">&quot;native_get_debugreg&quot;</span><span class="p">,},</span>
	<span class="p">{</span><span class="s">&quot;irq_entries_start&quot;</span><span class="p">,},</span>
	<span class="p">{</span><span class="s">&quot;common_interrupt&quot;</span><span class="p">,},</span>
	<span class="p">{</span><span class="s">&quot;mcount&quot;</span><span class="p">,},</span>	<span class="cm">/* mcount can be called from everywhere */</span>
	<span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>    <span class="cm">/* Terminator */</span>
<span class="p">};</span>

<span class="cp">#ifdef __ARCH_WANT_KPROBES_INSN_SLOT</span>
<span class="cm">/*</span>
<span class="cm"> * kprobe-&gt;ainsn.insn points to the copy of the instruction to be</span>
<span class="cm"> * single-stepped. x86_64, POWER4 and above have no-exec support and</span>
<span class="cm"> * stepping on the instruction on a vmalloced/kmalloced/data page</span>
<span class="cm"> * is a recipe for disaster</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kprobe_insn_page</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="n">insns</span><span class="p">;</span>		<span class="cm">/* Page of instruction slots */</span>
	<span class="kt">int</span> <span class="n">nused</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ngarbage</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">slot_used</span><span class="p">[];</span>
<span class="p">};</span>

<span class="cp">#define KPROBE_INSN_PAGE_SIZE(slots)			\</span>
<span class="cp">	(offsetof(struct kprobe_insn_page, slot_used) +	\</span>
<span class="cp">	 (sizeof(char) * (slots)))</span>

<span class="k">struct</span> <span class="n">kprobe_insn_cache</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pages</span><span class="p">;</span>	<span class="cm">/* list of kprobe_insn_page */</span>
	<span class="kt">size_t</span> <span class="n">insn_size</span><span class="p">;</span>	<span class="cm">/* size of instruction slot */</span>
	<span class="kt">int</span> <span class="n">nr_garbage</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">slots_per_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe_insn_cache</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">PAGE_SIZE</span><span class="o">/</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">insn_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kprobe_opcode_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">kprobe_slot_state</span> <span class="p">{</span>
	<span class="n">SLOT_CLEAN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SLOT_DIRTY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">SLOT_USED</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">kprobe_insn_mutex</span><span class="p">);</span>	<span class="cm">/* Protects kprobe_insn_slots */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kprobe_insn_cache</span> <span class="n">kprobe_insn_slots</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">pages</span> <span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">kprobe_insn_slots</span><span class="p">.</span><span class="n">pages</span><span class="p">),</span>
	<span class="p">.</span><span class="n">insn_size</span> <span class="o">=</span> <span class="n">MAX_INSN_SIZE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nr_garbage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="n">collect_garbage_slots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe_insn_cache</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __get_insn_slot() - Find a slot on an executable page for an instruction.</span>
<span class="cm"> * We allocate an executable page if there&#39;s no room on existing ones.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">kprobe_opcode_t</span> <span class="n">__kprobes</span> <span class="o">*</span><span class="nf">__get_insn_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe_insn_cache</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe_insn_page</span> <span class="o">*</span><span class="n">kip</span><span class="p">;</span>

 <span class="nl">retry:</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">kip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kip</span><span class="o">-&gt;</span><span class="n">nused</span> <span class="o">&lt;</span> <span class="n">slots_per_page</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">slots_per_page</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">kip</span><span class="o">-&gt;</span><span class="n">slot_used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">SLOT_CLEAN</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">kip</span><span class="o">-&gt;</span><span class="n">slot_used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SLOT_USED</span><span class="p">;</span>
					<span class="n">kip</span><span class="o">-&gt;</span><span class="n">nused</span><span class="o">++</span><span class="p">;</span>
					<span class="k">return</span> <span class="n">kip</span><span class="o">-&gt;</span><span class="n">insns</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">insn_size</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/* kip-&gt;nused is broken. Fix it. */</span>
			<span class="n">kip</span><span class="o">-&gt;</span><span class="n">nused</span> <span class="o">=</span> <span class="n">slots_per_page</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If there are any garbage slots, collect it and try again. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nr_garbage</span> <span class="o">&amp;&amp;</span> <span class="n">collect_garbage_slots</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="cm">/* All out of space.  Need to allocate a new page. */</span>
	<span class="n">kip</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">KPROBE_INSN_PAGE_SIZE</span><span class="p">(</span><span class="n">slots_per_page</span><span class="p">(</span><span class="n">c</span><span class="p">)),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kip</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use module_alloc so this page is within +/- 2GB of where the</span>
<span class="cm">	 * kernel image and loaded module images reside. This is required</span>
<span class="cm">	 * so x86_64 can correctly handle the %rip-relative fixups.</span>
<span class="cm">	 */</span>
	<span class="n">kip</span><span class="o">-&gt;</span><span class="n">insns</span> <span class="o">=</span> <span class="n">module_alloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kip</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">kip</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kip</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">kip</span><span class="o">-&gt;</span><span class="n">slot_used</span><span class="p">,</span> <span class="n">SLOT_CLEAN</span><span class="p">,</span> <span class="n">slots_per_page</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
	<span class="n">kip</span><span class="o">-&gt;</span><span class="n">slot_used</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SLOT_USED</span><span class="p">;</span>
	<span class="n">kip</span><span class="o">-&gt;</span><span class="n">nused</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">kip</span><span class="o">-&gt;</span><span class="n">ngarbage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kip</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">kip</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">kprobe_opcode_t</span> <span class="n">__kprobes</span> <span class="o">*</span><span class="nf">get_insn_slot</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_insn_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__get_insn_slot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_insn_slots</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_insn_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return 1 if all garbages are collected, otherwise 0. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">collect_one_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe_insn_page</span> <span class="o">*</span><span class="n">kip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kip</span><span class="o">-&gt;</span><span class="n">slot_used</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">SLOT_CLEAN</span><span class="p">;</span>
	<span class="n">kip</span><span class="o">-&gt;</span><span class="n">nused</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kip</span><span class="o">-&gt;</span><span class="n">nused</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Page is no longer in use.  Free it unless</span>
<span class="cm">		 * it&#39;s the last one.  We keep the last one</span>
<span class="cm">		 * so as not to have to set it up again the</span>
<span class="cm">		 * next time somebody inserts a probe.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_is_singular</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kip</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kip</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">module_free</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">kip</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">kip</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">collect_garbage_slots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe_insn_cache</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe_insn_page</span> <span class="o">*</span><span class="n">kip</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/* Ensure no-one is interrupted on the garbages */</span>
	<span class="n">synchronize_sched</span><span class="p">();</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">kip</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kip</span><span class="o">-&gt;</span><span class="n">ngarbage</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">kip</span><span class="o">-&gt;</span><span class="n">ngarbage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* we will collect all garbages */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">slots_per_page</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kip</span><span class="o">-&gt;</span><span class="n">slot_used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">SLOT_DIRTY</span> <span class="o">&amp;&amp;</span>
			    <span class="n">collect_one_slot</span><span class="p">(</span><span class="n">kip</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">nr_garbage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">__free_insn_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe_insn_cache</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				       <span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="n">slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe_insn_page</span> <span class="o">*</span><span class="n">kip</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">kip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">idx</span> <span class="o">=</span> <span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">slot</span> <span class="o">-</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">kip</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">)</span> <span class="o">/</span>
				<span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">insn_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kprobe_opcode_t</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">slots_per_page</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">kip</span><span class="o">-&gt;</span><span class="n">slot_used</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">SLOT_USED</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kip</span><span class="o">-&gt;</span><span class="n">slot_used</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">SLOT_DIRTY</span><span class="p">;</span>
				<span class="n">kip</span><span class="o">-&gt;</span><span class="n">ngarbage</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nr_garbage</span> <span class="o">&gt;</span> <span class="n">slots_per_page</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
					<span class="n">collect_garbage_slots</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">collect_one_slot</span><span class="p">(</span><span class="n">kip</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Could not free this slot. */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">free_insn_slot</span><span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span> <span class="n">slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_insn_mutex</span><span class="p">);</span>
	<span class="n">__free_insn_slot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_insn_slots</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">dirty</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_insn_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#ifdef CONFIG_OPTPROBES</span>
<span class="cm">/* For optimized_kprobe buffer */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">kprobe_optinsn_mutex</span><span class="p">);</span> <span class="cm">/* Protects kprobe_optinsn_slots */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kprobe_insn_cache</span> <span class="n">kprobe_optinsn_slots</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">pages</span> <span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">kprobe_optinsn_slots</span><span class="p">.</span><span class="n">pages</span><span class="p">),</span>
	<span class="cm">/* .insn_size is initialized later */</span>
	<span class="p">.</span><span class="n">nr_garbage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>
<span class="cm">/* Get a slot for optimized_kprobe buffer */</span>
<span class="n">kprobe_opcode_t</span> <span class="n">__kprobes</span> <span class="o">*</span><span class="nf">get_optinsn_slot</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_optinsn_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__get_insn_slot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_optinsn_slots</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_optinsn_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">free_optinsn_slot</span><span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span> <span class="n">slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_optinsn_mutex</span><span class="p">);</span>
	<span class="n">__free_insn_slot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_optinsn_slots</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">dirty</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_optinsn_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cm">/* We have preemption disabled.. so it is safe to use __ versions */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_kprobe_instance</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">kprobe_instance</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reset_kprobe_instance</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">kprobe_instance</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine is called either:</span>
<span class="cm"> * 	- under the kprobe_mutex - during kprobe_[un]register()</span>
<span class="cm"> * 				OR</span>
<span class="cm"> * 	- with preemption disabled - from arch/xxx/kernel/kprobes.c</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kprobe</span> <span class="n">__kprobes</span> <span class="o">*</span><span class="nf">get_kprobe</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kprobe_table</span><span class="p">[</span><span class="n">hash_ptr</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">KPROBE_HASH_BITS</span><span class="p">)];</span>
	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="n">aggr_pre_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>

<span class="cm">/* Return true if the kprobe is an aggregator */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kprobe_aggrprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pre_handler</span> <span class="o">==</span> <span class="n">aggr_pre_handler</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return true(!0) if the kprobe is unused */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kprobe_unused</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kprobe_aggrprobe</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Keep all fields in the kprobe consistent</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">copy_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kprobe_opcode_t</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ainsn</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">arch_specific_insn</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_OPTPROBES</span>
<span class="cm">/* NOTE: change this value only with kprobe_mutex held */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">kprobes_allow_optimization</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Call all pre_handler on the list, but ignores its return value.</span>
<span class="cm"> * This must be called from arch-dep optimized caller.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">opt_pre_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">kp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">pre_handler</span> <span class="o">&amp;&amp;</span> <span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">kp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">set_kprobe_instance</span><span class="p">(</span><span class="n">kp</span><span class="p">);</span>
			<span class="n">kp</span><span class="o">-&gt;</span><span class="n">pre_handler</span><span class="p">(</span><span class="n">kp</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">reset_kprobe_instance</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Free optimized instructions and optimized_kprobe */</span>
<span class="k">static</span> <span class="n">__kprobes</span> <span class="kt">void</span> <span class="nf">free_aggr_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">optimized_kprobe</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="n">op</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">optimized_kprobe</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>
	<span class="n">arch_remove_optimized_kprobe</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
	<span class="n">arch_remove_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Return true(!0) if the kprobe is ready for optimization. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kprobe_optready</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">optimized_kprobe</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_aggrprobe</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">op</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">optimized_kprobe</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">arch_prepared_optinsn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">optinsn</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return true(!0) if the kprobe is disarmed. Note: p must be on hash list */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kprobe_disarmed</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">optimized_kprobe</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="cm">/* If kprobe is not aggr/opt probe, just return kprobe is disabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobe_aggrprobe</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">op</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">optimized_kprobe</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Return true(!0) if the probe is queued on (un)optimizing lists */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">kprobe_queued</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">optimized_kprobe</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_aggrprobe</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">op</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">optimized_kprobe</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return an optimized kprobe whose optimizing code replaces</span>
<span class="cm"> * instructions including addr (exclude breakpoint).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">__kprobes</span> <span class="nf">get_optimized_kprobe</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">optimized_kprobe</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t check i == 0, since that is a breakpoint case. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">!</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_OPTIMIZED_LENGTH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">get_kprobe</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">addr</span> <span class="o">-</span> <span class="n">i</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">kprobe_optready</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">op</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">optimized_kprobe</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arch_within_optimized_kprobe</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Optimization staging list, protected by kprobe_mutex */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">optimizing_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">unoptimizing_list</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">kprobe_optimizer</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_DELAYED_WORK</span><span class="p">(</span><span class="n">optimizing_work</span><span class="p">,</span> <span class="n">kprobe_optimizer</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_COMPLETION</span><span class="p">(</span><span class="n">optimizer_comp</span><span class="p">);</span>
<span class="cp">#define OPTIMIZE_DELAY 5</span>

<span class="cm">/*</span>
<span class="cm"> * Optimize (replace a breakpoint with a jump) kprobes listed on</span>
<span class="cm"> * optimizing_list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__kprobes</span> <span class="kt">void</span> <span class="nf">do_optimize_kprobes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Optimization never be done when disarmed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kprobes_all_disarmed</span> <span class="o">||</span> <span class="o">!</span><span class="n">kprobes_allow_optimization</span> <span class="o">||</span>
	    <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">optimizing_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The optimization/unoptimization refers online_cpus via</span>
<span class="cm">	 * stop_machine() and cpu-hotplug modifies online_cpus.</span>
<span class="cm">	 * And same time, text_mutex will be held in cpu-hotplug and here.</span>
<span class="cm">	 * This combination can cause a deadlock (cpu-hotplug try to lock</span>
<span class="cm">	 * text_mutex but stop_machine can not be done because online_cpus</span>
<span class="cm">	 * has been changed)</span>
<span class="cm">	 * To avoid this deadlock, we need to call get_online_cpus()</span>
<span class="cm">	 * for preventing cpu-hotplug outside of text_mutex locking.</span>
<span class="cm">	 */</span>
	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">text_mutex</span><span class="p">);</span>
	<span class="n">arch_optimize_kprobes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">optimizing_list</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">text_mutex</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unoptimize (replace a jump with a breakpoint and remove the breakpoint</span>
<span class="cm"> * if need) kprobes listed on unoptimizing_list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__kprobes</span> <span class="kt">void</span> <span class="nf">do_unoptimize_kprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">free_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">optimized_kprobe</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* Unoptimization must be done anytime */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unoptimizing_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Ditto to do_optimize_kprobes */</span>
	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">text_mutex</span><span class="p">);</span>
	<span class="n">arch_unoptimize_kprobes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unoptimizing_list</span><span class="p">,</span> <span class="n">free_list</span><span class="p">);</span>
	<span class="cm">/* Loop free_list for disarming */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">free_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Disarm probes if marked disabled */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">))</span>
			<span class="n">arch_disarm_kprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_unused</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Remove unused probes from hash list. After waiting</span>
<span class="cm">			 * for synchronization, these probes are reclaimed.</span>
<span class="cm">			 * (reclaiming is done by do_free_cleaned_kprobes.)</span>
<span class="cm">			 */</span>
			<span class="n">hlist_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">.</span><span class="n">hlist</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">text_mutex</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Reclaim all kprobes on the free_list */</span>
<span class="k">static</span> <span class="n">__kprobes</span> <span class="kt">void</span> <span class="nf">do_free_cleaned_kprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">free_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">optimized_kprobe</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">free_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">kprobe_unused</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">));</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">free_aggr_kprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Start optimizer after OPTIMIZE_DELAY passed */</span>
<span class="k">static</span> <span class="n">__kprobes</span> <span class="kt">void</span> <span class="nf">kick_kprobe_optimizer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">delayed_work_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">optimizing_work</span><span class="p">))</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">optimizing_work</span><span class="p">,</span> <span class="n">OPTIMIZE_DELAY</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Kprobe jump optimizer */</span>
<span class="k">static</span> <span class="n">__kprobes</span> <span class="kt">void</span> <span class="nf">kprobe_optimizer</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">free_list</span><span class="p">);</span>

	<span class="cm">/* Lock modules while optimizing kprobes */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Step 1: Unoptimize kprobes and collect cleaned (unused and disarmed)</span>
<span class="cm">	 * kprobes before waiting for quiesence period.</span>
<span class="cm">	 */</span>
	<span class="n">do_unoptimize_kprobes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Step 2: Wait for quiesence period to ensure all running interrupts</span>
<span class="cm">	 * are done. Because optprobe may modify multiple instructions</span>
<span class="cm">	 * there is a chance that Nth instruction is interrupted. In that</span>
<span class="cm">	 * case, running interrupt can return to 2nd-Nth byte of jump</span>
<span class="cm">	 * instruction. This wait is for avoiding it.</span>
<span class="cm">	 */</span>
	<span class="n">synchronize_sched</span><span class="p">();</span>

	<span class="cm">/* Step 3: Optimize kprobes after quiesence period */</span>
	<span class="n">do_optimize_kprobes</span><span class="p">();</span>

	<span class="cm">/* Step 4: Free cleaned kprobes after quiesence period */</span>
	<span class="n">do_free_cleaned_kprobes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_list</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_mutex</span><span class="p">);</span>

	<span class="cm">/* Step 5: Kick optimizer again if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">optimizing_list</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unoptimizing_list</span><span class="p">))</span>
		<span class="n">kick_kprobe_optimizer</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="cm">/* Wake up all waiters */</span>
		<span class="n">complete_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">optimizer_comp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Wait for completing optimization and unoptimization */</span>
<span class="k">static</span> <span class="n">__kprobes</span> <span class="kt">void</span> <span class="nf">wait_for_kprobe_optimizer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delayed_work_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">optimizing_work</span><span class="p">))</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">optimizer_comp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Optimize kprobe if p is ready to be optimized */</span>
<span class="k">static</span> <span class="n">__kprobes</span> <span class="kt">void</span> <span class="nf">optimize_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">optimized_kprobe</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="cm">/* Check if the kprobe is disabled or not ready for optimization. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobe_optready</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">kprobes_allow_optimization</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="n">kprobes_all_disarmed</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Both of break_handler and post_handler are not supported. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">break_handler</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">post_handler</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">op</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">optimized_kprobe</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>

	<span class="cm">/* Check there is no other kprobes at the optimized instructions */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arch_check_optimized_kprobe</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Check if it is already optimized. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KPROBE_FLAG_OPTIMIZED</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">KPROBE_FLAG_OPTIMIZED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
		<span class="cm">/* This is under unoptimizing. Just dequeue the probe */</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">optimizing_list</span><span class="p">);</span>
		<span class="n">kick_kprobe_optimizer</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Short cut to direct unoptimizing */</span>
<span class="k">static</span> <span class="n">__kprobes</span> <span class="kt">void</span> <span class="nf">force_unoptimize_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">optimized_kprobe</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">arch_unoptimize_kprobe</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">))</span>
		<span class="n">arch_disarm_kprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Unoptimize a kprobe if p is optimized */</span>
<span class="k">static</span> <span class="n">__kprobes</span> <span class="kt">void</span> <span class="nf">unoptimize_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">optimized_kprobe</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobe_aggrprobe</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="n">kprobe_disarmed</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* This is not an optprobe nor optimized */</span>

	<span class="n">op</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">optimized_kprobe</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobe_optimized</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Unoptimized or unoptimizing case */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">force</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Only if this is unoptimizing kprobe and forced,</span>
<span class="cm">			 * forcibly unoptimize it. (No need to unoptimize</span>
<span class="cm">			 * unoptimized kprobe again :)</span>
<span class="cm">			 */</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">force_unoptimize_kprobe</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">op</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">KPROBE_FLAG_OPTIMIZED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Dequeue from the optimization queue */</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Optimized kprobe case */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">force</span><span class="p">)</span>
		<span class="cm">/* Forcibly update the code: this is a special case */</span>
		<span class="n">force_unoptimize_kprobe</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unoptimizing_list</span><span class="p">);</span>
		<span class="n">kick_kprobe_optimizer</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Cancel unoptimizing for reusing */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reuse_unused_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">optimized_kprobe</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">kprobe_unused</span><span class="p">(</span><span class="n">ap</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Unused kprobe MUST be on the way of delayed unoptimizing (means</span>
<span class="cm">	 * there is still a relative jump) and disabled.</span>
<span class="cm">	 */</span>
	<span class="n">op</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">optimized_kprobe</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">)))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Warning: found a stray unused &quot;</span>
			<span class="s">&quot;aggrprobe@%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="cm">/* Enable the probe again */</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">KPROBE_FLAG_DISABLED</span><span class="p">;</span>
	<span class="cm">/* Optimize it again (remove from op-&gt;list) */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">kprobe_optready</span><span class="p">(</span><span class="n">ap</span><span class="p">));</span>
	<span class="n">optimize_kprobe</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Remove optimized instructions */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">kill_optimized_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">optimized_kprobe</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="n">op</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">optimized_kprobe</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
		<span class="cm">/* Dequeue from the (un)optimization queue */</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">op</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">KPROBE_FLAG_OPTIMIZED</span><span class="p">;</span>
	<span class="cm">/* Don&#39;t touch the code, because it is already freed. */</span>
	<span class="n">arch_remove_optimized_kprobe</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Try to prepare optimized instructions */</span>
<span class="k">static</span> <span class="n">__kprobes</span> <span class="kt">void</span> <span class="nf">prepare_optimized_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">optimized_kprobe</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="n">op</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">optimized_kprobe</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>
	<span class="n">arch_prepare_optimized_kprobe</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Allocate new optimized_kprobe and try to prepare optimized instructions */</span>
<span class="k">static</span> <span class="n">__kprobes</span> <span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="nf">alloc_aggr_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">optimized_kprobe</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="n">op</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">optimized_kprobe</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">arch_prepare_optimized_kprobe</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="n">init_aggr_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Prepare an optimized_kprobe and optimize it</span>
<span class="cm"> * NOTE: p must be a normal registered kprobe</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__kprobes</span> <span class="kt">void</span> <span class="nf">try_to_optimize_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">optimized_kprobe</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="n">ap</span> <span class="o">=</span> <span class="n">alloc_aggr_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">op</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">optimized_kprobe</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_prepared_optinsn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">optinsn</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* If failed to setup optimizing, fallback to kprobe */</span>
		<span class="n">arch_remove_optimized_kprobe</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">init_aggr_kprobe</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">optimize_kprobe</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SYSCTL</span>
<span class="cm">/* This should be called with kprobe_mutex locked */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">optimize_all_kprobes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* If optimization is already allowed, just return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kprobes_allow_optimization</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">kprobes_allow_optimization</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KPROBE_TABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kprobe_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
				<span class="n">optimize_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Kprobes globally optimized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This should be called with kprobe_mutex locked */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">unoptimize_all_kprobes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* If optimization is already prohibited, just return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobes_allow_optimization</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">kprobes_allow_optimization</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KPROBE_TABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kprobe_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
				<span class="n">unoptimize_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Wait for unoptimizing completion */</span>
	<span class="n">wait_for_kprobe_optimizer</span><span class="p">();</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Kprobes globally unoptimized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">sysctl_kprobes_optimization</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">proc_kprobes_optimization_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span>
				      <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>
	<span class="n">sysctl_kprobes_optimization</span> <span class="o">=</span> <span class="n">kprobes_allow_optimization</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_kprobes_optimization</span><span class="p">)</span>
		<span class="n">optimize_all_kprobes</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">unoptimize_all_kprobes</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SYSCTL */</span><span class="cp"></span>

<span class="cm">/* Put a breakpoint for a probe. Must be called with text_mutex locked */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">__arm_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">_p</span><span class="p">;</span>

	<span class="cm">/* Check collision with other optimized kprobes */</span>
	<span class="n">_p</span> <span class="o">=</span> <span class="n">get_optimized_kprobe</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">_p</span><span class="p">))</span>
		<span class="cm">/* Fallback to unoptimized kprobe */</span>
		<span class="n">unoptimize_kprobe</span><span class="p">(</span><span class="n">_p</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">arch_arm_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">optimize_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>	<span class="cm">/* Try to optimize (add kprobe to a list) */</span>
<span class="p">}</span>

<span class="cm">/* Remove the breakpoint of a probe. Must be called with text_mutex locked */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">__disarm_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">bool</span> <span class="n">reopt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">_p</span><span class="p">;</span>

	<span class="n">unoptimize_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>	<span class="cm">/* Try to unoptimize */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobe_queued</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">arch_disarm_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="cm">/* If another kprobe was blocked, optimize it. */</span>
		<span class="n">_p</span> <span class="o">=</span> <span class="n">get_optimized_kprobe</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">_p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">reopt</span><span class="p">)</span>
			<span class="n">optimize_kprobe</span><span class="p">(</span><span class="n">_p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* TODO: reoptimize others after unoptimized this probe */</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_OPTPROBES */</span><span class="cp"></span>

<span class="cp">#define optimize_kprobe(p)			do {} while (0)</span>
<span class="cp">#define unoptimize_kprobe(p, f)			do {} while (0)</span>
<span class="cp">#define kill_optimized_kprobe(p)		do {} while (0)</span>
<span class="cp">#define prepare_optimized_kprobe(p)		do {} while (0)</span>
<span class="cp">#define try_to_optimize_kprobe(p)		do {} while (0)</span>
<span class="cp">#define __arm_kprobe(p)				arch_arm_kprobe(p)</span>
<span class="cp">#define __disarm_kprobe(p, o)			arch_disarm_kprobe(p)</span>
<span class="cp">#define kprobe_disarmed(p)			kprobe_disabled(p)</span>
<span class="cp">#define wait_for_kprobe_optimizer()		do {} while (0)</span>

<span class="cm">/* There should be no unused kprobes can be reused without optimization */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reuse_unused_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Error: There should be no unused kprobe here.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">kprobe_unused</span><span class="p">(</span><span class="n">ap</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__kprobes</span> <span class="kt">void</span> <span class="nf">free_aggr_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">arch_remove_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__kprobes</span> <span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="nf">alloc_aggr_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_OPTPROBES */</span><span class="cp"></span>

<span class="cm">/* Arm a kprobe with text_mutex */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">arm_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Here, since __arm_kprobe() doesn&#39;t use stop_machine(),</span>
<span class="cm">	 * this doesn&#39;t cause deadlock on text_mutex. So, we don&#39;t</span>
<span class="cm">	 * need get_online_cpus().</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">text_mutex</span><span class="p">);</span>
	<span class="n">__arm_kprobe</span><span class="p">(</span><span class="n">kp</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">text_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Disarm a kprobe with text_mutex */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">disarm_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Ditto */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">text_mutex</span><span class="p">);</span>
	<span class="n">__disarm_kprobe</span><span class="p">(</span><span class="n">kp</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">text_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Aggregate handlers for multiple kprobes support - these handlers</span>
<span class="cm"> * take care of invoking the individual kprobe handlers on p-&gt;list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">aggr_pre_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">kp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">pre_handler</span> <span class="o">&amp;&amp;</span> <span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">kp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">set_kprobe_instance</span><span class="p">(</span><span class="n">kp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">pre_handler</span><span class="p">(</span><span class="n">kp</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">reset_kprobe_instance</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">aggr_post_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">kp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kp</span><span class="o">-&gt;</span><span class="n">post_handler</span> <span class="o">&amp;&amp;</span> <span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">kp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">set_kprobe_instance</span><span class="p">(</span><span class="n">kp</span><span class="p">);</span>
			<span class="n">kp</span><span class="o">-&gt;</span><span class="n">post_handler</span><span class="p">(</span><span class="n">kp</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">reset_kprobe_instance</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">aggr_fault_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">trapnr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">kprobe_instance</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if we faulted &quot;during&quot; the execution of a user specified</span>
<span class="cm">	 * probe handler, invoke just that probe&#39;s fault handler</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">fault_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">fault_handler</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">trapnr</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">aggr_break_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">kprobe_instance</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">break_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">break_handler</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">reset_kprobe_instance</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Walks the list and increments nmissed count for multiprobe case */</span>
<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">kprobes_inc_nmissed_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobe_aggrprobe</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">nmissed</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">kp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="n">kp</span><span class="o">-&gt;</span><span class="n">nmissed</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">recycle_rp_inst</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe_instance</span> <span class="o">*</span><span class="n">ri</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">ri</span><span class="o">-&gt;</span><span class="n">rp</span><span class="p">;</span>

	<span class="cm">/* remove rp inst off the rprobe_inst_table */</span>
	<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
	<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">free_instances</span><span class="p">);</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* Unregistering */</span>
		<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">kretprobe_hash_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">**</span><span class="n">head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="n">__acquires</span><span class="p">(</span><span class="n">hlist_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash_ptr</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">KPROBE_HASH_BITS</span><span class="p">);</span>
	<span class="n">raw_spinlock_t</span> <span class="o">*</span><span class="n">hlist_lock</span><span class="p">;</span>

	<span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kretprobe_inst_table</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span>
	<span class="n">hlist_lock</span> <span class="o">=</span> <span class="n">kretprobe_table_lock_ptr</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="n">hlist_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">kretprobe_table_lock</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="n">__acquires</span><span class="p">(</span><span class="n">hlist_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spinlock_t</span> <span class="o">*</span><span class="n">hlist_lock</span> <span class="o">=</span> <span class="n">kretprobe_table_lock_ptr</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="n">hlist_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">kretprobe_hash_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="n">__releases</span><span class="p">(</span><span class="n">hlist_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash_ptr</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">KPROBE_HASH_BITS</span><span class="p">);</span>
	<span class="n">raw_spinlock_t</span> <span class="o">*</span><span class="n">hlist_lock</span><span class="p">;</span>

	<span class="n">hlist_lock</span> <span class="o">=</span> <span class="n">kretprobe_table_lock_ptr</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="n">hlist_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">kretprobe_table_unlock</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">,</span>
       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="n">__releases</span><span class="p">(</span><span class="n">hlist_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spinlock_t</span> <span class="o">*</span><span class="n">hlist_lock</span> <span class="o">=</span> <span class="n">kretprobe_table_lock_ptr</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="n">hlist_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called from finish_task_switch when task tk becomes dead,</span>
<span class="cm"> * so that we can recycle any function-return probe instances associated</span>
<span class="cm"> * with this task. These left over instances represent probed functions</span>
<span class="cm"> * that have been called but will never return.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">kprobe_flush_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kretprobe_instance</span> <span class="o">*</span><span class="n">ri</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="n">empty_rp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">,</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">kprobes_initialized</span><span class="p">))</span>
		<span class="cm">/* Early boot.  kretprobe_table_locks not yet initialized. */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty_rp</span><span class="p">);</span>
	<span class="n">hash</span> <span class="o">=</span> <span class="n">hash_ptr</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="n">KPROBE_HASH_BITS</span><span class="p">);</span>
	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kretprobe_inst_table</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span>
	<span class="n">kretprobe_table_lock</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">==</span> <span class="n">tk</span><span class="p">)</span>
			<span class="n">recycle_rp_inst</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">empty_rp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kretprobe_table_unlock</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">empty_rp</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ri</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_rp_inst</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kretprobe_instance</span> <span class="o">*</span><span class="n">ri</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">free_instances</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ri</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">cleanup_rp_inst</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kretprobe_instance</span> <span class="o">*</span><span class="n">ri</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="cm">/* No race here */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">hash</span> <span class="o">&lt;</span> <span class="n">KPROBE_TABLE_SIZE</span><span class="p">;</span> <span class="n">hash</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kretprobe_table_lock</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kretprobe_inst_table</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span>
		<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">rp</span> <span class="o">==</span> <span class="n">rp</span><span class="p">)</span>
				<span class="n">ri</span><span class="o">-&gt;</span><span class="n">rp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kretprobe_table_unlock</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">free_rp_inst</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">* Add the new probe to ap-&gt;list. Fail if this is the</span>
<span class="cm">* second jprobe at the address - two jprobes can&#39;t coexist</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">add_new_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">kprobe_gone</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span> <span class="o">||</span> <span class="n">kprobe_gone</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">break_handler</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">post_handler</span><span class="p">)</span>
		<span class="n">unoptimize_kprobe</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>	<span class="cm">/* Fall back to normal kprobe */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">break_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">break_handler</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">break_handler</span> <span class="o">=</span> <span class="n">aggr_break_handler</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">post_handler</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">post_handler</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">post_handler</span> <span class="o">=</span> <span class="n">aggr_post_handler</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">KPROBE_FLAG_DISABLED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobes_all_disarmed</span><span class="p">)</span>
			<span class="cm">/* Arm the breakpoint again. */</span>
			<span class="n">__arm_kprobe</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fill in the required fields of the &quot;manager kprobe&quot;. Replace the</span>
<span class="cm"> * earlier kprobe in the hlist with the manager kprobe</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">init_aggr_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Copy p&#39;s insn slot to ap */</span>
	<span class="n">copy_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
	<span class="n">flush_insn_slot</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">KPROBE_FLAG_OPTIMIZED</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">pre_handler</span> <span class="o">=</span> <span class="n">aggr_pre_handler</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">fault_handler</span> <span class="o">=</span> <span class="n">aggr_fault_handler</span><span class="p">;</span>
	<span class="cm">/* We don&#39;t care the kprobe which has gone. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">post_handler</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kprobe_gone</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">post_handler</span> <span class="o">=</span> <span class="n">aggr_post_handler</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">break_handler</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kprobe_gone</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">break_handler</span> <span class="o">=</span> <span class="n">aggr_break_handler</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>

	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">hlist_replace_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is the second or subsequent kprobe at the address - handle</span>
<span class="cm"> * the intricacies</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">register_aggr_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">orig_p</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">orig_p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobe_aggrprobe</span><span class="p">(</span><span class="n">orig_p</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* If orig_p is not an aggr_kprobe, create new aggr_kprobe. */</span>
		<span class="n">ap</span> <span class="o">=</span> <span class="n">alloc_aggr_kprobe</span><span class="p">(</span><span class="n">orig_p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">init_aggr_kprobe</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">orig_p</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">kprobe_unused</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
		<span class="cm">/* This probe is going to die. Rescue it */</span>
		<span class="n">reuse_unused_kprobe</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_gone</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Attempting to insert new probe at the same location that</span>
<span class="cm">		 * had a probe in the module vaddr area which already</span>
<span class="cm">		 * freed. So, the instruction slot has already been</span>
<span class="cm">		 * released. We need a new slot for the new probe.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_prepare_kprobe</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * Even if fail to allocate new slot, don&#39;t need to</span>
<span class="cm">			 * free aggr_probe. It will be used next time, or</span>
<span class="cm">			 * freed by unregister_kprobe.</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/* Prepare optimized instructions if possible. */</span>
		<span class="n">prepare_optimized_kprobe</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Clear gone flag to prevent allocating new slot again, and</span>
<span class="cm">		 * set disabled flag because it is not armed yet.</span>
<span class="cm">		 */</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">KPROBE_FLAG_GONE</span><span class="p">)</span>
			    <span class="o">|</span> <span class="n">KPROBE_FLAG_DISABLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Copy ap&#39;s insn slot to p */</span>
	<span class="n">copy_kprobe</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">add_new_kprobe</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">in_kprobes_functions</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe_blackpoint</span> <span class="o">*</span><span class="n">kb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__kprobes_text_start</span> <span class="o">&amp;&amp;</span>
	    <span class="n">addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__kprobes_text_end</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If there exists a kprobe_blacklist, verify and</span>
<span class="cm">	 * fail any probe registration in the prohibited area</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">kb</span> <span class="o">=</span> <span class="n">kprobe_blacklist</span><span class="p">;</span> <span class="n">kb</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">kb</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kb</span><span class="o">-&gt;</span><span class="n">start_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">kb</span><span class="o">-&gt;</span><span class="n">start_addr</span> <span class="o">&amp;&amp;</span>
			    <span class="n">addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">kb</span><span class="o">-&gt;</span><span class="n">start_addr</span> <span class="o">+</span> <span class="n">kb</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If we have a symbol_name argument, look it up and add the offset field</span>
<span class="cm"> * to it. This way, we can specify a relative address to a symbol.</span>
<span class="cm"> * This returns encoded errors if it fails to look up symbol or invalid</span>
<span class="cm"> * combination of parameters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">kprobe_opcode_t</span> <span class="n">__kprobes</span> <span class="o">*</span><span class="nf">kprobe_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">symbol_name</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">symbol_name</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">symbol_name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kprobe_lookup_name</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">symbol_name</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>

<span class="nl">invalid:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check passed kprobe is valid and return kprobe in kprobe_table. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span> <span class="n">__kprobes</span> <span class="nf">__get_valid_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="o">*</span><span class="n">list_p</span><span class="p">;</span>

	<span class="n">ap</span> <span class="o">=</span> <span class="n">get_kprobe</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">ap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">list_p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_p</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>
			<span class="cm">/* kprobe p is a valid probe */</span>
				<span class="k">goto</span> <span class="n">valid</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">valid:</span>
	<span class="k">return</span> <span class="n">ap</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return error if the kprobe is being re-registered */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_kprobe_rereg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__get_valid_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">register_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">old_p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">probed_mod</span><span class="p">;</span>
	<span class="n">kprobe_opcode_t</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">kprobe_addr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">check_kprobe_rereg</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">jump_label_lock</span><span class="p">();</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kernel_text_address</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">in_kprobes_functions</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">ftrace_text_reserved</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">jump_label_text_reserved</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cannot_probe</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* User can pass only KPROBE_FLAG_DISABLED to register_kprobe */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">KPROBE_FLAG_DISABLED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if are we probing a module.</span>
<span class="cm">	 */</span>
	<span class="n">probed_mod</span> <span class="o">=</span> <span class="n">__module_text_address</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">probed_mod</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Return -ENOENT if fail. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We must hold a refcount of the probed module while updating</span>
<span class="cm">		 * its code to prohibit unexpected unloading.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">probed_mod</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">cannot_probe</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the module freed .init.text, we couldn&#39;t insert</span>
<span class="cm">		 * kprobes in there.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">within_module_init</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">probed_mod</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">probed_mod</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">MODULE_STATE_COMING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">module_put</span><span class="p">(</span><span class="n">probed_mod</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cannot_probe</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* ret will be updated by following code */</span>
	<span class="p">}</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="n">jump_label_unlock</span><span class="p">();</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">nmissed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>

	<span class="n">jump_label_lock</span><span class="p">();</span> <span class="cm">/* needed to call jump_label_text_reserved() */</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>	<span class="cm">/* For avoiding text_mutex deadlock. */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">text_mutex</span><span class="p">);</span>

	<span class="n">old_p</span> <span class="o">=</span> <span class="n">get_kprobe</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_p</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Since this may unoptimize old_p, locking text_mutex. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">register_aggr_kprobe</span><span class="p">(</span><span class="n">old_p</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">arch_prepare_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
	<span class="n">hlist_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">kprobe_table</span><span class="p">[</span><span class="n">hash_ptr</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">KPROBE_HASH_BITS</span><span class="p">)]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobes_all_disarmed</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="n">__arm_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/* Try to optimize kprobe */</span>
	<span class="n">try_to_optimize_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">text_mutex</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="n">jump_label_unlock</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">probed_mod</span><span class="p">)</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">probed_mod</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">cannot_probe:</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="n">jump_label_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">register_kprobe</span><span class="p">);</span>

<span class="cm">/* Check if all probes on the aggrprobe are disabled */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">aggr_kprobe_disabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">kp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">kp</span><span class="p">))</span>
			<span class="cm">/*</span>
<span class="cm">			 * There is an active probe on the list.</span>
<span class="cm">			 * We can&#39;t disable this ap.</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Disable one kprobe: Make sure called under kprobe_mutex is locked */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">__kprobes</span> <span class="nf">__disable_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">orig_p</span><span class="p">;</span>

	<span class="cm">/* Get an original kprobe for return */</span>
	<span class="n">orig_p</span> <span class="o">=</span> <span class="n">__get_valid_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">orig_p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Disable probe if it is a child probe */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">orig_p</span><span class="p">)</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">KPROBE_FLAG_DISABLED</span><span class="p">;</span>

		<span class="cm">/* Try to disarm and disable this/parent probe */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">orig_p</span> <span class="o">||</span> <span class="n">aggr_kprobe_disabled</span><span class="p">(</span><span class="n">orig_p</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">disarm_kprobe</span><span class="p">(</span><span class="n">orig_p</span><span class="p">);</span>
			<span class="n">orig_p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">KPROBE_FLAG_DISABLED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">orig_p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unregister a kprobe without a scheduler synchronization.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">__unregister_kprobe_top</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="o">*</span><span class="n">list_p</span><span class="p">;</span>

	<span class="cm">/* Disable kprobe. This will disarm it if needed. */</span>
	<span class="n">ap</span> <span class="o">=</span> <span class="n">__disable_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * This probe is an independent(and non-optimized) kprobe</span>
<span class="cm">		 * (not an aggrprobe). Remove from the hash list.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">disarmed</span><span class="p">;</span>

	<span class="cm">/* Following process expects this probe is an aggrprobe */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">kprobe_aggrprobe</span><span class="p">(</span><span class="n">ap</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_is_singular</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">kprobe_disarmed</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * !disarmed could be happen if the probe is under delayed</span>
<span class="cm">		 * unoptimizing.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">disarmed</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* If disabling probe has special handlers, update aggrprobe */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">break_handler</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kprobe_gone</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">break_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">post_handler</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kprobe_gone</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">list_p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">list_p</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">list_p</span><span class="o">-&gt;</span><span class="n">post_handler</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">noclean</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">post_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">noclean:</span>
		<span class="cm">/*</span>
<span class="cm">		 * Remove from the aggrprobe: this path will do nothing in</span>
<span class="cm">		 * __unregister_kprobe_bottom().</span>
<span class="cm">		 */</span>
		<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kprobes_all_disarmed</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * Try to optimize this probe again, because post</span>
<span class="cm">			 * handler may have been changed.</span>
<span class="cm">			 */</span>
			<span class="n">optimize_kprobe</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">disarmed:</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">kprobe_disarmed</span><span class="p">(</span><span class="n">ap</span><span class="p">));</span>
	<span class="n">hlist_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">__unregister_kprobe_bottom</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
		<span class="cm">/* This is an independent kprobe */</span>
		<span class="n">arch_remove_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">list_is_singular</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* This is the last child of an aggrprobe */</span>
		<span class="n">ap</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kprobe</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">free_aggr_kprobe</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Otherwise, do nothing. */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">register_kprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">**</span><span class="n">kps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">register_kprobe</span><span class="p">(</span><span class="n">kps</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">unregister_kprobes</span><span class="p">(</span><span class="n">kps</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">register_kprobes</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">unregister_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_kprobes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unregister_kprobe</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">unregister_kprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">**</span><span class="n">kps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__unregister_kprobe_top</span><span class="p">(</span><span class="n">kps</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">kps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>

	<span class="n">synchronize_sched</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
			<span class="n">__unregister_kprobe_bottom</span><span class="p">(</span><span class="n">kps</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unregister_kprobes</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">kprobe_exceptions_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">kprobe_exceptions_notify</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mh">0x7fffffff</span> <span class="cm">/* we need to be notified first */</span>
<span class="p">};</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__weak</span> <span class="nf">arch_deref_entry_point</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">register_jprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">jprobe</span> <span class="o">**</span><span class="n">jps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jprobe</span> <span class="o">*</span><span class="n">jp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">jp</span> <span class="o">=</span> <span class="n">jps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">arch_deref_entry_point</span><span class="p">(</span><span class="n">jp</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>

		<span class="cm">/* Verify probepoint is a function entry point */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kallsyms_lookup_size_offset</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jp</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">.</span><span class="n">pre_handler</span> <span class="o">=</span> <span class="n">setjmp_pre_handler</span><span class="p">;</span>
			<span class="n">jp</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">.</span><span class="n">break_handler</span> <span class="o">=</span> <span class="n">longjmp_break_handler</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">register_kprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jp</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">unregister_jprobes</span><span class="p">(</span><span class="n">jps</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">register_jprobes</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">register_jprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">jprobe</span> <span class="o">*</span><span class="n">jp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">register_jprobes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">register_jprobe</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">unregister_jprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">jprobe</span> <span class="o">*</span><span class="n">jp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_jprobes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unregister_jprobe</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">unregister_jprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">jprobe</span> <span class="o">**</span><span class="n">jps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__unregister_kprobe_top</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">jps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>

	<span class="n">synchronize_sched</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">.</span><span class="n">addr</span><span class="p">)</span>
			<span class="n">__unregister_kprobe_bottom</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unregister_jprobes</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_KRETPROBES</span>
<span class="cm">/*</span>
<span class="cm"> * This kprobe pre_handler is registered with every kretprobe. When probe</span>
<span class="cm"> * hits it will set up the return probe.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">pre_handler_kretprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kretprobe</span><span class="p">,</span> <span class="n">kp</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">,</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kretprobe_instance</span> <span class="o">*</span><span class="n">ri</span><span class="p">;</span>

	<span class="cm">/*TODO: consider to only swap the RA after the last pre_handler fired */</span>
	<span class="n">hash</span> <span class="o">=</span> <span class="n">hash_ptr</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">KPROBE_HASH_BITS</span><span class="p">);</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">free_instances</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ri</span> <span class="o">=</span> <span class="n">hlist_entry</span><span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">free_instances</span><span class="p">.</span><span class="n">first</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kretprobe_instance</span><span class="p">,</span> <span class="n">hlist</span><span class="p">);</span>
		<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">ri</span><span class="o">-&gt;</span><span class="n">rp</span> <span class="o">=</span> <span class="n">rp</span><span class="p">;</span>
		<span class="n">ri</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">entry_handler</span> <span class="o">&amp;&amp;</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">entry_handler</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">free_instances</span><span class="p">);</span>
			<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">arch_prepare_kretprobe</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

		<span class="cm">/* XXX(hch): why is there no hlist_move_head? */</span>
		<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
		<span class="n">kretprobe_table_lock</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ri</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kretprobe_inst_table</span><span class="p">[</span><span class="n">hash</span><span class="p">]);</span>
		<span class="n">kretprobe_table_unlock</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">nmissed</span><span class="o">++</span><span class="p">;</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">register_kretprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kretprobe_instance</span> <span class="o">*</span><span class="n">inst</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kretprobe_blacklist_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">kprobe_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">kretprobe_blacklist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kretprobe_blacklist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">.</span><span class="n">pre_handler</span> <span class="o">=</span> <span class="n">pre_handler_kretprobe</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">.</span><span class="n">post_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">.</span><span class="n">fault_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">.</span><span class="n">break_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Pre-allocate memory for max kretprobe instances */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">maxactive</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_PREEMPT</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">maxactive</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">num_possible_cpus</span><span class="p">());</span>
<span class="cp">#else</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">maxactive</span> <span class="o">=</span> <span class="n">num_possible_cpus</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">free_instances</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">maxactive</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inst</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe_instance</span><span class="p">)</span> <span class="o">+</span>
			       <span class="n">rp</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inst</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_rp_inst</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
		<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">free_instances</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rp</span><span class="o">-&gt;</span><span class="n">nmissed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Establish function entry probe point */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_kprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">free_rp_inst</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">register_kretprobe</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">register_kretprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">**</span><span class="n">rps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">register_kretprobe</span><span class="p">(</span><span class="n">rps</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">unregister_kretprobes</span><span class="p">(</span><span class="n">rps</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">register_kretprobes</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">unregister_kretprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_kretprobes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unregister_kretprobe</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">unregister_kretprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">**</span><span class="n">rps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__unregister_kprobe_top</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">rps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>

	<span class="n">synchronize_sched</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">.</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__unregister_kprobe_bottom</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">kp</span><span class="p">);</span>
			<span class="n">cleanup_rp_inst</span><span class="p">(</span><span class="n">rps</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unregister_kretprobes</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_KRETPROBES */</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">register_kretprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">register_kretprobe</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">register_kretprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">**</span><span class="n">rps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">register_kretprobes</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">unregister_kretprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unregister_kretprobe</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">unregister_kretprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">**</span><span class="n">rps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unregister_kretprobes</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">pre_handler_kretprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_KRETPROBES */</span><span class="cp"></span>

<span class="cm">/* Set the kprobe gone and remove its instruction buffer. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">kill_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">KPROBE_FLAG_GONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_aggrprobe</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this is an aggr_kprobe, we have to list all the</span>
<span class="cm">		 * chained probes and mark them GONE.</span>
<span class="cm">		 */</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">kp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="n">kp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">KPROBE_FLAG_GONE</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">post_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">break_handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kill_optimized_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Here, we can remove insn_slot safely, because no thread calls</span>
<span class="cm">	 * the original probed function (which will be freed soon) any more.</span>
<span class="cm">	 */</span>
	<span class="n">arch_remove_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Disable one kprobe */</span>
<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">disable_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>

	<span class="cm">/* Disable this kprobe */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__disable_kprobe</span><span class="p">(</span><span class="n">kp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">disable_kprobe</span><span class="p">);</span>

<span class="cm">/* Enable one kprobe */</span>
<span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">enable_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>

	<span class="cm">/* Check whether specified probe is valid. */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">__get_valid_kprobe</span><span class="p">(</span><span class="n">kp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_gone</span><span class="p">(</span><span class="n">kp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* This kprobe has gone, we couldn&#39;t enable it. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">kp</span><span class="p">)</span>
		<span class="n">kp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">KPROBE_FLAG_DISABLED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobes_all_disarmed</span> <span class="o">&amp;&amp;</span> <span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">KPROBE_FLAG_DISABLED</span><span class="p">;</span>
		<span class="n">arm_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">enable_kprobe</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">dump_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Dumping kprobe:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Name: %s</span><span class="se">\n</span><span class="s">Address: %p</span><span class="se">\n</span><span class="s">Offset: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">kp</span><span class="o">-&gt;</span><span class="n">symbol_name</span><span class="p">,</span> <span class="n">kp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">kp</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Module notifier call back, checking kprobes on the module */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">kprobes_module_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">checkcore</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">MODULE_STATE_GOING</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="n">MODULE_STATE_GOING</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">!=</span> <span class="n">MODULE_STATE_LIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When MODULE_STATE_GOING was notified, both of module .text and</span>
<span class="cm">	 * .init.text sections would be freed. When MODULE_STATE_LIVE was</span>
<span class="cm">	 * notified, only .init.text section would be freed. We need to</span>
<span class="cm">	 * disable kprobes which have been inserted in the sections.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KPROBE_TABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kprobe_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">within_module_init</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">checkcore</span> <span class="o">&amp;&amp;</span>
			     <span class="n">within_module_core</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">mod</span><span class="p">)))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * The vaddr this probe is installed will soon</span>
<span class="cm">				 * be vfreed buy not synced to disk. Hence,</span>
<span class="cm">				 * disarming the breakpoint isn&#39;t needed.</span>
<span class="cm">				 */</span>
				<span class="n">kill_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">kprobe_module_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">kprobes_module_callback</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_kprobes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">,</span> <span class="n">namebuf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symbol_name</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kprobe_blackpoint</span> <span class="o">*</span><span class="n">kb</span><span class="p">;</span>

	<span class="cm">/* FIXME allocate the probe table, currently defined statically */</span>
	<span class="cm">/* initialize all list heads */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KPROBE_TABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kretprobe_inst_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">kretprobe_table_locks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Lookup and populate the kprobe_blacklist.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Unlike the kretprobe blacklist, we&#39;ll need to determine</span>
<span class="cm">	 * the range of addresses that belong to the said functions,</span>
<span class="cm">	 * since a kprobe need not necessarily be at the beginning</span>
<span class="cm">	 * of a function.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">kb</span> <span class="o">=</span> <span class="n">kprobe_blacklist</span><span class="p">;</span> <span class="n">kb</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">kb</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kprobe_lookup_name</span><span class="p">(</span><span class="n">kb</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">kb</span><span class="o">-&gt;</span><span class="n">start_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
		<span class="n">symbol_name</span> <span class="o">=</span> <span class="n">kallsyms_lookup</span><span class="p">(</span><span class="n">kb</span><span class="o">-&gt;</span><span class="n">start_addr</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modname</span><span class="p">,</span> <span class="n">namebuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">symbol_name</span><span class="p">)</span>
			<span class="n">kb</span><span class="o">-&gt;</span><span class="n">range</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">kb</span><span class="o">-&gt;</span><span class="n">range</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kretprobe_blacklist_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* lookup the function address from its name */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">kretprobe_blacklist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kprobe_lookup_name</span><span class="p">(</span><span class="n">kretprobe_blacklist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span>
					   <span class="n">kretprobe_blacklist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kretprobe_blacklist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;kretprobe: lookup failed: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">kretprobe_blacklist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#if defined(CONFIG_OPTPROBES)</span>
<span class="cp">#if defined(__ARCH_WANT_KPROBES_INSN_SLOT)</span>
	<span class="cm">/* Init kprobe_optinsn_slots */</span>
	<span class="n">kprobe_optinsn_slots</span><span class="p">.</span><span class="n">insn_size</span> <span class="o">=</span> <span class="n">MAX_OPTINSN_SIZE</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* By default, kprobes can be optimized */</span>
	<span class="n">kprobes_allow_optimization</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* By default, kprobes are armed */</span>
	<span class="n">kprobes_all_disarmed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">arch_init_kprobes</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">register_die_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_exceptions_nb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">register_module_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_module_nb</span><span class="p">);</span>

	<span class="n">kprobes_initialized</span> <span class="o">=</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">init_test_probes</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">report_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sym</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">pp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kprobe_type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pre_handler</span> <span class="o">==</span> <span class="n">pre_handler_kretprobe</span><span class="p">)</span>
		<span class="n">kprobe_type</span> <span class="o">=</span> <span class="s">&quot;r&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pre_handler</span> <span class="o">==</span> <span class="n">setjmp_pre_handler</span><span class="p">)</span>
		<span class="n">kprobe_type</span> <span class="o">=</span> <span class="s">&quot;j&quot;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">kprobe_type</span> <span class="o">=</span> <span class="s">&quot;k&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sym</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="s">&quot;%p  %s  %s+0x%x  %s &quot;</span><span class="p">,</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">kprobe_type</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
			<span class="p">(</span><span class="n">modname</span> <span class="o">?</span> <span class="n">modname</span> <span class="o">:</span> <span class="s">&quot; &quot;</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="s">&quot;%p  %s  %p &quot;</span><span class="p">,</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">kprobe_type</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pp</span><span class="p">)</span>
		<span class="n">pp</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="s">&quot;%s%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">kprobe_gone</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;[GONE]&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
		<span class="p">((</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kprobe_gone</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">?</span>  <span class="s">&quot;[DISABLED]&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
		<span class="p">(</span><span class="n">kprobe_optimized</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;[OPTIMIZED]&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="o">*</span><span class="nf">kprobe_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">KPROBE_TABLE_SIZE</span><span class="p">)</span> <span class="o">?</span> <span class="n">pos</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="o">*</span><span class="nf">kprobe_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">KPROBE_TABLE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">kprobe_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Nothing to do */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">show_kprobe_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">kp</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sym</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">loff_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">,</span> <span class="n">namebuf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kprobe_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym</span> <span class="o">=</span> <span class="n">kallsyms_lookup</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modname</span><span class="p">,</span> <span class="n">namebuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_aggrprobe</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">kp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
				<span class="n">report_probe</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">kp</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">modname</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">report_probe</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">modname</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">kprobes_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">kprobe_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">kprobe_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">kprobe_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">show_kprobe_addr</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">kprobes_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kprobes_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">debugfs_kprobes_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">kprobes_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>           <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">arm_all_kprobes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>

	<span class="cm">/* If kprobes are armed, just return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobes_all_disarmed</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">already_enabled</span><span class="p">;</span>

	<span class="cm">/* Arming kprobes doesn&#39;t optimize kprobe itself */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">text_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KPROBE_TABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kprobe_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
				<span class="n">__arm_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">text_mutex</span><span class="p">);</span>

	<span class="n">kprobes_all_disarmed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Kprobes globally enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">already_enabled:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__kprobes</span> <span class="nf">disarm_all_kprobes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>

	<span class="cm">/* If kprobes are already disarmed, just return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kprobes_all_disarmed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kprobes_all_disarmed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Kprobes globally disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">text_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KPROBE_TABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kprobe_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_trampoline_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kprobe_disabled</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
				<span class="n">__disarm_kprobe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">text_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kprobe_mutex</span><span class="p">);</span>

	<span class="cm">/* Wait for disarming all kprobes by optimizer */</span>
	<span class="n">wait_for_kprobe_optimizer</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * XXX: The debugfs bool file interface doesn&#39;t allow for callbacks</span>
<span class="cm"> * when the bool state is switched. We can reuse that facility when</span>
<span class="cm"> * available</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">read_enabled_file_bool</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
	       <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kprobes_all_disarmed</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">user_buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">write_enabled_file_bool</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
	       <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">;</span>

	<span class="n">buf_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">user_buf</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;y&#39;</span>:
	<span class="k">case</span> <span class="sc">&#39;Y&#39;</span>:
	<span class="k">case</span> <span class="sc">&#39;1&#39;</span>:
		<span class="n">arm_all_kprobes</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="sc">&#39;n&#39;</span>:
	<span class="k">case</span> <span class="sc">&#39;N&#39;</span>:
	<span class="k">case</span> <span class="sc">&#39;0&#39;</span>:
		<span class="n">disarm_all_kprobes</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">fops_kp</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span>         <span class="n">read_enabled_file_bool</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span>        <span class="n">write_enabled_file_bool</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span>	<span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__kprobes</span> <span class="nf">debugfs_kprobe_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dir</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;kprobes&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;list&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">debugfs_kprobes_operations</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;enabled&quot;</span><span class="p">,</span> <span class="mo">0600</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fops_kp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">late_initcall</span><span class="p">(</span><span class="n">debugfs_kprobe_init</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_FS */</span><span class="cp"></span>

<span class="n">module_init</span><span class="p">(</span><span class="n">init_kprobes</span><span class="p">);</span>

<span class="cm">/* defined in arch/.../kernel/kprobes.c */</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">jprobe_return</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
