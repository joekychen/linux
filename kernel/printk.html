<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › printk.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>printk.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/kernel/printk.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> * Modified to make sys_syslog() more flexible: added commands to</span>
<span class="cm"> * return the last 4k of kernel messages, regardless of whether</span>
<span class="cm"> * they&#39;ve been read or not.  Added option to suppress kernel printk&#39;s</span>
<span class="cm"> * to the console.  Added hook for sending the console messages</span>
<span class="cm"> * elsewhere, in preparation for a serial line console (someday).</span>
<span class="cm"> * Ted Ts&#39;o, 2/11/93.</span>
<span class="cm"> * Modified for sysctl support, 1/8/97, Chris Horn.</span>
<span class="cm"> * Fixed SMP synchronization, 08/08/99, Manfred Spraul</span>
<span class="cm"> *     manfred@colorfullife.com</span>
<span class="cm"> * Rewrote bits to get rid of console_lock</span>
<span class="cm"> *	01Mar01 Andrew Morton</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/tty_driver.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/nmi.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;			</span><span class="cm">/* For in_interrupt() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/kexec.h&gt;</span>
<span class="cp">#include &lt;linux/kdb.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &lt;linux/kmsg_dump.h&gt;</span>
<span class="cp">#include &lt;linux/syslog.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/rculist.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/printk.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Architectures can override it:</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">asmlinkage</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">early_printk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/* printk&#39;s without a loglevel use this.. */</span>
<span class="cp">#define DEFAULT_MESSAGE_LOGLEVEL CONFIG_DEFAULT_MESSAGE_LOGLEVEL</span>

<span class="cm">/* We show everything that is MORE important than this.. */</span>
<span class="cp">#define MINIMUM_CONSOLE_LOGLEVEL 1 </span><span class="cm">/* Minimum loglevel we let people use */</span><span class="cp"></span>
<span class="cp">#define DEFAULT_CONSOLE_LOGLEVEL 7 </span><span class="cm">/* anything MORE serious than KERN_DEBUG */</span><span class="cp"></span>

<span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">log_wait</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">console_printk</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">DEFAULT_CONSOLE_LOGLEVEL</span><span class="p">,</span>	<span class="cm">/* console_loglevel */</span>
	<span class="n">DEFAULT_MESSAGE_LOGLEVEL</span><span class="p">,</span>	<span class="cm">/* default_message_loglevel */</span>
	<span class="n">MINIMUM_CONSOLE_LOGLEVEL</span><span class="p">,</span>	<span class="cm">/* minimum_console_loglevel */</span>
	<span class="n">DEFAULT_CONSOLE_LOGLEVEL</span><span class="p">,</span>	<span class="cm">/* default_console_loglevel */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Low level drivers may need that to know if they can schedule in</span>
<span class="cm"> * their unblank() callback or not. So let&#39;s export it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">oops_in_progress</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">oops_in_progress</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * console_sem protects the console_drivers list, and also</span>
<span class="cm"> * provides serialisation for access to the entire console</span>
<span class="cm"> * driver system.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_SEMAPHORE</span><span class="p">(</span><span class="n">console_sem</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">console_drivers</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">console_drivers</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This is used for debugging the mess that is the VT code by</span>
<span class="cm"> * keeping track if we have the console semaphore held. It&#39;s</span>
<span class="cm"> * definitely not the perfect debug tool (we don&#39;t know if _WE_</span>
<span class="cm"> * hold it are racing, but it helps tracking those weird code</span>
<span class="cm"> * path in the console code where we end up in places I want</span>
<span class="cm"> * locked without the console sempahore held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">console_locked</span><span class="p">,</span> <span class="n">console_suspended</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * If exclusive_console is non-NULL then only this console is to be printed to.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">exclusive_console</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *	Array of consoles built from command line options (console=)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">console_cmdline</span>
<span class="p">{</span>
	<span class="kt">char</span>	<span class="n">name</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>			<span class="cm">/* Name of the driver	    */</span>
	<span class="kt">int</span>	<span class="n">index</span><span class="p">;</span>				<span class="cm">/* Minor dev. to use	    */</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">options</span><span class="p">;</span>			<span class="cm">/* Options for the driver   */</span>
<span class="cp">#ifdef CONFIG_A11Y_BRAILLE_CONSOLE</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">brl_options</span><span class="p">;</span>			<span class="cm">/* Options for braille driver */</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#define MAX_CMDLINECONSOLES 8</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">console_cmdline</span> <span class="n">console_cmdline</span><span class="p">[</span><span class="n">MAX_CMDLINECONSOLES</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">selected_console</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">preferred_console</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">console_set_on_cmdline</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">console_set_on_cmdline</span><span class="p">);</span>

<span class="cm">/* Flag: console code may call schedule() */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">console_may_schedule</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The printk log buffer consists of a chain of concatenated variable</span>
<span class="cm"> * length records. Every record starts with a record header, containing</span>
<span class="cm"> * the overall length of the record.</span>
<span class="cm"> *</span>
<span class="cm"> * The heads to the first and last entry in the buffer, as well as the</span>
<span class="cm"> * sequence numbers of these both entries are maintained when messages</span>
<span class="cm"> * are stored..</span>
<span class="cm"> *</span>
<span class="cm"> * If the heads indicate available messages, the length in the header</span>
<span class="cm"> * tells the start next message. A length == 0 for the next message</span>
<span class="cm"> * indicates a wrap-around to the beginning of the buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Every record carries the monotonic timestamp in microseconds, as well as</span>
<span class="cm"> * the standard userspace syslog level and syslog facility. The usual</span>
<span class="cm"> * kernel messages use LOG_KERN; userspace-injected messages always carry</span>
<span class="cm"> * a matching syslog facility, by default LOG_USER. The origin of every</span>
<span class="cm"> * message can be reliably determined that way.</span>
<span class="cm"> *</span>
<span class="cm"> * The human readable log message directly follows the message header. The</span>
<span class="cm"> * length of the message text is stored in the header, the stored message</span>
<span class="cm"> * is not terminated.</span>
<span class="cm"> *</span>
<span class="cm"> * Optionally, a message can carry a dictionary of properties (key/value pairs),</span>
<span class="cm"> * to provide userspace with a machine-readable message context.</span>
<span class="cm"> *</span>
<span class="cm"> * Examples for well-defined, commonly used property names are:</span>
<span class="cm"> *   DEVICE=b12:8               device identifier</span>
<span class="cm"> *                                b12:8         block dev_t</span>
<span class="cm"> *                                c127:3        char dev_t</span>
<span class="cm"> *                                n8            netdev ifindex</span>
<span class="cm"> *                                +sound:card0  subsystem:devname</span>
<span class="cm"> *   SUBSYSTEM=pci              driver-core subsystem name</span>
<span class="cm"> *</span>
<span class="cm"> * Valid characters in property names are [a-zA-Z0-9.-_]. The plain text value</span>
<span class="cm"> * follows directly after a &#39;=&#39; character. Every property is terminated by</span>
<span class="cm"> * a &#39;\0&#39; character. The last property is not terminated.</span>
<span class="cm"> *</span>
<span class="cm"> * Example of a message structure:</span>
<span class="cm"> *   0000  ff 8f 00 00 00 00 00 00      monotonic time in nsec</span>
<span class="cm"> *   0008  34 00                        record is 52 bytes long</span>
<span class="cm"> *   000a        0b 00                  text is 11 bytes long</span>
<span class="cm"> *   000c              1f 00            dictionary is 23 bytes long</span>
<span class="cm"> *   000e                    03 00      LOG_KERN (facility) LOG_ERR (level)</span>
<span class="cm"> *   0010  69 74 27 73 20 61 20 6c      &quot;it&#39;s a l&quot;</span>
<span class="cm"> *         69 6e 65                     &quot;ine&quot;</span>
<span class="cm"> *   001b           44 45 56 49 43      &quot;DEVIC&quot;</span>
<span class="cm"> *         45 3d 62 38 3a 32 00 44      &quot;E=b8:2\0D&quot;</span>
<span class="cm"> *         52 49 56 45 52 3d 62 75      &quot;RIVER=bu&quot;</span>
<span class="cm"> *         67                           &quot;g&quot;</span>
<span class="cm"> *   0032     00 00 00                  padding to next message header</span>
<span class="cm"> *</span>
<span class="cm"> * The &#39;struct log&#39; buffer header must never be directly exported to</span>
<span class="cm"> * userspace, it is a kernel-private implementation detail that might</span>
<span class="cm"> * need to be changed in the future, when the requirements change.</span>
<span class="cm"> *</span>
<span class="cm"> * /dev/kmsg exports the structured data in the following line format:</span>
<span class="cm"> *   &quot;level,sequnum,timestamp;&lt;message text&gt;\n&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * The optional key/value pairs are attached as continuation lines starting</span>
<span class="cm"> * with a space character and terminated by a newline. All possible</span>
<span class="cm"> * non-prinatable characters are escaped in the &quot;\xff&quot; notation.</span>
<span class="cm"> *</span>
<span class="cm"> * Users of the export format should ignore possible additional values</span>
<span class="cm"> * separated by &#39;,&#39;, and find the message after the &#39;;&#39; character.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">log_flags</span> <span class="p">{</span>
	<span class="n">LOG_DEFAULT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">LOG_NOCONS</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>		<span class="cm">/* already flushed, do not print to console */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">log</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ts_nsec</span><span class="p">;</span>		<span class="cm">/* timestamp in nanoseconds */</span>
	<span class="n">u16</span> <span class="n">len</span><span class="p">;</span>		<span class="cm">/* length of entire record */</span>
	<span class="n">u16</span> <span class="n">text_len</span><span class="p">;</span>		<span class="cm">/* length of text buffer */</span>
	<span class="n">u16</span> <span class="n">dict_len</span><span class="p">;</span>		<span class="cm">/* length of dictionary buffer */</span>
	<span class="n">u8</span> <span class="n">facility</span><span class="p">;</span>		<span class="cm">/* syslog facility */</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>		<span class="cm">/* internal record flags */</span>
	<span class="n">u8</span> <span class="n">level</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>		<span class="cm">/* syslog level */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The logbuf_lock protects kmsg buffer, indices, counters. It is also</span>
<span class="cm"> * used in interesting ways to provide interlocking in console_unlock();</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_RAW_SPINLOCK</span><span class="p">(</span><span class="n">logbuf_lock</span><span class="p">);</span>

<span class="cm">/* the next printk record to read by syslog(READ) or /proc/kmsg */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">syslog_seq</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">syslog_idx</span><span class="p">;</span>

<span class="cm">/* index and sequence number of the first record stored in the buffer */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">log_first_seq</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">log_first_idx</span><span class="p">;</span>

<span class="cm">/* index and sequence number of the next record to store in the buffer */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">log_next_seq</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PRINTK</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">log_next_idx</span><span class="p">;</span>

<span class="cm">/* the next printk record to read after the last &#39;clear&#39; command */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">clear_seq</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">clear_idx</span><span class="p">;</span>

<span class="cp">#define LOG_LINE_MAX 1024</span>

<span class="cm">/* record buffer */</span>
<span class="cp">#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)</span>
<span class="cp">#define LOG_ALIGN 4</span>
<span class="cp">#else</span>
<span class="cp">#define LOG_ALIGN __alignof__(struct log)</span>
<span class="cp">#endif</span>
<span class="cp">#define __LOG_BUF_LEN (1 &lt;&lt; CONFIG_LOG_BUF_SHIFT)</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">__log_buf</span><span class="p">[</span><span class="n">__LOG_BUF_LEN</span><span class="p">]</span> <span class="n">__aligned</span><span class="p">(</span><span class="n">LOG_ALIGN</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">log_buf</span> <span class="o">=</span> <span class="n">__log_buf</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">log_buf_len</span> <span class="o">=</span> <span class="n">__LOG_BUF_LEN</span><span class="p">;</span>

<span class="cm">/* cpu currently holding logbuf_lock */</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">logbuf_cpu</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>

<span class="cm">/* human readable text of the record */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">log_text</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">log</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* optional key/value pair dictionary attached to the record */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">log_dict</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">log</span><span class="p">)</span> <span class="o">+</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">text_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* get record by index; idx must point to valid msg */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="nf">log_from_idx</span><span class="p">(</span><span class="n">u32</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="p">)(</span><span class="n">log_buf</span> <span class="o">+</span> <span class="n">idx</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * A length == 0 record is the end of buffer marker. Wrap around and</span>
<span class="cm">	 * read the message at the start of the buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="p">)</span><span class="n">log_buf</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">msg</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* get next record; idx must point to valid msg */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">log_next</span><span class="p">(</span><span class="n">u32</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="p">)(</span><span class="n">log_buf</span> <span class="o">+</span> <span class="n">idx</span><span class="p">);</span>

	<span class="cm">/* length == 0 indicates the end of the buffer; wrap */</span>
	<span class="cm">/*</span>
<span class="cm">	 * A length == 0 record is the end of buffer marker. Wrap around and</span>
<span class="cm">	 * read the message at the start of the buffer as *this* one, and</span>
<span class="cm">	 * return the one after that.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="p">)</span><span class="n">log_buf</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* insert record into the buffer, discard old ones, update heads */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">log_store</span><span class="p">(</span><span class="kt">int</span> <span class="n">facility</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
		      <span class="k">enum</span> <span class="n">log_flags</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ts_nsec</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dict</span><span class="p">,</span> <span class="n">u16</span> <span class="n">dict_len</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="n">u16</span> <span class="n">text_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">,</span> <span class="n">pad_len</span><span class="p">;</span>

	<span class="cm">/* number of &#39;\0&#39; padding bytes to next message */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">log</span><span class="p">)</span> <span class="o">+</span> <span class="n">text_len</span> <span class="o">+</span> <span class="n">dict_len</span><span class="p">;</span>
	<span class="n">pad_len</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">LOG_ALIGN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">pad_len</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">log_first_seq</span> <span class="o">&lt;</span> <span class="n">log_next_seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">free</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">log_next_idx</span> <span class="o">&gt;</span> <span class="n">log_first_idx</span><span class="p">)</span>
			<span class="n">free</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">log_buf_len</span> <span class="o">-</span> <span class="n">log_next_idx</span><span class="p">,</span> <span class="n">log_first_idx</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">free</span> <span class="o">=</span> <span class="n">log_first_idx</span> <span class="o">-</span> <span class="n">log_next_idx</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&gt;</span> <span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">log</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* drop old messages until we have enough contiuous space */</span>
		<span class="n">log_first_idx</span> <span class="o">=</span> <span class="n">log_next</span><span class="p">(</span><span class="n">log_first_idx</span><span class="p">);</span>
		<span class="n">log_first_seq</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">log_next_idx</span> <span class="o">+</span> <span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">log</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">log_buf_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This message + an additional empty header does not fit</span>
<span class="cm">		 * at the end of the buffer. Add an empty header with len == 0</span>
<span class="cm">		 * to signify a wrap around.</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">log_buf</span> <span class="o">+</span> <span class="n">log_next_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">log</span><span class="p">));</span>
		<span class="n">log_next_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* fill message */</span>
	<span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="p">)(</span><span class="n">log_buf</span> <span class="o">+</span> <span class="n">log_next_idx</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">log_text</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span> <span class="n">text</span><span class="p">,</span> <span class="n">text_len</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">text_len</span> <span class="o">=</span> <span class="n">text_len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">log_dict</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span> <span class="n">dict</span><span class="p">,</span> <span class="n">dict_len</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">dict_len</span> <span class="o">=</span> <span class="n">dict_len</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">facility</span> <span class="o">=</span> <span class="n">facility</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ts_nsec</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">ts_nsec</span> <span class="o">=</span> <span class="n">ts_nsec</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">ts_nsec</span> <span class="o">=</span> <span class="n">local_clock</span><span class="p">();</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">log_dict</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">+</span> <span class="n">dict_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pad_len</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">log</span><span class="p">)</span> <span class="o">+</span> <span class="n">text_len</span> <span class="o">+</span> <span class="n">dict_len</span> <span class="o">+</span> <span class="n">pad_len</span><span class="p">;</span>

	<span class="cm">/* insert message */</span>
	<span class="n">log_next_idx</span> <span class="o">+=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">log_next_seq</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* /dev/kmsg - userspace message inject/listen interface */</span>
<span class="k">struct</span> <span class="n">devkmsg_user</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8192</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">devkmsg_writev</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">line</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">default_message_loglevel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">facility</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* LOG_USER */</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">LOG_LINE_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">line</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">iv</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_base</span><span class="p">,</span> <span class="n">iv</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">line</span> <span class="o">+=</span> <span class="n">iv</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Extract and skip the syslog prefix &lt;[0-9]*&gt;. Coming from userspace</span>
<span class="cm">	 * the decimal value represents 32bit, the lower 3 bit are the log</span>
<span class="cm">	 * level, the rest are the log facility.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If no prefix or no userspace facility is specified, we</span>
<span class="cm">	 * enforce LOG_USER, to be able to reliably distinguish</span>
<span class="cm">	 * kernel-generated messages from userspace-injected ones.</span>
<span class="cm">	 */</span>
	<span class="n">line</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;&lt;&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">i</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">line</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">endp</span> <span class="o">&amp;&amp;</span> <span class="n">endp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;&gt;&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">level</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span>
				<span class="n">facility</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">endp</span><span class="o">++</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">endp</span> <span class="o">-</span> <span class="n">line</span><span class="p">;</span>
			<span class="n">line</span> <span class="o">=</span> <span class="n">endp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">line</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">printk_emit</span><span class="p">(</span><span class="n">facility</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">devkmsg_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devkmsg_user</span> <span class="o">*</span><span class="n">user</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ts_usec</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">==</span> <span class="n">log_next_seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">log_wait</span><span class="p">,</span>
					       <span class="n">user</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">!=</span> <span class="n">log_next_seq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">&lt;</span> <span class="n">log_first_seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* our last seen message is gone, return error and reset */</span>
		<span class="n">user</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">log_first_idx</span><span class="p">;</span>
		<span class="n">user</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">log_first_seq</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">log_from_idx</span><span class="p">(</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>
	<span class="n">ts_usec</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">ts_nsec</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">ts_usec</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u,%llu,%llu;&quot;</span><span class="p">,</span>
		      <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">facility</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="n">user</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">ts_usec</span><span class="p">);</span>

	<span class="cm">/* escape non-printable characters */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">text_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">log_text</span><span class="p">(</span><span class="n">msg</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">x%02x&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">user</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">user</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">dict_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">line</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">dict_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">log_dict</span><span class="p">(</span><span class="n">msg</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">user</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
				<span class="n">line</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">user</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
				<span class="n">line</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">x%02x&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">user</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">user</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">user</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">log_next</span><span class="p">(</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>
	<span class="n">user</span><span class="o">-&gt;</span><span class="n">seq</span><span class="o">++</span><span class="p">;</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">user</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">loff_t</span> <span class="nf">devkmsg_llseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devkmsg_user</span> <span class="o">*</span><span class="n">user</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESPIPE</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">whence</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SEEK_SET</span>:
		<span class="cm">/* the first record */</span>
		<span class="n">user</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">log_first_idx</span><span class="p">;</span>
		<span class="n">user</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">log_first_seq</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEEK_DATA</span>:
		<span class="cm">/*</span>
<span class="cm">		 * The first record after the last SYSLOG_ACTION_CLEAR,</span>
<span class="cm">		 * like issued by &#39;dmesg -c&#39;. Reading /dev/kmsg itself</span>
<span class="cm">		 * changes no global state, and does not clear anything.</span>
<span class="cm">		 */</span>
		<span class="n">user</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">clear_idx</span><span class="p">;</span>
		<span class="n">user</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">clear_seq</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEEK_END</span>:
		<span class="cm">/* after the last record */</span>
		<span class="n">user</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">log_next_idx</span><span class="p">;</span>
		<span class="n">user</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">log_next_seq</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">devkmsg_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devkmsg_user</span> <span class="o">*</span><span class="n">user</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">POLLERR</span><span class="o">|</span><span class="n">POLLNVAL</span><span class="p">;</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">&lt;</span> <span class="n">log_next_seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* return error when data has vanished underneath us */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">&lt;</span> <span class="n">log_first_seq</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="o">|</span><span class="n">POLLRDNORM</span><span class="o">|</span><span class="n">POLLERR</span><span class="o">|</span><span class="n">POLLPRI</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="o">|</span><span class="n">POLLRDNORM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">devkmsg_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devkmsg_user</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* write-only does not need any file context */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">==</span> <span class="n">O_WRONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">security_syslog</span><span class="p">(</span><span class="n">SYSLOG_ACTION_READ_ALL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">user</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">devkmsg_user</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
	<span class="n">user</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">log_first_idx</span><span class="p">;</span>
	<span class="n">user</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">log_first_seq</span><span class="p">;</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">user</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">devkmsg_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devkmsg_user</span> <span class="o">*</span><span class="n">user</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">kmsg_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">devkmsg_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">devkmsg_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_write</span> <span class="o">=</span> <span class="n">devkmsg_writev</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">devkmsg_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span> <span class="n">devkmsg_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">devkmsg_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_KEXEC</span>
<span class="cm">/*</span>
<span class="cm"> * This appends the listed symbols to /proc/vmcoreinfo</span>
<span class="cm"> *</span>
<span class="cm"> * /proc/vmcoreinfo is used by various utiilties, like crash and makedumpfile to</span>
<span class="cm"> * obtain access to symbols that are otherwise very difficult to locate.  These</span>
<span class="cm"> * symbols are specifically used so that utilities can access and extract the</span>
<span class="cm"> * dmesg log from a vmcore file after a crash.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">log_buf_kexec_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VMCOREINFO_SYMBOL</span><span class="p">(</span><span class="n">log_buf</span><span class="p">);</span>
	<span class="n">VMCOREINFO_SYMBOL</span><span class="p">(</span><span class="n">log_buf_len</span><span class="p">);</span>
	<span class="n">VMCOREINFO_SYMBOL</span><span class="p">(</span><span class="n">log_first_idx</span><span class="p">);</span>
	<span class="n">VMCOREINFO_SYMBOL</span><span class="p">(</span><span class="n">log_next_idx</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* requested log_buf_len from kernel cmdline */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__initdata</span> <span class="n">new_log_buf_len</span><span class="p">;</span>

<span class="cm">/* save requested log_buf_len since it&#39;s too early to process it */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">log_buf_len_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">log_buf_len</span><span class="p">)</span>
		<span class="n">new_log_buf_len</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;log_buf_len&quot;</span><span class="p">,</span> <span class="n">log_buf_len_setup</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_log_buf</span><span class="p">(</span><span class="kt">int</span> <span class="n">early</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">new_log_buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">free</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_log_buf_len</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">early</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mem</span><span class="p">;</span>

		<span class="n">mem</span> <span class="o">=</span> <span class="n">memblock_alloc</span><span class="p">(</span><span class="n">new_log_buf_len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">new_log_buf</span> <span class="o">=</span> <span class="n">__va</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">new_log_buf</span> <span class="o">=</span> <span class="n">alloc_bootmem_nopanic</span><span class="p">(</span><span class="n">new_log_buf_len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">new_log_buf</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;log_buf_len: %ld bytes not available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">new_log_buf_len</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">log_buf_len</span> <span class="o">=</span> <span class="n">new_log_buf_len</span><span class="p">;</span>
	<span class="n">log_buf</span> <span class="o">=</span> <span class="n">new_log_buf</span><span class="p">;</span>
	<span class="n">new_log_buf_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">free</span> <span class="o">=</span> <span class="n">__LOG_BUF_LEN</span> <span class="o">-</span> <span class="n">log_next_idx</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">log_buf</span><span class="p">,</span> <span class="n">__log_buf</span><span class="p">,</span> <span class="n">__LOG_BUF_LEN</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;log_buf_len: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">log_buf_len</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;early log buf free: %d(%d%%)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">free</span><span class="p">,</span> <span class="p">(</span><span class="n">free</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="n">__LOG_BUF_LEN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_BOOT_PRINTK_DELAY</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">boot_delay</span><span class="p">;</span> <span class="cm">/* msecs delay after each printk during bootup */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">loops_per_msec</span><span class="p">;</span>	<span class="cm">/* based on boot_delay */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">boot_delay_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lpj</span><span class="p">;</span>

	<span class="n">lpj</span> <span class="o">=</span> <span class="n">preset_lpj</span> <span class="o">?</span> <span class="n">preset_lpj</span> <span class="o">:</span> <span class="mi">1000000</span><span class="p">;</span>	<span class="cm">/* some guess */</span>
	<span class="n">loops_per_msec</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">lpj</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">boot_delay</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_delay</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
		<span class="n">boot_delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;boot_delay: %u, preset_lpj: %ld, lpj: %lu, &quot;</span>
		<span class="s">&quot;HZ: %d, loops_per_msec: %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">boot_delay</span><span class="p">,</span> <span class="n">preset_lpj</span><span class="p">,</span> <span class="n">lpj</span><span class="p">,</span> <span class="n">HZ</span><span class="p">,</span> <span class="n">loops_per_msec</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;boot_delay=&quot;</span><span class="p">,</span> <span class="n">boot_delay_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">boot_delay_msec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">k</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_delay</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">system_state</span> <span class="o">!=</span> <span class="n">SYSTEM_BOOTING</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">loops_per_msec</span> <span class="o">*</span> <span class="n">boot_delay</span><span class="p">;</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">boot_delay</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">k</span><span class="o">--</span><span class="p">;</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="cm">/*</span>
<span class="cm">		 * use (volatile) jiffies to prevent</span>
<span class="cm">		 * compiler reduction; loop termination via jiffies</span>
<span class="cm">		 * is secondary and may or may not happen.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">touch_nmi_watchdog</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">boot_delay_msec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SECURITY_DMESG_RESTRICT</span>
<span class="kt">int</span> <span class="n">dmesg_restrict</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="kt">int</span> <span class="n">dmesg_restrict</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">syslog_action_restricted</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dmesg_restrict</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Unless restricted, we allow &quot;read all&quot; and &quot;get buffer size&quot; for everybody */</span>
	<span class="k">return</span> <span class="n">type</span> <span class="o">!=</span> <span class="n">SYSLOG_ACTION_READ_ALL</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">!=</span> <span class="n">SYSLOG_ACTION_SIZE_BUFFER</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_syslog_permissions</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">bool</span> <span class="n">from_file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this is from /proc/kmsg and we&#39;ve already opened it, then we&#39;ve</span>
<span class="cm">	 * already done the capabilities checks at open time.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">from_file</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">!=</span> <span class="n">SYSLOG_ACTION_OPEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">syslog_action_restricted</span><span class="p">(</span><span class="n">type</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYSLOG</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* For historical reasons, accept CAP_SYS_ADMIN too, with a warning */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s (%d): &quot;</span>
				 <span class="s">&quot;Attempt to access syslog with CAP_SYS_ADMIN &quot;</span>
				 <span class="s">&quot;but no CAP_SYSLOG (deprecated).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_PRINTK_TIME)</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">printk_time</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">printk_time</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">printk_time</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">print_time</span><span class="p">(</span><span class="n">u64</span> <span class="n">ts</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rem_nsec</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">printk_time</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">15</span><span class="p">;</span>

	<span class="n">rem_nsec</span> <span class="o">=</span> <span class="n">do_div</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="mi">1000000000</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;[%5lu.%06lu] &quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ts</span><span class="p">,</span> <span class="n">rem_nsec</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">print_prefix</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">bool</span> <span class="n">syslog</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">syslog</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;&lt;%u&gt;&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)</span>
				<span class="n">len</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">99</span><span class="p">)</span>
				<span class="n">len</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">print_time</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">ts_nsec</span><span class="p">,</span> <span class="n">buf</span> <span class="o">?</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">len</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">msg_print_text</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">bool</span> <span class="n">syslog</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span> <span class="o">=</span> <span class="n">log_text</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">text_size</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">text_len</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">memchr</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">text_size</span><span class="p">);</span>
		<span class="kt">size_t</span> <span class="n">text_len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">text_len</span> <span class="o">=</span> <span class="n">next</span> <span class="o">-</span> <span class="n">text</span><span class="p">;</span>
			<span class="n">next</span><span class="o">++</span><span class="p">;</span>
			<span class="n">text_size</span> <span class="o">-=</span> <span class="n">next</span> <span class="o">-</span> <span class="n">text</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">text_len</span> <span class="o">=</span> <span class="n">text_size</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">print_prefix</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">syslog</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">+</span>
			    <span class="n">text_len</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&gt;=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">len</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">len</span> <span class="o">+=</span> <span class="n">print_prefix</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">syslog</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">text_len</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">text_len</span><span class="p">;</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* SYSLOG_ACTION_* buffer size only calculation */</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">print_prefix</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">syslog</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">text_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">text</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">text</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">syslog_print</span><span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">text</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">LOG_LINE_MAX</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">text</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">n</span><span class="p">;</span>

		<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">syslog_seq</span> <span class="o">&lt;</span> <span class="n">log_first_seq</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* messages are gone, move to first one */</span>
			<span class="n">syslog_seq</span> <span class="o">=</span> <span class="n">log_first_seq</span><span class="p">;</span>
			<span class="n">syslog_idx</span> <span class="o">=</span> <span class="n">log_first_idx</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">syslog_seq</span> <span class="o">==</span> <span class="n">log_next_seq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="n">log_from_idx</span><span class="p">(</span><span class="n">syslog_idx</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">msg_print_text</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">LOG_LINE_MAX</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">syslog_idx</span> <span class="o">=</span> <span class="n">log_next</span><span class="p">(</span><span class="n">syslog_idx</span><span class="p">);</span>
			<span class="n">syslog_seq</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
				<span class="n">len</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">syslog_print_all</span><span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">bool</span> <span class="n">clear</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">text</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">LOG_LINE_MAX</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">text</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">next_seq</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">seq</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">idx</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">clear_seq</span> <span class="o">&lt;</span> <span class="n">log_first_seq</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* messages are gone, move to first available one */</span>
			<span class="n">clear_seq</span> <span class="o">=</span> <span class="n">log_first_seq</span><span class="p">;</span>
			<span class="n">clear_idx</span> <span class="o">=</span> <span class="n">log_first_idx</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Find first record that fits, including all following records,</span>
<span class="cm">		 * into the user-provided buffer for this dump.</span>
<span class="cm">		 */</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">clear_seq</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">clear_idx</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">seq</span> <span class="o">&lt;</span> <span class="n">log_next_seq</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">log_from_idx</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

			<span class="n">len</span> <span class="o">+=</span> <span class="n">msg_print_text</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">log_next</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
			<span class="n">seq</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* move first record forward until length fits into the buffer */</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">clear_seq</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">clear_idx</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">seq</span> <span class="o">&lt;</span> <span class="n">log_next_seq</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">log_from_idx</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

			<span class="n">len</span> <span class="o">-=</span> <span class="n">msg_print_text</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">log_next</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
			<span class="n">seq</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* last message fitting into this dump */</span>
		<span class="n">next_seq</span> <span class="o">=</span> <span class="n">log_next_seq</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">seq</span> <span class="o">&lt;</span> <span class="n">next_seq</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">log_from_idx</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
			<span class="kt">int</span> <span class="n">textlen</span><span class="p">;</span>

			<span class="n">textlen</span> <span class="o">=</span> <span class="n">msg_print_text</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">LOG_LINE_MAX</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">textlen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">textlen</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">log_next</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
			<span class="n">seq</span><span class="o">++</span><span class="p">;</span>

			<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">textlen</span><span class="p">))</span>
				<span class="n">len</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">len</span> <span class="o">+=</span> <span class="n">textlen</span><span class="p">;</span>
			<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">seq</span> <span class="o">&lt;</span> <span class="n">log_first_seq</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* messages are gone, move to next one */</span>
				<span class="n">seq</span> <span class="o">=</span> <span class="n">log_first_seq</span><span class="p">;</span>
				<span class="n">idx</span> <span class="o">=</span> <span class="n">log_first_idx</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clear</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_seq</span> <span class="o">=</span> <span class="n">log_next_seq</span><span class="p">;</span>
		<span class="n">clear_idx</span> <span class="o">=</span> <span class="n">log_next_idx</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">do_syslog</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">bool</span> <span class="n">from_file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">clear</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">saved_console_loglevel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">syslog_mutex</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">check_syslog_permissions</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">from_file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_syslog</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_CLOSE</span>:	<span class="cm">/* Close log */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_OPEN</span>:	<span class="cm">/* Open log */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_READ</span>:	<span class="cm">/* Read from log */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">syslog_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">log_wait</span><span class="p">,</span>
						 <span class="n">syslog_seq</span> <span class="o">!=</span> <span class="n">log_next_seq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">syslog_mutex</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">syslog_print</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">syslog_mutex</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/* Read/clear last kernel messages */</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_READ_CLEAR</span>:
		<span class="n">clear</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="cm">/* FALL THRU */</span>
	<span class="cm">/* Read last kernel messages */</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_READ_ALL</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">syslog_print_all</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">clear</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/* Clear ring buffer */</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_CLEAR</span>:
		<span class="n">syslog_print_all</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/* Disable logging to console */</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_CONSOLE_OFF</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">saved_console_loglevel</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">saved_console_loglevel</span> <span class="o">=</span> <span class="n">console_loglevel</span><span class="p">;</span>
		<span class="n">console_loglevel</span> <span class="o">=</span> <span class="n">minimum_console_loglevel</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/* Enable logging to console */</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_CONSOLE_ON</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">saved_console_loglevel</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">console_loglevel</span> <span class="o">=</span> <span class="n">saved_console_loglevel</span><span class="p">;</span>
			<span class="n">saved_console_loglevel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/* Set level of messages printed to console */</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_CONSOLE_LEVEL</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">minimum_console_loglevel</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">minimum_console_loglevel</span><span class="p">;</span>
		<span class="n">console_loglevel</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="cm">/* Implicitly re-enable logging to console */</span>
		<span class="n">saved_console_loglevel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/* Number of chars in the log buffer */</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_SIZE_UNREAD</span>:
		<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">syslog_seq</span> <span class="o">&lt;</span> <span class="n">log_first_seq</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* messages are gone, move to first one */</span>
			<span class="n">syslog_seq</span> <span class="o">=</span> <span class="n">log_first_seq</span><span class="p">;</span>
			<span class="n">syslog_idx</span> <span class="o">=</span> <span class="n">log_first_idx</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">from_file</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Short-cut for poll(/&quot;proc/kmsg&quot;) which simply checks</span>
<span class="cm">			 * for pending data, not the size; return the count of</span>
<span class="cm">			 * records, not the length.</span>
<span class="cm">			 */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">log_next_idx</span> <span class="o">-</span> <span class="n">syslog_idx</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">seq</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">idx</span><span class="p">;</span>

			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">seq</span> <span class="o">=</span> <span class="n">syslog_seq</span><span class="p">;</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">syslog_idx</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">seq</span> <span class="o">&lt;</span> <span class="n">log_next_seq</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">log_from_idx</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

				<span class="n">error</span> <span class="o">+=</span> <span class="n">msg_print_text</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">idx</span> <span class="o">=</span> <span class="n">log_next</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
				<span class="n">seq</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/* Size of the log buffer */</span>
	<span class="k">case</span> <span class="n">SYSLOG_ACTION_SIZE_BUFFER</span>:
		<span class="n">error</span> <span class="o">=</span> <span class="n">log_buf_len</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">syslog</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_syslog</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">SYSLOG_FROM_CALL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef	CONFIG_KGDB_KDB</span>
<span class="cm">/* kdb dmesg command needs access to the syslog buffer.  do_syslog()</span>
<span class="cm"> * uses locks so it cannot be used during debugging.  Just tell kdb</span>
<span class="cm"> * where the start and end of the physical and logical logs are.  This</span>
<span class="cm"> * is equivalent to do_syslog(3).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">kdb_syslog_data</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">syslog_data</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="p">{</span>
	<span class="n">syslog_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_buf</span><span class="p">;</span>
	<span class="n">syslog_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_buf</span> <span class="o">+</span> <span class="n">log_buf_len</span><span class="p">;</span>
	<span class="n">syslog_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_buf</span> <span class="o">+</span> <span class="n">log_first_idx</span><span class="p">;</span>
	<span class="n">syslog_data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_buf</span> <span class="o">+</span> <span class="n">log_next_idx</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_KGDB_KDB */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">__read_mostly</span> <span class="n">ignore_loglevel</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ignore_loglevel_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ignore_loglevel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;debug: ignoring loglevel setting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;ignore_loglevel&quot;</span><span class="p">,</span> <span class="n">ignore_loglevel_setup</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ignore_loglevel</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ignore_loglevel</span><span class="p">,</span> <span class="s">&quot;ignore loglevel setting, to&quot;</span>
	<span class="s">&quot;print all kernel messages to the console.&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Call the console drivers, asking them to write out</span>
<span class="cm"> * log_buf[start] to log_buf[end - 1].</span>
<span class="cm"> * The console_lock must be held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">call_console_drivers</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">con</span><span class="p">;</span>

	<span class="n">trace_console</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;=</span> <span class="n">console_loglevel</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ignore_loglevel</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">console_drivers</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_console</span><span class="p">(</span><span class="n">con</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exclusive_console</span> <span class="o">&amp;&amp;</span> <span class="n">con</span> <span class="o">!=</span> <span class="n">exclusive_console</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">con</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_ENABLED</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">con</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">())</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">con</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_ANYTIME</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">con</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Zap console related locks when oopsing. Only zap at most once</span>
<span class="cm"> * every 10 seconds, to leave time for slow consoles to print a</span>
<span class="cm"> * full oops.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">zap_locks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">oops_timestamp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">oops_timestamp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">oops_timestamp</span> <span class="o">+</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">oops_timestamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">debug_locks_off</span><span class="p">();</span>
	<span class="cm">/* If a crash is occurring, make sure we can&#39;t deadlock */</span>
	<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
	<span class="cm">/* And make sure that we print immediately */</span>
	<span class="n">sema_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">console_sem</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check if we have any console registered that can be called early in boot. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">have_callable_console</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">con</span><span class="p">;</span>

	<span class="n">for_each_console</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">con</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_ANYTIME</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Can we actually use the console at this time on this cpu?</span>
<span class="cm"> *</span>
<span class="cm"> * Console drivers may assume that per-cpu resources have</span>
<span class="cm"> * been allocated. So unless they&#39;re explicitly marked as</span>
<span class="cm"> * being able to cope (CON_ANYTIME) don&#39;t call them until</span>
<span class="cm"> * this CPU is officially up.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">can_use_console</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">||</span> <span class="n">have_callable_console</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try to get console ownership to actually show the kernel</span>
<span class="cm"> * messages from a &#39;printk&#39;. Return true (and with the</span>
<span class="cm"> * console_lock held, and &#39;console_locked&#39; set) if it</span>
<span class="cm"> * is successful, false otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * This gets called with the &#39;logbuf_lock&#39; spinlock held and</span>
<span class="cm"> * interrupts disabled. It should return with &#39;lockbuf_lock&#39;</span>
<span class="cm"> * released but interrupts still disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">console_trylock_for_printk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">console_trylock</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we can&#39;t use the console, we need to release</span>
<span class="cm">		 * the console semaphore by hand to avoid flushing</span>
<span class="cm">		 * the buffer. We need to hold the console semaphore</span>
<span class="cm">		 * in order to do this test safely.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_use_console</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">console_locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">wake</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">logbuf_cpu</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wake</span><span class="p">)</span>
		<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">console_sem</span><span class="p">);</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">printk_delay_msec</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">printk_delay</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">printk_delay_msec</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">printk_delay_msec</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">touch_nmi_watchdog</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Continuation lines are buffered, and not committed to the record buffer</span>
<span class="cm"> * until the line is complete, or a race forces it. The line fragments</span>
<span class="cm"> * though, are printed immediately to the consoles to ensure everything has</span>
<span class="cm"> * reached the console in case of a kernel crash.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cont</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">LOG_LINE_MAX</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>			<span class="cm">/* length == 0 means unused buffer */</span>
	<span class="kt">size_t</span> <span class="n">cons</span><span class="p">;</span>			<span class="cm">/* bytes written to console */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>	<span class="cm">/* task of first print*/</span>
	<span class="n">u64</span> <span class="n">ts_nsec</span><span class="p">;</span>			<span class="cm">/* time of first print */</span>
	<span class="n">u8</span> <span class="n">level</span><span class="p">;</span>			<span class="cm">/* log level of first message */</span>
	<span class="n">u8</span> <span class="n">facility</span><span class="p">;</span>			<span class="cm">/* log level of first message */</span>
	<span class="n">bool</span> <span class="n">flushed</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>			<span class="cm">/* buffer sealed and committed */</span>
<span class="p">}</span> <span class="n">cont</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cont_flush</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">flushed</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">log_store</span><span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">facility</span><span class="p">,</span> <span class="n">cont</span><span class="p">.</span><span class="n">level</span><span class="p">,</span> <span class="n">LOG_NOCONS</span><span class="p">,</span> <span class="n">cont</span><span class="p">.</span><span class="n">ts_nsec</span><span class="p">,</span>
		  <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cont</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">cont</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>

	<span class="n">cont</span><span class="p">.</span><span class="n">flushed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">cont_add</span><span class="p">(</span><span class="kt">int</span> <span class="n">facility</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">cont</span><span class="p">.</span><span class="n">flushed</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">len</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">buf</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cont_flush</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cont</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cont</span><span class="p">.</span><span class="n">facility</span> <span class="o">=</span> <span class="n">facility</span><span class="p">;</span>
		<span class="n">cont</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
		<span class="n">cont</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
		<span class="n">cont</span><span class="p">.</span><span class="n">ts_nsec</span> <span class="o">=</span> <span class="n">local_clock</span><span class="p">();</span>
		<span class="n">cont</span><span class="p">.</span><span class="n">cons</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cont</span><span class="p">.</span><span class="n">flushed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">cont</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">cont</span><span class="p">.</span><span class="n">len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">cont_print_text</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">textlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">cons</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">textlen</span> <span class="o">+=</span> <span class="n">print_time</span><span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">ts_nsec</span><span class="p">,</span> <span class="n">text</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">textlen</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">cont</span><span class="p">.</span><span class="n">len</span> <span class="o">-</span> <span class="n">cont</span><span class="p">.</span><span class="n">cons</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">text</span> <span class="o">+</span> <span class="n">textlen</span><span class="p">,</span> <span class="n">cont</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">cont</span><span class="p">.</span><span class="n">cons</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">textlen</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">cont</span><span class="p">.</span><span class="n">cons</span> <span class="o">=</span> <span class="n">cont</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">flushed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">text</span><span class="p">[</span><span class="n">textlen</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
		<span class="cm">/* got everything, release buffer */</span>
		<span class="n">cont</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">textlen</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">asmlinkage</span> <span class="kt">int</span> <span class="nf">vprintk_emit</span><span class="p">(</span><span class="kt">int</span> <span class="n">facility</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dict</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dictlen</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">recursion_bug</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">textbuf</span><span class="p">[</span><span class="n">LOG_LINE_MAX</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">text</span> <span class="o">=</span> <span class="n">textbuf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">text_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">this_cpu</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">newline</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">prefix</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">printed_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">boot_delay_msec</span><span class="p">();</span>
	<span class="n">printk_delay</span><span class="p">();</span>

	<span class="cm">/* This stops the holder of console_sem just where we want him */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">this_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ouch, printk recursed into itself!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">logbuf_cpu</span> <span class="o">==</span> <span class="n">this_cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If a crash is occurring during printk() on this CPU,</span>
<span class="cm">		 * then try to get the crash message out but make sure</span>
<span class="cm">		 * we can&#39;t deadlock. Otherwise just return to avoid the</span>
<span class="cm">		 * recursion and return - but flag the recursion so that</span>
<span class="cm">		 * it can be printed at the next appropriate moment:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oops_in_progress</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lockdep_recursing</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">recursion_bug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_restore_irqs</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">zap_locks</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">lockdep_off</span><span class="p">();</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
	<span class="n">logbuf_cpu</span> <span class="o">=</span> <span class="n">this_cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">recursion_bug</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">recursion_msg</span><span class="p">[]</span> <span class="o">=</span>
			<span class="s">&quot;BUG: recent printk recursion!&quot;</span><span class="p">;</span>

		<span class="n">recursion_bug</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">printed_len</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">recursion_msg</span><span class="p">);</span>
		<span class="cm">/* emit KERN_CRIT message */</span>
		<span class="n">log_store</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">LOG_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			  <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">recursion_msg</span><span class="p">,</span> <span class="n">printed_len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The printf needs to come first; we need the syslog</span>
<span class="cm">	 * prefix which might be passed-in as a parameter.</span>
<span class="cm">	 */</span>
	<span class="n">text_len</span> <span class="o">=</span> <span class="n">vscnprintf</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">textbuf</span><span class="p">),</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>

	<span class="cm">/* mark and strip a trailing newline */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">text_len</span> <span class="o">&amp;&amp;</span> <span class="n">text</span><span class="p">[</span><span class="n">text_len</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">text_len</span><span class="o">--</span><span class="p">;</span>
		<span class="n">newline</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* strip syslog prefix and extract log level or control flags */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;&lt;&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">text</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;&gt;&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;0&#39;</span> <span class="p">...</span> <span class="sc">&#39;7&#39;</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="n">level</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;d&#39;</span>:	<span class="cm">/* KERN_DEFAULT */</span>
			<span class="n">prefix</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;c&#39;</span>:	<span class="cm">/* KERN_CONT */</span>
			<span class="n">text</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">text_len</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">level</span> <span class="o">=</span> <span class="n">default_message_loglevel</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prefix</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">newline</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newline</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Flush the conflicting buffer. An earlier newline was missing,</span>
<span class="cm">		 * or another task also prints continuation lines.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">prefix</span> <span class="o">||</span> <span class="n">cont</span><span class="p">.</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">current</span><span class="p">))</span>
			<span class="n">cont_flush</span><span class="p">();</span>

		<span class="cm">/* buffer line if possible, otherwise store it right away */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cont_add</span><span class="p">(</span><span class="n">facility</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">text_len</span><span class="p">))</span>
			<span class="n">log_store</span><span class="p">(</span><span class="n">facility</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">LOG_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">dict</span><span class="p">,</span> <span class="n">dictlen</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">text_len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">stored</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If an earlier newline was missing and it was the same task,</span>
<span class="cm">		 * either merge it with the current buffer and flush, or if</span>
<span class="cm">		 * there was a race with interrupts (prefix == true) then just</span>
<span class="cm">		 * flush it out and store this line separately.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">cont</span><span class="p">.</span><span class="n">owner</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prefix</span><span class="p">)</span>
				<span class="n">stored</span> <span class="o">=</span> <span class="n">cont_add</span><span class="p">(</span><span class="n">facility</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">text_len</span><span class="p">);</span>
			<span class="n">cont_flush</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stored</span><span class="p">)</span>
			<span class="n">log_store</span><span class="p">(</span><span class="n">facility</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">LOG_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">dict</span><span class="p">,</span> <span class="n">dictlen</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">text_len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printed_len</span> <span class="o">+=</span> <span class="n">text_len</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to acquire and then immediately release the console semaphore.</span>
<span class="cm">	 * The release will print out buffers and wake up /dev/kmsg and syslog()</span>
<span class="cm">	 * users.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The console_trylock_for_printk() function will release &#39;logbuf_lock&#39;</span>
<span class="cm">	 * regardless of whether it actually gets the console semaphore or not.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">console_trylock_for_printk</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">))</span>
		<span class="n">console_unlock</span><span class="p">();</span>

	<span class="n">lockdep_on</span><span class="p">();</span>
<span class="nl">out_restore_irqs:</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">printed_len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vprintk_emit</span><span class="p">);</span>

<span class="n">asmlinkage</span> <span class="kt">int</span> <span class="nf">vprintk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vprintk_emit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vprintk</span><span class="p">);</span>

<span class="n">asmlinkage</span> <span class="kt">int</span> <span class="nf">printk_emit</span><span class="p">(</span><span class="kt">int</span> <span class="n">facility</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dict</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dictlen</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">vprintk_emit</span><span class="p">(</span><span class="n">facility</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">dictlen</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">printk_emit</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * printk - print a kernel message</span>
<span class="cm"> * @fmt: format string</span>
<span class="cm"> *</span>
<span class="cm"> * This is printk(). It can be called from any context. We want it to work.</span>
<span class="cm"> *</span>
<span class="cm"> * We try to grab the console_lock. If we succeed, it&#39;s easy - we log the</span>
<span class="cm"> * output and call the console drivers.  If we fail to get the semaphore, we</span>
<span class="cm"> * place the output into the log buffer and return. The current holder of</span>
<span class="cm"> * the console_sem will notice the new output in console_unlock(); and will</span>
<span class="cm"> * send it to the consoles before releasing the lock.</span>
<span class="cm"> *</span>
<span class="cm"> * One effect of this deferred printing is that code which calls printk() and</span>
<span class="cm"> * then changes console_loglevel may break. This is because console_loglevel</span>
<span class="cm"> * is inspected when the actual printing occurs.</span>
<span class="cm"> *</span>
<span class="cm"> * See also:</span>
<span class="cm"> * printf(3)</span>
<span class="cm"> *</span>
<span class="cm"> * See the vsnprintf() documentation for format string extensions over C99.</span>
<span class="cm"> */</span>
<span class="n">asmlinkage</span> <span class="kt">int</span> <span class="nf">printk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_KGDB_KDB</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">kdb_trap_printk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">vkdb_printf</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
		<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">vprintk_emit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">printk</span><span class="p">);</span>

<span class="cp">#else</span>

<span class="cp">#define LOG_LINE_MAX 0</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cont</span> <span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">cons</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">flushed</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">cont</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="nf">log_from_idx</span><span class="p">(</span><span class="n">u32</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">log_next</span><span class="p">(</span><span class="n">u32</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">call_console_drivers</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">msg_print_text</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">bool</span> <span class="n">syslog</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">cont_print_text</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PRINTK */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__add_preferred_console</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span>
				   <span class="kt">char</span> <span class="o">*</span><span class="n">brl_options</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">console_cmdline</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	See if this tty is not yet registered, and</span>
<span class="cm">	 *	if we have a slot free.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_CMDLINECONSOLES</span> <span class="o">&amp;&amp;</span> <span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			  <span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">brl_options</span><span class="p">)</span>
					<span class="n">selected_console</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MAX_CMDLINECONSOLES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">brl_options</span><span class="p">)</span>
		<span class="n">selected_console</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_A11Y_BRAILLE_CONSOLE</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">brl_options</span> <span class="o">=</span> <span class="n">brl_options</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Set up a list of consoles.  Called from init/main.c</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">console_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">console_cmdline</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span> <span class="cm">/* 4 for index */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span> <span class="o">*</span><span class="n">brl_options</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_A11Y_BRAILLE_CONSOLE</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;brl,&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">brl_options</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
		<span class="n">str</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;brl=&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">brl_options</span> <span class="o">=</span> <span class="n">str</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">str</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">brl_options</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;need port name after brl=</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="p">(</span><span class="n">str</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Decode str into name, index, options.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;ttyS&quot;</span><span class="p">);</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">buf</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">options</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="n">options</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef __sparc__</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;ttya&quot;</span><span class="p">))</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;ttyS0&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;ttyb&quot;</span><span class="p">))</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;ttyS1&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">s</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">s</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="o">*</span><span class="n">s</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">__add_preferred_console</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">brl_options</span><span class="p">);</span>
	<span class="n">console_set_on_cmdline</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;console=&quot;</span><span class="p">,</span> <span class="n">console_setup</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * add_preferred_console - add a device to the list of preferred consoles.</span>
<span class="cm"> * @name: device name</span>
<span class="cm"> * @idx: device index</span>
<span class="cm"> * @options: options for this console</span>
<span class="cm"> *</span>
<span class="cm"> * The last preferred console added will be used for kernel messages</span>
<span class="cm"> * and stdin/out/err for init.  Normally this is used by console_setup</span>
<span class="cm"> * above to handle user-supplied console arguments; however it can also</span>
<span class="cm"> * be used by arch-specific code either to override the user or more</span>
<span class="cm"> * commonly to provide a default console (ie from PROM variables) when</span>
<span class="cm"> * the user has not supplied one.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">add_preferred_console</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__add_preferred_console</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">update_console_cmdline</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name_new</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx_new</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">console_cmdline</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_CMDLINECONSOLES</span> <span class="o">&amp;&amp;</span> <span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			  <span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">strlcpy</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name_new</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">;</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">idx_new</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="cm">/* not found */</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="n">console_suspend_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">console_suspend_enabled</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">console_suspend_disable</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">console_suspend_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;no_console_suspend&quot;</span><span class="p">,</span> <span class="n">console_suspend_disable</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">console_suspend</span><span class="p">,</span> <span class="n">console_suspend_enabled</span><span class="p">,</span>
		<span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">console_suspend</span><span class="p">,</span> <span class="s">&quot;suspend console during suspend&quot;</span>
	<span class="s">&quot; and hibernate operations&quot;</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * suspend_console - suspend the console subsystem</span>
<span class="cm"> *</span>
<span class="cm"> * This disables printk() while we go into suspend states</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">suspend_console</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">console_suspend_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Suspending console(s) (use no_console_suspend to debug)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">console_lock</span><span class="p">();</span>
	<span class="n">console_suspended</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">console_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">resume_console</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">console_suspend_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">console_sem</span><span class="p">);</span>
	<span class="n">console_suspended</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">console_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * console_cpu_notify - print deferred console messages after CPU hotplug</span>
<span class="cm"> * @self: notifier struct</span>
<span class="cm"> * @action: CPU hotplug event</span>
<span class="cm"> * @hcpu: unused</span>
<span class="cm"> *</span>
<span class="cm"> * If printk() is called from a CPU that is not online yet, the messages</span>
<span class="cm"> * will be spooled but will not show up on the console.  This function is</span>
<span class="cm"> * called when a new CPU comes online (or fails to come up), and ensures</span>
<span class="cm"> * that any such output gets printed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">console_cpu_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
	<span class="k">case</span> <span class="n">CPU_DEAD</span>:
	<span class="k">case</span> <span class="n">CPU_DYING</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED</span>:
	<span class="k">case</span> <span class="n">CPU_UP_CANCELED</span>:
		<span class="n">console_lock</span><span class="p">();</span>
		<span class="n">console_unlock</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * console_lock - lock the console system for exclusive use.</span>
<span class="cm"> *</span>
<span class="cm"> * Acquires a lock which guarantees that the caller has</span>
<span class="cm"> * exclusive access to the console system and the console_drivers list.</span>
<span class="cm"> *</span>
<span class="cm"> * Can sleep, returns nothing.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">console_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">());</span>
	<span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">console_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">console_suspended</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">console_locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">console_may_schedule</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">console_lock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * console_trylock - try to lock the console system for exclusive use.</span>
<span class="cm"> *</span>
<span class="cm"> * Tried to acquire a lock which guarantees that the caller has</span>
<span class="cm"> * exclusive access to the console system and the console_drivers list.</span>
<span class="cm"> *</span>
<span class="cm"> * returns 1 on success, and 0 on failure to acquire the lock.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">console_trylock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">down_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">console_sem</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">console_suspended</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">console_sem</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">console_locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">console_may_schedule</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">console_trylock</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">is_console_locked</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">console_locked</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Delayed printk version, for scheduler-internal messages:</span>
<span class="cm"> */</span>
<span class="cp">#define PRINTK_BUF_SIZE		512</span>

<span class="cp">#define PRINTK_PENDING_WAKEUP	0x01</span>
<span class="cp">#define PRINTK_PENDING_SCHED	0x02</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">printk_pending</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">char</span> <span class="p">[</span><span class="n">PRINTK_BUF_SIZE</span><span class="p">],</span> <span class="n">printk_sched_buf</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">printk_tick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">printk_pending</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pending</span> <span class="o">=</span> <span class="n">__this_cpu_xchg</span><span class="p">(</span><span class="n">printk_pending</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">&amp;</span> <span class="n">PRINTK_PENDING_SCHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">printk_sched_buf</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;[sched_delayed] %s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">&amp;</span> <span class="n">PRINTK_PENDING_WAKEUP</span><span class="p">)</span>
			<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log_wait</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">printk_needs_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_offline</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
		<span class="n">printk_tick</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">printk_pending</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">wake_up_klogd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log_wait</span><span class="p">))</span>
		<span class="n">this_cpu_or</span><span class="p">(</span><span class="n">printk_pending</span><span class="p">,</span> <span class="n">PRINTK_PENDING_WAKEUP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* the next printk record to write to the console */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">console_seq</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">console_idx</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * console_unlock - unlock the console system</span>
<span class="cm"> *</span>
<span class="cm"> * Releases the console_lock which the caller holds on the console system</span>
<span class="cm"> * and the console driver list.</span>
<span class="cm"> *</span>
<span class="cm"> * While the console_lock was held, console output may have been buffered</span>
<span class="cm"> * by printk().  If this is the case, console_unlock(); emits</span>
<span class="cm"> * the output prior to releasing the lock.</span>
<span class="cm"> *</span>
<span class="cm"> * If there is output waiting, we wake /dev/kmsg and syslog() users.</span>
<span class="cm"> *</span>
<span class="cm"> * console_unlock(); may be called from any context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">console_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">text</span><span class="p">[</span><span class="n">LOG_LINE_MAX</span><span class="p">];</span>
	<span class="k">static</span> <span class="n">u64</span> <span class="n">seen_seq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">wake_klogd</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">retry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">console_suspended</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">console_sem</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">console_may_schedule</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* flush buffered message fragment immediately to console */</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">cons</span> <span class="o">&lt;</span> <span class="n">cont</span><span class="p">.</span><span class="n">len</span> <span class="o">||</span> <span class="n">cont</span><span class="p">.</span><span class="n">flushed</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">cont_print_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">text</span><span class="p">));</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
		<span class="n">stop_critical_timings</span><span class="p">();</span>
		<span class="n">call_console_drivers</span><span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">level</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">start_critical_timings</span><span class="p">();</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="nl">again:</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seen_seq</span> <span class="o">!=</span> <span class="n">log_next_seq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wake_klogd</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">seen_seq</span> <span class="o">=</span> <span class="n">log_next_seq</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">console_seq</span> <span class="o">&lt;</span> <span class="n">log_first_seq</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* messages are gone, move to first one */</span>
			<span class="n">console_seq</span> <span class="o">=</span> <span class="n">log_first_seq</span><span class="p">;</span>
			<span class="n">console_idx</span> <span class="o">=</span> <span class="n">log_first_idx</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">skip:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">console_seq</span> <span class="o">==</span> <span class="n">log_next_seq</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">msg</span> <span class="o">=</span> <span class="n">log_from_idx</span><span class="p">(</span><span class="n">console_idx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOG_NOCONS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Skip record we have buffered and already printed</span>
<span class="cm">			 * directly to the console when we received it.</span>
<span class="cm">			 */</span>
			<span class="n">console_idx</span> <span class="o">=</span> <span class="n">log_next</span><span class="p">(</span><span class="n">console_idx</span><span class="p">);</span>
			<span class="n">console_seq</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">level</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">msg_print_text</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">text</span><span class="p">));</span>

		<span class="n">console_idx</span> <span class="o">=</span> <span class="n">log_next</span><span class="p">(</span><span class="n">console_idx</span><span class="p">);</span>
		<span class="n">console_seq</span><span class="o">++</span><span class="p">;</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>

		<span class="n">stop_critical_timings</span><span class="p">();</span>	<span class="cm">/* don&#39;t trace print latency */</span>
		<span class="n">call_console_drivers</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">start_critical_timings</span><span class="p">();</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">console_locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Release the exclusive_console once it is used */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">exclusive_console</span><span class="p">))</span>
		<span class="n">exclusive_console</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>

	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">console_sem</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Someone could have filled up the buffer again, so re-check if there&#39;s</span>
<span class="cm">	 * something to flush. In case we cannot trylock the console_sem again,</span>
<span class="cm">	 * there&#39;s a new owner and the console_unlock() from them will do the</span>
<span class="cm">	 * flush, no worries.</span>
<span class="cm">	 */</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">);</span>
	<span class="n">retry</span> <span class="o">=</span> <span class="n">console_seq</span> <span class="o">!=</span> <span class="n">log_next_seq</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retry</span> <span class="o">&amp;&amp;</span> <span class="n">console_trylock</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wake_klogd</span><span class="p">)</span>
		<span class="n">wake_up_klogd</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">console_unlock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * console_conditional_schedule - yield the CPU if required</span>
<span class="cm"> *</span>
<span class="cm"> * If the console code is currently allowed to sleep, and</span>
<span class="cm"> * if this CPU should yield the CPU to another task, do</span>
<span class="cm"> * so here.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called within console_lock();.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__sched</span> <span class="nf">console_conditional_schedule</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">console_may_schedule</span><span class="p">)</span>
		<span class="n">cond_resched</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">console_conditional_schedule</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">console_unblank</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * console_unblank can no longer be called in interrupt context unless</span>
<span class="cm">	 * oops_in_progress is set to 1..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oops_in_progress</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">down_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">console_sem</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">console_lock</span><span class="p">();</span>

	<span class="n">console_locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">console_may_schedule</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_console</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">unblank</span><span class="p">)</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">unblank</span><span class="p">();</span>
	<span class="n">console_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the console tty driver structure and its associated index</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="nf">console_device</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">console_lock</span><span class="p">();</span>
	<span class="n">for_each_console</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">driver</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">console_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">driver</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Prevent further output on the passed console device so that (for example)</span>
<span class="cm"> * serial drivers can disable console output before suspending a port, and can</span>
<span class="cm"> * re-enable output afterwards.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">console_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">console</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">console_lock</span><span class="p">();</span>
	<span class="n">console</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CON_ENABLED</span><span class="p">;</span>
	<span class="n">console_unlock</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">console_stop</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">console_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">console</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">console_lock</span><span class="p">();</span>
	<span class="n">console</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CON_ENABLED</span><span class="p">;</span>
	<span class="n">console_unlock</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">console_start</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__read_mostly</span> <span class="n">keep_bootcon</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">keep_bootcon_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">keep_bootcon</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;debug: skip boot console de-registration.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;keep_bootcon&quot;</span><span class="p">,</span> <span class="n">keep_bootcon_setup</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The console driver calls this routine during kernel initialization</span>
<span class="cm"> * to register the console printing procedure with printk() and to</span>
<span class="cm"> * print any messages that were printed by the kernel before the</span>
<span class="cm"> * console driver was initialized.</span>
<span class="cm"> *</span>
<span class="cm"> * This can happen pretty early during the boot process (because of</span>
<span class="cm"> * early_printk) - sometimes before setup_arch() completes - be careful</span>
<span class="cm"> * of what kernel features are used - they may not be initialised yet.</span>
<span class="cm"> *</span>
<span class="cm"> * There are two types of consoles - bootconsoles (early_printk) and</span>
<span class="cm"> * &quot;real&quot; consoles (everything which is not a bootconsole) which are</span>
<span class="cm"> * handled differently.</span>
<span class="cm"> *  - Any number of bootconsoles can be registered at any time.</span>
<span class="cm"> *  - As soon as a &quot;real&quot; console is registered, all bootconsoles</span>
<span class="cm"> *    will be unregistered automatically.</span>
<span class="cm"> *  - Once a &quot;real&quot; console is registered, any attempt to register a</span>
<span class="cm"> *    bootconsoles will be rejected</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">register_console</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">newcon</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">bcon</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * before we register a new CON_BOOT console, make sure we don&#39;t</span>
<span class="cm">	 * already have a valid console</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">console_drivers</span> <span class="o">&amp;&amp;</span> <span class="n">newcon</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_BOOT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* find the last or real console */</span>
		<span class="n">for_each_console</span><span class="p">(</span><span class="n">bcon</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bcon</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_BOOT</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Too late to register bootconsole %s%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">newcon</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">newcon</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">console_drivers</span> <span class="o">&amp;&amp;</span> <span class="n">console_drivers</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_BOOT</span><span class="p">)</span>
		<span class="n">bcon</span> <span class="o">=</span> <span class="n">console_drivers</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">preferred_console</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">bcon</span> <span class="o">||</span> <span class="o">!</span><span class="n">console_drivers</span><span class="p">)</span>
		<span class="n">preferred_console</span> <span class="o">=</span> <span class="n">selected_console</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">newcon</span><span class="o">-&gt;</span><span class="n">early_setup</span><span class="p">)</span>
		<span class="n">newcon</span><span class="o">-&gt;</span><span class="n">early_setup</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 *	See if we want to use this console driver. If we</span>
<span class="cm">	 *	didn&#39;t select a console we take the first one</span>
<span class="cm">	 *	that registers here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">preferred_console</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newcon</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">newcon</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newcon</span><span class="o">-&gt;</span><span class="n">setup</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
		    <span class="n">newcon</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="n">newcon</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">newcon</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CON_ENABLED</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newcon</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">newcon</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CON_CONSDEV</span><span class="p">;</span>
				<span class="n">preferred_console</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	See if this console matches one we selected on</span>
<span class="cm">	 *	the command line.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_CMDLINECONSOLES</span> <span class="o">&amp;&amp;</span> <span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">newcon</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newcon</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">newcon</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newcon</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">newcon</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_A11Y_BRAILLE_CONSOLE</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">brl_options</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">newcon</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CON_BRL</span><span class="p">;</span>
			<span class="n">braille_register_console</span><span class="p">(</span><span class="n">newcon</span><span class="p">,</span>
					<span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span><span class="p">,</span>
					<span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">options</span><span class="p">,</span>
					<span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">brl_options</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newcon</span><span class="o">-&gt;</span><span class="n">setup</span> <span class="o">&amp;&amp;</span>
		    <span class="n">newcon</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="n">newcon</span><span class="p">,</span> <span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">options</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">newcon</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CON_ENABLED</span><span class="p">;</span>
		<span class="n">newcon</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">console_cmdline</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">selected_console</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">newcon</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CON_CONSDEV</span><span class="p">;</span>
			<span class="n">preferred_console</span> <span class="o">=</span> <span class="n">selected_console</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">newcon</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_ENABLED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have a bootconsole, and are switching to a real console,</span>
<span class="cm">	 * don&#39;t print everything out again, since when the boot console, and</span>
<span class="cm">	 * the real console are the same physical device, it&#39;s annoying to</span>
<span class="cm">	 * see the beginning boot messages twice</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bcon</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">newcon</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CON_CONSDEV</span> <span class="o">|</span> <span class="n">CON_BOOT</span><span class="p">))</span> <span class="o">==</span> <span class="n">CON_CONSDEV</span><span class="p">))</span>
		<span class="n">newcon</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CON_PRINTBUFFER</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Put this console in the list - keep the</span>
<span class="cm">	 *	preferred driver at the head of the list.</span>
<span class="cm">	 */</span>
	<span class="n">console_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">newcon</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_CONSDEV</span><span class="p">)</span> <span class="o">||</span> <span class="n">console_drivers</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">newcon</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">console_drivers</span><span class="p">;</span>
		<span class="n">console_drivers</span> <span class="o">=</span> <span class="n">newcon</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newcon</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="n">newcon</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CON_CONSDEV</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">newcon</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">console_drivers</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">console_drivers</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newcon</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newcon</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_PRINTBUFFER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * console_unlock(); will print out the buffered messages</span>
<span class="cm">		 * for us.</span>
<span class="cm">		 */</span>
		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">console_seq</span> <span class="o">=</span> <span class="n">syslog_seq</span><span class="p">;</span>
		<span class="n">console_idx</span> <span class="o">=</span> <span class="n">syslog_idx</span><span class="p">;</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re about to replay the log buffer.  Only do this to the</span>
<span class="cm">		 * just-registered console to avoid excessive message spam to</span>
<span class="cm">		 * the already-registered consoles.</span>
<span class="cm">		 */</span>
		<span class="n">exclusive_console</span> <span class="o">=</span> <span class="n">newcon</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">console_unlock</span><span class="p">();</span>
	<span class="n">console_sysfs_notify</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * By unregistering the bootconsoles after we enable the real console</span>
<span class="cm">	 * we get the &quot;console xxx enabled&quot; message on all the consoles -</span>
<span class="cm">	 * boot consoles, real consoles, etc - this is to ensure that end</span>
<span class="cm">	 * users know there might be something in the kernel&#39;s log buffer that</span>
<span class="cm">	 * went to the bootconsole (that they do not see on the real console)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bcon</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">newcon</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CON_CONSDEV</span> <span class="o">|</span> <span class="n">CON_BOOT</span><span class="p">))</span> <span class="o">==</span> <span class="n">CON_CONSDEV</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">keep_bootcon</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we need to iterate through twice, to make sure we print</span>
<span class="cm">		 * everything out, before we unregister the console(s)</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;console [%s%d] enabled, bootconsole disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">newcon</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">newcon</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">for_each_console</span><span class="p">(</span><span class="n">bcon</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bcon</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_BOOT</span><span class="p">)</span>
				<span class="n">unregister_console</span><span class="p">(</span><span class="n">bcon</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%sconsole [%s%d] enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">newcon</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_BOOT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;boot&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span> <span class="p">,</span>
			<span class="n">newcon</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">newcon</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">register_console</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">unregister_console</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">console</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_A11Y_BRAILLE_CONSOLE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">console</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_BRL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">braille_unregister_console</span><span class="p">(</span><span class="n">console</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">console_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">console_drivers</span> <span class="o">==</span> <span class="n">console</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">console_drivers</span><span class="o">=</span><span class="n">console</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">console_drivers</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">console_drivers</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">console_drivers</span> <span class="p">;</span>
		     <span class="n">a</span><span class="p">;</span> <span class="n">b</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">console</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
				<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this isn&#39;t the last console and it has CON_CONSDEV set, we</span>
<span class="cm">	 * need to set it on the next preferred console.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">console_drivers</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">console</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_CONSDEV</span><span class="p">)</span>
		<span class="n">console_drivers</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CON_CONSDEV</span><span class="p">;</span>

	<span class="n">console_unlock</span><span class="p">();</span>
	<span class="n">console_sysfs_notify</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unregister_console</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">printk_late_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">con</span><span class="p">;</span>

	<span class="n">for_each_console</span><span class="p">(</span><span class="n">con</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">keep_bootcon</span> <span class="o">&amp;&amp;</span> <span class="n">con</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_BOOT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;turn off boot console %s%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">con</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">con</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
			<span class="n">unregister_console</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">hotcpu_notifier</span><span class="p">(</span><span class="n">console_cpu_notify</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">printk_late_init</span><span class="p">);</span>

<span class="cp">#if defined CONFIG_PRINTK</span>

<span class="kt">int</span> <span class="nf">printk_sched</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">printk_sched_buf</span><span class="p">);</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">vsnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PRINTK_BUF_SIZE</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">__this_cpu_or</span><span class="p">(</span><span class="n">printk_pending</span><span class="p">,</span> <span class="n">PRINTK_PENDING_SCHED</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * printk rate limiting, lifted from the networking subsystem.</span>
<span class="cm"> *</span>
<span class="cm"> * This enforces a rate limit: not more than 10 kernel messages</span>
<span class="cm"> * every 5s to make a denial-of-service attack impossible.</span>
<span class="cm"> */</span>
<span class="n">DEFINE_RATELIMIT_STATE</span><span class="p">(</span><span class="n">printk_ratelimit_state</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__printk_ratelimit</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">___ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printk_ratelimit_state</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__printk_ratelimit</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * printk_timed_ratelimit - caller-controlled printk ratelimiting</span>
<span class="cm"> * @caller_jiffies: pointer to caller&#39;s state</span>
<span class="cm"> * @interval_msecs: minimum interval between prints</span>
<span class="cm"> *</span>
<span class="cm"> * printk_timed_ratelimit() returns true if more than @interval_msecs</span>
<span class="cm"> * milliseconds have elapsed since the last time printk_timed_ratelimit()</span>
<span class="cm"> * returned true.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">printk_timed_ratelimit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">caller_jiffies</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">interval_msecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">caller_jiffies</span> <span class="o">==</span> <span class="mi">0</span>
			<span class="o">||</span> <span class="o">!</span><span class="n">time_in_range</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="o">*</span><span class="n">caller_jiffies</span><span class="p">,</span>
					<span class="o">*</span><span class="n">caller_jiffies</span>
					<span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">interval_msecs</span><span class="p">)))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">caller_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">printk_timed_ratelimit</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">dump_list_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">dump_list</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kmsg_dump_register - register a kernel log dumper.</span>
<span class="cm"> * @dumper: pointer to the kmsg_dumper structure</span>
<span class="cm"> *</span>
<span class="cm"> * Adds a kernel log dumper to the system. The dump callback in the</span>
<span class="cm"> * structure will be called when the kernel oopses or panics and must be</span>
<span class="cm"> * set. Returns zero on success and %-EINVAL or %-EBUSY otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kmsg_dump_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmsg_dumper</span> <span class="o">*</span><span class="n">dumper</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* The dump callback needs to be set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dumper</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dump_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Don&#39;t allow registering multiple times */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dumper</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dumper</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dump_list</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dump_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kmsg_dump_register</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kmsg_dump_unregister - unregister a kmsg dumper.</span>
<span class="cm"> * @dumper: pointer to the kmsg_dumper structure</span>
<span class="cm"> *</span>
<span class="cm"> * Removes a dump device from the system. Returns zero on success and</span>
<span class="cm"> * %-EINVAL otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kmsg_dump_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmsg_dumper</span> <span class="o">*</span><span class="n">dumper</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dump_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dumper</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dumper</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dump_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">synchronize_rcu</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kmsg_dump_unregister</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">always_kmsg_dump</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">always_kmsg_dump</span><span class="p">,</span> <span class="n">always_kmsg_dump</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kmsg_dump - dump kernel log to kernel message dumpers.</span>
<span class="cm"> * @reason: the reason (oops, panic etc) for dumping</span>
<span class="cm"> *</span>
<span class="cm"> * Call each of the registered dumper&#39;s dump() callback, which can</span>
<span class="cm"> * retrieve the kmsg records with kmsg_dump_get_line() or</span>
<span class="cm"> * kmsg_dump_get_buffer().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kmsg_dump</span><span class="p">(</span><span class="k">enum</span> <span class="n">kmsg_dump_reason</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmsg_dumper</span> <span class="o">*</span><span class="n">dumper</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">reason</span> <span class="o">&gt;</span> <span class="n">KMSG_DUMP_OOPS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">always_kmsg_dump</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">dumper</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dump_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dumper</span><span class="o">-&gt;</span><span class="n">max_reason</span> <span class="o">&amp;&amp;</span> <span class="n">reason</span> <span class="o">&gt;</span> <span class="n">dumper</span><span class="o">-&gt;</span><span class="n">max_reason</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* initialize iterator with data about the stored records */</span>
		<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_seq</span> <span class="o">=</span> <span class="n">clear_seq</span><span class="p">;</span>
		<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_idx</span> <span class="o">=</span> <span class="n">clear_idx</span><span class="p">;</span>
		<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">next_seq</span> <span class="o">=</span> <span class="n">log_next_seq</span><span class="p">;</span>
		<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">next_idx</span> <span class="o">=</span> <span class="n">log_next_idx</span><span class="p">;</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* invoke dumper which will iterate over records */</span>
		<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">dumper</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>

		<span class="cm">/* reset iterator */</span>
		<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kmsg_dump_get_line - retrieve one kmsg log line</span>
<span class="cm"> * @dumper: registered kmsg dumper</span>
<span class="cm"> * @syslog: include the &quot;&lt;4&gt;&quot; prefixes</span>
<span class="cm"> * @line: buffer to copy the line to</span>
<span class="cm"> * @size: maximum size of the buffer</span>
<span class="cm"> * @len: length of line placed into buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Start at the beginning of the kmsg buffer, with the oldest kmsg</span>
<span class="cm"> * record, and copy one record into the provided buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Consecutive calls will return the next available record moving</span>
<span class="cm"> * towards the end of the buffer with the youngest messages.</span>
<span class="cm"> *</span>
<span class="cm"> * A return value of FALSE indicates that there are no more records to</span>
<span class="cm"> * read.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">kmsg_dump_get_line</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmsg_dumper</span> <span class="o">*</span><span class="n">dumper</span><span class="p">,</span> <span class="n">bool</span> <span class="n">syslog</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">line</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dumper</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_seq</span> <span class="o">&lt;</span> <span class="n">log_first_seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* messages are gone, move to first available one */</span>
		<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_seq</span> <span class="o">=</span> <span class="n">log_first_seq</span><span class="p">;</span>
		<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_idx</span> <span class="o">=</span> <span class="n">log_first_idx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* last entry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_seq</span> <span class="o">&gt;=</span> <span class="n">log_next_seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">log_from_idx</span><span class="p">(</span><span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_idx</span><span class="p">);</span>
	<span class="n">l</span> <span class="o">=</span> <span class="n">msg_print_text</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">syslog</span><span class="p">,</span>
			      <span class="n">line</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_idx</span> <span class="o">=</span> <span class="n">log_next</span><span class="p">(</span><span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_idx</span><span class="p">);</span>
	<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_seq</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span>
		<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kmsg_dump_get_line</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kmsg_dump_get_buffer - copy kmsg log lines</span>
<span class="cm"> * @dumper: registered kmsg dumper</span>
<span class="cm"> * @syslog: include the &quot;&lt;4&gt;&quot; prefixes</span>
<span class="cm"> * @buf: buffer to copy the line to</span>
<span class="cm"> * @size: maximum size of the buffer</span>
<span class="cm"> * @len: length of line placed into buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Start at the end of the kmsg buffer and fill the provided buffer</span>
<span class="cm"> * with as many of the the *youngest* kmsg records that fit into it.</span>
<span class="cm"> * If the buffer is large enough, all available kmsg records will be</span>
<span class="cm"> * copied with a single call.</span>
<span class="cm"> *</span>
<span class="cm"> * Consecutive calls will fill the buffer with the next block of</span>
<span class="cm"> * available older records, not including the earlier retrieved ones.</span>
<span class="cm"> *</span>
<span class="cm"> * A return value of FALSE indicates that there are no more records to</span>
<span class="cm"> * read.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">kmsg_dump_get_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmsg_dumper</span> <span class="o">*</span><span class="n">dumper</span><span class="p">,</span> <span class="n">bool</span> <span class="n">syslog</span><span class="p">,</span>
			  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">next_seq</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">next_idx</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dumper</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_seq</span> <span class="o">&lt;</span> <span class="n">log_first_seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* messages are gone, move to first available one */</span>
		<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_seq</span> <span class="o">=</span> <span class="n">log_first_seq</span><span class="p">;</span>
		<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_idx</span> <span class="o">=</span> <span class="n">log_first_idx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* last entry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_seq</span> <span class="o">&gt;=</span> <span class="n">dumper</span><span class="o">-&gt;</span><span class="n">next_seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* calculate length of entire buffer */</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_seq</span><span class="p">;</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_idx</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">seq</span> <span class="o">&lt;</span> <span class="n">dumper</span><span class="o">-&gt;</span><span class="n">next_seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">log_from_idx</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

		<span class="n">l</span> <span class="o">+=</span> <span class="n">msg_print_text</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">log_next</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
		<span class="n">seq</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* move first record forward until length fits into the buffer */</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_seq</span><span class="p">;</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_idx</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">seq</span> <span class="o">&lt;</span> <span class="n">dumper</span><span class="o">-&gt;</span><span class="n">next_seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">log_from_idx</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

		<span class="n">l</span> <span class="o">-=</span> <span class="n">msg_print_text</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">log_next</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
		<span class="n">seq</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* last message in next interation */</span>
	<span class="n">next_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">next_idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">seq</span> <span class="o">&lt;</span> <span class="n">dumper</span><span class="o">-&gt;</span><span class="n">next_seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">log</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">log_from_idx</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

		<span class="n">l</span> <span class="o">+=</span> <span class="n">msg_print_text</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">syslog</span><span class="p">,</span>
				    <span class="n">buf</span> <span class="o">+</span> <span class="n">l</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="n">l</span><span class="p">);</span>

		<span class="n">idx</span> <span class="o">=</span> <span class="n">log_next</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
		<span class="n">seq</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">next_seq</span> <span class="o">=</span> <span class="n">next_seq</span><span class="p">;</span>
	<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">next_idx</span> <span class="o">=</span> <span class="n">next_idx</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span>
		<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kmsg_dump_get_buffer</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kmsg_dump_rewind - reset the interator</span>
<span class="cm"> * @dumper: registered kmsg dumper</span>
<span class="cm"> *</span>
<span class="cm"> * Reset the dumper&#39;s iterator so that kmsg_dump_get_line() and</span>
<span class="cm"> * kmsg_dump_get_buffer() can be called again and used multiple</span>
<span class="cm"> * times within the same dumper.dump() callback.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kmsg_dump_rewind</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmsg_dumper</span> <span class="o">*</span><span class="n">dumper</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_seq</span> <span class="o">=</span> <span class="n">clear_seq</span><span class="p">;</span>
	<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">cur_idx</span> <span class="o">=</span> <span class="n">clear_idx</span><span class="p">;</span>
	<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">next_seq</span> <span class="o">=</span> <span class="n">log_next_seq</span><span class="p">;</span>
	<span class="n">dumper</span><span class="o">-&gt;</span><span class="n">next_idx</span> <span class="o">=</span> <span class="n">log_next_idx</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logbuf_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kmsg_dump_rewind</span><span class="p">);</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
