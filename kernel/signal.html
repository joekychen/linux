<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › signal.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>signal.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/kernel/signal.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  1997-11-02  Modified for POSIX.1b signals by Richard Henderson</span>
<span class="cm"> *</span>
<span class="cm"> *  2003-06-02  Jim Houston - Concurrent Computer Corp.</span>
<span class="cm"> *		Changes to use preallocated sigqueue structures</span>
<span class="cm"> *		to allow signals to be sent reliably.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/binfmts.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/signalfd.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &lt;linux/tracehook.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/pid_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>
<span class="cp">#include &lt;linux/user_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/uprobes.h&gt;</span>
<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/signal.h&gt;</span>

<span class="cp">#include &lt;asm/param.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/unistd.h&gt;</span>
<span class="cp">#include &lt;asm/siginfo.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &quot;audit.h&quot;	</span><span class="cm">/* audit_signal_info() */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * SLAB caches for signal bits.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">sigqueue_cachep</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">print_fatal_signals</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="nf">sig_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="n">sig</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sig_handler_ignored</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Is it explicitly or implicitly ignored? */</span>
	<span class="k">return</span> <span class="n">handler</span> <span class="o">==</span> <span class="n">SIG_IGN</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">handler</span> <span class="o">==</span> <span class="n">SIG_DFL</span> <span class="o">&amp;&amp;</span> <span class="n">sig_kernel_ignore</span><span class="p">(</span><span class="n">sig</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sig_task_ignored</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">handler</span><span class="p">;</span>

	<span class="n">handler</span> <span class="o">=</span> <span class="n">sig_handler</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_UNKILLABLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">handler</span> <span class="o">==</span> <span class="n">SIG_DFL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">force</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sig_handler_ignored</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sig_ignored</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Blocked signals are never ignored, since the</span>
<span class="cm">	 * signal handler may change by the time it is</span>
<span class="cm">	 * unblocked.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span> <span class="o">||</span> <span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">real_blocked</span><span class="p">,</span> <span class="n">sig</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sig_task_ignored</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">force</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tracers may want to know about even ignored signals.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Re-calculate pending state from the set of locally pending</span>
<span class="cm"> * signals, globally pending signals, and blocked signals.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">has_pending_signals</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">signal</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">blocked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ready</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">_NSIG_WORDS</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">_NSIG_WORDS</span><span class="p">,</span> <span class="n">ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">;)</span>
			<span class="n">ready</span> <span class="o">|=</span> <span class="n">signal</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;~</span> <span class="n">blocked</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">4</span>: <span class="n">ready</span>  <span class="o">=</span> <span class="n">signal</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;~</span> <span class="n">blocked</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="n">ready</span> <span class="o">|=</span> <span class="n">signal</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;~</span> <span class="n">blocked</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="n">ready</span> <span class="o">|=</span> <span class="n">signal</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;~</span> <span class="n">blocked</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">ready</span> <span class="o">|=</span> <span class="n">signal</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;~</span> <span class="n">blocked</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">2</span>: <span class="n">ready</span>  <span class="o">=</span> <span class="n">signal</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;~</span> <span class="n">blocked</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">ready</span> <span class="o">|=</span> <span class="n">signal</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;~</span> <span class="n">blocked</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">1</span>: <span class="n">ready</span>  <span class="o">=</span> <span class="n">signal</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;~</span> <span class="n">blocked</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ready</span> <span class="o">!=</span>	<span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PENDING(p,b) has_pending_signals(&amp;(p)-&gt;signal, (b))</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">recalc_sigpending_tsk</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_PENDING_MASK</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">PENDING</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">PENDING</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">shared_pending</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_tsk_thread_flag</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TIF_SIGPENDING</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We must never clear the flag in another thread, or in current</span>
<span class="cm">	 * when it&#39;s possible the current syscall is returning -ERESTART*.</span>
<span class="cm">	 * So we don&#39;t clear it here, and only callers who know they should do.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * After recalculating TIF_SIGPENDING, we need to make sure the task wakes up.</span>
<span class="cm"> * This is superfluous when called on current, the wakeup is a harmless no-op.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">recalc_sigpending_and_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">recalc_sigpending_tsk</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
		<span class="n">signal_wake_up</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">recalc_sigpending</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">recalc_sigpending_tsk</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">freezing</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="n">clear_thread_flag</span><span class="p">(</span><span class="n">TIF_SIGPENDING</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/* Given the mask, find the first available signal that should be serviced. */</span>

<span class="cp">#define SYNCHRONOUS_MASK \</span>
<span class="cp">	(sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \</span>
<span class="cp">	 sigmask(SIGTRAP) | sigmask(SIGFPE) | sigmask(SIGSYS))</span>

<span class="kt">int</span> <span class="nf">next_signal</span><span class="p">(</span><span class="k">struct</span> <span class="n">sigpending</span> <span class="o">*</span><span class="n">pending</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">pending</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">.</span><span class="n">sig</span><span class="p">;</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">mask</span><span class="o">-&gt;</span><span class="n">sig</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Handle the first word specially: it contains the</span>
<span class="cm">	 * synchronous signals that need to be dequeued first.</span>
<span class="cm">	 */</span>
	<span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span> <span class="o">&amp;~</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">SYNCHRONOUS_MASK</span><span class="p">)</span>
			<span class="n">x</span> <span class="o">&amp;=</span> <span class="n">SYNCHRONOUS_MASK</span><span class="p">;</span>
		<span class="n">sig</span> <span class="o">=</span> <span class="n">ffz</span><span class="p">(</span><span class="o">~</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">sig</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">_NSIG_WORDS</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_NSIG_WORDS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">x</span> <span class="o">=</span> <span class="o">*++</span><span class="n">s</span> <span class="o">&amp;~</span> <span class="o">*++</span><span class="n">m</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">sig</span> <span class="o">=</span> <span class="n">ffz</span><span class="p">(</span><span class="o">~</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">_NSIG_BPW</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;~</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">sig</span> <span class="o">=</span> <span class="n">ffz</span><span class="p">(</span><span class="o">~</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">_NSIG_BPW</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">1</span>:
		<span class="cm">/* Nothing to do */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sig</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">print_dropped_signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">DEFINE_RATELIMIT_STATE</span><span class="p">(</span><span class="n">ratelimit_state</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">print_fatal_signals</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ratelimit_state</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * task_set_jobctl_pending - set jobctl pending bits</span>
<span class="cm"> * @task: target task</span>
<span class="cm"> * @mask: pending bits to set</span>
<span class="cm"> *</span>
<span class="cm"> * Clear @mask from @task-&gt;jobctl.  @mask must be subset of</span>
<span class="cm"> * %JOBCTL_PENDING_MASK | %JOBCTL_STOP_CONSUME | %JOBCTL_STOP_SIGMASK |</span>
<span class="cm"> * %JOBCTL_TRAPPING.  If stop signo is being set, the existing signo is</span>
<span class="cm"> * cleared.  If @task is already being killed or exiting, this function</span>
<span class="cm"> * becomes noop.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Must be called with @task-&gt;sighand-&gt;siglock held.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * %true if @mask is set, %false if made noop because @task was dying.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">task_set_jobctl_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">JOBCTL_PENDING_MASK</span> <span class="o">|</span> <span class="n">JOBCTL_STOP_CONSUME</span> <span class="o">|</span>
			<span class="n">JOBCTL_STOP_SIGMASK</span> <span class="o">|</span> <span class="n">JOBCTL_TRAPPING</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">JOBCTL_TRAPPING</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">JOBCTL_PENDING_MASK</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">JOBCTL_STOP_SIGMASK</span><span class="p">)</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">JOBCTL_STOP_SIGMASK</span><span class="p">;</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * task_clear_jobctl_trapping - clear jobctl trapping bit</span>
<span class="cm"> * @task: target task</span>
<span class="cm"> *</span>
<span class="cm"> * If JOBCTL_TRAPPING is set, a ptracer is waiting for us to enter TRACED.</span>
<span class="cm"> * Clear it and wake up the ptracer.  Note that we don&#39;t need any further</span>
<span class="cm"> * locking.  @task-&gt;siglock guarantees that @task-&gt;parent points to the</span>
<span class="cm"> * ptracer.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Must be called with @task-&gt;sighand-&gt;siglock held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">task_clear_jobctl_trapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_TRAPPING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">JOBCTL_TRAPPING</span><span class="p">;</span>
		<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">jobctl</span><span class="p">,</span> <span class="n">JOBCTL_TRAPPING_BIT</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * task_clear_jobctl_pending - clear jobctl pending bits</span>
<span class="cm"> * @task: target task</span>
<span class="cm"> * @mask: pending bits to clear</span>
<span class="cm"> *</span>
<span class="cm"> * Clear @mask from @task-&gt;jobctl.  @mask must be subset of</span>
<span class="cm"> * %JOBCTL_PENDING_MASK.  If %JOBCTL_STOP_PENDING is being cleared, other</span>
<span class="cm"> * STOP bits are cleared together.</span>
<span class="cm"> *</span>
<span class="cm"> * If clearing of @mask leaves no stop or trap pending, this function calls</span>
<span class="cm"> * task_clear_jobctl_trapping().</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Must be called with @task-&gt;sighand-&gt;siglock held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">task_clear_jobctl_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">JOBCTL_PENDING_MASK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">JOBCTL_STOP_PENDING</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">JOBCTL_STOP_CONSUME</span> <span class="o">|</span> <span class="n">JOBCTL_STOP_DEQUEUED</span><span class="p">;</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_PENDING_MASK</span><span class="p">))</span>
		<span class="n">task_clear_jobctl_trapping</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * task_participate_group_stop - participate in a group stop</span>
<span class="cm"> * @task: task participating in a group stop</span>
<span class="cm"> *</span>
<span class="cm"> * @task has %JOBCTL_STOP_PENDING set and is participating in a group stop.</span>
<span class="cm"> * Group stop states are cleared and the group stop count is consumed if</span>
<span class="cm"> * %JOBCTL_STOP_CONSUME was set.  If the consumption completes the group</span>
<span class="cm"> * stop, the appropriate %SIGNAL_* flags are set.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Must be called with @task-&gt;sighand-&gt;siglock held.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * %true if group stop completion should be notified to the parent, %false</span>
<span class="cm"> * otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">task_participate_group_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">consume</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_STOP_CONSUME</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_STOP_PENDING</span><span class="p">));</span>

	<span class="n">task_clear_jobctl_pending</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">JOBCTL_STOP_PENDING</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">consume</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">group_stop_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">group_stop_count</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tell the caller to notify completion iff we are entering into a</span>
<span class="cm">	 * fresh group stop.  Read comment in do_signal_stop() for details.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">group_stop_count</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_STOP_STOPPED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">SIGNAL_STOP_STOPPED</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * allocate a new signal queue record</span>
<span class="cm"> * - this may be called without locks if and only if t == current, otherwise an</span>
<span class="cm"> *   appropriate lock must be held to stop the target task from exiting</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span>
<span class="nf">__sigqueue_alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">override_rlimit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protect access to @t credentials. This can go away when all</span>
<span class="cm">	 * callers hold rcu read lock.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">user</span> <span class="o">=</span> <span class="n">get_uid</span><span class="p">(</span><span class="n">__task_cred</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">sigpending</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">override_rlimit</span> <span class="o">||</span>
	    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">sigpending</span><span class="p">)</span> <span class="o">&lt;=</span>
			<span class="n">task_rlimit</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">RLIMIT_SIGPENDING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">sigqueue_cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">print_dropped_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">sigpending</span><span class="p">);</span>
		<span class="n">free_uid</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">=</span> <span class="n">user</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">q</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__sigqueue_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGQUEUE_PREALLOC</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">sigpending</span><span class="p">);</span>
	<span class="n">free_uid</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">sigqueue_cachep</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">flush_sigqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sigpending</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sigqueue</span> <span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">__sigqueue_free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush all pending signals for a task.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__flush_signals</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_tsk_thread_flag</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TIF_SIGPENDING</span><span class="p">);</span>
	<span class="n">flush_sigqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>
	<span class="n">flush_sigqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">shared_pending</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">flush_signals</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__flush_signals</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__flush_itimer_signals</span><span class="p">(</span><span class="k">struct</span> <span class="n">sigpending</span> <span class="o">*</span><span class="n">pending</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sigset_t</span> <span class="n">signal</span><span class="p">,</span> <span class="n">retain</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">signal</span> <span class="o">=</span> <span class="n">pending</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
	<span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retain</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pending</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_signo</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">!=</span> <span class="n">SI_TIMER</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retain</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sigdelset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">signal</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">__sigqueue_free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">sigorsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">signal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retain</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">flush_itimer_signals</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__flush_itimer_signals</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>
	<span class="n">__flush_itimer_signals</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">shared_pending</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ignore_signals</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_NSIG</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">SIG_IGN</span><span class="p">;</span>

	<span class="n">flush_signals</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush all handlers for a task.</span>
<span class="cm"> */</span>

<span class="kt">void</span>
<span class="nf">flush_signal_handlers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force_default</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="n">ka</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">_NSIG</span> <span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">force_default</span> <span class="o">||</span> <span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">!=</span> <span class="n">SIG_IGN</span><span class="p">)</span>
			<span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">SIG_DFL</span><span class="p">;</span>
		<span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
		<span class="n">ka</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">unhandled_signal</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">handler</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="n">sig</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_global_init</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handler</span> <span class="o">!=</span> <span class="n">SIG_IGN</span> <span class="o">&amp;&amp;</span> <span class="n">handler</span> <span class="o">!=</span> <span class="n">SIG_DFL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* if ptraced, let the tracer determine */</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Notify the system that a driver wants to block all signals for this</span>
<span class="cm"> * process, and wants to be notified if any signals at all were to be</span>
<span class="cm"> * sent/acted upon.  If the notifier routine returns non-zero, then the</span>
<span class="cm"> * signal will be acted upon after all.  If the notifier routine returns 0,</span>
<span class="cm"> * then then signal will be blocked.  Only one block per process is</span>
<span class="cm"> * allowed.  priv is a pointer to private data that the notifier routine</span>
<span class="cm"> * can use to determine if the signal should be blocked or not.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">block_all_signals</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">notifier</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">notifier_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">notifier_data</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">notifier</span> <span class="o">=</span> <span class="n">notifier</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Notify the system that blocking has ended. */</span>

<span class="kt">void</span>
<span class="nf">unblock_all_signals</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">notifier</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">notifier_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">recalc_sigpending</span><span class="p">();</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">collect_signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sigpending</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Collect the siginfo appropriate to this signal.  Check if</span>
<span class="cm">	 * there is another siginfo for the same signal.</span>
<span class="cm">	*/</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">==</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">still_pending</span><span class="p">;</span>
			<span class="n">first</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">sigdelset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">still_pending:</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">copy_siginfo</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">);</span>
		<span class="n">__sigqueue_free</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Ok, it wasn&#39;t in the queue.  This must be</span>
<span class="cm">		 * a fast-pathed signal or we must have been</span>
<span class="cm">		 * out of queue space.  So zero out the info.</span>
<span class="cm">		 */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">SI_USER</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_uid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__dequeue_signal</span><span class="p">(</span><span class="k">struct</span> <span class="n">sigpending</span> <span class="o">*</span><span class="n">pending</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
			<span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">next_signal</span><span class="p">(</span><span class="n">pending</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">notifier</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">notifier_mask</span><span class="p">,</span> <span class="n">sig</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">notifier</span><span class="p">)(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">notifier_data</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">clear_thread_flag</span><span class="p">(</span><span class="n">TIF_SIGPENDING</span><span class="p">);</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">collect_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">pending</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sig</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Dequeue a signal and return the element to the caller, which is</span>
<span class="cm"> * expected to free it.</span>
<span class="cm"> *</span>
<span class="cm"> * All callers have to hold the siglock.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dequeue_signal</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">signr</span><span class="p">;</span>

	<span class="cm">/* We only dequeue private signals from ourselves, we don&#39;t let</span>
<span class="cm">	 * signalfd steal them</span>
<span class="cm">	 */</span>
	<span class="n">signr</span> <span class="o">=</span> <span class="n">__dequeue_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">signr</span> <span class="o">=</span> <span class="n">__dequeue_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">shared_pending</span><span class="p">,</span>
					 <span class="n">mask</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * itimer signal ?</span>
<span class="cm">		 *</span>
<span class="cm">		 * itimers are process shared and we restart periodic</span>
<span class="cm">		 * itimers in the signal delivery path to prevent DoS</span>
<span class="cm">		 * attacks in the high resolution timer case. This is</span>
<span class="cm">		 * compliant with the old way of self-restarting</span>
<span class="cm">		 * itimers, as the SIGALRM is a legacy signal and only</span>
<span class="cm">		 * queued once. Changing the restart behaviour to</span>
<span class="cm">		 * restart the timer in the signal dequeue path is</span>
<span class="cm">		 * reducing the timer noise on heavy loaded !highres</span>
<span class="cm">		 * systems too.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">signr</span> <span class="o">==</span> <span class="n">SIGALRM</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">tmr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">real_timer</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hrtimer_is_queued</span><span class="p">(</span><span class="n">tmr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">it_real_incr</span><span class="p">.</span><span class="n">tv64</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hrtimer_forward</span><span class="p">(</span><span class="n">tmr</span><span class="p">,</span> <span class="n">tmr</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">get_time</span><span class="p">(),</span>
						<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">it_real_incr</span><span class="p">);</span>
				<span class="n">hrtimer_restart</span><span class="p">(</span><span class="n">tmr</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">recalc_sigpending</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sig_kernel_stop</span><span class="p">(</span><span class="n">signr</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set a marker that we have dequeued a stop signal.  Our</span>
<span class="cm">		 * caller might release the siglock and then the pending</span>
<span class="cm">		 * stop signal it is about to process is no longer in the</span>
<span class="cm">		 * pending bitmasks, but must still be cleared by a SIGCONT</span>
<span class="cm">		 * (and overruled by a SIGKILL).  So those cases clear this</span>
<span class="cm">		 * shared flag after we&#39;ve set it.  Note that this flag may</span>
<span class="cm">		 * remain set after the signal we return is ignored or</span>
<span class="cm">		 * handled.  That doesn&#39;t matter because its only purpose</span>
<span class="cm">		 * is to alert stop-signal processing code when another</span>
<span class="cm">		 * processor has come along and cleared the flag.</span>
<span class="cm">		 */</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">|=</span> <span class="n">JOBCTL_STOP_DEQUEUED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">&amp;</span> <span class="n">__SI_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">__SI_TIMER</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_sys_private</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Release the siglock to ensure proper locking order</span>
<span class="cm">		 * of timer locks outside of siglocks.  Note, we leave</span>
<span class="cm">		 * irqs disabled here, since the posix-timers code is</span>
<span class="cm">		 * about to disable them again anyway.</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="n">do_schedule_next_timer</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">signr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Tell a process that it has a new active signal..</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE! we rely on the previous spin_lock to</span>
<span class="cm"> * lock interrupts for us! We can only be called with</span>
<span class="cm"> * &quot;siglock&quot; held, and the local interrupt must</span>
<span class="cm"> * have been disabled when that got acquired!</span>
<span class="cm"> *</span>
<span class="cm"> * No need to set need_resched since signal event passing</span>
<span class="cm"> * goes through -&gt;blocked</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">signal_wake_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resume</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">set_tsk_thread_flag</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TIF_SIGPENDING</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * For SIGKILL, we want to wake it up in the stopped/traced/killable</span>
<span class="cm">	 * case. We don&#39;t check t-&gt;state here because there is a race with it</span>
<span class="cm">	 * executing another processor and just now entering stopped state.</span>
<span class="cm">	 * By using wake_up_state, we ensure the process will wake up and</span>
<span class="cm">	 * handle its death signal.</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">resume</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">TASK_WAKEKILL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wake_up_state</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mask</span><span class="p">))</span>
		<span class="n">kick_process</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove signals in mask from the pending set and queue.</span>
<span class="cm"> * Returns 1 if any signals were found.</span>
<span class="cm"> *</span>
<span class="cm"> * All callers must be holding the siglock.</span>
<span class="cm"> *</span>
<span class="cm"> * This version takes a sigset mask and looks at all signals,</span>
<span class="cm"> * not just those in the first mask word.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rm_from_queue_full</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sigpending</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">m</span><span class="p">;</span>

	<span class="n">sigandsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigisemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sigandnsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_signo</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">__sigqueue_free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Remove signals in mask from the pending set and queue.</span>
<span class="cm"> * Returns 1 if any signals were found.</span>
<span class="cm"> *</span>
<span class="cm"> * All callers must be holding the siglock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rm_from_queue</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sigpending</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sigtestsetmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">,</span> <span class="n">mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sigdelsetmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">&lt;</span> <span class="n">SIGRTMIN</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">sigmask</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_signo</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">__sigqueue_free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_si_special</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">info</span> <span class="o">&lt;=</span> <span class="n">SEND_SIG_FORCED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">si_fromuser</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">info</span> <span class="o">==</span> <span class="n">SEND_SIG_NOINFO</span> <span class="o">||</span>
		<span class="p">(</span><span class="o">!</span><span class="n">is_si_special</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">SI_FROMUSER</span><span class="p">(</span><span class="n">info</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * called with RCU read lock from check_kill_permission()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kill_ok_by_cred</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">tcred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">suid</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">)</span>  <span class="o">||</span>
	    <span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span>  <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">suid</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span>  <span class="n">tcred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ns_capable</span><span class="p">(</span><span class="n">tcred</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="n">CAP_KILL</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Bad permissions for sending the signal</span>
<span class="cm"> * - the caller must hold the RCU read lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_kill_permission</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">sid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">si_fromuser</span><span class="p">(</span><span class="n">info</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">audit_signal_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="cm">/* Let audit system see the signal */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">same_thread_group</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">kill_ok_by_cred</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SIGCONT</span>:
			<span class="n">sid</span> <span class="o">=</span> <span class="n">task_session</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * We don&#39;t return the error if sid == NULL. The</span>
<span class="cm">			 * task was unhashed, the caller must notice this.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sid</span> <span class="o">||</span> <span class="n">sid</span> <span class="o">==</span> <span class="n">task_session</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">security_task_kill</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ptrace_trap_notify - schedule trap to notify ptracer</span>
<span class="cm"> * @t: tracee wanting to notify tracer</span>
<span class="cm"> *</span>
<span class="cm"> * This function schedules sticky ptrace trap which is cleared on the next</span>
<span class="cm"> * TRAP_STOP to notify ptracer of an event.  @t must have been seized by</span>
<span class="cm"> * ptracer.</span>
<span class="cm"> *</span>
<span class="cm"> * If @t is running, STOP trap will be taken.  If trapped for STOP and</span>
<span class="cm"> * ptracer is listening for events, tracee is woken up so that it can</span>
<span class="cm"> * re-trap for the new event.  If trapped otherwise, STOP trap will be</span>
<span class="cm"> * eventually taken without returning to userland after the existing traps</span>
<span class="cm"> * are finished by PTRACE_CONT.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Must be called with @task-&gt;sighand-&gt;siglock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ptrace_trap_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;</span> <span class="n">PT_SEIZED</span><span class="p">));</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

	<span class="n">task_set_jobctl_pending</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">JOBCTL_TRAP_NOTIFY</span><span class="p">);</span>
	<span class="n">signal_wake_up</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_LISTENING</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle magic process-wide effects of stop/continue signals. Unlike</span>
<span class="cm"> * the signal actions, these happen immediately at signal-generation</span>
<span class="cm"> * time regardless of blocking, ignoring, or handling.  This does the</span>
<span class="cm"> * actual continuing for SIGCONT, but not the actual stopping for stop</span>
<span class="cm"> * signals. The process stop is done as a signal action for SIG_DFL.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if the signal should be actually delivered, otherwise</span>
<span class="cm"> * it should be dropped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">prepare_signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">signal</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_GROUP_EXIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The process is in the middle of dying, nothing to do.</span>
<span class="cm">		 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sig_kernel_stop</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is a stop signal.  Remove SIGCONT from all queues.</span>
<span class="cm">		 */</span>
		<span class="n">rm_from_queue</span><span class="p">(</span><span class="n">sigmask</span><span class="p">(</span><span class="n">SIGCONT</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">shared_pending</span><span class="p">);</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">rm_from_queue</span><span class="p">(</span><span class="n">sigmask</span><span class="p">(</span><span class="n">SIGCONT</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>
		<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="n">SIGCONT</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">why</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Remove all stop signals from all queues, wake all threads.</span>
<span class="cm">		 */</span>
		<span class="n">rm_from_queue</span><span class="p">(</span><span class="n">SIG_KERNEL_STOP_MASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">shared_pending</span><span class="p">);</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">task_clear_jobctl_pending</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">JOBCTL_STOP_PENDING</span><span class="p">);</span>
			<span class="n">rm_from_queue</span><span class="p">(</span><span class="n">SIG_KERNEL_STOP_MASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;</span> <span class="n">PT_SEIZED</span><span class="p">)))</span>
				<span class="n">wake_up_state</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">__TASK_STOPPED</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ptrace_trap_notify</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Notify the parent with CLD_CONTINUED if we were stopped.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If we were in the middle of a group stop, we pretend it</span>
<span class="cm">		 * was already finished, and then continued. Since SIGCHLD</span>
<span class="cm">		 * doesn&#39;t queue we report only CLD_STOPPED, as if the next</span>
<span class="cm">		 * CLD_CONTINUED was dropped.</span>
<span class="cm">		 */</span>
		<span class="n">why</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_STOP_STOPPED</span><span class="p">)</span>
			<span class="n">why</span> <span class="o">|=</span> <span class="n">SIGNAL_CLD_CONTINUED</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_stop_count</span><span class="p">)</span>
			<span class="n">why</span> <span class="o">|=</span> <span class="n">SIGNAL_CLD_STOPPED</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">why</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The first thread which returns from do_signal_stop()</span>
<span class="cm">			 * will take -&gt;siglock, notice SIGNAL_CLD_MASK, and</span>
<span class="cm">			 * notify its parent. See get_signal_to_deliver().</span>
<span class="cm">			 */</span>
			<span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">why</span> <span class="o">|</span> <span class="n">SIGNAL_STOP_CONTINUED</span><span class="p">;</span>
			<span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_stop_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_exit_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">sig_ignored</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">force</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Test if P wants to take SIG.  After we&#39;ve checked all threads with this,</span>
<span class="cm"> * it&#39;s equivalent to finding no threads not blocking SIG.  Any threads not</span>
<span class="cm"> * blocking SIG were ruled out because they are not running and already</span>
<span class="cm"> * have pending signals.  Such threads will dequeue from the shared queue</span>
<span class="cm"> * as soon as they&#39;re available, so putting the signal on the shared queue</span>
<span class="cm"> * will be equivalent to sending it to one such thread.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">wants_signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="n">sig</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="n">SIGKILL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task_is_stopped_or_traced</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">task_curr</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">complete_signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">signal</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now find a thread we can wake up to take the signal off the queue.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the main thread wants the signal, it gets first crack.</span>
<span class="cm">	 * Probably the least surprising to the average bear.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wants_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group</span> <span class="o">||</span> <span class="n">thread_group_empty</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * There is just one thread and it does not need to be woken.</span>
<span class="cm">		 * It will dequeue unblocked signals before it runs again.</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Otherwise try to find a suitable thread.</span>
<span class="cm">		 */</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">signal</span><span class="o">-&gt;</span><span class="n">curr_target</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">wants_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">next_thread</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">signal</span><span class="o">-&gt;</span><span class="n">curr_target</span><span class="p">)</span>
				<span class="cm">/*</span>
<span class="cm">				 * No thread needs to be woken.</span>
<span class="cm">				 * Any eligible threads will see</span>
<span class="cm">				 * the signal in the queue soon.</span>
<span class="cm">				 */</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">signal</span><span class="o">-&gt;</span><span class="n">curr_target</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Found a killable thread.  If the signal will be fatal,</span>
<span class="cm">	 * then start taking the whole group down immediately.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sig_fatal</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SIGNAL_UNKILLABLE</span> <span class="o">|</span> <span class="n">SIGNAL_GROUP_EXIT</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">real_blocked</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="n">SIGKILL</span> <span class="o">||</span> <span class="o">!</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This signal will be fatal to the whole group.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sig_kernel_coredump</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Start a group exit and wake everybody up.</span>
<span class="cm">			 * This way we don&#39;t have other threads</span>
<span class="cm">			 * running and doing things after a slower</span>
<span class="cm">			 * thread has the fatal signal pending.</span>
<span class="cm">			 */</span>
			<span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">SIGNAL_GROUP_EXIT</span><span class="p">;</span>
			<span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_exit_code</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>
			<span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_stop_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="n">task_clear_jobctl_pending</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">JOBCTL_PENDING_MASK</span><span class="p">);</span>
				<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">);</span>
				<span class="n">signal_wake_up</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The signal is already in the shared-pending queue.</span>
<span class="cm">	 * Tell the chosen thread to wake up and dequeue it.</span>
<span class="cm">	 */</span>
	<span class="n">signal_wake_up</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sig</span> <span class="o">==</span> <span class="n">SIGKILL</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">legacy_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sigpending</span> <span class="o">*</span><span class="n">signals</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sig</span> <span class="o">&lt;</span> <span class="n">SIGRTMIN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">signals</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_USER_NS</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">userns_fixup_signal_uid</span><span class="p">(</span><span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_user_ns</span><span class="p">()</span> <span class="o">==</span> <span class="n">task_cred_xxx</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">user_ns</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SI_FROMKERNEL</span><span class="p">(</span><span class="n">info</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_uid</span> <span class="o">=</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">task_cred_xxx</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">user_ns</span><span class="p">),</span>
					<span class="n">make_kuid</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">));</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">userns_fixup_signal_uid</span><span class="p">(</span><span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__send_signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">group</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from_ancestor_ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sigpending</span> <span class="o">*</span><span class="n">pending</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">override_rlimit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">TRACE_SIGNAL_IGNORED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prepare_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
			<span class="n">from_ancestor_ns</span> <span class="o">||</span> <span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="n">SEND_SIG_FORCED</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pending</span> <span class="o">=</span> <span class="n">group</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">shared_pending</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Short-circuit ignored signals and support queuing</span>
<span class="cm">	 * exactly one non-rt signal, so that we can get more</span>
<span class="cm">	 * detailed information about the cause of the signal.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">TRACE_SIGNAL_ALREADY_PENDING</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">legacy_queue</span><span class="p">(</span><span class="n">pending</span><span class="p">,</span> <span class="n">sig</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">TRACE_SIGNAL_DELIVERED</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * fast-pathed signals for kernel-internal things like SIGSTOP</span>
<span class="cm">	 * or SIGKILL.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="n">SEND_SIG_FORCED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_set</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Real-time signals must be queued if sent by sigqueue, or</span>
<span class="cm">	 * some other real-time mechanism.  It is implementation</span>
<span class="cm">	 * defined whether kill() does so.  We attempt to do so, on</span>
<span class="cm">	 * the principle of least surprise, but since kill is not</span>
<span class="cm">	 * allowed to fail with EAGAIN when low on memory we just</span>
<span class="cm">	 * make sure at least one signal gets delivered and don&#39;t</span>
<span class="cm">	 * pass on the info struct.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">&lt;</span> <span class="n">SIGRTMIN</span><span class="p">)</span>
		<span class="n">override_rlimit</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_si_special</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">||</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">override_rlimit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">q</span> <span class="o">=</span> <span class="n">__sigqueue_alloc</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">__GFP_NOTRACK_FALSE_POSITIVE</span><span class="p">,</span>
		<span class="n">override_rlimit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pending</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">SEND_SIG_NOINFO</span>:
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">SI_USER</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_pid</span> <span class="o">=</span> <span class="n">task_tgid_nr_ns</span><span class="p">(</span><span class="n">current</span><span class="p">,</span>
							<span class="n">task_active_pid_ns</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_uid</span> <span class="o">=</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span> <span class="n">current_uid</span><span class="p">());</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">SEND_SIG_PRIV</span>:
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">SI_KERNEL</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_uid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">copy_siginfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">from_ancestor_ns</span><span class="p">)</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">userns_fixup_signal_uid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_si_special</span><span class="p">(</span><span class="n">info</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">&gt;=</span> <span class="n">SIGRTMIN</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">!=</span> <span class="n">SI_USER</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Queue overflow, abort.  We may abort if the</span>
<span class="cm">			 * signal was rt and sent by user using something</span>
<span class="cm">			 * other than kill().</span>
<span class="cm">			 */</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">TRACE_SIGNAL_OVERFLOW_FAIL</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is a silent loss of information.  We still</span>
<span class="cm">			 * send the signal, but the *info bits are lost.</span>
<span class="cm">			 */</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">TRACE_SIGNAL_LOSE_INFO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out_set:</span>
	<span class="n">signalfd_notify</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
	<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
	<span class="n">complete_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
<span class="nl">ret:</span>
	<span class="n">trace_signal_generate</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">from_ancestor_ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PID_NS</span>
	<span class="n">from_ancestor_ns</span> <span class="o">=</span> <span class="n">si_fromuser</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="o">!</span><span class="n">task_pid_nr_ns</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">task_active_pid_ns</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">__send_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">from_ancestor_ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_fatal_signal</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s/%d: potentially unexpected fatal signal %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">signr</span><span class="p">);</span>

<span class="cp">#if defined(__i386__) &amp;&amp; !defined(__arch_um__)</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;code at %08lx: &quot;</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">insn</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">+</span> <span class="n">i</span><span class="p">)))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">insn</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">show_regs</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_print_fatal_signals</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_option</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">print_fatal_signals</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;print-fatal-signals=&quot;</span><span class="p">,</span> <span class="n">setup_print_fatal_signals</span><span class="p">);</span>

<span class="kt">int</span>
<span class="nf">__group_send_sig_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">send_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">specific_send_sig_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">send_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">do_send_sig_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
			<span class="n">bool</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">send_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
		<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Force a signal that the process can&#39;t ignore: if necessary</span>
<span class="cm"> * we unblock the signal and change any SIG_IGN to SIG_DFL.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: If we unblock the signal, we always reset it to SIG_DFL,</span>
<span class="cm"> * since we do not want to have a signal handler that was blocked</span>
<span class="cm"> * be invoked when user space had explicitly blocked it.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t want to have recursive SIGSEGV&#39;s etc, for example,</span>
<span class="cm"> * that is why we also clear SIGNAL_UNKILLABLE.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">force_sig_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">blocked</span><span class="p">,</span> <span class="n">ignored</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="n">action</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">action</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="n">sig</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">ignored</span> <span class="o">=</span> <span class="n">action</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">==</span> <span class="n">SIG_IGN</span><span class="p">;</span>
	<span class="n">blocked</span> <span class="o">=</span> <span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blocked</span> <span class="o">||</span> <span class="n">ignored</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">action</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">SIG_DFL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blocked</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sigdelset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
			<span class="n">recalc_sigpending_and_wake</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">==</span> <span class="n">SIG_DFL</span><span class="p">)</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SIGNAL_UNKILLABLE</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">specific_send_sig_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Nuke all other threads in the group.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">zap_other_threads</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_stop_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">while_each_thread</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task_clear_jobctl_pending</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">JOBCTL_PENDING_MASK</span><span class="p">);</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Don&#39;t bother with already dead threads */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">exit_state</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">);</span>
		<span class="n">signal_wake_up</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="nf">__lock_task_sighand</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">sighand</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">sighand</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sighand</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="n">local_irq_restore</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sighand</span> <span class="o">==</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sighand</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * send signal info to all the members of a group</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">group_send_sig_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">check_kill_permission</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">sig</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_send_sig_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __kill_pgrp_info() sends a signal to a process group: this is what the tty</span>
<span class="cm"> * control characters do (^C, ^Z etc)</span>
<span class="cm"> * - the caller must hold at least a readlock on tasklist_lock</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__kill_pgrp_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pgrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">success</span><span class="p">;</span>

	<span class="n">success</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">do_each_pid_task</span><span class="p">(</span><span class="n">pgrp</span><span class="p">,</span> <span class="n">PIDTYPE_PGID</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">group_send_sig_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">success</span> <span class="o">|=</span> <span class="o">!</span><span class="n">err</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">while_each_pid_task</span><span class="p">(</span><span class="n">pgrp</span><span class="p">,</span> <span class="n">PIDTYPE_PGID</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">success</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kill_pid_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="nl">retry:</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">pid_task</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">group_send_sig_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">))</span>
			<span class="cm">/*</span>
<span class="cm">			 * The task was unhashed in between, try again.</span>
<span class="cm">			 * If it is dead, pid_task() will return NULL,</span>
<span class="cm">			 * if we race with de_thread() it will find the</span>
<span class="cm">			 * new leader.</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kill_proc_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">kill_pid_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">find_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">));</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kill_as_cred_perm</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">pcred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">pcred</span><span class="o">-&gt;</span><span class="n">suid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">pcred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span>  <span class="n">pcred</span><span class="o">-&gt;</span><span class="n">suid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span>  <span class="n">pcred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* like kill_pid_info(), but doesn&#39;t use uid/euid of &quot;current&quot; */</span>
<span class="kt">int</span> <span class="nf">kill_pid_info_as_cred</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">pid_task</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">si_fromuser</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kill_as_cred_perm</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">security_task_kill</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">secid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__send_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kill_pid_info_as_cred</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * kill_something_info() interprets pid in interesting ways just like kill(2).</span>
<span class="cm"> *</span>
<span class="cm"> * POSIX specifies that kill(-1,sig) is unspecified, but what we have</span>
<span class="cm"> * is probably wrong.  Should make it like BSD or SYSV.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kill_something_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kill_pid_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">find_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">));</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__kill_pgrp_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span>
				<span class="n">pid</span> <span class="o">?</span> <span class="n">find_vpid</span><span class="p">(</span><span class="o">-</span><span class="n">pid</span><span class="p">)</span> <span class="o">:</span> <span class="n">task_pgrp</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>

		<span class="n">for_each_process</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
					<span class="o">!</span><span class="n">same_thread_group</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">group_send_sig_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
				<span class="o">++</span><span class="n">count</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">)</span>
					<span class="n">retval</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">count</span> <span class="o">?</span> <span class="n">retval</span> <span class="o">:</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These are for backward compatibility with the rest of the kernel source.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">send_sig_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure legacy kernel users don&#39;t send in bad values</span>
<span class="cm">	 * (normal paths check this in check_kill_permission).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">do_send_sig_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define __si_special(priv) \</span>
<span class="cp">	((priv) ? SEND_SIG_PRIV : SEND_SIG_NOINFO)</span>

<span class="kt">int</span>
<span class="nf">send_sig</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">send_sig_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">__si_special</span><span class="p">(</span><span class="n">priv</span><span class="p">),</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">force_sig</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">force_sig_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">SEND_SIG_PRIV</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When things go south during signal handling, we</span>
<span class="cm"> * will force a SIGSEGV. And if the signal that caused</span>
<span class="cm"> * the problem was already a SIGSEGV, we&#39;ll want to</span>
<span class="cm"> * make sure we don&#39;t even try to deliver the signal..</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">force_sigsegv</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="n">SIGSEGV</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="n">sig</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">SIG_DFL</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kill_pgrp</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__kill_pgrp_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">__si_special</span><span class="p">(</span><span class="n">priv</span><span class="p">),</span> <span class="n">pid</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kill_pgrp</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kill_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kill_pid_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">__si_special</span><span class="p">(</span><span class="n">priv</span><span class="p">),</span> <span class="n">pid</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kill_pid</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * These functions support sending signals using preallocated sigqueue</span>
<span class="cm"> * structures.  This is needed &quot;because realtime applications cannot</span>
<span class="cm"> * afford to lose notifications of asynchronous events, like timer</span>
<span class="cm"> * expirations or I/O completions&quot;.  In the case of POSIX Timers</span>
<span class="cm"> * we allocate the sigqueue structure from the timer_create.  If this</span>
<span class="cm"> * allocation fails we are able to report the failure to the application</span>
<span class="cm"> * with an EAGAIN error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="nf">sigqueue_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">__sigqueue_alloc</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SIGQUEUE_PREALLOC</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">q</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sigqueue_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGQUEUE_PREALLOC</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * We must hold -&gt;siglock while testing q-&gt;list</span>
<span class="cm">	 * to serialize with collect_signal() or with</span>
<span class="cm">	 * __exit_signal()-&gt;flush_sigqueue().</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SIGQUEUE_PREALLOC</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If it is queued it will be freed when dequeued,</span>
<span class="cm">	 * like the &quot;regular&quot; sigqueue.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
		<span class="n">q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span>
		<span class="n">__sigqueue_free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">send_sigqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_signo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sigpending</span> <span class="o">*</span><span class="n">pending</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGQUEUE_PREALLOC</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">likely</span><span class="p">(</span><span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* the signal is ignored */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">TRACE_SIGNAL_IGNORED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prepare_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If an SI_TIMER entry is already queue just increment</span>
<span class="cm">		 * the overrun count.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">!=</span> <span class="n">SI_TIMER</span><span class="p">);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_overrun</span><span class="o">++</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">TRACE_SIGNAL_ALREADY_PENDING</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">si_overrun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">signalfd_notify</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
	<span class="n">pending</span> <span class="o">=</span> <span class="n">group</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">shared_pending</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pending</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
	<span class="n">complete_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">TRACE_SIGNAL_DELIVERED</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">trace_signal_generate</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
<span class="nl">ret:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Let a parent know about the death of a child.</span>
<span class="cm"> * For a stopped/continued status change, use do_notify_parent_cldstop instead.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if our parent ignored us and so we&#39;ve switched to</span>
<span class="cm"> * self-reaping.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">do_notify_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">siginfo</span> <span class="n">info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">psig</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">autoreap</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

 	<span class="cm">/* do_notify_parent_cldstop should have been called instead.  */</span>
 	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">task_is_stopped_or_traced</span><span class="p">(</span><span class="n">tsk</span><span class="p">));</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">!=</span> <span class="n">tsk</span> <span class="o">||</span> <span class="o">!</span><span class="n">thread_group_empty</span><span class="p">(</span><span class="n">tsk</span><span class="p">)));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">!=</span> <span class="n">SIGCHLD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is only possible if parent == real_parent.</span>
<span class="cm">		 * Check if it has changed security domain.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">parent_exec_id</span> <span class="o">!=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">self_exec_id</span><span class="p">)</span>
			<span class="n">sig</span> <span class="o">=</span> <span class="n">SIGCHLD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We are under tasklist_lock here so our parent is tied to</span>
<span class="cm">	 * us and cannot change.</span>
<span class="cm">	 *</span>
<span class="cm">	 * task_active_pid_ns will always return the same pid namespace</span>
<span class="cm">	 * until a task passes through release_task.</span>
<span class="cm">	 *</span>
<span class="cm">	 * write_lock() currently calls preempt_disable() which is the</span>
<span class="cm">	 * same as rcu_read_lock(), but according to Oleg, this is not</span>
<span class="cm">	 * correct to rely on this</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_pid</span> <span class="o">=</span> <span class="n">task_pid_nr_ns</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">task_active_pid_ns</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">));</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_uid</span> <span class="o">=</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">task_cred_xxx</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">user_ns</span><span class="p">),</span>
				       <span class="n">task_uid</span><span class="p">(</span><span class="n">tsk</span><span class="p">));</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">info</span><span class="p">.</span><span class="n">si_utime</span> <span class="o">=</span> <span class="n">cputime_to_clock_t</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">+</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">utime</span><span class="p">);</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_stime</span> <span class="o">=</span> <span class="n">cputime_to_clock_t</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">stime</span> <span class="o">+</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">);</span>

	<span class="n">info</span><span class="p">.</span><span class="n">si_status</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_code</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_code</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">CLD_DUMPED</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_code</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">CLD_KILLED</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">CLD_EXITED</span><span class="p">;</span>
		<span class="n">info</span><span class="p">.</span><span class="n">si_status</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_code</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">psig</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psig</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;&amp;</span> <span class="n">sig</span> <span class="o">==</span> <span class="n">SIGCHLD</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">psig</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="n">SIGCHLD</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">==</span> <span class="n">SIG_IGN</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">psig</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="n">SIGCHLD</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">&amp;</span> <span class="n">SA_NOCLDWAIT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are exiting and our parent doesn&#39;t care.  POSIX.1</span>
<span class="cm">		 * defines special semantics for setting SIGCHLD to SIG_IGN</span>
<span class="cm">		 * or setting the SA_NOCLDWAIT flag: we should be reaped</span>
<span class="cm">		 * automatically and not left for our parent&#39;s wait4 call.</span>
<span class="cm">		 * Rather than having the parent do it as a magic kind of</span>
<span class="cm">		 * signal handler, we just set this to tell do_exit that we</span>
<span class="cm">		 * can be cleaned up without becoming a zombie.  Note that</span>
<span class="cm">		 * we still call __wake_up_parent in this case, because a</span>
<span class="cm">		 * blocked sys_wait4 might now return -ECHILD.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Whether we send SIGCHLD or not for SA_NOCLDWAIT</span>
<span class="cm">		 * is implementation-defined: we do (if you don&#39;t want</span>
<span class="cm">		 * it, just use SIG_IGN instead).</span>
<span class="cm">		 */</span>
		<span class="n">autoreap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">psig</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="n">SIGCHLD</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">==</span> <span class="n">SIG_IGN</span><span class="p">)</span>
			<span class="n">sig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">valid_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sig</span><span class="p">)</span>
		<span class="n">__group_send_sig_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">__wake_up_parent</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psig</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">autoreap</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_notify_parent_cldstop - notify parent of stopped/continued state change</span>
<span class="cm"> * @tsk: task reporting the state change</span>
<span class="cm"> * @for_ptracer: the notification is for ptracer</span>
<span class="cm"> * @why: CLD_{CONTINUED|STOPPED|TRAPPED} to report</span>
<span class="cm"> *</span>
<span class="cm"> * Notify @tsk&#39;s parent that the stopped/continued state has changed.  If</span>
<span class="cm"> * @for_ptracer is %false, @tsk&#39;s group leader notifies to its real parent.</span>
<span class="cm"> * If %true, @tsk reports to @tsk-&gt;parent which should be the ptracer.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Must be called with tasklist_lock at least read locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_notify_parent_cldstop</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
				     <span class="n">bool</span> <span class="n">for_ptracer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">why</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">siginfo</span> <span class="n">info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">sighand</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">for_ptracer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tsk</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">;</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">SIGCHLD</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * see comment in do_notify_parent() about the following 4 lines</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_pid</span> <span class="o">=</span> <span class="n">task_pid_nr_ns</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">pid_ns</span><span class="p">);</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_uid</span> <span class="o">=</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">task_cred_xxx</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">user_ns</span><span class="p">),</span> <span class="n">task_uid</span><span class="p">(</span><span class="n">tsk</span><span class="p">));</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">info</span><span class="p">.</span><span class="n">si_utime</span> <span class="o">=</span> <span class="n">cputime_to_clock_t</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">utime</span><span class="p">);</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_stime</span> <span class="o">=</span> <span class="n">cputime_to_clock_t</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">);</span>

 	<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">why</span><span class="p">;</span>
 	<span class="k">switch</span> <span class="p">(</span><span class="n">why</span><span class="p">)</span> <span class="p">{</span>
 	<span class="k">case</span> <span class="n">CLD_CONTINUED</span>:
 		<span class="n">info</span><span class="p">.</span><span class="n">si_status</span> <span class="o">=</span> <span class="n">SIGCONT</span><span class="p">;</span>
 		<span class="k">break</span><span class="p">;</span>
 	<span class="k">case</span> <span class="n">CLD_STOPPED</span>:
 		<span class="n">info</span><span class="p">.</span><span class="n">si_status</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_exit_code</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
 		<span class="k">break</span><span class="p">;</span>
 	<span class="k">case</span> <span class="n">CLD_TRAPPED</span>:
 		<span class="n">info</span><span class="p">.</span><span class="n">si_status</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_code</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
 		<span class="k">break</span><span class="p">;</span>
 	<span class="nl">default:</span>
 		<span class="n">BUG</span><span class="p">();</span>
 	<span class="p">}</span>

	<span class="n">sighand</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="n">SIGCHLD</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">!=</span> <span class="n">SIG_IGN</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="n">SIGCHLD</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">&amp;</span> <span class="n">SA_NOCLDSTOP</span><span class="p">))</span>
		<span class="n">__group_send_sig_info</span><span class="p">(</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Even if SIGCHLD is not generated, we must wake up wait4 calls.</span>
<span class="cm">	 */</span>
	<span class="n">__wake_up_parent</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">may_ptrace_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">likely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Are we in the middle of do_coredump?</span>
<span class="cm">	 * If so and our tracer is also part of the coredump stopping</span>
<span class="cm">	 * is a deadlock situation, and pointless because our tracer</span>
<span class="cm">	 * is dead so don&#39;t allow us to stop.</span>
<span class="cm">	 * If SIGKILL was already sent before the caller unlocked</span>
<span class="cm">	 * -&gt;siglock we must see -&gt;core_state != NULL. Otherwise it</span>
<span class="cm">	 * is safe to enter schedule().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">core_state</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return non-zero if there is a SIGKILL that should be waking us up.</span>
<span class="cm"> * Called with the siglock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sigkill_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>	<span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">shared_pending</span><span class="p">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This must be called with current-&gt;sighand-&gt;siglock held.</span>
<span class="cm"> *</span>
<span class="cm"> * This should be the path for all ptrace stops.</span>
<span class="cm"> * We always set current-&gt;last_siginfo while stopped here.</span>
<span class="cm"> * That makes it a way to test a stopped process for</span>
<span class="cm"> * being ptrace-stopped vs being job-control-stopped.</span>
<span class="cm"> *</span>
<span class="cm"> * If we actually decide not to stop at all because the tracer</span>
<span class="cm"> * is gone, we keep current-&gt;exit_code unless clear_code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ptrace_stop</span><span class="p">(</span><span class="kt">int</span> <span class="n">exit_code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">why</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clear_code</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">gstop_done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arch_ptrace_stop_needed</span><span class="p">(</span><span class="n">exit_code</span><span class="p">,</span> <span class="n">info</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The arch code has something special to do before a</span>
<span class="cm">		 * ptrace stop.  This is allowed to block, e.g. for faults</span>
<span class="cm">		 * on user stack pages.  We can&#39;t keep the siglock while</span>
<span class="cm">		 * calling arch_ptrace_stop, so we must release it now.</span>
<span class="cm">		 * To preserve proper semantics, we must do this before</span>
<span class="cm">		 * any signal bookkeeping like checking group_stop_count.</span>
<span class="cm">		 * Meanwhile, a SIGKILL could come in before we retake the</span>
<span class="cm">		 * siglock.  That must prevent us from sleeping in TASK_TRACED.</span>
<span class="cm">		 * So after regaining the lock, we must check for SIGKILL.</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="n">arch_ptrace_stop</span><span class="p">(</span><span class="n">exit_code</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sigkill_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re committing to trapping.  TRACED should be visible before</span>
<span class="cm">	 * TRAPPING is cleared; otherwise, the tracer might fail do_wait().</span>
<span class="cm">	 * Also, transition to TRACED and updates to -&gt;jobctl should be</span>
<span class="cm">	 * atomic with respect to siglock and should be done after the arch</span>
<span class="cm">	 * hook as siglock is released and regrabbed across it.</span>
<span class="cm">	 */</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_TRACED</span><span class="p">);</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">last_siginfo</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">exit_code</span> <span class="o">=</span> <span class="n">exit_code</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If @why is CLD_STOPPED, we&#39;re trapping to participate in a group</span>
<span class="cm">	 * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered</span>
<span class="cm">	 * across siglock relocks since INTERRUPT was scheduled, PENDING</span>
<span class="cm">	 * could be clear now.  We act as if SIGCONT is received after</span>
<span class="cm">	 * TASK_TRACED is entered - ignore it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">why</span> <span class="o">==</span> <span class="n">CLD_STOPPED</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_STOP_PENDING</span><span class="p">))</span>
		<span class="n">gstop_done</span> <span class="o">=</span> <span class="n">task_participate_group_stop</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="cm">/* any trap clears pending STOP trap, STOP trap clears NOTIFY */</span>
	<span class="n">task_clear_jobctl_pending</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">JOBCTL_TRAP_STOP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span> <span class="o">==</span> <span class="n">PTRACE_EVENT_STOP</span><span class="p">)</span>
		<span class="n">task_clear_jobctl_pending</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">JOBCTL_TRAP_NOTIFY</span><span class="p">);</span>

	<span class="cm">/* entering a trap, clear TRAPPING */</span>
	<span class="n">task_clear_jobctl_trapping</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">may_ptrace_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Notify parents of the stop.</span>
<span class="cm">		 *</span>
<span class="cm">		 * While ptraced, there are two parents - the ptracer and</span>
<span class="cm">		 * the real_parent of the group_leader.  The ptracer should</span>
<span class="cm">		 * know about every stop while the real parent is only</span>
<span class="cm">		 * interested in the completion of group stop.  The states</span>
<span class="cm">		 * for the two don&#39;t interact with each other.  Notify</span>
<span class="cm">		 * separately unless they&#39;re gonna be duplicates.</span>
<span class="cm">		 */</span>
		<span class="n">do_notify_parent_cldstop</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">why</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gstop_done</span> <span class="o">&amp;&amp;</span> <span class="n">ptrace_reparented</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="n">do_notify_parent_cldstop</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">why</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t want to allow preemption here, because</span>
<span class="cm">		 * sys_ptrace() needs this task to be inactive.</span>
<span class="cm">		 *</span>
<span class="cm">		 * XXX: implement read_unlock_no_resched().</span>
<span class="cm">		 */</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * By the time we got the lock, our tracer went away.</span>
<span class="cm">		 * Don&#39;t drop the lock yet, another tracer may come.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If @gstop_done, the ptracer went away between group stop</span>
<span class="cm">		 * completion and here.  During detach, it would have set</span>
<span class="cm">		 * JOBCTL_STOP_PENDING on us and we&#39;ll re-enter</span>
<span class="cm">		 * TASK_STOPPED in do_signal_stop() on return, so notifying</span>
<span class="cm">		 * the real parent of the group stop completion is enough.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gstop_done</span><span class="p">)</span>
			<span class="n">do_notify_parent_cldstop</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">why</span><span class="p">);</span>

		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clear_code</span><span class="p">)</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">exit_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * While in TASK_TRACED, we were considered &quot;frozen enough&quot;.</span>
<span class="cm">	 * Now that we woke up, it&#39;s crucial if we&#39;re supposed to be</span>
<span class="cm">	 * frozen that we freeze now before running anything substantial.</span>
<span class="cm">	 */</span>
	<span class="n">try_to_freeze</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are back.  Now reacquire the siglock before touching</span>
<span class="cm">	 * last_siginfo, so that we are sure to have synchronized with</span>
<span class="cm">	 * any signal-sending on another CPU that wants to examine it.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">last_siginfo</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* LISTENING can be set only during STOP traps, clear it */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">JOBCTL_LISTENING</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Queued signals ignored us while we were stopped for tracing.</span>
<span class="cm">	 * So check for any that we should take before resuming user mode.</span>
<span class="cm">	 * This sets TIF_SIGPENDING, but never clears it.</span>
<span class="cm">	 */</span>
	<span class="n">recalc_sigpending_tsk</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ptrace_do_notify</span><span class="p">(</span><span class="kt">int</span> <span class="n">signr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exit_code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">why</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">siginfo_t</span> <span class="n">info</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">info</span><span class="p">);</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">signr</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">exit_code</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_pid</span> <span class="o">=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_uid</span> <span class="o">=</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span> <span class="n">current_uid</span><span class="p">());</span>

	<span class="cm">/* Let the debugger run.  */</span>
	<span class="n">ptrace_stop</span><span class="p">(</span><span class="n">exit_code</span><span class="p">,</span> <span class="n">why</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ptrace_notify</span><span class="p">(</span><span class="kt">int</span> <span class="n">exit_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">exit_code</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x7f</span> <span class="o">|</span> <span class="o">~</span><span class="mh">0xffff</span><span class="p">))</span> <span class="o">!=</span> <span class="n">SIGTRAP</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">ptrace_do_notify</span><span class="p">(</span><span class="n">SIGTRAP</span><span class="p">,</span> <span class="n">exit_code</span><span class="p">,</span> <span class="n">CLD_TRAPPED</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_signal_stop - handle group stop for SIGSTOP and other stop signals</span>
<span class="cm"> * @signr: signr causing group stop if initiating</span>
<span class="cm"> *</span>
<span class="cm"> * If %JOBCTL_STOP_PENDING is not set yet, initiate group stop with @signr</span>
<span class="cm"> * and participate in it.  If already set, participate in the existing</span>
<span class="cm"> * group stop.  If participated in a group stop (and thus slept), %true is</span>
<span class="cm"> * returned with siglock released.</span>
<span class="cm"> *</span>
<span class="cm"> * If ptraced, this function doesn&#39;t handle stop itself.  Instead,</span>
<span class="cm"> * %JOBCTL_TRAP_STOP is scheduled and %false is returned with siglock</span>
<span class="cm"> * untouched.  The caller must ensure that INTERRUPT trap handling takes</span>
<span class="cm"> * places afterwards.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Must be called with @current-&gt;sighand-&gt;siglock held, which is released</span>
<span class="cm"> * on %true return.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * %false if group stop is already cancelled or ptrace trap is scheduled.</span>
<span class="cm"> * %true if participated in group stop.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">do_signal_stop</span><span class="p">(</span><span class="kt">int</span> <span class="n">signr</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_STOP_PENDING</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gstop</span> <span class="o">=</span> <span class="n">JOBCTL_STOP_PENDING</span> <span class="o">|</span> <span class="n">JOBCTL_STOP_CONSUME</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

		<span class="cm">/* signr will be recorded in task-&gt;jobctl for retries */</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">signr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">JOBCTL_STOP_SIGMASK</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">likely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_STOP_DEQUEUED</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">unlikely</span><span class="p">(</span><span class="n">signal_group_exit</span><span class="p">(</span><span class="n">sig</span><span class="p">)))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * There is no group stop already in progress.  We must</span>
<span class="cm">		 * initiate one now.</span>
<span class="cm">		 *</span>
<span class="cm">		 * While ptraced, a task may be resumed while group stop is</span>
<span class="cm">		 * still in effect and then receive a stop signal and</span>
<span class="cm">		 * initiate another group stop.  This deviates from the</span>
<span class="cm">		 * usual behavior as two consecutive stop signals can&#39;t</span>
<span class="cm">		 * cause two group stops when !ptraced.  That is why we</span>
<span class="cm">		 * also check !task_is_stopped(t) below.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The condition can be distinguished by testing whether</span>
<span class="cm">		 * SIGNAL_STOP_STOPPED is already set.  Don&#39;t generate</span>
<span class="cm">		 * group_exit_code in such case.</span>
<span class="cm">		 *</span>
<span class="cm">		 * This is not necessary for SIGNAL_STOP_CONTINUED because</span>
<span class="cm">		 * an intervening stop signal is required to cause two</span>
<span class="cm">		 * continued events regardless of ptrace.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_STOP_STOPPED</span><span class="p">))</span>
			<span class="n">sig</span><span class="o">-&gt;</span><span class="n">group_exit_code</span> <span class="o">=</span> <span class="n">signr</span><span class="p">;</span>

		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">group_stop_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">task_set_jobctl_pending</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">signr</span> <span class="o">|</span> <span class="n">gstop</span><span class="p">))</span>
			<span class="n">sig</span><span class="o">-&gt;</span><span class="n">group_stop_count</span><span class="o">++</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">next_thread</span><span class="p">(</span><span class="n">current</span><span class="p">);</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">current</span><span class="p">;</span>
		     <span class="n">t</span> <span class="o">=</span> <span class="n">next_thread</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Setting state to TASK_STOPPED for a group</span>
<span class="cm">			 * stop is always done with the siglock held,</span>
<span class="cm">			 * so this check has no races.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_is_stopped</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">task_set_jobctl_pending</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">signr</span> <span class="o">|</span> <span class="n">gstop</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">sig</span><span class="o">-&gt;</span><span class="n">group_stop_count</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;</span> <span class="n">PT_SEIZED</span><span class="p">)))</span>
					<span class="n">signal_wake_up</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">ptrace_trap_notify</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">notify</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If there are no other threads in the group, or if there</span>
<span class="cm">		 * is a group stop in progress and we are the last to stop,</span>
<span class="cm">		 * report to the parent.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task_participate_group_stop</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="n">notify</span> <span class="o">=</span> <span class="n">CLD_STOPPED</span><span class="p">;</span>

		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_STOPPED</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Notify the parent of the group stop completion.  Because</span>
<span class="cm">		 * we&#39;re not holding either the siglock or tasklist_lock</span>
<span class="cm">		 * here, ptracer may attach inbetween; however, this is for</span>
<span class="cm">		 * group stop and should always be delivered to the real</span>
<span class="cm">		 * parent of the group leader.  The new ptracer will get</span>
<span class="cm">		 * its notification when this task transitions into</span>
<span class="cm">		 * TASK_TRACED.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">notify</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
			<span class="n">do_notify_parent_cldstop</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">notify</span><span class="p">);</span>
			<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Now we don&#39;t run again until woken by SIGCONT or SIGKILL */</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * While ptraced, group stop is handled by STOP trap.</span>
<span class="cm">		 * Schedule it and let the caller deal with it.</span>
<span class="cm">		 */</span>
		<span class="n">task_set_jobctl_pending</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">JOBCTL_TRAP_STOP</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_jobctl_trap - take care of ptrace jobctl traps</span>
<span class="cm"> *</span>
<span class="cm"> * When PT_SEIZED, it&#39;s used for both group stop and explicit</span>
<span class="cm"> * SEIZE/INTERRUPT traps.  Both generate PTRACE_EVENT_STOP trap with</span>
<span class="cm"> * accompanying siginfo.  If stopped, lower eight bits of exit_code contain</span>
<span class="cm"> * the stop signal; otherwise, %SIGTRAP.</span>
<span class="cm"> *</span>
<span class="cm"> * When !PT_SEIZED, it&#39;s used only for group stop trap with stop signal</span>
<span class="cm"> * number as exit_code and no siginfo.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Must be called with @current-&gt;sighand-&gt;siglock held, which may be</span>
<span class="cm"> * released and re-acquired before returning with intervening sleep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_jobctl_trap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">signal</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">signr</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_STOP_SIGMASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;</span> <span class="n">PT_SEIZED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_stop_count</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_STOP_STOPPED</span><span class="p">))</span>
			<span class="n">signr</span> <span class="o">=</span> <span class="n">SIGTRAP</span><span class="p">;</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">signr</span><span class="p">);</span>
		<span class="n">ptrace_do_notify</span><span class="p">(</span><span class="n">signr</span><span class="p">,</span> <span class="n">signr</span> <span class="o">|</span> <span class="p">(</span><span class="n">PTRACE_EVENT_STOP</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
				 <span class="n">CLD_STOPPED</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">signr</span><span class="p">);</span>
		<span class="n">ptrace_stop</span><span class="p">(</span><span class="n">signr</span><span class="p">,</span> <span class="n">CLD_STOPPED</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">exit_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ptrace_signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">signr</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ptrace_signal_deliver</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We do not check sig_kernel_stop(signr) but set this marker</span>
<span class="cm">	 * unconditionally because we do not know whether debugger will</span>
<span class="cm">	 * change signr. This flag has no meaning unless we are going</span>
<span class="cm">	 * to stop after return from ptrace_stop(). In this case it will</span>
<span class="cm">	 * be checked in do_signal_stop(), we should only stop if it was</span>
<span class="cm">	 * not cleared by SIGCONT while we were sleeping. See also the</span>
<span class="cm">	 * comment in dequeue_signal().</span>
<span class="cm">	 */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">|=</span> <span class="n">JOBCTL_STOP_DEQUEUED</span><span class="p">;</span>
	<span class="n">ptrace_stop</span><span class="p">(</span><span class="n">signr</span><span class="p">,</span> <span class="n">CLD_TRAPPED</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="cm">/* We&#39;re back.  Did the debugger cancel the sig?  */</span>
	<span class="n">signr</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">exit_code</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">signr</span><span class="p">;</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">exit_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the siginfo structure if the signal has</span>
<span class="cm">	 * changed.  If the debugger wanted something</span>
<span class="cm">	 * specific in the siginfo structure then it should</span>
<span class="cm">	 * have updated *info via PTRACE_SETSIGINFO.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signr</span> <span class="o">!=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_signo</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">signr</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">SI_USER</span><span class="p">;</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_pid</span> <span class="o">=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_uid</span> <span class="o">=</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span>
						<span class="n">task_uid</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">));</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* If the (new) signal is now blocked, requeue it.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="n">signr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">specific_send_sig_info</span><span class="p">(</span><span class="n">signr</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="n">signr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">signr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get_signal_to_deliver</span><span class="p">(</span><span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="n">return_ka</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">sighand</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">signal</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">signr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">uprobe_deny_signal</span><span class="p">()))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">relock:</span>
	<span class="cm">/*</span>
<span class="cm">	 * We&#39;ll jump back here after any time we were stopped in TASK_STOPPED.</span>
<span class="cm">	 * While in TASK_STOPPED, we were considered &quot;frozen enough&quot;.</span>
<span class="cm">	 * Now that we woke up, it&#39;s crucial if we&#39;re supposed to be</span>
<span class="cm">	 * frozen that we freeze now before running anything substantial.</span>
<span class="cm">	 */</span>
	<span class="n">try_to_freeze</span><span class="p">();</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Every stopped thread goes here after wakeup. Check to see if</span>
<span class="cm">	 * we should notify the parent, prepare_signal(SIGCONT) encodes</span>
<span class="cm">	 * the CLD_ si_code into SIGNAL_CLD_MASK bits.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_CLD_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">why</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_CLD_CONTINUED</span><span class="p">)</span>
			<span class="n">why</span> <span class="o">=</span> <span class="n">CLD_CONTINUED</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">why</span> <span class="o">=</span> <span class="n">CLD_STOPPED</span><span class="p">;</span>

		<span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SIGNAL_CLD_MASK</span><span class="p">;</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Notify the parent that we&#39;re continuing.  This event is</span>
<span class="cm">		 * always per-process and doesn&#39;t make whole lot of sense</span>
<span class="cm">		 * for ptracers, who shouldn&#39;t consume the state via</span>
<span class="cm">		 * wait(2) either, but, for backward compatibility, notify</span>
<span class="cm">		 * the ptracer of the group leader too unless it&#39;s gonna be</span>
<span class="cm">		 * a duplicate.</span>
<span class="cm">		 */</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="n">do_notify_parent_cldstop</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">why</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ptrace_reparented</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">))</span>
			<span class="n">do_notify_parent_cldstop</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">,</span>
						<span class="nb">true</span><span class="p">,</span> <span class="n">why</span><span class="p">);</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">relock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="n">ka</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_STOP_PENDING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">do_signal_stop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">relock</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_TRAP_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">do_jobctl_trap</span><span class="p">();</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">relock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">signr</span> <span class="o">=</span> <span class="n">dequeue_signal</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signr</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span> <span class="cm">/* will return 0 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">signr</span> <span class="o">!=</span> <span class="n">SIGKILL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">signr</span> <span class="o">=</span> <span class="n">ptrace_signal</span><span class="p">(</span><span class="n">signr</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span>
					      <span class="n">regs</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signr</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ka</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="n">signr</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>

		<span class="cm">/* Trace actually delivered signals. */</span>
		<span class="n">trace_signal_deliver</span><span class="p">(</span><span class="n">signr</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">ka</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">==</span> <span class="n">SIG_IGN</span><span class="p">)</span> <span class="cm">/* Do nothing.  */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">!=</span> <span class="n">SIG_DFL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Run the handler.  */</span>
			<span class="o">*</span><span class="n">return_ka</span> <span class="o">=</span> <span class="o">*</span><span class="n">ka</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">&amp;</span> <span class="n">SA_ONESHOT</span><span class="p">)</span>
				<span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">SIG_DFL</span><span class="p">;</span>

			<span class="k">break</span><span class="p">;</span> <span class="cm">/* will return non-zero &quot;signr&quot; value */</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Now we are doing the default action for this signal.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sig_kernel_ignore</span><span class="p">(</span><span class="n">signr</span><span class="p">))</span> <span class="cm">/* Default is nothing. */</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Global init gets no signals it doesn&#39;t want.</span>
<span class="cm">		 * Container-init gets no signals it doesn&#39;t want from same</span>
<span class="cm">		 * container.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note that if global/container-init sees a sig_kernel_only()</span>
<span class="cm">		 * signal here, the signal must have been generated internally</span>
<span class="cm">		 * or must have come from an ancestor namespace. In either</span>
<span class="cm">		 * case, the signal cannot be dropped.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_UNKILLABLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="n">sig_kernel_only</span><span class="p">(</span><span class="n">signr</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sig_kernel_stop</span><span class="p">(</span><span class="n">signr</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The default action is to stop all threads in</span>
<span class="cm">			 * the thread group.  The job control signals</span>
<span class="cm">			 * do nothing in an orphaned pgrp, but SIGSTOP</span>
<span class="cm">			 * always works.  Note that siglock needs to be</span>
<span class="cm">			 * dropped during the call to is_orphaned_pgrp()</span>
<span class="cm">			 * because of lock ordering with tasklist_lock.</span>
<span class="cm">			 * This allows an intervening SIGCONT to be posted.</span>
<span class="cm">			 * We need to check for that and bail out if necessary.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signr</span> <span class="o">!=</span> <span class="n">SIGSTOP</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

				<span class="cm">/* signals can be posted during this window */</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">is_current_pgrp_orphaned</span><span class="p">())</span>
					<span class="k">goto</span> <span class="n">relock</span><span class="p">;</span>

				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">do_signal_stop</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">si_signo</span><span class="p">)))</span> <span class="p">{</span>
				<span class="cm">/* It released the siglock.  */</span>
				<span class="k">goto</span> <span class="n">relock</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * We didn&#39;t actually stop, due to a race</span>
<span class="cm">			 * with SIGCONT or something like that.</span>
<span class="cm">			 */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Anything else is fatal, maybe with a core dump.</span>
<span class="cm">		 */</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_SIGNALED</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sig_kernel_coredump</span><span class="p">(</span><span class="n">signr</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">print_fatal_signals</span><span class="p">)</span>
				<span class="n">print_fatal_signal</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_signo</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If it was able to dump core, this kills all</span>
<span class="cm">			 * other threads in the group and synchronizes with</span>
<span class="cm">			 * their demise.  If we lost the race with another</span>
<span class="cm">			 * thread getting here, it set group_exit_code</span>
<span class="cm">			 * first and our do_group_exit call below will use</span>
<span class="cm">			 * that value and ignore the one we pass it.</span>
<span class="cm">			 */</span>
			<span class="n">do_coredump</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">si_signo</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_signo</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Death signals, no core dump.</span>
<span class="cm">		 */</span>
		<span class="n">do_group_exit</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">si_signo</span><span class="p">);</span>
		<span class="cm">/* NOTREACHED */</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">signr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * signal_delivered - </span>
<span class="cm"> * @sig:		number of signal being delivered</span>
<span class="cm"> * @info:		siginfo_t of signal being delivered</span>
<span class="cm"> * @ka:			sigaction setting that chose the handler</span>
<span class="cm"> * @regs:		user register state</span>
<span class="cm"> * @stepping:		nonzero if debugger single-step or block-step in use</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called when a signal has succesfully been</span>
<span class="cm"> * delivered. It updates the blocked signals accordingly (@ka-&gt;sa.sa_mask</span>
<span class="cm"> * is always blocked, and the signal itself is blocked unless %SA_NODEFER</span>
<span class="cm"> * is set in @ka-&gt;sa.sa_flags.  Tracing is notified.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">signal_delivered</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="n">ka</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stepping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sigset_t</span> <span class="n">blocked</span><span class="p">;</span>

	<span class="cm">/* A signal was successfully delivered, and the</span>
<span class="cm">	   saved sigmask was stored on the signal frame,</span>
<span class="cm">	   and will be restored by sigreturn.  So we can</span>
<span class="cm">	   simply clear the restore sigmask flag.  */</span>
	<span class="n">clear_restore_sigmask</span><span class="p">();</span>

	<span class="n">sigorsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">&amp;</span> <span class="n">SA_NODEFER</span><span class="p">))</span>
		<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocked</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
	<span class="n">set_current_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocked</span><span class="p">);</span>
	<span class="n">tracehook_signal_handler</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">ka</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">stepping</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * It could be that complete_signal() picked us to notify about the</span>
<span class="cm"> * group-wide signal. Other threads should be notified now to take</span>
<span class="cm"> * the shared signals in @which since we will not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">retarget_shared_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">which</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sigset_t</span> <span class="n">retarget</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="n">sigandsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retarget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">shared_pending</span><span class="p">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">which</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigisemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retarget</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">tsk</span><span class="p">;</span>
	<span class="n">while_each_thread</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_pending_signals</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retarget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* Remove the signals this thread can handle. */</span>
		<span class="n">sigandsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retarget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retarget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
			<span class="n">signal_wake_up</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sigisemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retarget</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">exit_signals</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">group_stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">unblocked</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * @tsk is about to have PF_EXITING set - lock out users which</span>
<span class="cm">	 * expect stable threadgroup.</span>
<span class="cm">	 */</span>
	<span class="n">threadgroup_change_begin</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">thread_group_empty</span><span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="o">||</span> <span class="n">signal_group_exit</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_EXITING</span><span class="p">;</span>
		<span class="n">threadgroup_change_end</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * From now this task is not visible for group-wide signals,</span>
<span class="cm">	 * see wants_signal(), do_signal_stop().</span>
<span class="cm">	 */</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_EXITING</span><span class="p">;</span>

	<span class="n">threadgroup_change_end</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">unblocked</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">;</span>
	<span class="n">signotset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unblocked</span><span class="p">);</span>
	<span class="n">retarget_shared_pending</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unblocked</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">jobctl</span> <span class="o">&amp;</span> <span class="n">JOBCTL_STOP_PENDING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">task_participate_group_stop</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
		<span class="n">group_stop</span> <span class="o">=</span> <span class="n">CLD_STOPPED</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If group stop has completed, deliver the notification.  This</span>
<span class="cm">	 * should always go to the real parent of the group leader.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">group_stop</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="n">do_notify_parent_cldstop</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">group_stop</span><span class="p">);</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">recalc_sigpending</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dequeue_signal</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">flush_signals</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">force_sig</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">send_sig</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">send_sig_info</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sigprocmask</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">block_all_signals</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unblock_all_signals</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * System call entry points.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *  sys_restart_syscall - restart a system call</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">restart_syscall</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">restart_block</span> <span class="o">*</span><span class="n">restart</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">restart_block</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">restart</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">(</span><span class="n">restart</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="n">do_no_restart_syscall</span><span class="p">(</span><span class="k">struct</span> <span class="n">restart_block</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__set_task_blocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">const</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">newset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">thread_group_empty</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sigset_t</span> <span class="n">newblocked</span><span class="p">;</span>
		<span class="cm">/* A set of now blocked but previously unblocked signals. */</span>
		<span class="n">sigandnsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newblocked</span><span class="p">,</span> <span class="n">newset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">);</span>
		<span class="n">retarget_shared_pending</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newblocked</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">blocked</span> <span class="o">=</span> <span class="o">*</span><span class="n">newset</span><span class="p">;</span>
	<span class="n">recalc_sigpending</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * set_current_blocked - change current-&gt;blocked mask</span>
<span class="cm"> * @newset: new mask</span>
<span class="cm"> *</span>
<span class="cm"> * It is wrong to change -&gt;blocked directly, this helper should be used</span>
<span class="cm"> * to ensure the process can&#39;t miss a shared signal we are going to block.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">set_current_blocked</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">newset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">sigdelsetmask</span><span class="p">(</span><span class="n">newset</span><span class="p">,</span> <span class="n">sigmask</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">)</span> <span class="o">|</span> <span class="n">sigmask</span><span class="p">(</span><span class="n">SIGSTOP</span><span class="p">));</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">__set_task_blocked</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">newset</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__set_current_blocked</span><span class="p">(</span><span class="k">const</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">newset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">__set_task_blocked</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">newset</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is also useful for kernel threads that want to temporarily</span>
<span class="cm"> * (or permanently) block certain signals.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE! Unlike the user-mode sys_sigprocmask(), the kernel</span>
<span class="cm"> * interface happily blocks &quot;unblockable&quot; signals like SIGKILL</span>
<span class="cm"> * and friends.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sigprocmask</span><span class="p">(</span><span class="kt">int</span> <span class="n">how</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">oldset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">newset</span><span class="p">;</span>

	<span class="cm">/* Lockless, only current can change -&gt;blocked, never from irq */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldset</span><span class="p">)</span>
		<span class="o">*</span><span class="n">oldset</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">how</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIG_BLOCK</span>:
		<span class="n">sigorsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIG_UNBLOCK</span>:
		<span class="n">sigandnsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIG_SETMASK</span>:
		<span class="n">newset</span> <span class="o">=</span> <span class="o">*</span><span class="n">set</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">__set_current_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  sys_rt_sigprocmask - change the list of currently blocked signals</span>
<span class="cm"> *  @how: whether to add, remove, or set signals</span>
<span class="cm"> *  @nset: stores pending signals</span>
<span class="cm"> *  @oset: previous value of signal mask if non-null</span>
<span class="cm"> *  @sigsetsize: size of sigset_t type</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">rt_sigprocmask</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">nset</span><span class="p">,</span>
		<span class="n">sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">oset</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">sigsetsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sigset_t</span> <span class="n">old_set</span><span class="p">,</span> <span class="n">new_set</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* XXX: Don&#39;t preclude handling different sized sigset_t&#39;s.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigsetsize</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sigset_t</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">old_set</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nset</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_set</span><span class="p">,</span> <span class="n">nset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sigset_t</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">sigdelsetmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_set</span><span class="p">,</span> <span class="n">sigmask</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">)</span><span class="o">|</span><span class="n">sigmask</span><span class="p">(</span><span class="n">SIGSTOP</span><span class="p">));</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">sigprocmask</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_set</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oset</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">oset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_set</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sigset_t</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="n">do_sigpending</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sigsetsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">pending</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sigsetsize</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sigset_t</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">sigorsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">.</span><span class="n">signal</span><span class="p">,</span>
		  <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">shared_pending</span><span class="p">.</span><span class="n">signal</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

	<span class="cm">/* Outside the lock because only this thread touches it.  */</span>
	<span class="n">sigandsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pending</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pending</span><span class="p">,</span> <span class="n">sigsetsize</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  sys_rt_sigpending - examine a pending signal that has been raised</span>
<span class="cm"> *			while blocked</span>
<span class="cm"> *  @set: stores pending signals</span>
<span class="cm"> *  @sigsetsize: size of sigset_t type or larger</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">rt_sigpending</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">set</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">sigsetsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_sigpending</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="n">sigsetsize</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef HAVE_ARCH_COPY_SIGINFO_TO_USER</span>

<span class="kt">int</span> <span class="n">copy_siginfo_to_user</span><span class="p">(</span><span class="n">siginfo_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span> <span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">siginfo_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">__copy_to_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">siginfo_t</span><span class="p">))</span>
			<span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If you change siginfo_t structure, please be sure</span>
<span class="cm">	 * this code is fixed accordingly.</span>
<span class="cm">	 * Please remember to update the signalfd_copyinfo() function</span>
<span class="cm">	 * inside fs/signalfd.c too, in case siginfo_t changes.</span>
<span class="cm">	 * It should never copy any pad contained in the structure</span>
<span class="cm">	 * to avoid security leaks, but must copy the generic</span>
<span class="cm">	 * 3 ints plus the relevant union member.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_signo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_signo</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_errno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_errno</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">((</span><span class="kt">short</span><span class="p">)</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_code</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">&amp;</span> <span class="n">__SI_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">__SI_KILL</span>:
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">__SI_TIMER</span>:
		 <span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_tid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_tid</span><span class="p">);</span>
		 <span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_overrun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_overrun</span><span class="p">);</span>
		 <span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_ptr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">__SI_POLL</span>:
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_band</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_band</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_fd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">__SI_FAULT</span>:
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_addr</span><span class="p">);</span>
<span class="cp">#ifdef __ARCH_SI_TRAPNO</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_trapno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_trapno</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef BUS_MCEERR_AO</span>
		<span class="cm">/*</span>
<span class="cm">		 * Other callers might not initialize the si_lsb field,</span>
<span class="cm">		 * so check explicitly for the right codes here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">==</span> <span class="n">BUS_MCEERR_AR</span> <span class="o">||</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">==</span> <span class="n">BUS_MCEERR_AO</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_addr_lsb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_addr_lsb</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">__SI_CHLD</span>:
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_status</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_utime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_utime</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_stime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_stime</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">__SI_RT</span>: <span class="cm">/* This is not generated by the kernel as of now. */</span>
	<span class="k">case</span> <span class="n">__SI_MESGQ</span>: <span class="cm">/* But this is */</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_ptr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef __ARCH_SIGSYS</span>
	<span class="k">case</span> <span class="n">__SI_SYS</span>:
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_call_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_call_addr</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_syscall</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_syscall</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_arch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_arch</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="nl">default:</span> <span class="cm">/* this is just in case for now ... */</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">si_uid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *  do_sigtimedwait - wait for queued signals specified in @which</span>
<span class="cm"> *  @which: queued signals to wait for</span>
<span class="cm"> *  @info: if non-null, the signal&#39;s siginfo is returned here</span>
<span class="cm"> *  @ts: upper bound on process time suspension</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">do_sigtimedwait</span><span class="p">(</span><span class="k">const</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">which</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="o">*</span><span class="n">which</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sig</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timespec_valid</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">timespec_to_jiffies</span><span class="p">(</span><span class="n">ts</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We can be close to the next tick, add another one</span>
<span class="cm">		 * to ensure we will wait at least the time asked for.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">||</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">)</span>
			<span class="n">timeout</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Invert the set of allowed signals to get those we want to block.</span>
<span class="cm">	 */</span>
	<span class="n">sigdelsetmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">sigmask</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">)</span> <span class="o">|</span> <span class="n">sigmask</span><span class="p">(</span><span class="n">SIGSTOP</span><span class="p">));</span>
	<span class="n">signotset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">sig</span> <span class="o">=</span> <span class="n">dequeue_signal</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sig</span> <span class="o">&amp;&amp;</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * None ready, temporarily unblock those we&#39;re interested</span>
<span class="cm">		 * while we are sleeping in so that we&#39;ll be awakened when</span>
<span class="cm">		 * they arrive. Unblocking is always fine, we can avoid</span>
<span class="cm">		 * set_current_blocked().</span>
<span class="cm">		 */</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">real_blocked</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">;</span>
		<span class="n">sigandsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>
		<span class="n">recalc_sigpending</span><span class="p">();</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

		<span class="n">timeout</span> <span class="o">=</span> <span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="n">__set_task_blocked</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">real_blocked</span><span class="p">);</span>
		<span class="n">siginitset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">real_blocked</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">sig</span> <span class="o">=</span> <span class="n">dequeue_signal</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sig</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sig</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">timeout</span> <span class="o">?</span> <span class="o">-</span><span class="n">EINTR</span> <span class="o">:</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  sys_rt_sigtimedwait - synchronously wait for queued signals specified</span>
<span class="cm"> *			in @uthese</span>
<span class="cm"> *  @uthese: queued signals to wait for</span>
<span class="cm"> *  @uinfo: if non-null, the signal&#39;s siginfo is returned here</span>
<span class="cm"> *  @uts: upper bound on process time suspension</span>
<span class="cm"> *  @sigsetsize: size of sigset_t type</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">rt_sigtimedwait</span><span class="p">,</span> <span class="k">const</span> <span class="n">sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">uthese</span><span class="p">,</span>
		<span class="n">siginfo_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">uinfo</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">uts</span><span class="p">,</span>
		<span class="kt">size_t</span><span class="p">,</span> <span class="n">sigsetsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sigset_t</span> <span class="n">these</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>
	<span class="n">siginfo_t</span> <span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* XXX: Don&#39;t preclude handling different sized sigset_t&#39;s.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigsetsize</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sigset_t</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">these</span><span class="p">,</span> <span class="n">uthese</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">these</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uts</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">,</span> <span class="n">uts</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ts</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_sigtimedwait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">these</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">uts</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">ts</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">uinfo</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_siginfo_to_user</span><span class="p">(</span><span class="n">uinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  sys_kill - send a signal to a process</span>
<span class="cm"> *  @pid: the PID of the process</span>
<span class="cm"> *  @sig: signal to be sent</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">kill</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">siginfo</span> <span class="n">info</span><span class="p">;</span>

	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">SI_USER</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_pid</span> <span class="o">=</span> <span class="n">task_tgid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_uid</span> <span class="o">=</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span> <span class="n">current_uid</span><span class="p">());</span>

	<span class="k">return</span> <span class="n">kill_something_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="n">do_send_specific</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">tgid</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tgid</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">task_tgid_vnr</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">tgid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">check_kill_permission</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * The null signal is a permissions and process existence</span>
<span class="cm">		 * probe.  No signal is actually delivered.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">do_send_sig_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If lock_task_sighand() failed we pretend the task</span>
<span class="cm">			 * dies after receiving the signal. The window is tiny,</span>
<span class="cm">			 * and the signal is private anyway.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">))</span>
				<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">do_tkill</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">tgid</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">siginfo</span> <span class="n">info</span><span class="p">;</span>

	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">SI_TKILL</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_pid</span> <span class="o">=</span> <span class="n">task_tgid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_uid</span> <span class="o">=</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span> <span class="n">current_uid</span><span class="p">());</span>

	<span class="k">return</span> <span class="n">do_send_specific</span><span class="p">(</span><span class="n">tgid</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  sys_tgkill - send signal to one specific thread</span>
<span class="cm"> *  @tgid: the thread group ID of the thread</span>
<span class="cm"> *  @pid: the PID of the thread</span>
<span class="cm"> *  @sig: signal to be sent</span>
<span class="cm"> *</span>
<span class="cm"> *  This syscall also checks the @tgid and returns -ESRCH even if the PID</span>
<span class="cm"> *  exists but it&#39;s not belonging to the target process anymore. This</span>
<span class="cm"> *  method solves the problem of threads exiting and PIDs getting reused.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">tgkill</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">tgid</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This is only valid for single tasks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tgid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">do_tkill</span><span class="p">(</span><span class="n">tgid</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  sys_tkill - send signal to one specific task</span>
<span class="cm"> *  @pid: the PID of the task</span>
<span class="cm"> *  @sig: signal to be sent</span>
<span class="cm"> *</span>
<span class="cm"> *  Send a signal to only one task, even if it&#39;s a CLONE_THREAD task.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">tkill</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This is only valid for single tasks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">do_tkill</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  sys_rt_sigqueueinfo - send signal information to a signal</span>
<span class="cm"> *  @pid: the PID of the thread</span>
<span class="cm"> *  @sig: signal to be sent</span>
<span class="cm"> *  @uinfo: signal info to be sent</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">rt_sigqueueinfo</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span>
		<span class="n">siginfo_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">siginfo_t</span> <span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">uinfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">siginfo_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* Not even root can pretend to send signals from the kernel.</span>
<span class="cm">	 * Nor can they impersonate a kill()/tgkill(), which adds source info.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">==</span> <span class="n">SI_TKILL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We used to allow any &lt; 0 si_code */</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">si_code</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>

	<span class="cm">/* POSIX.1b doesn&#39;t mention process groups.  */</span>
	<span class="k">return</span> <span class="n">kill_proc_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="n">do_rt_tgsigqueueinfo</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">tgid</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This is only valid for single tasks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tgid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Not even root can pretend to send signals from the kernel.</span>
<span class="cm">	 * Nor can they impersonate a kill()/tgkill(), which adds source info.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">==</span> <span class="n">SI_TKILL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We used to allow any &lt; 0 si_code */</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">do_send_specific</span><span class="p">(</span><span class="n">tgid</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">rt_tgsigqueueinfo</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">tgid</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span>
		<span class="n">siginfo_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">siginfo_t</span> <span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">uinfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">siginfo_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">do_rt_tgsigqueueinfo</span><span class="p">(</span><span class="n">tgid</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">do_sigaction</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="n">act</span><span class="p">,</span> <span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="n">oact</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="n">k</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">||</span> <span class="n">sig</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="n">act</span> <span class="o">&amp;&amp;</span> <span class="n">sig_kernel_only</span><span class="p">(</span><span class="n">sig</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="n">sig</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oact</span><span class="p">)</span>
		<span class="o">*</span><span class="n">oact</span> <span class="o">=</span> <span class="o">*</span><span class="n">k</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">act</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sigdelsetmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">act</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">,</span>
			      <span class="n">sigmask</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">)</span> <span class="o">|</span> <span class="n">sigmask</span><span class="p">(</span><span class="n">SIGSTOP</span><span class="p">));</span>
		<span class="o">*</span><span class="n">k</span> <span class="o">=</span> <span class="o">*</span><span class="n">act</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * POSIX 3.3.1.3:</span>
<span class="cm">		 *  &quot;Setting a signal action to SIG_IGN for a signal that is</span>
<span class="cm">		 *   pending shall cause the pending signal to be discarded,</span>
<span class="cm">		 *   whether or not it is blocked.&quot;</span>
<span class="cm">		 *</span>
<span class="cm">		 *  &quot;Setting a signal action to SIG_DFL for a signal that is</span>
<span class="cm">		 *   pending and whose default action is to ignore the signal</span>
<span class="cm">		 *   (for example, SIGCHLD), shall cause the pending signal to</span>
<span class="cm">		 *   be discarded, whether or not it is blocked&quot;</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sig_handler_ignored</span><span class="p">(</span><span class="n">sig_handler</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sig</span><span class="p">),</span> <span class="n">sig</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>
			<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
			<span class="n">rm_from_queue_full</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">shared_pending</span><span class="p">);</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="n">rm_from_queue_full</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>
				<span class="n">t</span> <span class="o">=</span> <span class="n">next_thread</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">current</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> 
<span class="n">do_sigaltstack</span> <span class="p">(</span><span class="k">const</span> <span class="n">stack_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uss</span><span class="p">,</span> <span class="n">stack_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uoss</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">stack_t</span> <span class="n">oss</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">oss</span><span class="p">.</span><span class="n">ss_sp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_sp</span><span class="p">;</span>
	<span class="n">oss</span><span class="p">.</span><span class="n">ss_size</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_size</span><span class="p">;</span>
	<span class="n">oss</span><span class="p">.</span><span class="n">ss_flags</span> <span class="o">=</span> <span class="n">sas_ss_flags</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uss</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ss_sp</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">ss_size</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ss_flags</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">uss</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uss</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">ss_sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uss</span><span class="o">-&gt;</span><span class="n">ss_sp</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">__get_user</span><span class="p">(</span><span class="n">ss_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uss</span><span class="o">-&gt;</span><span class="n">ss_flags</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">__get_user</span><span class="p">(</span><span class="n">ss_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uss</span><span class="o">-&gt;</span><span class="n">ss_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">on_sig_stack</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note - this code used to test ss_flags incorrectly:</span>
<span class="cm">		 *  	  old code may have been written using ss_flags==0</span>
<span class="cm">		 *	  to mean ss_flags==SS_ONSTACK (as this was the only</span>
<span class="cm">		 *	  way that worked) - this fix preserves that older</span>
<span class="cm">		 *	  mechanism.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss_flags</span> <span class="o">!=</span> <span class="n">SS_DISABLE</span> <span class="o">&amp;&amp;</span> <span class="n">ss_flags</span> <span class="o">!=</span> <span class="n">SS_ONSTACK</span> <span class="o">&amp;&amp;</span> <span class="n">ss_flags</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ss_flags</span> <span class="o">==</span> <span class="n">SS_DISABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ss_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ss_sp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss_size</span> <span class="o">&lt;</span> <span class="n">MINSIGSTKSZ</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_sp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ss_sp</span><span class="p">;</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_size</span> <span class="o">=</span> <span class="n">ss_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uoss</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">uoss</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uoss</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">oss</span><span class="p">.</span><span class="n">ss_sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uoss</span><span class="o">-&gt;</span><span class="n">ss_sp</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">__put_user</span><span class="p">(</span><span class="n">oss</span><span class="p">.</span><span class="n">ss_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uoss</span><span class="o">-&gt;</span><span class="n">ss_size</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">__put_user</span><span class="p">(</span><span class="n">oss</span><span class="p">.</span><span class="n">ss_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uoss</span><span class="o">-&gt;</span><span class="n">ss_flags</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef __ARCH_WANT_SYS_SIGPENDING</span>

<span class="cm">/**</span>
<span class="cm"> *  sys_sigpending - examine pending signals</span>
<span class="cm"> *  @set: where mask of pending signal is returned</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">sigpending</span><span class="p">,</span> <span class="n">old_sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_sigpending</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">set</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cp">#ifdef __ARCH_WANT_SYS_SIGPROCMASK</span>
<span class="cm">/**</span>
<span class="cm"> *  sys_sigprocmask - examine and change blocked signals</span>
<span class="cm"> *  @how: whether to add, remove, or set signals</span>
<span class="cm"> *  @nset: signals to add or remove (if non-null)</span>
<span class="cm"> *  @oset: previous value of signal mask if non-null</span>
<span class="cm"> *</span>
<span class="cm"> * Some platforms have their own version with special arguments;</span>
<span class="cm"> * others support only sys_rt_sigprocmask.</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">sigprocmask</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">old_sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">nset</span><span class="p">,</span>
		<span class="n">old_sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">oset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">old_sigset_t</span> <span class="n">old_set</span><span class="p">,</span> <span class="n">new_set</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">new_blocked</span><span class="p">;</span>

	<span class="n">old_set</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nset</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_set</span><span class="p">,</span> <span class="n">nset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nset</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">new_set</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">sigmask</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">)</span> <span class="o">|</span> <span class="n">sigmask</span><span class="p">(</span><span class="n">SIGSTOP</span><span class="p">));</span>

		<span class="n">new_blocked</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">how</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SIG_BLOCK</span>:
			<span class="n">sigaddsetmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_blocked</span><span class="p">,</span> <span class="n">new_set</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SIG_UNBLOCK</span>:
			<span class="n">sigdelsetmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_blocked</span><span class="p">,</span> <span class="n">new_set</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SIG_SETMASK</span>:
			<span class="n">new_blocked</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_set</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">__set_current_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_blocked</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oset</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">oset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_set</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">oset</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __ARCH_WANT_SYS_SIGPROCMASK */</span><span class="cp"></span>

<span class="cp">#ifdef __ARCH_WANT_SYS_RT_SIGACTION</span>
<span class="cm">/**</span>
<span class="cm"> *  sys_rt_sigaction - alter an action taken by a process</span>
<span class="cm"> *  @sig: signal to be sent</span>
<span class="cm"> *  @act: new sigaction</span>
<span class="cm"> *  @oact: used to save the previous sigaction</span>
<span class="cm"> *  @sigsetsize: size of sigset_t type</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">rt_sigaction</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">act</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sigaction</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">oact</span><span class="p">,</span>
		<span class="kt">size_t</span><span class="p">,</span> <span class="n">sigsetsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">k_sigaction</span> <span class="n">new_sa</span><span class="p">,</span> <span class="n">old_sa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* XXX: Don&#39;t preclude handling different sized sigset_t&#39;s.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigsetsize</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sigset_t</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">act</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_sa</span><span class="p">.</span><span class="n">sa</span><span class="p">,</span> <span class="n">act</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">new_sa</span><span class="p">.</span><span class="n">sa</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_sigaction</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">act</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">new_sa</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">oact</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">old_sa</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">oact</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">oact</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_sa</span><span class="p">.</span><span class="n">sa</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">old_sa</span><span class="p">.</span><span class="n">sa</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __ARCH_WANT_SYS_RT_SIGACTION */</span><span class="cp"></span>

<span class="cp">#ifdef __ARCH_WANT_SYS_SGETMASK</span>

<span class="cm">/*</span>
<span class="cm"> * For backwards compatibility.  Functionality superseded by sigprocmask.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">sgetmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* SMP safe */</span>
	<span class="k">return</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">ssetmask</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">newmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">sigset_t</span> <span class="n">newset</span><span class="p">;</span>

	<span class="n">set_current_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __ARCH_WANT_SGETMASK */</span><span class="cp"></span>

<span class="cp">#ifdef __ARCH_WANT_SYS_SIGNAL</span>
<span class="cm">/*</span>
<span class="cm"> * For backwards compatibility.  Functionality superseded by sigaction.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">__sighandler_t</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">k_sigaction</span> <span class="n">new_sa</span><span class="p">,</span> <span class="n">old_sa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">new_sa</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
	<span class="n">new_sa</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="n">SA_ONESHOT</span> <span class="o">|</span> <span class="n">SA_NOMASK</span><span class="p">;</span>
	<span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_sa</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_sigaction</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_sa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_sa</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">old_sa</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __ARCH_WANT_SYS_SIGNAL */</span><span class="cp"></span>

<span class="cp">#ifdef __ARCH_WANT_SYS_PAUSE</span>

<span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">pause</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">;</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTNOHAND</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">sigsuspend</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">saved_sigmask</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">;</span>
	<span class="n">set_current_blocked</span><span class="p">(</span><span class="n">set</span><span class="p">);</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">;</span>
	<span class="n">schedule</span><span class="p">();</span>
	<span class="n">set_restore_sigmask</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTNOHAND</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef __ARCH_WANT_SYS_RT_SIGSUSPEND</span>
<span class="cm">/**</span>
<span class="cm"> *  sys_rt_sigsuspend - replace the signal mask for a value with the</span>
<span class="cm"> *	@unewset value until a signal is received</span>
<span class="cm"> *  @unewset: new signal mask value</span>
<span class="cm"> *  @sigsetsize: size of sigset_t type</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">rt_sigsuspend</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">unewset</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">sigsetsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sigset_t</span> <span class="n">newset</span><span class="p">;</span>

	<span class="cm">/* XXX: Don&#39;t preclude handling different sized sigset_t&#39;s.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sigsetsize</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sigset_t</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">,</span> <span class="n">unewset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">newset</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __ARCH_WANT_SYS_RT_SIGSUSPEND */</span><span class="cp"></span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arch_vma_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="n">signals_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sigqueue_cachep</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">sigqueue</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_KGDB_KDB</span>
<span class="cp">#include &lt;linux/kdb.h&gt;</span>
<span class="cm">/*</span>
<span class="cm"> * kdb_send_sig_info - Allows kdb to send signals without exposing</span>
<span class="cm"> * signal internals.  This function checks if the required locks are</span>
<span class="cm"> * available before calling the main signal code, to avoid kdb</span>
<span class="cm"> * deadlocks.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="n">kdb_send_sig_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">kdb_prev_t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">new_t</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;Can&#39;t do kill command now.</span><span class="se">\n</span><span class="s">&quot;</span>
			   <span class="s">&quot;The sigmask lock is held somewhere else in &quot;</span>
			   <span class="s">&quot;kernel, try again later</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">new_t</span> <span class="o">=</span> <span class="n">kdb_prev_t</span> <span class="o">!=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">kdb_prev_t</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">TASK_RUNNING</span> <span class="o">&amp;&amp;</span> <span class="n">new_t</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;Process is not RUNNING, sending a signal from &quot;</span>
			   <span class="s">&quot;kdb risks deadlock</span><span class="se">\n</span><span class="s">&quot;</span>
			   <span class="s">&quot;on the run queue locks. &quot;</span>
			   <span class="s">&quot;The signal has _not_ been sent.</span><span class="se">\n</span><span class="s">&quot;</span>
			   <span class="s">&quot;Reissue the kill command if you want to risk &quot;</span>
			   <span class="s">&quot;the deadlock.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sig</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_signo</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">send_sig_info</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;Fail to deliver Signal %d to process %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">sig</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kdb_printf</span><span class="p">(</span><span class="s">&quot;Signal %d is sent to process %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_KGDB_KDB */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
