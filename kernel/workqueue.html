<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › workqueue.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>workqueue.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * kernel/workqueue.c - generic async execution with shared worker pool</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2002		Ingo Molnar</span>
<span class="cm"> *</span>
<span class="cm"> *   Derived from the taskqueue/keventd code by:</span>
<span class="cm"> *     David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
<span class="cm"> *     Andrew Morton</span>
<span class="cm"> *     Kai Petzke &lt;wpp@marie.physik.tu-berlin.de&gt;</span>
<span class="cm"> *     Theodore Ts&#39;o &lt;tytso@mit.edu&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Made to use alloc_percpu by Christoph Lameter.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2010		SUSE Linux Products GmbH</span>
<span class="cm"> * Copyright (C) 2010		Tejun Heo &lt;tj@kernel.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This is the generic async execution mechanism.  Work items as are</span>
<span class="cm"> * executed in process context.  The worker pool is shared and</span>
<span class="cm"> * automatically managed.  There is one worker pool for each CPU and</span>
<span class="cm"> * one extra for works which are better served by workers which are</span>
<span class="cm"> * not bound to any specific CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * Please read Documentation/workqueue.txt for details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/mempolicy.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/debug_locks.h&gt;</span>
<span class="cp">#include &lt;linux/lockdep.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>

<span class="cp">#include &quot;workqueue_sched.h&quot;</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* global_cwq flags */</span>
	<span class="n">GCWQ_MANAGE_WORKERS</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* need to manage workers */</span>
	<span class="n">GCWQ_MANAGING_WORKERS</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* managing workers */</span>
	<span class="n">GCWQ_DISASSOCIATED</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>	<span class="cm">/* cpu can&#39;t serve workers */</span>
	<span class="n">GCWQ_FREEZING</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/* freeze in progress */</span>
	<span class="n">GCWQ_HIGHPRI_PENDING</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/* highpri works on queue */</span>

	<span class="cm">/* worker flags */</span>
	<span class="n">WORKER_STARTED</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* started */</span>
	<span class="n">WORKER_DIE</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* die die die */</span>
	<span class="n">WORKER_IDLE</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>	<span class="cm">/* is idle */</span>
	<span class="n">WORKER_PREP</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/* preparing to run works */</span>
	<span class="n">WORKER_ROGUE</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/* not bound to any cpu */</span>
	<span class="n">WORKER_REBIND</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">,</span>	<span class="cm">/* mom is home, come back */</span>
	<span class="n">WORKER_CPU_INTENSIVE</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">,</span>	<span class="cm">/* cpu intensive */</span>
	<span class="n">WORKER_UNBOUND</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">,</span>	<span class="cm">/* worker is unbound */</span>

	<span class="n">WORKER_NOT_RUNNING</span>	<span class="o">=</span> <span class="n">WORKER_PREP</span> <span class="o">|</span> <span class="n">WORKER_ROGUE</span> <span class="o">|</span> <span class="n">WORKER_REBIND</span> <span class="o">|</span>
				  <span class="n">WORKER_CPU_INTENSIVE</span> <span class="o">|</span> <span class="n">WORKER_UNBOUND</span><span class="p">,</span>

	<span class="cm">/* gcwq-&gt;trustee_state */</span>
	<span class="n">TRUSTEE_START</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>		<span class="cm">/* start */</span>
	<span class="n">TRUSTEE_IN_CHARGE</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>		<span class="cm">/* trustee in charge of gcwq */</span>
	<span class="n">TRUSTEE_BUTCHER</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>		<span class="cm">/* butcher workers */</span>
	<span class="n">TRUSTEE_RELEASE</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>		<span class="cm">/* release workers */</span>
	<span class="n">TRUSTEE_DONE</span>		<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>		<span class="cm">/* trustee is done */</span>

	<span class="n">BUSY_WORKER_HASH_ORDER</span>	<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>		<span class="cm">/* 64 pointers */</span>
	<span class="n">BUSY_WORKER_HASH_SIZE</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BUSY_WORKER_HASH_ORDER</span><span class="p">,</span>
	<span class="n">BUSY_WORKER_HASH_MASK</span>	<span class="o">=</span> <span class="n">BUSY_WORKER_HASH_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>

	<span class="n">MAX_IDLE_WORKERS_RATIO</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>		<span class="cm">/* 1/4 of busy can be idle */</span>
	<span class="n">IDLE_WORKER_TIMEOUT</span>	<span class="o">=</span> <span class="mi">300</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>	<span class="cm">/* keep idle ones for 5 mins */</span>

	<span class="n">MAYDAY_INITIAL_TIMEOUT</span>  <span class="o">=</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">100</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">?</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">100</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
						<span class="cm">/* call for help after 10ms</span>
<span class="cm">						   (min two ticks) */</span>
	<span class="n">MAYDAY_INTERVAL</span>		<span class="o">=</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">10</span><span class="p">,</span>	<span class="cm">/* and then every 100ms */</span>
	<span class="n">CREATE_COOLDOWN</span>		<span class="o">=</span> <span class="n">HZ</span><span class="p">,</span>		<span class="cm">/* time to breath after fail */</span>
	<span class="n">TRUSTEE_COOLDOWN</span>	<span class="o">=</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">10</span><span class="p">,</span>	<span class="cm">/* for trustee draining */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Rescue workers are used only on emergencies and shared by</span>
<span class="cm">	 * all cpus.  Give -20.</span>
<span class="cm">	 */</span>
	<span class="n">RESCUER_NICE_LEVEL</span>	<span class="o">=</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Structure fields follow one of the following exclusion rules.</span>
<span class="cm"> *</span>
<span class="cm"> * I: Modifiable by initialization/destruction paths and read-only for</span>
<span class="cm"> *    everyone else.</span>
<span class="cm"> *</span>
<span class="cm"> * P: Preemption protected.  Disabling preemption is enough and should</span>
<span class="cm"> *    only be modified and accessed from the local cpu.</span>
<span class="cm"> *</span>
<span class="cm"> * L: gcwq-&gt;lock protected.  Access with gcwq-&gt;lock held.</span>
<span class="cm"> *</span>
<span class="cm"> * X: During normal operation, modification requires gcwq-&gt;lock and</span>
<span class="cm"> *    should be done only from local cpu.  Either disabling preemption</span>
<span class="cm"> *    on local cpu or grabbing gcwq-&gt;lock is enough for read access.</span>
<span class="cm"> *    If GCWQ_DISASSOCIATED is set, it&#39;s identical to L.</span>
<span class="cm"> *</span>
<span class="cm"> * F: wq-&gt;flush_mutex protected.</span>
<span class="cm"> *</span>
<span class="cm"> * W: workqueue_lock protected.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">global_cwq</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The poor guys doing the actual heavy lifting.  All on-duty workers</span>
<span class="cm"> * are either serving the manager role, on idle list or on busy hash.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">worker</span> <span class="p">{</span>
	<span class="cm">/* on idle list while idle, on busy hash table while busy */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">entry</span><span class="p">;</span>	<span class="cm">/* L: while idle */</span>
		<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">hentry</span><span class="p">;</span>	<span class="cm">/* L: while busy */</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="o">*</span><span class="n">current_work</span><span class="p">;</span>	<span class="cm">/* L: work being processed */</span>
	<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">current_cwq</span><span class="p">;</span> <span class="cm">/* L: current_work&#39;s cwq */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">scheduled</span><span class="p">;</span>	<span class="cm">/* L: scheduled works */</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">task</span><span class="p">;</span>		<span class="cm">/* I: worker task */</span>
	<span class="k">struct</span> <span class="n">global_cwq</span>	<span class="o">*</span><span class="n">gcwq</span><span class="p">;</span>		<span class="cm">/* I: the associated gcwq */</span>
	<span class="cm">/* 64 bytes boundary on 64bit, 32 on 32bit */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">last_active</span><span class="p">;</span>	<span class="cm">/* L: last active timestamp */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* X: flags */</span>
	<span class="kt">int</span>			<span class="n">id</span><span class="p">;</span>		<span class="cm">/* I: worker id */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">rebind_work</span><span class="p">;</span>	<span class="cm">/* L: rebind worker to cpu */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Global per-cpu workqueue.  There&#39;s one and only one for each cpu</span>
<span class="cm"> * and all works are queued and processed here regardless of their</span>
<span class="cm"> * target workqueues.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">global_cwq</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* the gcwq lock */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">worklist</span><span class="p">;</span>	<span class="cm">/* L: list of pending works */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">cpu</span><span class="p">;</span>		<span class="cm">/* I: the associated cpu */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* L: GCWQ_* flags */</span>

	<span class="kt">int</span>			<span class="n">nr_workers</span><span class="p">;</span>	<span class="cm">/* L: total number of workers */</span>
	<span class="kt">int</span>			<span class="n">nr_idle</span><span class="p">;</span>	<span class="cm">/* L: currently idle ones */</span>

	<span class="cm">/* workers are chained either in the idle_list or busy_hash */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">idle_list</span><span class="p">;</span>	<span class="cm">/* X: list of idle workers */</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="n">busy_hash</span><span class="p">[</span><span class="n">BUSY_WORKER_HASH_SIZE</span><span class="p">];</span>
						<span class="cm">/* L: hash of busy workers */</span>

	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">idle_timer</span><span class="p">;</span>	<span class="cm">/* L: worker idle timeout */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">mayday_timer</span><span class="p">;</span>	<span class="cm">/* L: SOS timer for dworkers */</span>

	<span class="k">struct</span> <span class="n">ida</span>		<span class="n">worker_ida</span><span class="p">;</span>	<span class="cm">/* L: for worker IDs */</span>

	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">trustee</span><span class="p">;</span>	<span class="cm">/* L: for gcwq shutdown */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">trustee_state</span><span class="p">;</span>	<span class="cm">/* L: trustee state */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">trustee_wait</span><span class="p">;</span>	<span class="cm">/* trustee wait */</span>
	<span class="k">struct</span> <span class="n">worker</span>		<span class="o">*</span><span class="n">first_idle</span><span class="p">;</span>	<span class="cm">/* L: first idle worker */</span>
<span class="p">}</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The per-CPU workqueue.  The lower WORK_STRUCT_FLAG_BITS of</span>
<span class="cm"> * work_struct-&gt;data are used for flags and thus cwqs need to be</span>
<span class="cm"> * aligned at two&#39;s power of the number of flag bits.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_cwq</span>	<span class="o">*</span><span class="n">gcwq</span><span class="p">;</span>		<span class="cm">/* I: the associated gcwq */</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>		<span class="cm">/* I: the owning workqueue */</span>
	<span class="kt">int</span>			<span class="n">work_color</span><span class="p">;</span>	<span class="cm">/* L: current color */</span>
	<span class="kt">int</span>			<span class="n">flush_color</span><span class="p">;</span>	<span class="cm">/* L: flushing color */</span>
	<span class="kt">int</span>			<span class="n">nr_in_flight</span><span class="p">[</span><span class="n">WORK_NR_COLORS</span><span class="p">];</span>
						<span class="cm">/* L: nr of in_flight works */</span>
	<span class="kt">int</span>			<span class="n">nr_active</span><span class="p">;</span>	<span class="cm">/* L: nr of active works */</span>
	<span class="kt">int</span>			<span class="n">max_active</span><span class="p">;</span>	<span class="cm">/* L: max active works */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">delayed_works</span><span class="p">;</span>	<span class="cm">/* L: delayed works */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Structure used to wait for workqueue flush.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">wq_flusher</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>		<span class="cm">/* F: list of flushers */</span>
	<span class="kt">int</span>			<span class="n">flush_color</span><span class="p">;</span>	<span class="cm">/* F: flush color waiting for */</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">done</span><span class="p">;</span>		<span class="cm">/* flush completion */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * All cpumasks are assumed to be always set on UP and thus can&#39;t be</span>
<span class="cm"> * used to determine whether there&#39;s something to be done.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">typedef</span> <span class="n">cpumask_var_t</span> <span class="n">mayday_mask_t</span><span class="p">;</span>
<span class="cp">#define mayday_test_and_set_cpu(cpu, mask)	\</span>
<span class="cp">	cpumask_test_and_set_cpu((cpu), (mask))</span>
<span class="cp">#define mayday_clear_cpu(cpu, mask)		cpumask_clear_cpu((cpu), (mask))</span>
<span class="cp">#define for_each_mayday_cpu(cpu, mask)		for_each_cpu((cpu), (mask))</span>
<span class="cp">#define alloc_mayday_mask(maskp, gfp)		zalloc_cpumask_var((maskp), (gfp))</span>
<span class="cp">#define free_mayday_mask(mask)			free_cpumask_var((mask))</span>
<span class="cp">#else</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mayday_mask_t</span><span class="p">;</span>
<span class="cp">#define mayday_test_and_set_cpu(cpu, mask)	test_and_set_bit(0, &amp;(mask))</span>
<span class="cp">#define mayday_clear_cpu(cpu, mask)		clear_bit(0, &amp;(mask))</span>
<span class="cp">#define for_each_mayday_cpu(cpu, mask)		if ((cpu) = 0, (mask))</span>
<span class="cp">#define alloc_mayday_mask(maskp, gfp)		true</span>
<span class="cp">#define free_mayday_mask(mask)			do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The externally visible workqueue abstraction is an array of</span>
<span class="cm"> * per-CPU workqueues:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* W: WQ_* flags */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="n">__percpu</span>	<span class="o">*</span><span class="n">pcpu</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span>		<span class="o">*</span><span class="n">single</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span>				<span class="n">v</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">cpu_wq</span><span class="p">;</span>				<span class="cm">/* I: cwq&#39;s */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>		<span class="cm">/* W: list of all workqueues */</span>

	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">flush_mutex</span><span class="p">;</span>	<span class="cm">/* protects wq flushing */</span>
	<span class="kt">int</span>			<span class="n">work_color</span><span class="p">;</span>	<span class="cm">/* F: current work color */</span>
	<span class="kt">int</span>			<span class="n">flush_color</span><span class="p">;</span>	<span class="cm">/* F: current flush color */</span>
	<span class="n">atomic_t</span>		<span class="n">nr_cwqs_to_flush</span><span class="p">;</span> <span class="cm">/* flush in progress */</span>
	<span class="k">struct</span> <span class="n">wq_flusher</span>	<span class="o">*</span><span class="n">first_flusher</span><span class="p">;</span>	<span class="cm">/* F: first flusher */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">flusher_queue</span><span class="p">;</span>	<span class="cm">/* F: flush waiters */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">flusher_overflow</span><span class="p">;</span> <span class="cm">/* F: flush overflow list */</span>

	<span class="n">mayday_mask_t</span>		<span class="n">mayday_mask</span><span class="p">;</span>	<span class="cm">/* cpus requesting rescue */</span>
	<span class="k">struct</span> <span class="n">worker</span>		<span class="o">*</span><span class="n">rescuer</span><span class="p">;</span>	<span class="cm">/* I: rescue worker */</span>

	<span class="kt">int</span>			<span class="n">nr_drainers</span><span class="p">;</span>	<span class="cm">/* W: drain in progress */</span>
	<span class="kt">int</span>			<span class="n">saved_max_active</span><span class="p">;</span> <span class="cm">/* W: saved cwq max_active */</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
	<span class="k">struct</span> <span class="n">lockdep_map</span>	<span class="n">lockdep_map</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">char</span>			<span class="n">name</span><span class="p">[];</span>		<span class="cm">/* I: workqueue name */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">system_wq</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">system_long_wq</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">system_nrt_wq</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">system_unbound_wq</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">system_freezable_wq</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">system_nrt_freezable_wq</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">system_wq</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">system_long_wq</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">system_nrt_wq</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">system_unbound_wq</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">system_freezable_wq</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">system_nrt_freezable_wq</span><span class="p">);</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/workqueue.h&gt;</span>

<span class="cp">#define for_each_busy_worker(worker, i, pos, gcwq)			\</span>
<span class="cp">	for (i = 0; i &lt; BUSY_WORKER_HASH_SIZE; i++)			\</span>
<span class="cp">		hlist_for_each_entry(worker, pos, &amp;gcwq-&gt;busy_hash[i], hentry)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__next_gcwq_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sw</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_next</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sw</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">WORK_CPU_UNBOUND</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">WORK_CPU_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__next_wq_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__next_gcwq_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">!</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_UNBOUND</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * CPU iterators</span>
<span class="cm"> *</span>
<span class="cm"> * An extra gcwq is defined for an invalid cpu number</span>
<span class="cm"> * (WORK_CPU_UNBOUND) to host workqueues which are not bound to any</span>
<span class="cm"> * specific CPU.  The following iterators are similar to</span>
<span class="cm"> * for_each_*_cpu() iterators but also considers the unbound gcwq.</span>
<span class="cm"> *</span>
<span class="cm"> * for_each_gcwq_cpu()		: possible CPUs + WORK_CPU_UNBOUND</span>
<span class="cm"> * for_each_online_gcwq_cpu()	: online CPUs + WORK_CPU_UNBOUND</span>
<span class="cm"> * for_each_cwq_cpu()		: possible CPUs for bound workqueues,</span>
<span class="cm"> *				  WORK_CPU_UNBOUND for unbound workqueues</span>
<span class="cm"> */</span>
<span class="cp">#define for_each_gcwq_cpu(cpu)						\</span>
<span class="cp">	for ((cpu) = __next_gcwq_cpu(-1, cpu_possible_mask, 3);		\</span>
<span class="cp">	     (cpu) &lt; WORK_CPU_NONE;					\</span>
<span class="cp">	     (cpu) = __next_gcwq_cpu((cpu), cpu_possible_mask, 3))</span>

<span class="cp">#define for_each_online_gcwq_cpu(cpu)					\</span>
<span class="cp">	for ((cpu) = __next_gcwq_cpu(-1, cpu_online_mask, 3);		\</span>
<span class="cp">	     (cpu) &lt; WORK_CPU_NONE;					\</span>
<span class="cp">	     (cpu) = __next_gcwq_cpu((cpu), cpu_online_mask, 3))</span>

<span class="cp">#define for_each_cwq_cpu(cpu, wq)					\</span>
<span class="cp">	for ((cpu) = __next_wq_cpu(-1, cpu_possible_mask, (wq));	\</span>
<span class="cp">	     (cpu) &lt; WORK_CPU_NONE;					\</span>
<span class="cp">	     (cpu) = __next_wq_cpu((cpu), cpu_possible_mask, (wq)))</span>

<span class="cp">#ifdef CONFIG_DEBUG_OBJECTS_WORK</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="n">work_debug_descr</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">work_debug_hint</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_init is called when:</span>
<span class="cm"> * - an active object is initialized</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">work_fixup_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="n">cancel_work_sync</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
		<span class="n">debug_object_init</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work_debug_descr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_activate is called when:</span>
<span class="cm"> * - an active object is activated</span>
<span class="cm"> * - an unknown object is activated (might be a statically initialized object)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">work_fixup_activate</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">ODEBUG_STATE_NOTAVAILABLE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * This is not really a fixup. The work struct was</span>
<span class="cm">		 * statically initialized. We just make sure that it</span>
<span class="cm">		 * is tracked in the object tracker.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">WORK_STRUCT_STATIC_BIT</span><span class="p">,</span> <span class="n">work_data_bits</span><span class="p">(</span><span class="n">work</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">debug_object_init</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work_debug_descr</span><span class="p">);</span>
			<span class="n">debug_object_activate</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work_debug_descr</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_free is called when:</span>
<span class="cm"> * - an active object is freed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">work_fixup_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="n">cancel_work_sync</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
		<span class="n">debug_object_free</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work_debug_descr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="n">work_debug_descr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;work_struct&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">debug_hint</span>	<span class="o">=</span> <span class="n">work_debug_hint</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_init</span>	<span class="o">=</span> <span class="n">work_fixup_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_activate</span>	<span class="o">=</span> <span class="n">work_fixup_activate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_free</span>	<span class="o">=</span> <span class="n">work_fixup_free</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_work_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_activate</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work_debug_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_work_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_deactivate</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work_debug_descr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__init_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="kt">int</span> <span class="n">onstack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">onstack</span><span class="p">)</span>
		<span class="n">debug_object_init_on_stack</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work_debug_descr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">debug_object_init</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work_debug_descr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__init_work</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">destroy_work_on_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_object_free</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work_debug_descr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">destroy_work_on_stack</span><span class="p">);</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_work_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_work_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Serializes the accesses to the list of workqueues. */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">workqueue_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">workqueues</span><span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">workqueue_freezing</span><span class="p">;</span>		<span class="cm">/* W: have wqs started freezing? */</span>

<span class="cm">/*</span>
<span class="cm"> * The almighty global cpu workqueues.  nr_running is the only field</span>
<span class="cm"> * which is expected to be used frequently by other cpus via</span>
<span class="cm"> * try_to_wake_up().  Put it in a separate cacheline.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span><span class="p">,</span> <span class="n">global_cwq</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU_SHARED_ALIGNED</span><span class="p">(</span><span class="n">atomic_t</span><span class="p">,</span> <span class="n">gcwq_nr_running</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Global cpu workqueue and nr_running counter for unbound gcwq.  The</span>
<span class="cm"> * gcwq is always online, has GCWQ_DISASSOCIATED set, and all its</span>
<span class="cm"> * workers have WORKER_UNBOUND set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">global_cwq</span> <span class="n">unbound_global_cwq</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">unbound_gcwq_nr_running</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	<span class="cm">/* always 0 */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">worker_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__worker</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="nf">get_gcwq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">WORK_CPU_UNBOUND</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">global_cwq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">unbound_global_cwq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="nf">get_gcwq_nr_running</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">WORK_CPU_UNBOUND</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">gcwq_nr_running</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">unbound_gcwq_nr_running</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="nf">get_cwq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_UNBOUND</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">cpu_wq</span><span class="p">.</span><span class="n">pcpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">WORK_CPU_UNBOUND</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">cpu_wq</span><span class="p">.</span><span class="n">single</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">work_color_to_flags</span><span class="p">(</span><span class="kt">int</span> <span class="n">color</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">color</span> <span class="o">&lt;&lt;</span> <span class="n">WORK_STRUCT_COLOR_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_work_color</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">work_data_bits</span><span class="p">(</span><span class="n">work</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">WORK_STRUCT_COLOR_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">WORK_STRUCT_COLOR_BITS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">work_next_color</span><span class="p">(</span><span class="kt">int</span> <span class="n">color</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">color</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">WORK_NR_COLORS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A work&#39;s data points to the cwq with WORK_STRUCT_CWQ set while the</span>
<span class="cm"> * work is on queue.  Once execution starts, WORK_STRUCT_CWQ is</span>
<span class="cm"> * cleared and the work data contains the cpu number it was last on.</span>
<span class="cm"> *</span>
<span class="cm"> * set_work_{cwq|cpu}() and clear_work_data() can be used to set the</span>
<span class="cm"> * cwq, cpu or clear work-&gt;data.  These functions should only be</span>
<span class="cm"> * called while the work is owned - ie. while the PENDING bit is set.</span>
<span class="cm"> *</span>
<span class="cm"> * get_work_[g]cwq() can be used to obtain the gcwq or cwq</span>
<span class="cm"> * corresponding to a work.  gcwq is available once the work has been</span>
<span class="cm"> * queued anywhere after initialization.  cwq is available only from</span>
<span class="cm"> * queueing until execution starts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_work_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">work_pending</span><span class="p">(</span><span class="n">work</span><span class="p">));</span>
	<span class="n">atomic_long_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span> <span class="o">|</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">work_static</span><span class="p">(</span><span class="n">work</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_work_cwq</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">extra_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_work_data</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cwq</span><span class="p">,</span>
		      <span class="n">WORK_STRUCT_PENDING</span> <span class="o">|</span> <span class="n">WORK_STRUCT_CWQ</span> <span class="o">|</span> <span class="n">extra_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_work_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_work_data</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">&lt;&lt;</span> <span class="n">WORK_STRUCT_FLAG_BITS</span><span class="p">,</span> <span class="n">WORK_STRUCT_PENDING</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_work_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_work_data</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">WORK_STRUCT_NO_CPU</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="nf">get_work_cwq</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">WORK_STRUCT_CWQ</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">WORK_STRUCT_WQ_DATA_MASK</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="nf">get_work_gcwq</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">WORK_STRUCT_CWQ</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">((</span><span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">WORK_STRUCT_WQ_DATA_MASK</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="n">WORK_STRUCT_FLAG_BITS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">WORK_CPU_NONE</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span> <span class="o">&amp;&amp;</span> <span class="n">cpu</span> <span class="o">!=</span> <span class="n">WORK_CPU_UNBOUND</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">get_gcwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Policy functions.  These define the policies on how the global</span>
<span class="cm"> * worker pool is managed.  Unless noted otherwise, these functions</span>
<span class="cm"> * assume that they&#39;re being called with gcwq-&gt;lock held.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">__need_more_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="n">get_gcwq_nr_running</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">))</span> <span class="o">||</span>
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GCWQ_HIGHPRI_PENDING</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Need to wake up a worker?  Called from anything but currently</span>
<span class="cm"> * running workers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">need_more_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worklist</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">__need_more_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Can I start working?  Called from busy but !running workers. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">may_start_working</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">nr_idle</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Do I need to keep working?  Called from currently running workers. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">keep_working</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_t</span> <span class="o">*</span><span class="n">nr_running</span> <span class="o">=</span> <span class="n">get_gcwq_nr_running</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worklist</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="n">nr_running</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">||</span>
		 <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GCWQ_HIGHPRI_PENDING</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Do we need a new worker?  Called from manager. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">need_to_create_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">need_more_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">may_start_working</span><span class="p">(</span><span class="n">gcwq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Do I need to be the manager? */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">need_to_manage_workers</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">need_to_create_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">)</span> <span class="o">||</span> <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GCWQ_MANAGE_WORKERS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Do we have too many workers and should some go away? */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">too_many_workers</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">managing</span> <span class="o">=</span> <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GCWQ_MANAGING_WORKERS</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_idle</span> <span class="o">=</span> <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">nr_idle</span> <span class="o">+</span> <span class="n">managing</span><span class="p">;</span> <span class="cm">/* manager is considered idle */</span>
	<span class="kt">int</span> <span class="n">nr_busy</span> <span class="o">=</span> <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">nr_workers</span> <span class="o">-</span> <span class="n">nr_idle</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nr_idle</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nr_idle</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">MAX_IDLE_WORKERS_RATIO</span> <span class="o">&gt;=</span> <span class="n">nr_busy</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wake up functions.</span>
<span class="cm"> */</span>

<span class="cm">/* Return the first worker.  Safe with preemption disabled */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="nf">first_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_list</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">worker</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wake_up_worker - wake up an idle worker</span>
<span class="cm"> * @gcwq: gcwq to wake worker for</span>
<span class="cm"> *</span>
<span class="cm"> * Wake up the first idle worker of @gcwq.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wake_up_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span> <span class="o">=</span> <span class="n">first_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">worker</span><span class="p">))</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wq_worker_waking_up - a worker is waking up</span>
<span class="cm"> * @task: task waking up</span>
<span class="cm"> * @cpu: CPU @task is waking up to</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called during try_to_wake_up() when a worker is</span>
<span class="cm"> * being awoken.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(rq-&gt;lock)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">wq_worker_waking_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span> <span class="o">=</span> <span class="n">kthread_data</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WORKER_NOT_RUNNING</span><span class="p">))</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="n">get_gcwq_nr_running</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wq_worker_sleeping - a worker is going to sleep</span>
<span class="cm"> * @task: task going to sleep</span>
<span class="cm"> * @cpu: CPU in question, must be the current CPU number</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called during schedule() when a busy worker is</span>
<span class="cm"> * going to sleep.  Worker on the same cpu can be woken up by</span>
<span class="cm"> * returning pointer to its task.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(rq-&gt;lock)</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Worker task on @cpu to wake up, %NULL if none.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">wq_worker_sleeping</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span> <span class="o">=</span> <span class="n">kthread_data</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="o">*</span><span class="n">to_wakeup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">get_gcwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">atomic_t</span> <span class="o">*</span><span class="n">nr_running</span> <span class="o">=</span> <span class="n">get_gcwq_nr_running</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WORKER_NOT_RUNNING</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* this can only happen on the local cpu */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">raw_smp_processor_id</span><span class="p">());</span>

	<span class="cm">/*</span>
<span class="cm">	 * The counterpart of the following dec_and_test, implied mb,</span>
<span class="cm">	 * worklist not empty test sequence is in insert_work().</span>
<span class="cm">	 * Please read comment there.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOT_RUNNING is clear.  This means that trustee is not in</span>
<span class="cm">	 * charge and we&#39;re running on the local cpu w/ rq lock held</span>
<span class="cm">	 * and preemption disabled, which in turn means that none else</span>
<span class="cm">	 * could be manipulating idle_list, so dereferencing idle_list</span>
<span class="cm">	 * without gcwq lock is safe.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="n">nr_running</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worklist</span><span class="p">))</span>
		<span class="n">to_wakeup</span> <span class="o">=</span> <span class="n">first_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">to_wakeup</span> <span class="o">?</span> <span class="n">to_wakeup</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * worker_set_flags - set worker flags and adjust nr_running accordingly</span>
<span class="cm"> * @worker: self</span>
<span class="cm"> * @flags: flags to set</span>
<span class="cm"> * @wakeup: wakeup an idle worker if necessary</span>
<span class="cm"> *</span>
<span class="cm"> * Set @flags in @worker-&gt;flags and adjust nr_running accordingly.  If</span>
<span class="cm"> * nr_running becomes zero and @wakeup is %true, an idle worker is</span>
<span class="cm"> * woken up.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">worker_set_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
				    <span class="n">bool</span> <span class="n">wakeup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">!=</span> <span class="n">current</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If transitioning into NOT_RUNNING, adjust nr_running and</span>
<span class="cm">	 * wake up an idle worker as necessary if requested by</span>
<span class="cm">	 * @wakeup.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WORKER_NOT_RUNNING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WORKER_NOT_RUNNING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atomic_t</span> <span class="o">*</span><span class="n">nr_running</span> <span class="o">=</span> <span class="n">get_gcwq_nr_running</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wakeup</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="n">nr_running</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worklist</span><span class="p">))</span>
				<span class="n">wake_up_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="n">nr_running</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * worker_clr_flags - clear worker flags and adjust nr_running accordingly</span>
<span class="cm"> * @worker: self</span>
<span class="cm"> * @flags: flags to clear</span>
<span class="cm"> *</span>
<span class="cm"> * Clear @flags in @worker-&gt;flags and adjust nr_running accordingly.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">worker_clr_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oflags</span> <span class="o">=</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">!=</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If transitioning out of NOT_RUNNING, increment nr_running.  Note</span>
<span class="cm">	 * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask</span>
<span class="cm">	 * of multiple flags, not a single flag.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WORKER_NOT_RUNNING</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">oflags</span> <span class="o">&amp;</span> <span class="n">WORKER_NOT_RUNNING</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WORKER_NOT_RUNNING</span><span class="p">))</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="n">get_gcwq_nr_running</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * busy_worker_head - return the busy hash head for a work</span>
<span class="cm"> * @gcwq: gcwq of interest</span>
<span class="cm"> * @work: work to be hashed</span>
<span class="cm"> *</span>
<span class="cm"> * Return hash head of @gcwq for @work.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock).</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to the hash head.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="nf">busy_worker_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">base_shift</span> <span class="o">=</span> <span class="n">ilog2</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span><span class="p">));</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">work</span><span class="p">;</span>

	<span class="cm">/* simple shift and fold hash, do we need something better? */</span>
	<span class="n">v</span> <span class="o">&gt;&gt;=</span> <span class="n">base_shift</span><span class="p">;</span>
	<span class="n">v</span> <span class="o">+=</span> <span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">BUSY_WORKER_HASH_ORDER</span><span class="p">;</span>
	<span class="n">v</span> <span class="o">&amp;=</span> <span class="n">BUSY_WORKER_HASH_MASK</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">busy_hash</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __find_worker_executing_work - find worker which is executing a work</span>
<span class="cm"> * @gcwq: gcwq of interest</span>
<span class="cm"> * @bwh: hash head as returned by busy_worker_head()</span>
<span class="cm"> * @work: work to find worker for</span>
<span class="cm"> *</span>
<span class="cm"> * Find a worker which is executing @work on @gcwq.  @bwh should be</span>
<span class="cm"> * the hash head obtained by calling busy_worker_head() with the same</span>
<span class="cm"> * work.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock).</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to worker which is executing @work if found, NULL</span>
<span class="cm"> * otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="nf">__find_worker_executing_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">bwh</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">bwh</span><span class="p">,</span> <span class="n">hentry</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_work</span> <span class="o">==</span> <span class="n">work</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">worker</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_worker_executing_work - find worker which is executing a work</span>
<span class="cm"> * @gcwq: gcwq of interest</span>
<span class="cm"> * @work: work to find worker for</span>
<span class="cm"> *</span>
<span class="cm"> * Find a worker which is executing @work on @gcwq.  This function is</span>
<span class="cm"> * identical to __find_worker_executing_work() except that this</span>
<span class="cm"> * function calculates @bwh itself.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock).</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to worker which is executing @work if found, NULL</span>
<span class="cm"> * otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="nf">find_worker_executing_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__find_worker_executing_work</span><span class="p">(</span><span class="n">gcwq</span><span class="p">,</span> <span class="n">busy_worker_head</span><span class="p">(</span><span class="n">gcwq</span><span class="p">,</span> <span class="n">work</span><span class="p">),</span>
					    <span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * gcwq_determine_ins_pos - find insertion position</span>
<span class="cm"> * @gcwq: gcwq of interest</span>
<span class="cm"> * @cwq: cwq a work is being queued for</span>
<span class="cm"> *</span>
<span class="cm"> * A work for @cwq is about to be queued on @gcwq, determine insertion</span>
<span class="cm"> * position for the work.  If @cwq is for HIGHPRI wq, the work is</span>
<span class="cm"> * queued at the head of the queue but in FIFO order with respect to</span>
<span class="cm"> * other HIGHPRI works; otherwise, at the end of the queue.  This</span>
<span class="cm"> * function also sets GCWQ_HIGHPRI_PENDING flag to hint @gcwq that</span>
<span class="cm"> * there are HIGHPRI works pending.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock).</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to inserstion position.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="nf">gcwq_determine_ins_pos</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">twork</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_HIGHPRI</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worklist</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">twork</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worklist</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">tcwq</span> <span class="o">=</span> <span class="n">get_work_cwq</span><span class="p">(</span><span class="n">twork</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tcwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_HIGHPRI</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">GCWQ_HIGHPRI_PENDING</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">twork</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * insert_work - insert a work into gcwq</span>
<span class="cm"> * @cwq: cwq @work belongs to</span>
<span class="cm"> * @work: work to insert</span>
<span class="cm"> * @head: insertion point</span>
<span class="cm"> * @extra_flags: extra WORK_STRUCT_* flags to set</span>
<span class="cm"> *</span>
<span class="cm"> * Insert @work which belongs to @cwq into @gcwq after @head.</span>
<span class="cm"> * @extra_flags is or&#39;d to work_struct flags.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">insert_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">extra_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">cwq</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="p">;</span>

	<span class="cm">/* we own @work, set data and link */</span>
	<span class="n">set_work_cwq</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">cwq</span><span class="p">,</span> <span class="n">extra_flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that we get the right work-&gt;data if we see the</span>
<span class="cm">	 * result of list_add() below, see try_to_grab_pending().</span>
<span class="cm">	 */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure either worker_sched_deactivated() sees the above</span>
<span class="cm">	 * list_add_tail() or we see zero nr_running to avoid workers</span>
<span class="cm">	 * lying around lazily while there are works to be processed.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__need_more_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">))</span>
		<span class="n">wake_up_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Test whether @work is being queued from another work executing on the</span>
<span class="cm"> * same workqueue.  This is rather expensive and should only be used from</span>
<span class="cm"> * cold paths.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_chained_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_gcwq_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">get_gcwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">for_each_busy_worker</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">gcwq</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * I&#39;m @worker, no locking necessary.  See if @work</span>
<span class="cm">			 * is headed to the same workqueue.</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_cwq</span><span class="o">-&gt;</span><span class="n">wq</span> <span class="o">==</span> <span class="n">wq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__queue_work</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">worklist</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">work_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">debug_work_activate</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>

	<span class="cm">/* if dying, only works from the same workqueue are allowed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_DRAINING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">is_chained_work</span><span class="p">(</span><span class="n">wq</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* determine gcwq to use */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_UNBOUND</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">last_gcwq</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">WORK_CPU_UNBOUND</span><span class="p">))</span>
			<span class="n">cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s multi cpu.  If @wq is non-reentrant and @work</span>
<span class="cm">		 * was previously on a different cpu, it might still</span>
<span class="cm">		 * be running there, in which case the work needs to</span>
<span class="cm">		 * be queued on that cpu to guarantee non-reentrance.</span>
<span class="cm">		 */</span>
		<span class="n">gcwq</span> <span class="o">=</span> <span class="n">get_gcwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_NON_REENTRANT</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">last_gcwq</span> <span class="o">=</span> <span class="n">get_work_gcwq</span><span class="p">(</span><span class="n">work</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">last_gcwq</span> <span class="o">!=</span> <span class="n">gcwq</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">;</span>

			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="n">worker</span> <span class="o">=</span> <span class="n">find_worker_executing_work</span><span class="p">(</span><span class="n">last_gcwq</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">worker</span> <span class="o">&amp;&amp;</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_cwq</span><span class="o">-&gt;</span><span class="n">wq</span> <span class="o">==</span> <span class="n">wq</span><span class="p">)</span>
				<span class="n">gcwq</span> <span class="o">=</span> <span class="n">last_gcwq</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* meh... not running there, queue here */</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">gcwq</span> <span class="o">=</span> <span class="n">get_gcwq</span><span class="p">(</span><span class="n">WORK_CPU_UNBOUND</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* gcwq determined, get cwq and queue */</span>
	<span class="n">cwq</span> <span class="o">=</span> <span class="n">get_cwq</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>
	<span class="n">trace_workqueue_queue_work</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cwq</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cwq</span><span class="o">-&gt;</span><span class="n">nr_in_flight</span><span class="p">[</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">work_color</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">work_flags</span> <span class="o">=</span> <span class="n">work_color_to_flags</span><span class="p">(</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">work_color</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">nr_active</span> <span class="o">&lt;</span> <span class="n">cwq</span><span class="o">-&gt;</span><span class="n">max_active</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trace_workqueue_activate_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
		<span class="n">cwq</span><span class="o">-&gt;</span><span class="n">nr_active</span><span class="o">++</span><span class="p">;</span>
		<span class="n">worklist</span> <span class="o">=</span> <span class="n">gcwq_determine_ins_pos</span><span class="p">(</span><span class="n">gcwq</span><span class="p">,</span> <span class="n">cwq</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">work_flags</span> <span class="o">|=</span> <span class="n">WORK_STRUCT_DELAYED</span><span class="p">;</span>
		<span class="n">worklist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">delayed_works</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">insert_work</span><span class="p">(</span><span class="n">cwq</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">worklist</span><span class="p">,</span> <span class="n">work_flags</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * queue_work - queue work on a workqueue</span>
<span class="cm"> * @wq: workqueue to use</span>
<span class="cm"> * @work: work to queue</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if @work was already on a queue, non-zero otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * We queue the work to the CPU on which it was submitted, but if the CPU dies</span>
<span class="cm"> * it can be processed by another CPU.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">queue_work_on</span><span class="p">(</span><span class="n">get_cpu</span><span class="p">(),</span> <span class="n">wq</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="n">put_cpu</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">queue_work</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * queue_work_on - queue work on specific cpu</span>
<span class="cm"> * @cpu: CPU number to execute work on</span>
<span class="cm"> * @wq: workqueue to use</span>
<span class="cm"> * @work: work to queue</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if @work was already on a queue, non-zero otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * We queue the work to a specific CPU, the caller must ensure it</span>
<span class="cm"> * can&#39;t go away.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">queue_work_on</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">WORK_STRUCT_PENDING_BIT</span><span class="p">,</span> <span class="n">work_data_bits</span><span class="p">(</span><span class="n">work</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">__queue_work</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">queue_work_on</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">delayed_work_timer_fn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="p">)</span><span class="n">__data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span> <span class="o">=</span> <span class="n">get_work_cwq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwork</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>

	<span class="n">__queue_work</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">cwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwork</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * queue_delayed_work - queue work on a workqueue after delay</span>
<span class="cm"> * @wq: workqueue to use</span>
<span class="cm"> * @dwork: delayable work to queue</span>
<span class="cm"> * @delay: number of jiffies to wait before queueing</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if @work was already on a queue, non-zero otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">queue_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delay</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">queue_work</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwork</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">queue_delayed_work_on</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">wq</span><span class="p">,</span> <span class="n">dwork</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">queue_delayed_work</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * queue_delayed_work_on - queue work on specific CPU after delay</span>
<span class="cm"> * @cpu: CPU number to execute work on</span>
<span class="cm"> * @wq: workqueue to use</span>
<span class="cm"> * @dwork: work to queue</span>
<span class="cm"> * @delay: number of jiffies to wait before queueing</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if @work was already on a queue, non-zero otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">queue_delayed_work_on</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dwork</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dwork</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">WORK_STRUCT_PENDING_BIT</span><span class="p">,</span> <span class="n">work_data_bits</span><span class="p">(</span><span class="n">work</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lcpu</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">));</span>

		<span class="n">timer_stats_timer_set_start_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwork</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * This stores cwq for the moment, for the timer_fn.</span>
<span class="cm">		 * Note that the work&#39;s gcwq is preserved to allow</span>
<span class="cm">		 * reentrance detection for delayed works.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_UNBOUND</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">get_work_gcwq</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">gcwq</span> <span class="o">&amp;&amp;</span> <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">WORK_CPU_UNBOUND</span><span class="p">)</span>
				<span class="n">lcpu</span> <span class="o">=</span> <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">lcpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">lcpu</span> <span class="o">=</span> <span class="n">WORK_CPU_UNBOUND</span><span class="p">;</span>

		<span class="n">set_work_cwq</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">get_cwq</span><span class="p">(</span><span class="n">lcpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">delay</span><span class="p">;</span>
		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dwork</span><span class="p">;</span>
		<span class="n">timer</span><span class="o">-&gt;</span><span class="n">function</span> <span class="o">=</span> <span class="n">delayed_work_timer_fn</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">add_timer_on</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">add_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">queue_delayed_work_on</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * worker_enter_idle - enter idle state</span>
<span class="cm"> * @worker: worker which is entering idle state</span>
<span class="cm"> *</span>
<span class="cm"> * @worker is entering idle state.  Update stats and idle timer if</span>
<span class="cm"> * necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">worker_enter_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WORKER_IDLE</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">hentry</span><span class="p">.</span><span class="n">next</span> <span class="o">||</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">hentry</span><span class="p">.</span><span class="n">pprev</span><span class="p">));</span>

	<span class="cm">/* can&#39;t use worker_set_flags(), also called from start_worker() */</span>
	<span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">WORKER_IDLE</span><span class="p">;</span>
	<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">nr_idle</span><span class="o">++</span><span class="p">;</span>
	<span class="n">worker</span><span class="o">-&gt;</span><span class="n">last_active</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/* idle_list is LIFO */</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WORKER_ROGUE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">too_many_workers</span><span class="p">(</span><span class="n">gcwq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_timer</span><span class="p">))</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_timer</span><span class="p">,</span>
				  <span class="n">jiffies</span> <span class="o">+</span> <span class="n">IDLE_WORKER_TIMEOUT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_wait</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sanity check nr_running.  Because trustee releases gcwq-&gt;lock</span>
<span class="cm">	 * between setting %WORKER_ROGUE and zapping nr_running, the</span>
<span class="cm">	 * warning may trigger spuriously.  Check iff trustee is idle.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_state</span> <span class="o">==</span> <span class="n">TRUSTEE_DONE</span> <span class="o">&amp;&amp;</span>
		     <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">nr_workers</span> <span class="o">==</span> <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">nr_idle</span> <span class="o">&amp;&amp;</span>
		     <span class="n">atomic_read</span><span class="p">(</span><span class="n">get_gcwq_nr_running</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * worker_leave_idle - leave idle state</span>
<span class="cm"> * @worker: worker which is leaving idle state</span>
<span class="cm"> *</span>
<span class="cm"> * @worker is leaving idle state.  Update stats.</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">worker_leave_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WORKER_IDLE</span><span class="p">));</span>
	<span class="n">worker_clr_flags</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">WORKER_IDLE</span><span class="p">);</span>
	<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">nr_idle</span><span class="o">--</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * worker_maybe_bind_and_lock - bind worker to its cpu if possible and lock gcwq</span>
<span class="cm"> * @worker: self</span>
<span class="cm"> *</span>
<span class="cm"> * Works which are scheduled while the cpu is online must at least be</span>
<span class="cm"> * scheduled to a worker which is bound to the cpu so that if they are</span>
<span class="cm"> * flushed from cpu callbacks while cpu is going down, they are</span>
<span class="cm"> * guaranteed to execute on the cpu.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is to be used by rogue workers and rescuers to bind</span>
<span class="cm"> * themselves to the target cpu and may race with cpu going down or</span>
<span class="cm"> * coming online.  kthread_bind() can&#39;t be used because it may put the</span>
<span class="cm"> * worker to already dead cpu and set_cpus_allowed_ptr() can&#39;t be used</span>
<span class="cm"> * verbatim as it&#39;s best effort and blocking and gcwq may be</span>
<span class="cm"> * [dis]associated in the meantime.</span>
<span class="cm"> *</span>
<span class="cm"> * This function tries set_cpus_allowed() and locks gcwq and verifies</span>
<span class="cm"> * the binding against GCWQ_DISASSOCIATED which is set during</span>
<span class="cm"> * CPU_DYING and cleared during CPU_ONLINE, so if the worker enters</span>
<span class="cm"> * idle state or fetches works without dropping lock, it can guarantee</span>
<span class="cm"> * the scheduling requirement described in the first paragraph.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Might sleep.  Called without any lock but returns with gcwq-&gt;lock</span>
<span class="cm"> * held.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * %true if the associated gcwq is online (@worker is successfully</span>
<span class="cm"> * bound), %false if offline.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">worker_maybe_bind_and_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">)</span>
<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The following call may fail, succeed or succeed</span>
<span class="cm">		 * without actually migrating the task to the cpu if</span>
<span class="cm">		 * it races with cpu hotunplug operation.  Verify</span>
<span class="cm">		 * against GCWQ_DISASSOCIATED.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GCWQ_DISASSOCIATED</span><span class="p">))</span>
			<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">get_cpu_mask</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">));</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GCWQ_DISASSOCIATED</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">==</span> <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cpumask_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span>
				  <span class="n">get_cpu_mask</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">)))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We&#39;ve raced with CPU hot[un]plug.  Give it a breather</span>
<span class="cm">		 * and retry migration.  cond_resched() is required here;</span>
<span class="cm">		 * otherwise, we might deadlock against cpu_stop trying to</span>
<span class="cm">		 * bring down the CPU on non-preemptive kernel.</span>
<span class="cm">		 */</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function for worker-&gt;rebind_work used to rebind rogue busy workers</span>
<span class="cm"> * to the associated cpu which is coming back online.  This is</span>
<span class="cm"> * scheduled by cpu up but can race with other cpu hotplug operations</span>
<span class="cm"> * and may be executed twice without intervening cpu down.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">worker_rebind_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">worker</span><span class="p">,</span> <span class="n">rebind_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">worker_maybe_bind_and_lock</span><span class="p">(</span><span class="n">worker</span><span class="p">))</span>
		<span class="n">worker_clr_flags</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">WORKER_REBIND</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="nf">alloc_worker</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">;</span>

	<span class="n">worker</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">worker</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">worker</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">scheduled</span><span class="p">);</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">rebind_work</span><span class="p">,</span> <span class="n">worker_rebind_fn</span><span class="p">);</span>
		<span class="cm">/* on creation a worker is in !idle &amp;&amp; prep state */</span>
		<span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">WORKER_PREP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">worker</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * create_worker - create a new workqueue worker</span>
<span class="cm"> * @gcwq: gcwq the new worker will belong to</span>
<span class="cm"> * @bind: whether to set affinity to @cpu or not</span>
<span class="cm"> *</span>
<span class="cm"> * Create a new worker which is bound to @gcwq.  The returned worker</span>
<span class="cm"> * can be started by calling start_worker() or destroyed using</span>
<span class="cm"> * destroy_worker().</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Might sleep.  Does GFP_KERNEL allocations.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to the newly created worker.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="nf">create_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">,</span> <span class="n">bool</span> <span class="n">bind</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">on_unbound_cpu</span> <span class="o">=</span> <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">WORK_CPU_UNBOUND</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ida_get_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worker_ida</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ida_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worker_ida</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">worker</span> <span class="o">=</span> <span class="n">alloc_worker</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">worker</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">worker</span><span class="o">-&gt;</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">gcwq</span><span class="p">;</span>
	<span class="n">worker</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">on_unbound_cpu</span><span class="p">)</span>
		<span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">kthread_create_on_node</span><span class="p">(</span><span class="n">worker_thread</span><span class="p">,</span>
						      <span class="n">worker</span><span class="p">,</span>
						      <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">),</span>
						      <span class="s">&quot;kworker/%u:%d&quot;</span><span class="p">,</span> <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">kthread_create</span><span class="p">(</span><span class="n">worker_thread</span><span class="p">,</span> <span class="n">worker</span><span class="p">,</span>
					      <span class="s">&quot;kworker/u:%d&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A rogue worker will become a regular one if CPU comes</span>
<span class="cm">	 * online later on.  Make sure every worker has</span>
<span class="cm">	 * PF_THREAD_BOUND set.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bind</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">on_unbound_cpu</span><span class="p">)</span>
		<span class="n">kthread_bind</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_THREAD_BOUND</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">on_unbound_cpu</span><span class="p">)</span>
			<span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">WORKER_UNBOUND</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">worker</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">ida_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worker_ida</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * start_worker - start a newly created worker</span>
<span class="cm"> * @worker: worker to start</span>
<span class="cm"> *</span>
<span class="cm"> * Make the gcwq aware of @worker and start it.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">WORKER_STARTED</span><span class="p">;</span>
	<span class="n">worker</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">nr_workers</span><span class="o">++</span><span class="p">;</span>
	<span class="n">worker_enter_idle</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * destroy_worker - destroy a workqueue worker</span>
<span class="cm"> * @worker: worker to be destroyed</span>
<span class="cm"> *</span>
<span class="cm"> * Destroy @worker and adjust @gcwq stats accordingly.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock) which is released and regrabbed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="cm">/* sanity check frenzy */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_work</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">scheduled</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WORKER_STARTED</span><span class="p">)</span>
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">nr_workers</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WORKER_IDLE</span><span class="p">)</span>
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">nr_idle</span><span class="o">--</span><span class="p">;</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">WORKER_DIE</span><span class="p">;</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ida_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worker_ida</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">idle_worker_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__gcwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__gcwq</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">too_many_workers</span><span class="p">(</span><span class="n">gcwq</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">;</span>

		<span class="cm">/* idle_list is kept in LIFO order, check the last one */</span>
		<span class="n">worker</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">worker</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">expires</span> <span class="o">=</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">last_active</span> <span class="o">+</span> <span class="n">IDLE_WORKER_TIMEOUT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">expires</span><span class="p">))</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_timer</span><span class="p">,</span> <span class="n">expires</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* it&#39;s been idle for too long, wake up manager */</span>
			<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">GCWQ_MANAGE_WORKERS</span><span class="p">;</span>
			<span class="n">wake_up_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">send_mayday</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span> <span class="o">=</span> <span class="n">get_work_cwq</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span> <span class="o">=</span> <span class="n">cwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_RESCUER</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* mayday mayday mayday */</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">cwq</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
	<span class="cm">/* WORK_CPU_UNBOUND can&#39;t be set in cpumask, use cpu 0 instead */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">WORK_CPU_UNBOUND</span><span class="p">)</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mayday_test_and_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">mayday_mask</span><span class="p">))</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">rescuer</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gcwq_mayday_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__gcwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__gcwq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_to_create_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;ve been trying to create a new worker but</span>
<span class="cm">		 * haven&#39;t been successful.  We might be hitting an</span>
<span class="cm">		 * allocation deadlock.  Send distress signals to</span>
<span class="cm">		 * rescuers.</span>
<span class="cm">		 */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worklist</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>
			<span class="n">send_mayday</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">mayday_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">MAYDAY_INTERVAL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * maybe_create_worker - create a new worker if necessary</span>
<span class="cm"> * @gcwq: gcwq to create a new worker for</span>
<span class="cm"> *</span>
<span class="cm"> * Create a new worker for @gcwq if necessary.  @gcwq is guaranteed to</span>
<span class="cm"> * have at least one idle worker on return from this function.  If</span>
<span class="cm"> * creating a new worker takes longer than MAYDAY_INTERVAL, mayday is</span>
<span class="cm"> * sent to all rescuers with works scheduled on @gcwq to resolve</span>
<span class="cm"> * possible allocation deadlock.</span>
<span class="cm"> *</span>
<span class="cm"> * On return, need_to_create_worker() is guaranteed to be false and</span>
<span class="cm"> * may_start_working() true.</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock) which may be released and regrabbed</span>
<span class="cm"> * multiple times.  Does GFP_KERNEL allocations.  Called only from</span>
<span class="cm"> * manager.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * false if no action was taken and gcwq-&gt;lock stayed locked, true</span>
<span class="cm"> * otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">maybe_create_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">)</span>
<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_to_create_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="nl">restart:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* if we don&#39;t make progress in MAYDAY_INITIAL_TIMEOUT, call for help */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">mayday_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">MAYDAY_INITIAL_TIMEOUT</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">;</span>

		<span class="n">worker</span> <span class="o">=</span> <span class="n">create_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">worker</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">mayday_timer</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">start_worker</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">need_to_create_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">));</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_to_create_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">schedule_timeout</span><span class="p">(</span><span class="n">CREATE_COOLDOWN</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_to_create_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">mayday_timer</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_to_create_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * maybe_destroy_worker - destroy workers which have been idle for a while</span>
<span class="cm"> * @gcwq: gcwq to destroy workers for</span>
<span class="cm"> *</span>
<span class="cm"> * Destroy @gcwq workers which have been idle for longer than</span>
<span class="cm"> * IDLE_WORKER_TIMEOUT.</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock) which may be released and regrabbed</span>
<span class="cm"> * multiple times.  Called only from manager.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * false if no action was taken and gcwq-&gt;lock stayed locked, true</span>
<span class="cm"> * otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">maybe_destroy_workers</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">too_many_workers</span><span class="p">(</span><span class="n">gcwq</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">;</span>

		<span class="n">worker</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">worker</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">expires</span> <span class="o">=</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">last_active</span> <span class="o">+</span> <span class="n">IDLE_WORKER_TIMEOUT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">expires</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_timer</span><span class="p">,</span> <span class="n">expires</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">destroy_worker</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * manage_workers - manage worker pool</span>
<span class="cm"> * @worker: self</span>
<span class="cm"> *</span>
<span class="cm"> * Assume the manager role and manage gcwq worker pool @worker belongs</span>
<span class="cm"> * to.  At any given time, there can be only zero or one manager per</span>
<span class="cm"> * gcwq.  The exclusion is handled automatically by this function.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller can safely start processing works on false return.  On</span>
<span class="cm"> * true return, it&#39;s guaranteed that need_to_create_worker() is false</span>
<span class="cm"> * and may_start_working() is true.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock) which may be released and regrabbed</span>
<span class="cm"> * multiple times.  Does GFP_KERNEL allocations.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * false if no action was taken and gcwq-&gt;lock stayed locked, true if</span>
<span class="cm"> * some action was taken.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">manage_workers</span><span class="p">(</span><span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GCWQ_MANAGING_WORKERS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GCWQ_MANAGE_WORKERS</span><span class="p">;</span>
	<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">GCWQ_MANAGING_WORKERS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Destroy and then create so that may_start_working() is true</span>
<span class="cm">	 * on return.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">|=</span> <span class="n">maybe_destroy_workers</span><span class="p">(</span><span class="n">gcwq</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">|=</span> <span class="n">maybe_create_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">);</span>

	<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GCWQ_MANAGING_WORKERS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The trustee might be waiting to take over the manager</span>
<span class="cm">	 * position, tell it we&#39;re done.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee</span><span class="p">))</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * move_linked_works - move linked works to a list</span>
<span class="cm"> * @work: start of series of works to be scheduled</span>
<span class="cm"> * @head: target list to append @work to</span>
<span class="cm"> * @nextp: out paramter for nested worklist walking</span>
<span class="cm"> *</span>
<span class="cm"> * Schedule linked works starting from @work to @head.  Work series to</span>
<span class="cm"> * be scheduled starts at @work and includes any consecutive work with</span>
<span class="cm"> * WORK_STRUCT_LINKED set in its predecessor.</span>
<span class="cm"> *</span>
<span class="cm"> * If @nextp is not NULL, it&#39;s updated to point to the next work of</span>
<span class="cm"> * the last scheduled work.  This allows move_linked_works() to be</span>
<span class="cm"> * nested inside outer list_for_each_entry_safe().</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">move_linked_works</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">**</span><span class="n">nextp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Linked worklist will always end before the end of the list,</span>
<span class="cm">	 * use NULL for list head.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe_from</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">work_data_bits</span><span class="p">(</span><span class="n">work</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">WORK_STRUCT_LINKED</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re already inside safe list traversal and have moved</span>
<span class="cm">	 * multiple works to the scheduled queue, the next position</span>
<span class="cm">	 * needs to be updated.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nextp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">nextp</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cwq_activate_first_delayed</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">delayed_works</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">work_struct</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">gcwq_determine_ins_pos</span><span class="p">(</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="p">,</span> <span class="n">cwq</span><span class="p">);</span>

	<span class="n">trace_workqueue_activate_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="n">move_linked_works</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">WORK_STRUCT_DELAYED_BIT</span><span class="p">,</span> <span class="n">work_data_bits</span><span class="p">(</span><span class="n">work</span><span class="p">));</span>
	<span class="n">cwq</span><span class="o">-&gt;</span><span class="n">nr_active</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cwq_dec_nr_in_flight - decrement cwq&#39;s nr_in_flight</span>
<span class="cm"> * @cwq: cwq of interest</span>
<span class="cm"> * @color: color of work which left the queue</span>
<span class="cm"> * @delayed: for a delayed work</span>
<span class="cm"> *</span>
<span class="cm"> * A work either has completed or is removed from pending queue,</span>
<span class="cm"> * decrement nr_in_flight of its cwq and handle workqueue flushing.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cwq_dec_nr_in_flight</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">color</span><span class="p">,</span>
				 <span class="n">bool</span> <span class="n">delayed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* ignore uncolored works */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">color</span> <span class="o">==</span> <span class="n">WORK_NO_COLOR</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cwq</span><span class="o">-&gt;</span><span class="n">nr_in_flight</span><span class="p">[</span><span class="n">color</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">delayed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cwq</span><span class="o">-&gt;</span><span class="n">nr_active</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">delayed_works</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* one down, submit a delayed one */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">nr_active</span> <span class="o">&lt;</span> <span class="n">cwq</span><span class="o">-&gt;</span><span class="n">max_active</span><span class="p">)</span>
				<span class="n">cwq_activate_first_delayed</span><span class="p">(</span><span class="n">cwq</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* is flush in progress and are we at the flushing tip? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">flush_color</span> <span class="o">!=</span> <span class="n">color</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* are there still in-flight works? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">nr_in_flight</span><span class="p">[</span><span class="n">color</span><span class="p">])</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* this cwq is done, clear flush_color */</span>
	<span class="n">cwq</span><span class="o">-&gt;</span><span class="n">flush_color</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this was the last cwq, wake up the first flusher.  It</span>
<span class="cm">	 * will handle the rest.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">nr_cwqs_to_flush</span><span class="p">))</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">first_flusher</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * process_one_work - process single work</span>
<span class="cm"> * @worker: self</span>
<span class="cm"> * @work: work to process</span>
<span class="cm"> *</span>
<span class="cm"> * Process @work.  This function contains all the logics necessary to</span>
<span class="cm"> * process a single work including synchronization against and</span>
<span class="cm"> * interaction with other workers on the same cpu, queueing and</span>
<span class="cm"> * flushing.  As long as context requirement is met, any worker can</span>
<span class="cm"> * call this function to process a work.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock) which is released and regrabbed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_one_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">,</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span> <span class="o">=</span> <span class="n">get_work_cwq</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">cwq</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">bwh</span> <span class="o">=</span> <span class="n">busy_worker_head</span><span class="p">(</span><span class="n">gcwq</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">cpu_intensive</span> <span class="o">=</span> <span class="n">cwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_CPU_INTENSIVE</span><span class="p">;</span>
	<span class="n">work_func_t</span> <span class="n">f</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">work_color</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">collision</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
	<span class="cm">/*</span>
<span class="cm">	 * It is permissible to free the struct work_struct from</span>
<span class="cm">	 * inside the function that is called from it, this we need to</span>
<span class="cm">	 * take into account for lockdep too.  To avoid bogus &quot;held</span>
<span class="cm">	 * lock freed&quot; warnings as well as problems when looking into</span>
<span class="cm">	 * work-&gt;lockdep_map, make a copy and use that here.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">lockdep_map</span> <span class="n">lockdep_map</span><span class="p">;</span>

	<span class="n">lockdep_copy_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * A single work shouldn&#39;t be executed concurrently by</span>
<span class="cm">	 * multiple workers on a single cpu.  Check whether anyone is</span>
<span class="cm">	 * already processing the work.  If so, defer the work to the</span>
<span class="cm">	 * currently executing one.</span>
<span class="cm">	 */</span>
	<span class="n">collision</span> <span class="o">=</span> <span class="n">__find_worker_executing_work</span><span class="p">(</span><span class="n">gcwq</span><span class="p">,</span> <span class="n">bwh</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">collision</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">move_linked_works</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">collision</span><span class="o">-&gt;</span><span class="n">scheduled</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* claim and process */</span>
	<span class="n">debug_work_deactivate</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">hentry</span><span class="p">,</span> <span class="n">bwh</span><span class="p">);</span>
	<span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_work</span> <span class="o">=</span> <span class="n">work</span><span class="p">;</span>
	<span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_cwq</span> <span class="o">=</span> <span class="n">cwq</span><span class="p">;</span>
	<span class="n">work_color</span> <span class="o">=</span> <span class="n">get_work_color</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>

	<span class="cm">/* record the current cpu number in the work data and dequeue */</span>
	<span class="n">set_work_cpu</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If HIGHPRI_PENDING, check the next work, and, if HIGHPRI,</span>
<span class="cm">	 * wake up another worker; otherwise, clear HIGHPRI_PENDING.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GCWQ_HIGHPRI_PENDING</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">nwork</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worklist</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">work_struct</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worklist</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">get_work_cwq</span><span class="p">(</span><span class="n">nwork</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_HIGHPRI</span><span class="p">)</span>
			<span class="n">wake_up_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GCWQ_HIGHPRI_PENDING</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * CPU intensive works don&#39;t participate in concurrency</span>
<span class="cm">	 * management.  They&#39;re the scheduler&#39;s responsibility.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cpu_intensive</span><span class="p">))</span>
		<span class="n">worker_set_flags</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">WORKER_CPU_INTENSIVE</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">work_clear_pending</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="n">lock_map_acquire_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>
	<span class="n">lock_map_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_map</span><span class="p">);</span>
	<span class="n">trace_workqueue_execute_start</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="n">f</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * While we must be careful to not use &quot;work&quot; after this, the trace</span>
<span class="cm">	 * point will only record its address.</span>
<span class="cm">	 */</span>
	<span class="n">trace_workqueue_execute_end</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="n">lock_map_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_map</span><span class="p">);</span>
	<span class="n">lock_map_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">in_atomic</span><span class="p">()</span> <span class="o">||</span> <span class="n">lockdep_depth</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;BUG: workqueue leaked lock or atomic: &quot;</span>
		       <span class="s">&quot;%s/0x%08x/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">preempt_count</span><span class="p">(),</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;    last function: &quot;</span><span class="p">);</span>
		<span class="n">print_symbol</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">f</span><span class="p">);</span>
		<span class="n">debug_show_held_locks</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* clear cpu intensive status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cpu_intensive</span><span class="p">))</span>
		<span class="n">worker_clr_flags</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">WORKER_CPU_INTENSIVE</span><span class="p">);</span>

	<span class="cm">/* we&#39;re done with it, release */</span>
	<span class="n">hlist_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">hentry</span><span class="p">);</span>
	<span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_work</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_cwq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cwq_dec_nr_in_flight</span><span class="p">(</span><span class="n">cwq</span><span class="p">,</span> <span class="n">work_color</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * process_scheduled_works - process scheduled works</span>
<span class="cm"> * @worker: self</span>
<span class="cm"> *</span>
<span class="cm"> * Process all scheduled works.  Please note that the scheduled list</span>
<span class="cm"> * may change while processing a work, so this function repeatedly</span>
<span class="cm"> * fetches a work from the top and executes it.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock) which may be released and regrabbed</span>
<span class="cm"> * multiple times.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_scheduled_works</span><span class="p">(</span><span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">scheduled</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">scheduled</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">work_struct</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">process_one_work</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * worker_thread - the worker thread function</span>
<span class="cm"> * @__worker: self</span>
<span class="cm"> *</span>
<span class="cm"> * The gcwq worker thread function.  There&#39;s a single dynamic pool of</span>
<span class="cm"> * these per each cpu.  These workers process all works regardless of</span>
<span class="cm"> * their specific target workqueue.  The only exception is works which</span>
<span class="cm"> * belong to workqueues with a rescuer which will be explained in</span>
<span class="cm"> * rescuer_thread().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">worker_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__worker</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span> <span class="o">=</span> <span class="n">__worker</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="p">;</span>

	<span class="cm">/* tell the scheduler that this is a workqueue worker */</span>
	<span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_WQ_WORKER</span><span class="p">;</span>
<span class="nl">woke_up:</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* DIE can be set only while we&#39;re idle, checking here is enough */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WORKER_DIE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PF_WQ_WORKER</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">worker_leave_idle</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
<span class="nl">recheck:</span>
	<span class="cm">/* no more worker necessary? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_more_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">sleep</span><span class="p">;</span>

	<span class="cm">/* do we need to manage? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">may_start_working</span><span class="p">(</span><span class="n">gcwq</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">manage_workers</span><span class="p">(</span><span class="n">worker</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">recheck</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * -&gt;scheduled list can only be filled while a worker is</span>
<span class="cm">	 * preparing to process a work or actually processing it.</span>
<span class="cm">	 * Make sure nobody diddled with it while I was sleeping.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">scheduled</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * When control reaches this point, we&#39;re guaranteed to have</span>
<span class="cm">	 * at least one idle worker or that someone else has already</span>
<span class="cm">	 * assumed the manager role.</span>
<span class="cm">	 */</span>
	<span class="n">worker_clr_flags</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">WORKER_PREP</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span>
			<span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worklist</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">work_struct</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">work_data_bits</span><span class="p">(</span><span class="n">work</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">WORK_STRUCT_LINKED</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* optimization path, not strictly necessary */</span>
			<span class="n">process_one_work</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">scheduled</span><span class="p">)))</span>
				<span class="n">process_scheduled_works</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">move_linked_works</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">scheduled</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">process_scheduled_works</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">keep_working</span><span class="p">(</span><span class="n">gcwq</span><span class="p">));</span>

	<span class="n">worker_set_flags</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">WORKER_PREP</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="nl">sleep:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">need_to_manage_workers</span><span class="p">(</span><span class="n">gcwq</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">manage_workers</span><span class="p">(</span><span class="n">worker</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">recheck</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * gcwq-&gt;lock is held and there&#39;s no work to process and no</span>
<span class="cm">	 * need to manage, sleep.  Workers are woken up only while</span>
<span class="cm">	 * holding gcwq-&gt;lock or from local cpu, so setting the</span>
<span class="cm">	 * current state before releasing gcwq-&gt;lock is enough to</span>
<span class="cm">	 * prevent losing any event.</span>
<span class="cm">	 */</span>
	<span class="n">worker_enter_idle</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">schedule</span><span class="p">();</span>
	<span class="k">goto</span> <span class="n">woke_up</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rescuer_thread - the rescuer thread function</span>
<span class="cm"> * @__wq: the associated workqueue</span>
<span class="cm"> *</span>
<span class="cm"> * Workqueue rescuer thread function.  There&#39;s one rescuer for each</span>
<span class="cm"> * workqueue which has WQ_RESCUER set.</span>
<span class="cm"> *</span>
<span class="cm"> * Regular work processing on a gcwq may block trying to create a new</span>
<span class="cm"> * worker which uses GFP_KERNEL allocation which has slight chance of</span>
<span class="cm"> * developing into deadlock if some works currently on the same queue</span>
<span class="cm"> * need to be processed to satisfy the GFP_KERNEL allocation.  This is</span>
<span class="cm"> * the problem rescuer solves.</span>
<span class="cm"> *</span>
<span class="cm"> * When such condition is possible, the gcwq summons rescuers of all</span>
<span class="cm"> * workqueues which have works queued on the gcwq and let them process</span>
<span class="cm"> * those works so that forward progress can be guaranteed.</span>
<span class="cm"> *</span>
<span class="cm"> * This should happen rarely.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rescuer_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span> <span class="o">=</span> <span class="n">__wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">rescuer</span> <span class="o">=</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">rescuer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">scheduled</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rescuer</span><span class="o">-&gt;</span><span class="n">scheduled</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_unbound</span> <span class="o">=</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_UNBOUND</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">RESCUER_NICE_LEVEL</span><span class="p">);</span>
<span class="nl">repeat:</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * See whether any cpu is asking for help.  Unbounded</span>
<span class="cm">	 * workqueues use cpu 0 in mayday_mask for CPU_UNBOUND.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_mayday_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">mayday_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tcpu</span> <span class="o">=</span> <span class="n">is_unbound</span> <span class="o">?</span> <span class="n">WORK_CPU_UNBOUND</span> <span class="o">:</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span> <span class="o">=</span> <span class="n">get_cwq</span><span class="p">(</span><span class="n">tcpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">cwq</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
		<span class="n">mayday_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">mayday_mask</span><span class="p">);</span>

		<span class="cm">/* migrate to the target cpu if possible */</span>
		<span class="n">rescuer</span><span class="o">-&gt;</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">gcwq</span><span class="p">;</span>
		<span class="n">worker_maybe_bind_and_lock</span><span class="p">(</span><span class="n">rescuer</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Slurp in all works issued via this workqueue and</span>
<span class="cm">		 * process&#39;em.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rescuer</span><span class="o">-&gt;</span><span class="n">scheduled</span><span class="p">));</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worklist</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">get_work_cwq</span><span class="p">(</span><span class="n">work</span><span class="p">)</span> <span class="o">==</span> <span class="n">cwq</span><span class="p">)</span>
				<span class="n">move_linked_works</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">scheduled</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>

		<span class="n">process_scheduled_works</span><span class="p">(</span><span class="n">rescuer</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Leave this gcwq.  If keep_working() is %true, notify a</span>
<span class="cm">		 * regular worker; otherwise, we end up with 0 concurrency</span>
<span class="cm">		 * and stalling the execution.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">keep_working</span><span class="p">(</span><span class="n">gcwq</span><span class="p">))</span>
			<span class="n">wake_up_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">);</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">schedule</span><span class="p">();</span>
	<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">wq_barrier</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">done</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wq_barrier_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wq_barrier</span> <span class="o">*</span><span class="n">barr</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wq_barrier</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barr</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * insert_wq_barrier - insert a barrier work</span>
<span class="cm"> * @cwq: cwq to insert barrier into</span>
<span class="cm"> * @barr: wq_barrier to insert</span>
<span class="cm"> * @target: target work to attach @barr to</span>
<span class="cm"> * @worker: worker currently executing @target, NULL if @target is not executing</span>
<span class="cm"> *</span>
<span class="cm"> * @barr is linked to @target such that @barr is completed only after</span>
<span class="cm"> * @target finishes execution.  Please note that the ordering</span>
<span class="cm"> * guarantee is observed only with respect to @target and on the local</span>
<span class="cm"> * cpu.</span>
<span class="cm"> *</span>
<span class="cm"> * Currently, a queued barrier can&#39;t be canceled.  This is because</span>
<span class="cm"> * try_to_grab_pending() can&#39;t determine whether the work to be</span>
<span class="cm"> * grabbed is at the head of the queue and thus can&#39;t clear LINKED</span>
<span class="cm"> * flag of the previous work while there must be a valid next work</span>
<span class="cm"> * after a work with LINKED flag set.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that when @worker is non-NULL, @target may be modified</span>
<span class="cm"> * underneath us, so we can&#39;t reliably determine cwq from @target.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">insert_wq_barrier</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">wq_barrier</span> <span class="o">*</span><span class="n">barr</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">linked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * debugobject calls are safe here even with gcwq-&gt;lock locked</span>
<span class="cm">	 * as we know for sure that this will not trigger any of the</span>
<span class="cm">	 * checks and call back into the fixup functions where we</span>
<span class="cm">	 * might deadlock.</span>
<span class="cm">	 */</span>
	<span class="n">INIT_WORK_ONSTACK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barr</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">wq_barrier_func</span><span class="p">);</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">WORK_STRUCT_PENDING_BIT</span><span class="p">,</span> <span class="n">work_data_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barr</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">));</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barr</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If @target is currently being executed, schedule the</span>
<span class="cm">	 * barrier to the worker; otherwise, put it after @target.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">worker</span><span class="p">)</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">scheduled</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bits</span> <span class="o">=</span> <span class="n">work_data_bits</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>

		<span class="n">head</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="cm">/* there can already be other linked works, inherit and set */</span>
		<span class="n">linked</span> <span class="o">=</span> <span class="o">*</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">WORK_STRUCT_LINKED</span><span class="p">;</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">WORK_STRUCT_LINKED_BIT</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">debug_work_activate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barr</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="n">insert_work</span><span class="p">(</span><span class="n">cwq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">barr</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span>
		    <span class="n">work_color_to_flags</span><span class="p">(</span><span class="n">WORK_NO_COLOR</span><span class="p">)</span> <span class="o">|</span> <span class="n">linked</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * flush_workqueue_prep_cwqs - prepare cwqs for workqueue flushing</span>
<span class="cm"> * @wq: workqueue being flushed</span>
<span class="cm"> * @flush_color: new flush color, &lt; 0 for no-op</span>
<span class="cm"> * @work_color: new work color, &lt; 0 for no-op</span>
<span class="cm"> *</span>
<span class="cm"> * Prepare cwqs for workqueue flushing.</span>
<span class="cm"> *</span>
<span class="cm"> * If @flush_color is non-negative, flush_color on all cwqs should be</span>
<span class="cm"> * -1.  If no cwq has in-flight commands at the specified color, all</span>
<span class="cm"> * cwq-&gt;flush_color&#39;s stay at -1 and %false is returned.  If any cwq</span>
<span class="cm"> * has in flight commands, its cwq-&gt;flush_color is set to</span>
<span class="cm"> * @flush_color, @wq-&gt;nr_cwqs_to_flush is updated accordingly, cwq</span>
<span class="cm"> * wakeup logic is armed and %true is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller should have initialized @wq-&gt;first_flusher prior to</span>
<span class="cm"> * calling this function with non-negative @flush_color.  If</span>
<span class="cm"> * @flush_color is negative, no flush color update is done and %false</span>
<span class="cm"> * is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * If @work_color is non-negative, all cwqs should have the same</span>
<span class="cm"> * work_color which is previous to @work_color and all will be</span>
<span class="cm"> * advanced to @work_color.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * mutex_lock(wq-&gt;flush_mutex).</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * %true if @flush_color &gt;= 0 and there&#39;s something to flush.  %false</span>
<span class="cm"> * otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">flush_workqueue_prep_cwqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">flush_color</span><span class="p">,</span> <span class="kt">int</span> <span class="n">work_color</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">wait</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flush_color</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">nr_cwqs_to_flush</span><span class="p">));</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">nr_cwqs_to_flush</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">for_each_cwq_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span> <span class="o">=</span> <span class="n">get_cwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">cwq</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flush_color</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">flush_color</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">nr_in_flight</span><span class="p">[</span><span class="n">flush_color</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">cwq</span><span class="o">-&gt;</span><span class="n">flush_color</span> <span class="o">=</span> <span class="n">flush_color</span><span class="p">;</span>
				<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">nr_cwqs_to_flush</span><span class="p">);</span>
				<span class="n">wait</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">work_color</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">work_color</span> <span class="o">!=</span> <span class="n">work_next_color</span><span class="p">(</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">work_color</span><span class="p">));</span>
			<span class="n">cwq</span><span class="o">-&gt;</span><span class="n">work_color</span> <span class="o">=</span> <span class="n">work_color</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flush_color</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">nr_cwqs_to_flush</span><span class="p">))</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">first_flusher</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">wait</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * flush_workqueue - ensure that any scheduled work has run to completion.</span>
<span class="cm"> * @wq: workqueue to flush</span>
<span class="cm"> *</span>
<span class="cm"> * Forces execution of the workqueue and blocks until its completion.</span>
<span class="cm"> * This is typically used in driver shutdown handlers.</span>
<span class="cm"> *</span>
<span class="cm"> * We sleep until all works which were queued on entry have been handled,</span>
<span class="cm"> * but we are not livelocked by new incoming ones.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">flush_workqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wq_flusher</span> <span class="n">this_flusher</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">list</span> <span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">this_flusher</span><span class="p">.</span><span class="n">list</span><span class="p">),</span>
		<span class="p">.</span><span class="n">flush_color</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">done</span> <span class="o">=</span> <span class="n">COMPLETION_INITIALIZER_ONSTACK</span><span class="p">(</span><span class="n">this_flusher</span><span class="p">.</span><span class="n">done</span><span class="p">),</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">next_color</span><span class="p">;</span>

	<span class="n">lock_map_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>
	<span class="n">lock_map_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start-to-wait phase</span>
<span class="cm">	 */</span>
	<span class="n">next_color</span> <span class="o">=</span> <span class="n">work_next_color</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">work_color</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next_color</span> <span class="o">!=</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_color</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Color space is not full.  The current work_color</span>
<span class="cm">		 * becomes our flush_color and work_color is advanced</span>
<span class="cm">		 * by one.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flusher_overflow</span><span class="p">));</span>
		<span class="n">this_flusher</span><span class="p">.</span><span class="n">flush_color</span> <span class="o">=</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">work_color</span><span class="p">;</span>
		<span class="n">wq</span><span class="o">-&gt;</span><span class="n">work_color</span> <span class="o">=</span> <span class="n">next_color</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">first_flusher</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* no flush in progress, become the first flusher */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_color</span> <span class="o">!=</span> <span class="n">this_flusher</span><span class="p">.</span><span class="n">flush_color</span><span class="p">);</span>

			<span class="n">wq</span><span class="o">-&gt;</span><span class="n">first_flusher</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this_flusher</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flush_workqueue_prep_cwqs</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_color</span><span class="p">,</span>
						       <span class="n">wq</span><span class="o">-&gt;</span><span class="n">work_color</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* nothing to flush, done */</span>
				<span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_color</span> <span class="o">=</span> <span class="n">next_color</span><span class="p">;</span>
				<span class="n">wq</span><span class="o">-&gt;</span><span class="n">first_flusher</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* wait in queue */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_color</span> <span class="o">==</span> <span class="n">this_flusher</span><span class="p">.</span><span class="n">flush_color</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_flusher</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flusher_queue</span><span class="p">);</span>
			<span class="n">flush_workqueue_prep_cwqs</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">work_color</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Oops, color space is full, wait on overflow queue.</span>
<span class="cm">		 * The next flush completion will assign us</span>
<span class="cm">		 * flush_color and transfer to flusher_queue.</span>
<span class="cm">		 */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_flusher</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flusher_overflow</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_mutex</span><span class="p">);</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_flusher</span><span class="p">.</span><span class="n">done</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wake-up-and-cascade phase</span>
<span class="cm">	 *</span>
<span class="cm">	 * First flushers are responsible for cascading flushes and</span>
<span class="cm">	 * handling overflow.  Non-first flushers can simply return.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">first_flusher</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">this_flusher</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_mutex</span><span class="p">);</span>

	<span class="cm">/* we might have raced, check again with mutex held */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">first_flusher</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">this_flusher</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">wq</span><span class="o">-&gt;</span><span class="n">first_flusher</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_flusher</span><span class="p">.</span><span class="n">list</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_color</span> <span class="o">!=</span> <span class="n">this_flusher</span><span class="p">.</span><span class="n">flush_color</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">wq_flusher</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

		<span class="cm">/* complete all the flushers sharing the current flush color */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flusher_queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">flush_color</span> <span class="o">!=</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_color</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flusher_overflow</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_color</span> <span class="o">!=</span> <span class="n">work_next_color</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">work_color</span><span class="p">));</span>

		<span class="cm">/* this flush_color is finished, advance by one */</span>
		<span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_color</span> <span class="o">=</span> <span class="n">work_next_color</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_color</span><span class="p">);</span>

		<span class="cm">/* one color has been freed, handle overflow queue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flusher_overflow</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Assign the same color to all overflowed</span>
<span class="cm">			 * flushers, advance work_color and append to</span>
<span class="cm">			 * flusher_queue.  This is the start-to-wait</span>
<span class="cm">			 * phase for these overflowed flushers.</span>
<span class="cm">			 */</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flusher_overflow</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
				<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flush_color</span> <span class="o">=</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">work_color</span><span class="p">;</span>

			<span class="n">wq</span><span class="o">-&gt;</span><span class="n">work_color</span> <span class="o">=</span> <span class="n">work_next_color</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">work_color</span><span class="p">);</span>

			<span class="n">list_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flusher_overflow</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flusher_queue</span><span class="p">);</span>
			<span class="n">flush_workqueue_prep_cwqs</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">work_color</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flusher_queue</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_color</span> <span class="o">!=</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">work_color</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Need to flush more colors.  Make the next flusher</span>
<span class="cm">		 * the new first flusher and arm cwqs.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_color</span> <span class="o">==</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">work_color</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_color</span> <span class="o">!=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">flush_color</span><span class="p">);</span>

		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">wq</span><span class="o">-&gt;</span><span class="n">first_flusher</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flush_workqueue_prep_cwqs</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_color</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Meh... this color is already done, clear first</span>
<span class="cm">		 * flusher and repeat cascading.</span>
<span class="cm">		 */</span>
		<span class="n">wq</span><span class="o">-&gt;</span><span class="n">first_flusher</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">flush_workqueue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drain_workqueue - drain a workqueue</span>
<span class="cm"> * @wq: workqueue to drain</span>
<span class="cm"> *</span>
<span class="cm"> * Wait until the workqueue becomes empty.  While draining is in progress,</span>
<span class="cm"> * only chain queueing is allowed.  IOW, only currently pending or running</span>
<span class="cm"> * work items on @wq can queue further work items on it.  @wq is flushed</span>
<span class="cm"> * repeatedly until it becomes empty.  The number of flushing is detemined</span>
<span class="cm"> * by the depth of chaining and should be relatively short.  Whine if it</span>
<span class="cm"> * takes too long.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">drain_workqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flush_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * __queue_work() needs to test whether there are drainers, is much</span>
<span class="cm">	 * hotter than drain_workqueue() and already looks at @wq-&gt;flags.</span>
<span class="cm">	 * Use WQ_DRAINING so that queue doesn&#39;t have to check nr_drainers.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workqueue_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">nr_drainers</span><span class="o">++</span><span class="p">)</span>
		<span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">WQ_DRAINING</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workqueue_lock</span><span class="p">);</span>
<span class="nl">reflush:</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">wq</span><span class="p">);</span>

	<span class="n">for_each_cwq_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span> <span class="o">=</span> <span class="n">get_cwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>
		<span class="n">bool</span> <span class="n">drained</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">drained</span> <span class="o">=</span> <span class="o">!</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">nr_active</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">delayed_works</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">drained</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">flush_cnt</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">flush_cnt</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">flush_cnt</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="p">))</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;workqueue %s: flush on destruction isn&#39;t complete after %u tries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">wq</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">flush_cnt</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">reflush</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workqueue_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">nr_drainers</span><span class="p">)</span>
		<span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">WQ_DRAINING</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workqueue_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">drain_workqueue</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">start_flush_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wq_barrier</span> <span class="o">*</span><span class="n">barr</span><span class="p">,</span>
			     <span class="n">bool</span> <span class="n">wait_executing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="n">gcwq</span> <span class="o">=</span> <span class="n">get_work_gcwq</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gcwq</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * See the comment near try_to_grab_pending()-&gt;smp_rmb().</span>
<span class="cm">		 * If it was re-queued to a different gcwq under us, we</span>
<span class="cm">		 * are not going to wait.</span>
<span class="cm">		 */</span>
		<span class="n">smp_rmb</span><span class="p">();</span>
		<span class="n">cwq</span> <span class="o">=</span> <span class="n">get_work_cwq</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cwq</span> <span class="o">||</span> <span class="n">gcwq</span> <span class="o">!=</span> <span class="n">cwq</span><span class="o">-&gt;</span><span class="n">gcwq</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">already_gone</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wait_executing</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">worker</span> <span class="o">=</span> <span class="n">find_worker_executing_work</span><span class="p">(</span><span class="n">gcwq</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">worker</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">already_gone</span><span class="p">;</span>
		<span class="n">cwq</span> <span class="o">=</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_cwq</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">goto</span> <span class="n">already_gone</span><span class="p">;</span>

	<span class="n">insert_wq_barrier</span><span class="p">(</span><span class="n">cwq</span><span class="p">,</span> <span class="n">barr</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">worker</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If @max_active is 1 or rescuer is in use, flushing another work</span>
<span class="cm">	 * item on the same workqueue may lead to deadlock.  Make sure the</span>
<span class="cm">	 * flusher is not running on the same workqueue by verifying write</span>
<span class="cm">	 * access.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">saved_max_active</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">cwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_RESCUER</span><span class="p">)</span>
		<span class="n">lock_map_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">lock_map_acquire_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>
	<span class="n">lock_map_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="nl">already_gone:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * flush_work - wait for a work to finish executing the last queueing instance</span>
<span class="cm"> * @work: the work to flush</span>
<span class="cm"> *</span>
<span class="cm"> * Wait until @work has finished execution.  This function considers</span>
<span class="cm"> * only the last queueing instance of @work.  If @work has been</span>
<span class="cm"> * enqueued across different CPUs on a non-reentrant workqueue or on</span>
<span class="cm"> * multiple workqueues, @work might still be executing on return on</span>
<span class="cm"> * some of the CPUs from earlier queueing.</span>
<span class="cm"> *</span>
<span class="cm"> * If @work was queued only on a non-reentrant, ordered or unbound</span>
<span class="cm"> * workqueue, @work is guaranteed to be idle on return if it hasn&#39;t</span>
<span class="cm"> * been requeued since flush started.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * %true if flush_work() waited for the work to finish execution,</span>
<span class="cm"> * %false if it was already idle.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">flush_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wq_barrier</span> <span class="n">barr</span><span class="p">;</span>

	<span class="n">lock_map_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>
	<span class="n">lock_map_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start_flush_work</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">barr</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barr</span><span class="p">.</span><span class="n">done</span><span class="p">);</span>
		<span class="n">destroy_work_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barr</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">flush_work</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">wait_on_cpu_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wq_barrier</span> <span class="n">barr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">worker</span> <span class="o">=</span> <span class="n">find_worker_executing_work</span><span class="p">(</span><span class="n">gcwq</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">worker</span><span class="p">))</span>
		<span class="n">insert_wq_barrier</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_cwq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">barr</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">worker</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">worker</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barr</span><span class="p">.</span><span class="n">done</span><span class="p">);</span>
		<span class="n">destroy_work_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barr</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">wait_on_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">lock_map_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>
	<span class="n">lock_map_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>

	<span class="n">for_each_gcwq_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">wait_on_cpu_work</span><span class="p">(</span><span class="n">get_gcwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * flush_work_sync - wait until a work has finished execution</span>
<span class="cm"> * @work: the work to flush</span>
<span class="cm"> *</span>
<span class="cm"> * Wait until @work has finished execution.  On return, it&#39;s</span>
<span class="cm"> * guaranteed that all queueing instances of @work which happened</span>
<span class="cm"> * before this function is called are finished.  In other words, if</span>
<span class="cm"> * @work hasn&#39;t been requeued since this function was called, @work is</span>
<span class="cm"> * guaranteed to be idle on return.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * %true if flush_work_sync() waited for the work to finish execution,</span>
<span class="cm"> * %false if it was already idle.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">flush_work_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wq_barrier</span> <span class="n">barr</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">pending</span><span class="p">,</span> <span class="n">waited</span><span class="p">;</span>

	<span class="cm">/* we&#39;ll wait for executions separately, queue barr only if pending */</span>
	<span class="n">pending</span> <span class="o">=</span> <span class="n">start_flush_work</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">barr</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="cm">/* wait for executions to finish */</span>
	<span class="n">waited</span> <span class="o">=</span> <span class="n">wait_on_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>

	<span class="cm">/* wait for the pending one */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pending</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barr</span><span class="p">.</span><span class="n">done</span><span class="p">);</span>
		<span class="n">destroy_work_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barr</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pending</span> <span class="o">||</span> <span class="n">waited</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">flush_work_sync</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Upon a successful return (&gt;= 0), the caller &quot;owns&quot; WORK_STRUCT_PENDING bit,</span>
<span class="cm"> * so this work can&#39;t be re-armed in any way.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_to_grab_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">WORK_STRUCT_PENDING_BIT</span><span class="p">,</span> <span class="n">work_data_bits</span><span class="p">(</span><span class="n">work</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The queueing is in progress, or it is already queued. Try to</span>
<span class="cm">	 * steal it from -&gt;worklist without clearing WORK_STRUCT_PENDING.</span>
<span class="cm">	 */</span>
	<span class="n">gcwq</span> <span class="o">=</span> <span class="n">get_work_gcwq</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gcwq</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This work is queued, but perhaps we locked the wrong gcwq.</span>
<span class="cm">		 * In that case we must see the new value after rmb(), see</span>
<span class="cm">		 * insert_work()-&gt;wmb().</span>
<span class="cm">		 */</span>
		<span class="n">smp_rmb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gcwq</span> <span class="o">==</span> <span class="n">get_work_gcwq</span><span class="p">(</span><span class="n">work</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">debug_work_deactivate</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
			<span class="n">cwq_dec_nr_in_flight</span><span class="p">(</span><span class="n">get_work_cwq</span><span class="p">(</span><span class="n">work</span><span class="p">),</span>
				<span class="n">get_work_color</span><span class="p">(</span><span class="n">work</span><span class="p">),</span>
				<span class="o">*</span><span class="n">work_data_bits</span><span class="p">(</span><span class="n">work</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">WORK_STRUCT_DELAYED</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">__cancel_work_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">timer_list</span><span class="o">*</span> <span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">timer</span> <span class="o">&amp;&amp;</span> <span class="n">likely</span><span class="p">(</span><span class="n">del_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">)));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">try_to_grab_pending</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
		<span class="n">wait_on_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">));</span>

	<span class="n">clear_work_data</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cancel_work_sync - cancel a work and wait for it to finish</span>
<span class="cm"> * @work: the work to cancel</span>
<span class="cm"> *</span>
<span class="cm"> * Cancel @work and wait for its execution to finish.  This function</span>
<span class="cm"> * can be used even if the work re-queues itself or migrates to</span>
<span class="cm"> * another workqueue.  On return from this function, @work is</span>
<span class="cm"> * guaranteed to be not pending or executing on any CPU.</span>
<span class="cm"> *</span>
<span class="cm"> * cancel_work_sync(&amp;delayed_work-&gt;work) must not be used for</span>
<span class="cm"> * delayed_work&#39;s.  Use cancel_delayed_work_sync() instead.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must ensure that the workqueue on which @work was last</span>
<span class="cm"> * queued can&#39;t be destroyed before this function returns.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * %true if @work was pending, %false otherwise.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">cancel_work_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__cancel_work_timer</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cancel_work_sync</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * flush_delayed_work - wait for a dwork to finish executing the last queueing</span>
<span class="cm"> * @dwork: the delayed work to flush</span>
<span class="cm"> *</span>
<span class="cm"> * Delayed timer is cancelled and the pending work is queued for</span>
<span class="cm"> * immediate execution.  Like flush_work(), this function only</span>
<span class="cm"> * considers the last queueing instance of @dwork.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * %true if flush_work() waited for the work to finish execution,</span>
<span class="cm"> * %false if it was already idle.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">flush_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwork</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">))</span>
		<span class="n">__queue_work</span><span class="p">(</span><span class="n">raw_smp_processor_id</span><span class="p">(),</span>
			     <span class="n">get_work_cwq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwork</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwork</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">flush_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwork</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">flush_delayed_work</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * flush_delayed_work_sync - wait for a dwork to finish</span>
<span class="cm"> * @dwork: the delayed work to flush</span>
<span class="cm"> *</span>
<span class="cm"> * Delayed timer is cancelled and the pending work is queued for</span>
<span class="cm"> * execution immediately.  Other than timer handling, its behavior</span>
<span class="cm"> * is identical to flush_work_sync().</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * %true if flush_work_sync() waited for the work to finish execution,</span>
<span class="cm"> * %false if it was already idle.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">flush_delayed_work_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwork</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">))</span>
		<span class="n">__queue_work</span><span class="p">(</span><span class="n">raw_smp_processor_id</span><span class="p">(),</span>
			     <span class="n">get_work_cwq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwork</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwork</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">flush_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwork</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">flush_delayed_work_sync</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * cancel_delayed_work_sync - cancel a delayed work and wait for it to finish</span>
<span class="cm"> * @dwork: the delayed work cancel</span>
<span class="cm"> *</span>
<span class="cm"> * This is cancel_work_sync() for delayed works.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * %true if @dwork was pending, %false otherwise.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">cancel_delayed_work_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__cancel_work_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwork</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwork</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cancel_delayed_work_sync</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * schedule_work - put work task in global workqueue</span>
<span class="cm"> * @work: job to be done</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if @work was already on the kernel-global workqueue and</span>
<span class="cm"> * non-zero otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * This puts a job in the kernel-global workqueue if it was not already</span>
<span class="cm"> * queued and leaves it in the same position on the kernel-global</span>
<span class="cm"> * workqueue otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">schedule_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_work</span><span class="p">(</span><span class="n">system_wq</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">schedule_work</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * schedule_work_on - put work task on a specific cpu</span>
<span class="cm"> * @cpu: cpu to put the work task on</span>
<span class="cm"> * @work: job to be done</span>
<span class="cm"> *</span>
<span class="cm"> * This puts a job on a specific cpu</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">schedule_work_on</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_work_on</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">system_wq</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">schedule_work_on</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * schedule_delayed_work - put work task in global workqueue after delay</span>
<span class="cm"> * @dwork: job to be done</span>
<span class="cm"> * @delay: number of jiffies to wait or 0 for immediate execution</span>
<span class="cm"> *</span>
<span class="cm"> * After waiting for a given time this puts a job in the kernel-global</span>
<span class="cm"> * workqueue.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">schedule_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_wq</span><span class="p">,</span> <span class="n">dwork</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">schedule_delayed_work</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * schedule_delayed_work_on - queue work in global workqueue on CPU after delay</span>
<span class="cm"> * @cpu: cpu to use</span>
<span class="cm"> * @dwork: job to be done</span>
<span class="cm"> * @delay: number of jiffies to wait</span>
<span class="cm"> *</span>
<span class="cm"> * After waiting for a given time this puts a job in the kernel-global</span>
<span class="cm"> * workqueue on the specified CPU.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">schedule_delayed_work_on</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">queue_delayed_work_on</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">system_wq</span><span class="p">,</span> <span class="n">dwork</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">schedule_delayed_work_on</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * schedule_on_each_cpu - execute a function synchronously on each online CPU</span>
<span class="cm"> * @func: the function to call</span>
<span class="cm"> *</span>
<span class="cm"> * schedule_on_each_cpu() executes @func on each online CPU using the</span>
<span class="cm"> * system workqueue and blocks until all CPUs have completed.</span>
<span class="cm"> * schedule_on_each_cpu() is very slow.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">schedule_on_each_cpu</span><span class="p">(</span><span class="n">work_func_t</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">works</span><span class="p">;</span>

	<span class="n">works</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">works</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">works</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="n">INIT_WORK</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
		<span class="n">schedule_work_on</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">flush_work</span><span class="p">(</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">works</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>

	<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">works</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * flush_scheduled_work - ensure that any scheduled work has run to completion.</span>
<span class="cm"> *</span>
<span class="cm"> * Forces execution of the kernel-global workqueue and blocks until its</span>
<span class="cm"> * completion.</span>
<span class="cm"> *</span>
<span class="cm"> * Think twice before calling this function!  It&#39;s very easy to get into</span>
<span class="cm"> * trouble if you don&#39;t take great care.  Either of the following situations</span>
<span class="cm"> * will lead to deadlock:</span>
<span class="cm"> *</span>
<span class="cm"> *	One of the work items currently on the workqueue needs to acquire</span>
<span class="cm"> *	a lock held by your code or its caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	Your code is running in the context of a work routine.</span>
<span class="cm"> *</span>
<span class="cm"> * They will be detected by lockdep when they occur, but the first might not</span>
<span class="cm"> * occur very often.  It depends on what work items are on the workqueue and</span>
<span class="cm"> * what locks they need, which you have no control over.</span>
<span class="cm"> *</span>
<span class="cm"> * In most situations flushing the entire workqueue is overkill; you merely</span>
<span class="cm"> * need to know that a particular work item isn&#39;t queued and isn&#39;t running.</span>
<span class="cm"> * In such cases you should use cancel_delayed_work_sync() or</span>
<span class="cm"> * cancel_work_sync() instead.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">flush_scheduled_work</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">system_wq</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">flush_scheduled_work</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * execute_in_process_context - reliably execute the routine with user context</span>
<span class="cm"> * @fn:		the function to execute</span>
<span class="cm"> * @ew:		guaranteed storage for the execute work structure (must</span>
<span class="cm"> *		be available when the work executes)</span>
<span class="cm"> *</span>
<span class="cm"> * Executes the function immediately if process context is available,</span>
<span class="cm"> * otherwise schedules the function for delayed execution.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:	0 - function was executed</span>
<span class="cm"> *		1 - function was scheduled for execution</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">execute_in_process_context</span><span class="p">(</span><span class="n">work_func_t</span> <span class="n">fn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">execute_work</span> <span class="o">*</span><span class="n">ew</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_interrupt</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ew</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ew</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ew</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">execute_in_process_context</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">keventd_up</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">system_wq</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_cwqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * cwqs are forced aligned according to WORK_STRUCT_FLAG_BITS.</span>
<span class="cm">	 * Make sure that the alignment isn&#39;t lower than that of</span>
<span class="cm">	 * unsigned long long.</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpu_workqueue_struct</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">align</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">WORK_STRUCT_FLAG_BITS</span><span class="p">,</span>
				   <span class="n">__alignof__</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_UNBOUND</span><span class="p">))</span>
		<span class="n">wq</span><span class="o">-&gt;</span><span class="n">cpu_wq</span><span class="p">.</span><span class="n">pcpu</span> <span class="o">=</span> <span class="n">__alloc_percpu</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Allocate enough room to align cwq and put an extra</span>
<span class="cm">		 * pointer at the end pointing back to the originally</span>
<span class="cm">		 * allocated pointer which will be used for free.</span>
<span class="cm">		 */</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">align</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wq</span><span class="o">-&gt;</span><span class="n">cpu_wq</span><span class="p">.</span><span class="n">single</span> <span class="o">=</span> <span class="n">PTR_ALIGN</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
			<span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">cpu_wq</span><span class="p">.</span><span class="n">single</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* just in case, make sure it&#39;s actually aligned */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">cpu_wq</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">align</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">cpu_wq</span><span class="p">.</span><span class="n">v</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_cwqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_UNBOUND</span><span class="p">))</span>
		<span class="n">free_percpu</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">cpu_wq</span><span class="p">.</span><span class="n">pcpu</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">cpu_wq</span><span class="p">.</span><span class="n">single</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* the pointer to free is stored right after the cwq */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">cpu_wq</span><span class="p">.</span><span class="n">single</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wq_clamp_max_active</span><span class="p">(</span><span class="kt">int</span> <span class="n">max_active</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lim</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_UNBOUND</span> <span class="o">?</span> <span class="n">WQ_UNBOUND_MAX_ACTIVE</span> <span class="o">:</span> <span class="n">WQ_MAX_ACTIVE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_active</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">max_active</span> <span class="o">&gt;</span> <span class="n">lim</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;workqueue: max_active %d requested for %s &quot;</span>
		       <span class="s">&quot;is out of range, clamping between %d and %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">max_active</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lim</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">clamp_val</span><span class="p">(</span><span class="n">max_active</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lim</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="nf">__alloc_workqueue_key</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
					       <span class="kt">int</span> <span class="n">max_active</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
					       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lock_name</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">,</span> <span class="n">args1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">namelen</span><span class="p">;</span>

	<span class="cm">/* determine namelen, allocate wq and format name */</span>
	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">lock_name</span><span class="p">);</span>
	<span class="n">va_copy</span><span class="p">(</span><span class="n">args1</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">namelen</span> <span class="o">=</span> <span class="n">vsnprintf</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">wq</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">wq</span><span class="p">)</span> <span class="o">+</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wq</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">vsnprintf</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args1</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Workqueues which may be used during memory reclaim should</span>
<span class="cm">	 * have a rescuer to guarantee forward progress.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_MEM_RECLAIM</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">WQ_RESCUER</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unbound workqueues aren&#39;t concurrency managed and should be</span>
<span class="cm">	 * dispatched to workers immediately.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_UNBOUND</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">WQ_HIGHPRI</span><span class="p">;</span>

	<span class="n">max_active</span> <span class="o">=</span> <span class="n">max_active</span> <span class="o">?:</span> <span class="n">WQ_DFL_ACTIVE</span><span class="p">;</span>
	<span class="n">max_active</span> <span class="o">=</span> <span class="n">wq_clamp_max_active</span><span class="p">(</span><span class="n">max_active</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* init wq */</span>
	<span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">wq</span><span class="o">-&gt;</span><span class="n">saved_max_active</span> <span class="o">=</span> <span class="n">max_active</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flush_mutex</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">nr_cwqs_to_flush</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flusher_queue</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flusher_overflow</span><span class="p">);</span>

	<span class="n">lockdep_init_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">,</span> <span class="n">lock_name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_cwqs</span><span class="p">(</span><span class="n">wq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">for_each_cwq_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span> <span class="o">=</span> <span class="n">get_cwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">get_gcwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cwq</span> <span class="o">&amp;</span> <span class="n">WORK_STRUCT_FLAG_MASK</span><span class="p">);</span>
		<span class="n">cwq</span><span class="o">-&gt;</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">gcwq</span><span class="p">;</span>
		<span class="n">cwq</span><span class="o">-&gt;</span><span class="n">wq</span> <span class="o">=</span> <span class="n">wq</span><span class="p">;</span>
		<span class="n">cwq</span><span class="o">-&gt;</span><span class="n">flush_color</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">cwq</span><span class="o">-&gt;</span><span class="n">max_active</span> <span class="o">=</span> <span class="n">max_active</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">delayed_works</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_RESCUER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">rescuer</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_mayday_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">mayday_mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">wq</span><span class="o">-&gt;</span><span class="n">rescuer</span> <span class="o">=</span> <span class="n">rescuer</span> <span class="o">=</span> <span class="n">alloc_worker</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rescuer</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">rescuer</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">kthread_create</span><span class="p">(</span><span class="n">rescuer_thread</span><span class="p">,</span> <span class="n">wq</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
					       <span class="n">wq</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rescuer</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">rescuer</span><span class="o">-&gt;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_THREAD_BOUND</span><span class="p">;</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">rescuer</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * workqueue_lock protects global freeze state and workqueues</span>
<span class="cm">	 * list.  Grab it, set max_active accordingly and add the new</span>
<span class="cm">	 * workqueue to workqueues list.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workqueue_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">workqueue_freezing</span> <span class="o">&amp;&amp;</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FREEZABLE</span><span class="p">)</span>
		<span class="n">for_each_cwq_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">)</span>
			<span class="n">get_cwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">max_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">workqueues</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workqueue_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">wq</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_cwqs</span><span class="p">(</span><span class="n">wq</span><span class="p">);</span>
		<span class="n">free_mayday_mask</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">mayday_mask</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">rescuer</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">wq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__alloc_workqueue_key</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * destroy_workqueue - safely terminate a workqueue</span>
<span class="cm"> * @wq: target workqueue</span>
<span class="cm"> *</span>
<span class="cm"> * Safely destroy a workqueue. All work currently pending will be done first.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">destroy_workqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* drain it before proceeding with destruction */</span>
	<span class="n">drain_workqueue</span><span class="p">(</span><span class="n">wq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * wq list is used to freeze wq, remove from list after</span>
<span class="cm">	 * flushing is complete in case freeze races us.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workqueue_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workqueue_lock</span><span class="p">);</span>

	<span class="cm">/* sanity check */</span>
	<span class="n">for_each_cwq_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span> <span class="o">=</span> <span class="n">get_cwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">WORK_NR_COLORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">nr_in_flight</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">nr_active</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">delayed_works</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_RESCUER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">rescuer</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
		<span class="n">free_mayday_mask</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">mayday_mask</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">rescuer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">free_cwqs</span><span class="p">(</span><span class="n">wq</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">wq</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">destroy_workqueue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * workqueue_set_max_active - adjust max_active of a workqueue</span>
<span class="cm"> * @wq: target workqueue</span>
<span class="cm"> * @max_active: new max_active value.</span>
<span class="cm"> *</span>
<span class="cm"> * Set max_active of @wq to @max_active.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Don&#39;t call from IRQ context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">workqueue_set_max_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">max_active</span> <span class="o">=</span> <span class="n">wq_clamp_max_active</span><span class="p">(</span><span class="n">max_active</span><span class="p">,</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workqueue_lock</span><span class="p">);</span>

	<span class="n">wq</span><span class="o">-&gt;</span><span class="n">saved_max_active</span> <span class="o">=</span> <span class="n">max_active</span><span class="p">;</span>

	<span class="n">for_each_cwq_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">get_gcwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FREEZABLE</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GCWQ_FREEZING</span><span class="p">))</span>
			<span class="n">get_cwq</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">max_active</span> <span class="o">=</span> <span class="n">max_active</span><span class="p">;</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workqueue_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">workqueue_set_max_active</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * workqueue_congested - test whether a workqueue is congested</span>
<span class="cm"> * @cpu: CPU in question</span>
<span class="cm"> * @wq: target workqueue</span>
<span class="cm"> *</span>
<span class="cm"> * Test whether @wq&#39;s cpu workqueue for @cpu is congested.  There is</span>
<span class="cm"> * no synchronization around this function and the test result is</span>
<span class="cm"> * unreliable and only useful as advisory hints or for debugging.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * %true if congested, %false otherwise.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">workqueue_congested</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span> <span class="o">=</span> <span class="n">get_cwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">delayed_works</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">workqueue_congested</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * work_cpu - return the last known associated cpu for @work</span>
<span class="cm"> * @work: the work of interest</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * CPU number if @work was ever queued.  WORK_CPU_NONE otherwise.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">work_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">get_work_gcwq</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">gcwq</span> <span class="o">?</span> <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">:</span> <span class="n">WORK_CPU_NONE</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">work_cpu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * work_busy - test whether a work is currently pending or running</span>
<span class="cm"> * @work: the work to be tested</span>
<span class="cm"> *</span>
<span class="cm"> * Test whether @work is currently pending or running.  There is no</span>
<span class="cm"> * synchronization around this function and the test result is</span>
<span class="cm"> * unreliable and only useful as advisory hints or for debugging.</span>
<span class="cm"> * Especially for reentrant wqs, the pending state might hide the</span>
<span class="cm"> * running state.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * OR&#39;d bitmask of WORK_BUSY_* bits.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">work_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">get_work_gcwq</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gcwq</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">work_pending</span><span class="p">(</span><span class="n">work</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">WORK_BUSY_PENDING</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">find_worker_executing_work</span><span class="p">(</span><span class="n">gcwq</span><span class="p">,</span> <span class="n">work</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">WORK_BUSY_RUNNING</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">work_busy</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * CPU hotplug.</span>
<span class="cm"> *</span>
<span class="cm"> * There are two challenges in supporting CPU hotplug.  Firstly, there</span>
<span class="cm"> * are a lot of assumptions on strong associations among work, cwq and</span>
<span class="cm"> * gcwq which make migrating pending and scheduled works very</span>
<span class="cm"> * difficult to implement without impacting hot paths.  Secondly,</span>
<span class="cm"> * gcwqs serve mix of short, long and very long running works making</span>
<span class="cm"> * blocked draining impractical.</span>
<span class="cm"> *</span>
<span class="cm"> * This is solved by allowing a gcwq to be detached from CPU, running</span>
<span class="cm"> * it with unbound (rogue) workers and allowing it to be reattached</span>
<span class="cm"> * later if the cpu comes back online.  A separate thread is created</span>
<span class="cm"> * to govern a gcwq in such state and is called the trustee of the</span>
<span class="cm"> * gcwq.</span>
<span class="cm"> *</span>
<span class="cm"> * Trustee states and their descriptions.</span>
<span class="cm"> *</span>
<span class="cm"> * START	Command state used on startup.  On CPU_DOWN_PREPARE, a</span>
<span class="cm"> *		new trustee is started with this state.</span>
<span class="cm"> *</span>
<span class="cm"> * IN_CHARGE	Once started, trustee will enter this state after</span>
<span class="cm"> *		assuming the manager role and making all existing</span>
<span class="cm"> *		workers rogue.  DOWN_PREPARE waits for trustee to</span>
<span class="cm"> *		enter this state.  After reaching IN_CHARGE, trustee</span>
<span class="cm"> *		tries to execute the pending worklist until it&#39;s empty</span>
<span class="cm"> *		and the state is set to BUTCHER, or the state is set</span>
<span class="cm"> *		to RELEASE.</span>
<span class="cm"> *</span>
<span class="cm"> * BUTCHER	Command state which is set by the cpu callback after</span>
<span class="cm"> *		the cpu has went down.  Once this state is set trustee</span>
<span class="cm"> *		knows that there will be no new works on the worklist</span>
<span class="cm"> *		and once the worklist is empty it can proceed to</span>
<span class="cm"> *		killing idle workers.</span>
<span class="cm"> *</span>
<span class="cm"> * RELEASE	Command state which is set by the cpu callback if the</span>
<span class="cm"> *		cpu down has been canceled or it has come online</span>
<span class="cm"> *		again.  After recognizing this state, trustee stops</span>
<span class="cm"> *		trying to drain or butcher and clears ROGUE, rebinds</span>
<span class="cm"> *		all remaining workers back to the cpu and releases</span>
<span class="cm"> *		manager role.</span>
<span class="cm"> *</span>
<span class="cm"> * DONE		Trustee will enter this state after BUTCHER or RELEASE</span>
<span class="cm"> *		is complete.</span>
<span class="cm"> *</span>
<span class="cm"> *          trustee                 CPU                draining</span>
<span class="cm"> *         took over                down               complete</span>
<span class="cm"> * START -----------&gt; IN_CHARGE -----------&gt; BUTCHER -----------&gt; DONE</span>
<span class="cm"> *                        |                     |                  ^</span>
<span class="cm"> *                        | CPU is back online  v   return workers |</span>
<span class="cm"> *                         ----------------&gt; RELEASE --------------</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * trustee_wait_event_timeout - timed event wait for trustee</span>
<span class="cm"> * @cond: condition to wait for</span>
<span class="cm"> * @timeout: timeout in jiffies</span>
<span class="cm"> *</span>
<span class="cm"> * wait_event_timeout() for trustee to use.  Handles locking and</span>
<span class="cm"> * checks for RELEASE request.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock) which may be released and regrabbed</span>
<span class="cm"> * multiple times.  To be used by trustee.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Positive indicating left time if @cond is satisfied, 0 if timed</span>
<span class="cm"> * out, -1 if canceled.</span>
<span class="cm"> */</span>
<span class="cp">#define trustee_wait_event_timeout(cond, timeout) ({			\</span>
<span class="cp">	long __ret = (timeout);						\</span>
<span class="cp">	while (!((cond) || (gcwq-&gt;trustee_state == TRUSTEE_RELEASE)) &amp;&amp;	\</span>
<span class="cp">	       __ret) {							\</span>
<span class="cp">		spin_unlock_irq(&amp;gcwq-&gt;lock);				\</span>
<span class="cp">		__wait_event_timeout(gcwq-&gt;trustee_wait, (cond) ||	\</span>
<span class="cp">			(gcwq-&gt;trustee_state == TRUSTEE_RELEASE),	\</span>
<span class="cp">			__ret);						\</span>
<span class="cp">		spin_lock_irq(&amp;gcwq-&gt;lock);				\</span>
<span class="cp">	}								\</span>
<span class="cp">	gcwq-&gt;trustee_state == TRUSTEE_RELEASE ? -1 : (__ret);		\</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * trustee_wait_event - event wait for trustee</span>
<span class="cm"> * @cond: condition to wait for</span>
<span class="cm"> *</span>
<span class="cm"> * wait_event() for trustee to use.  Automatically handles locking and</span>
<span class="cm"> * checks for CANCEL request.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock) which may be released and regrabbed</span>
<span class="cm"> * multiple times.  To be used by trustee.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 if @cond is satisfied, -1 if canceled.</span>
<span class="cm"> */</span>
<span class="cp">#define trustee_wait_event(cond) ({					\</span>
<span class="cp">	long __ret1;							\</span>
<span class="cp">	__ret1 = trustee_wait_event_timeout(cond, MAX_SCHEDULE_TIMEOUT);\</span>
<span class="cp">	__ret1 &lt; 0 ? -1 : 0;						\</span>
<span class="cp">})</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">trustee_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__gcwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">__gcwq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Claim the manager position and make all workers rogue.</span>
<span class="cm">	 * Trustee must be bound to the target cpu and can&#39;t be</span>
<span class="cm">	 * cancelled.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">trustee_wait_event</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GCWQ_MANAGING_WORKERS</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">GCWQ_MANAGING_WORKERS</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_list</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>
		<span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">WORKER_ROGUE</span><span class="p">;</span>

	<span class="n">for_each_busy_worker</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">gcwq</span><span class="p">)</span>
		<span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">WORKER_ROGUE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call schedule() so that we cross rq-&gt;lock and thus can</span>
<span class="cm">	 * guarantee sched callbacks see the rogue flag.  This is</span>
<span class="cm">	 * necessary as scheduler callbacks may be invoked from other</span>
<span class="cm">	 * cpus.</span>
<span class="cm">	 */</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">schedule</span><span class="p">();</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sched callbacks are disabled now.  Zap nr_running.  After</span>
<span class="cm">	 * this, nr_running stays zero and need_more_worker() and</span>
<span class="cm">	 * keep_working() are always true as long as the worklist is</span>
<span class="cm">	 * not empty.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="n">get_gcwq_nr_running</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_timer</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re now in charge.  Notify and proceed to drain.  We need</span>
<span class="cm">	 * to keep the gcwq running during the whole CPU down</span>
<span class="cm">	 * procedure as other cpu hotunplug callbacks may need to</span>
<span class="cm">	 * flush currently running tasks.</span>
<span class="cm">	 */</span>
	<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_state</span> <span class="o">=</span> <span class="n">TRUSTEE_IN_CHARGE</span><span class="p">;</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_wait</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The original cpu is in the process of dying and may go away</span>
<span class="cm">	 * anytime now.  When that happens, we and all workers would</span>
<span class="cm">	 * be migrated to other cpus.  Try draining any left work.  We</span>
<span class="cm">	 * want to get it over with ASAP - spam rescuers, wake up as</span>
<span class="cm">	 * many idlers as necessary and create new ones till the</span>
<span class="cm">	 * worklist is empty.  Note that if the gcwq is frozen, there</span>
<span class="cm">	 * may be frozen works in freezable cwqs.  Don&#39;t declare</span>
<span class="cm">	 * completion while frozen.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">nr_workers</span> <span class="o">!=</span> <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">nr_idle</span> <span class="o">||</span>
	       <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GCWQ_FREEZING</span> <span class="o">||</span>
	       <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_state</span> <span class="o">==</span> <span class="n">TRUSTEE_IN_CHARGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nr_works</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worklist</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">send_mayday</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
			<span class="n">nr_works</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_list</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_works</span><span class="o">--</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">wake_up_process</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">need_to_create_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">worker</span> <span class="o">=</span> <span class="n">create_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">worker</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">WORKER_ROGUE</span><span class="p">;</span>
				<span class="n">start_worker</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* give a breather */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trustee_wait_event_timeout</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="n">TRUSTEE_COOLDOWN</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Either all works have been scheduled and cpu is down, or</span>
<span class="cm">	 * cpu down has already been canceled.  Wait for and butcher</span>
<span class="cm">	 * all workers till we&#39;re canceled.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">trustee_wait_event</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_list</span><span class="p">));</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_list</span><span class="p">))</span>
			<span class="n">destroy_worker</span><span class="p">(</span><span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_list</span><span class="p">,</span>
							<span class="k">struct</span> <span class="n">worker</span><span class="p">,</span> <span class="n">entry</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">nr_workers</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point, either draining has completed and no worker</span>
<span class="cm">	 * is left, or cpu down has been canceled or the cpu is being</span>
<span class="cm">	 * brought back up.  There shouldn&#39;t be any idle one left.</span>
<span class="cm">	 * Tell the remaining busy ones to rebind once it finishes the</span>
<span class="cm">	 * currently scheduled works by scheduling the rebind_work.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_list</span><span class="p">));</span>

	<span class="n">for_each_busy_worker</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">gcwq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">rebind_work</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">rebind_work</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Rebind_work may race with future cpu hotplug</span>
<span class="cm">		 * operations.  Use a separate flag to mark that</span>
<span class="cm">		 * rebinding is scheduled.</span>
<span class="cm">		 */</span>
		<span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">WORKER_REBIND</span><span class="p">;</span>
		<span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">WORKER_ROGUE</span><span class="p">;</span>

		<span class="cm">/* queue rebind_work, wq doesn&#39;t matter, use the default one */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">WORK_STRUCT_PENDING_BIT</span><span class="p">,</span>
				     <span class="n">work_data_bits</span><span class="p">(</span><span class="n">rebind_work</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">debug_work_activate</span><span class="p">(</span><span class="n">rebind_work</span><span class="p">);</span>
		<span class="n">insert_work</span><span class="p">(</span><span class="n">get_cwq</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">system_wq</span><span class="p">),</span> <span class="n">rebind_work</span><span class="p">,</span>
			    <span class="n">worker</span><span class="o">-&gt;</span><span class="n">scheduled</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
			    <span class="n">work_color_to_flags</span><span class="p">(</span><span class="n">WORK_NO_COLOR</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* relinquish manager role */</span>
	<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GCWQ_MANAGING_WORKERS</span><span class="p">;</span>

	<span class="cm">/* notify completion */</span>
	<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_state</span> <span class="o">=</span> <span class="n">TRUSTEE_DONE</span><span class="p">;</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_wait</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wait_trustee_state - wait for trustee to enter the specified state</span>
<span class="cm"> * @gcwq: gcwq the trustee of interest belongs to</span>
<span class="cm"> * @state: target state to wait for</span>
<span class="cm"> *</span>
<span class="cm"> * Wait for the trustee to reach @state.  DONE is already matched.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * spin_lock_irq(gcwq-&gt;lock) which may be released and regrabbed</span>
<span class="cm"> * multiple times.  To be used by cpu_callback.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">wait_trustee_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_state</span> <span class="o">==</span> <span class="n">state</span> <span class="o">||</span>
	      <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_state</span> <span class="o">==</span> <span class="n">TRUSTEE_DONE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">__wait_event</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_wait</span><span class="p">,</span>
			     <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_state</span> <span class="o">==</span> <span class="n">state</span> <span class="o">||</span>
			     <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_state</span> <span class="o">==</span> <span class="n">TRUSTEE_DONE</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">workqueue_cpu_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span>
						<span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">get_gcwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">new_trustee</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">new_worker</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">action</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CPU_TASKS_FROZEN</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE</span>:
		<span class="n">new_trustee</span> <span class="o">=</span> <span class="n">kthread_create</span><span class="p">(</span><span class="n">trustee_thread</span><span class="p">,</span> <span class="n">gcwq</span><span class="p">,</span>
					     <span class="s">&quot;workqueue_trustee/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_trustee</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_trustee</span><span class="p">));</span>
		<span class="n">kthread_bind</span><span class="p">(</span><span class="n">new_trustee</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">first_idle</span><span class="p">);</span>
		<span class="n">new_worker</span> <span class="o">=</span> <span class="n">create_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_worker</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_trustee</span><span class="p">)</span>
				<span class="n">kthread_stop</span><span class="p">(</span><span class="n">new_trustee</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NOTIFY_BAD</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* some are called w/ irq disabled, don&#39;t disturb irq status */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE</span>:
		<span class="cm">/* initialize trustee and tell it to acquire the gcwq */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee</span> <span class="o">||</span> <span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_state</span> <span class="o">!=</span> <span class="n">TRUSTEE_DONE</span><span class="p">);</span>
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee</span> <span class="o">=</span> <span class="n">new_trustee</span><span class="p">;</span>
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_state</span> <span class="o">=</span> <span class="n">TRUSTEE_START</span><span class="p">;</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee</span><span class="p">);</span>
		<span class="n">wait_trustee_state</span><span class="p">(</span><span class="n">gcwq</span><span class="p">,</span> <span class="n">TRUSTEE_IN_CHARGE</span><span class="p">);</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">first_idle</span><span class="p">);</span>
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">first_idle</span> <span class="o">=</span> <span class="n">new_worker</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_DYING</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Before this, the trustee and all workers except for</span>
<span class="cm">		 * the ones which are still executing works from</span>
<span class="cm">		 * before the last CPU down must be on the cpu.  After</span>
<span class="cm">		 * this, they&#39;ll all be diasporas.</span>
<span class="cm">		 */</span>
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">GCWQ_DISASSOCIATED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_POST_DEAD</span>:
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_state</span> <span class="o">=</span> <span class="n">TRUSTEE_BUTCHER</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">CPU_UP_CANCELED</span>:
		<span class="n">destroy_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">first_idle</span><span class="p">);</span>
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">first_idle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED</span>:
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GCWQ_DISASSOCIATED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_state</span> <span class="o">!=</span> <span class="n">TRUSTEE_DONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_state</span> <span class="o">=</span> <span class="n">TRUSTEE_RELEASE</span><span class="p">;</span>
			<span class="n">wake_up_process</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee</span><span class="p">);</span>
			<span class="n">wait_trustee_state</span><span class="p">(</span><span class="n">gcwq</span><span class="p">,</span> <span class="n">TRUSTEE_DONE</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Trustee is done and there might be no worker left.</span>
<span class="cm">		 * Put the first_idle in and request a real manager to</span>
<span class="cm">		 * take a look.</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">kthread_bind</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">first_idle</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">GCWQ_MANAGE_WORKERS</span><span class="p">;</span>
		<span class="n">start_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">first_idle</span><span class="p">);</span>
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">first_idle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>

<span class="k">struct</span> <span class="n">work_for_cpu</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">completion</span><span class="p">;</span>
	<span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_work_for_cpu</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_wfc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_for_cpu</span> <span class="o">*</span><span class="n">wfc</span> <span class="o">=</span> <span class="n">_wfc</span><span class="p">;</span>
	<span class="n">wfc</span><span class="o">-&gt;</span><span class="n">ret</span> <span class="o">=</span> <span class="n">wfc</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">(</span><span class="n">wfc</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wfc</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * work_on_cpu - run a function in user context on a particular cpu</span>
<span class="cm"> * @cpu: the cpu to run on</span>
<span class="cm"> * @fn: the function to run</span>
<span class="cm"> * @arg: the function arg</span>
<span class="cm"> *</span>
<span class="cm"> * This will return the value @fn returns.</span>
<span class="cm"> * It is up to the caller to ensure that the cpu doesn&#39;t go offline.</span>
<span class="cm"> * The caller must not hold any locks which would prevent @fn from completing.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="nf">work_on_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">sub_thread</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_for_cpu</span> <span class="n">wfc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">completion</span> <span class="o">=</span> <span class="n">COMPLETION_INITIALIZER_ONSTACK</span><span class="p">(</span><span class="n">wfc</span><span class="p">.</span><span class="n">completion</span><span class="p">),</span>
		<span class="p">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span><span class="p">,</span>
		<span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">sub_thread</span> <span class="o">=</span> <span class="n">kthread_create</span><span class="p">(</span><span class="n">do_work_for_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wfc</span><span class="p">,</span> <span class="s">&quot;work_for_cpu&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sub_thread</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sub_thread</span><span class="p">);</span>
	<span class="n">kthread_bind</span><span class="p">(</span><span class="n">sub_thread</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">sub_thread</span><span class="p">);</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wfc</span><span class="p">.</span><span class="n">completion</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">wfc</span><span class="p">.</span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">work_on_cpu</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_FREEZER</span>

<span class="cm">/**</span>
<span class="cm"> * freeze_workqueues_begin - begin freezing workqueues</span>
<span class="cm"> *</span>
<span class="cm"> * Start freezing workqueues.  After this function returns, all freezable</span>
<span class="cm"> * workqueues will queue new works to their frozen_works list instead of</span>
<span class="cm"> * gcwq-&gt;worklist.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Grabs and releases workqueue_lock and gcwq-&gt;lock&#39;s.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">freeze_workqueues_begin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workqueue_lock</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">workqueue_freezing</span><span class="p">);</span>
	<span class="n">workqueue_freezing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">for_each_gcwq_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">get_gcwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GCWQ_FREEZING</span><span class="p">);</span>
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">GCWQ_FREEZING</span><span class="p">;</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">workqueues</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span> <span class="o">=</span> <span class="n">get_cwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cwq</span> <span class="o">&amp;&amp;</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FREEZABLE</span><span class="p">)</span>
				<span class="n">cwq</span><span class="o">-&gt;</span><span class="n">max_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workqueue_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * freeze_workqueues_busy - are freezable workqueues still busy?</span>
<span class="cm"> *</span>
<span class="cm"> * Check whether freezing is complete.  This function must be called</span>
<span class="cm"> * between freeze_workqueues_begin() and thaw_workqueues().</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Grabs and releases workqueue_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * %true if some freezable workqueues are still busy.  %false if freezing</span>
<span class="cm"> * is complete.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">freeze_workqueues_busy</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">busy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workqueue_lock</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">workqueue_freezing</span><span class="p">);</span>

	<span class="n">for_each_gcwq_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * nr_active is monotonically decreasing.  It&#39;s safe</span>
<span class="cm">		 * to peek without lock.</span>
<span class="cm">		 */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">workqueues</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span> <span class="o">=</span> <span class="n">get_cwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cwq</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FREEZABLE</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">nr_active</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">nr_active</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">busy</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workqueue_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">busy</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * thaw_workqueues - thaw workqueues</span>
<span class="cm"> *</span>
<span class="cm"> * Thaw workqueues.  Normal queueing is restored and all collected</span>
<span class="cm"> * frozen works are transferred to their respective gcwq worklists.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Grabs and releases workqueue_lock and gcwq-&gt;lock&#39;s.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">thaw_workqueues</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workqueue_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">workqueue_freezing</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">for_each_gcwq_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">get_gcwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GCWQ_FREEZING</span><span class="p">));</span>
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GCWQ_FREEZING</span><span class="p">;</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">workqueues</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cpu_workqueue_struct</span> <span class="o">*</span><span class="n">cwq</span> <span class="o">=</span> <span class="n">get_cwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cwq</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FREEZABLE</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* restore max_active and repopulate worklist */</span>
			<span class="n">cwq</span><span class="o">-&gt;</span><span class="n">max_active</span> <span class="o">=</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">saved_max_active</span><span class="p">;</span>

			<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwq</span><span class="o">-&gt;</span><span class="n">delayed_works</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			       <span class="n">cwq</span><span class="o">-&gt;</span><span class="n">nr_active</span> <span class="o">&lt;</span> <span class="n">cwq</span><span class="o">-&gt;</span><span class="n">max_active</span><span class="p">)</span>
				<span class="n">cwq_activate_first_delayed</span><span class="p">(</span><span class="n">cwq</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">wake_up_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">);</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">workqueue_freezing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workqueue_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FREEZER */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_workqueues</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cpu_notifier</span><span class="p">(</span><span class="n">workqueue_cpu_callback</span><span class="p">,</span> <span class="n">CPU_PRI_WORKQUEUE</span><span class="p">);</span>

	<span class="cm">/* initialize gcwqs */</span>
	<span class="n">for_each_gcwq_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">get_gcwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worklist</span><span class="p">);</span>
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">GCWQ_DISASSOCIATED</span><span class="p">;</span>

		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_list</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BUSY_WORKER_HASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">busy_hash</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="n">init_timer_deferrable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_timer</span><span class="p">);</span>
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">idle_worker_timeout</span><span class="p">;</span>
		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">idle_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">gcwq</span><span class="p">;</span>

		<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">mayday_timer</span><span class="p">,</span> <span class="n">gcwq_mayday_timeout</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">gcwq</span><span class="p">);</span>

		<span class="n">ida_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">worker_ida</span><span class="p">);</span>

		<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_state</span> <span class="o">=</span> <span class="n">TRUSTEE_DONE</span><span class="p">;</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">trustee_wait</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* create the initial worker */</span>
	<span class="n">for_each_online_gcwq_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">global_cwq</span> <span class="o">*</span><span class="n">gcwq</span> <span class="o">=</span> <span class="n">get_gcwq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">worker</span> <span class="o">*</span><span class="n">worker</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">WORK_CPU_UNBOUND</span><span class="p">)</span>
			<span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GCWQ_DISASSOCIATED</span><span class="p">;</span>
		<span class="n">worker</span> <span class="o">=</span> <span class="n">create_worker</span><span class="p">(</span><span class="n">gcwq</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">worker</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">start_worker</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcwq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">system_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;events&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">system_long_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;events_long&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">system_nrt_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;events_nrt&quot;</span><span class="p">,</span> <span class="n">WQ_NON_REENTRANT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">system_unbound_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;events_unbound&quot;</span><span class="p">,</span> <span class="n">WQ_UNBOUND</span><span class="p">,</span>
					    <span class="n">WQ_UNBOUND_MAX_ACTIVE</span><span class="p">);</span>
	<span class="n">system_freezable_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;events_freezable&quot;</span><span class="p">,</span>
					      <span class="n">WQ_FREEZABLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">system_nrt_freezable_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;events_nrt_freezable&quot;</span><span class="p">,</span>
			<span class="n">WQ_NON_REENTRANT</span> <span class="o">|</span> <span class="n">WQ_FREEZABLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">system_wq</span> <span class="o">||</span> <span class="o">!</span><span class="n">system_long_wq</span> <span class="o">||</span> <span class="o">!</span><span class="n">system_nrt_wq</span> <span class="o">||</span>
	       <span class="o">!</span><span class="n">system_unbound_wq</span> <span class="o">||</span> <span class="o">!</span><span class="n">system_freezable_wq</span> <span class="o">||</span>
		<span class="o">!</span><span class="n">system_nrt_freezable_wq</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_initcall</span><span class="p">(</span><span class="n">init_workqueues</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
