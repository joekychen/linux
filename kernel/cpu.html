<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › cpu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>cpu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* CPU control.</span>
<span class="cm"> * (C) 2001, 2002, 2003, 2004 Rusty Russell</span>
<span class="cm"> *</span>
<span class="cm"> * This code is licenced under the GPL.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/oom.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/stop_machine.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/suspend.h&gt;</span>

<span class="cp">#include &quot;smpboot.h&quot;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/* Serializes the updates to cpu_online_mask, cpu_present_mask */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">cpu_add_remove_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The following two API&#39;s must be used when attempting</span>
<span class="cm"> * to serialize the updates to cpu_online_mask, cpu_present_mask.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cpu_maps_update_begin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_add_remove_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cpu_maps_update_done</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_add_remove_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">RAW_NOTIFIER_HEAD</span><span class="p">(</span><span class="n">cpu_chain</span><span class="p">);</span>

<span class="cm">/* If set, cpu_up and cpu_down will return -EBUSY and do nothing.</span>
<span class="cm"> * Should always be manipulated under cpu_add_remove_lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cpu_hotplug_disabled</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">active_writer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span> <span class="cm">/* Synchronizes accesses to refcount, */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Also blocks the new readers during</span>
<span class="cm">	 * an ongoing cpu hotplug operation.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">refcount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">cpu_hotplug</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">active_writer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">__MUTEX_INITIALIZER</span><span class="p">(</span><span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">lock</span><span class="p">),</span>
	<span class="p">.</span><span class="n">refcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">get_online_cpus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">active_writer</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">refcount</span><span class="o">++</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">get_online_cpus</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">put_online_cpus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">active_writer</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">refcount</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">active_writer</span><span class="p">))</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">active_writer</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">put_online_cpus</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This ensures that the hotplug operation can begin only when the</span>
<span class="cm"> * refcount goes to zero.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that during a cpu-hotplug operation, the new readers, if any,</span>
<span class="cm"> * will be blocked by the cpu_hotplug.lock</span>
<span class="cm"> *</span>
<span class="cm"> * Since cpu_hotplug_begin() is always called after invoking</span>
<span class="cm"> * cpu_maps_update_begin(), we can be sure that only one writer is active.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that theoretically, there is a possibility of a livelock:</span>
<span class="cm"> * - Refcount goes to zero, last reader wakes up the sleeping</span>
<span class="cm"> *   writer.</span>
<span class="cm"> * - Last reader unlocks the cpu_hotplug.lock.</span>
<span class="cm"> * - A new reader arrives at this moment, bumps up the refcount.</span>
<span class="cm"> * - The writer acquires the cpu_hotplug.lock finds the refcount</span>
<span class="cm"> *   non zero and goes to sleep again.</span>
<span class="cm"> *</span>
<span class="cm"> * However, this is very difficult to achieve in practice since</span>
<span class="cm"> * get_online_cpus() not an api which is called all that often.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_hotplug_begin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">active_writer</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">refcount</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_hotplug_done</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">active_writer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_hotplug</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* #if CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_hotplug_begin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_hotplug_done</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif	</span><span class="cm">/* #else #if CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

<span class="cm">/* Need to know about CPUs going up/down? */</span>
<span class="kt">int</span> <span class="n">__ref</span> <span class="nf">register_cpu_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">cpu_maps_update_begin</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">raw_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_chain</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
	<span class="n">cpu_maps_update_done</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__cpu_notify</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_to_call</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">nr_calls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__raw_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_chain</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">nr_to_call</span><span class="p">,</span>
					<span class="n">nr_calls</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">notifier_to_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_notify</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__cpu_notify</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_notify_nofail</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu_notify</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">register_cpu_notifier</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__ref</span> <span class="nf">unregister_cpu_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpu_maps_update_begin</span><span class="p">();</span>
	<span class="n">raw_notifier_chain_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_chain</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
	<span class="n">cpu_maps_update_done</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unregister_cpu_notifier</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clear_tasks_mm_cpumask - Safely clear tasks&#39; mm_cpumask for a CPU</span>
<span class="cm"> * @cpu: a CPU id</span>
<span class="cm"> *</span>
<span class="cm"> * This function walks all processes, finds a valid mm struct for each one and</span>
<span class="cm"> * then clears a corresponding bit in mm&#39;s cpumask.  While this all sounds</span>
<span class="cm"> * trivial, there are various non-obvious corner cases, which this function</span>
<span class="cm"> * tries to solve in a safe manner.</span>
<span class="cm"> *</span>
<span class="cm"> * Also note that the function uses a somewhat relaxed locking scheme, so it may</span>
<span class="cm"> * be called only for an already offlined CPU.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clear_tasks_mm_cpumask</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This function is called after the cpu is taken down and marked</span>
<span class="cm">	 * offline, so its not like new tasks will ever get this cpu set in</span>
<span class="cm">	 * their mm mask. -- Peter Zijlstra</span>
<span class="cm">	 * Thus, we may use rcu_read_lock() here, instead of grabbing</span>
<span class="cm">	 * full-fledged tasklist_lock.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_process</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Main thread might exit, but other threads may still have</span>
<span class="cm">		 * a valid mm. Find one.</span>
<span class="cm">		 */</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">find_lock_task_mm</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">mm_cpumask</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">));</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">check_for_tasks</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">for_each_process</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">cpu</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_RUNNING</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Task %s (pid = %d) is on cpu %d &quot;</span>
				<span class="s">&quot;(state = %ld, flags = %x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">cpu</span><span class="p">,</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">take_cpu_down_param</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mod</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Take this CPU down. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__ref</span> <span class="nf">take_cpu_down</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">take_cpu_down_param</span> <span class="o">*</span><span class="n">param</span> <span class="o">=</span> <span class="n">_param</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Ensure this CPU doesn&#39;t handle any more interrupts. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">__cpu_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">cpu_notify</span><span class="p">(</span><span class="n">CPU_DYING</span> <span class="o">|</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">mod</span><span class="p">,</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">hcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Requires cpu_add_remove_lock to be held */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__ref</span> <span class="nf">_cpu_down</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tasks_frozen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">nr_calls</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">tasks_frozen</span> <span class="o">?</span> <span class="n">CPU_TASKS_FROZEN</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">take_cpu_down_param</span> <span class="n">tcd_param</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">mod</span> <span class="o">=</span> <span class="n">mod</span><span class="p">,</span>
		<span class="p">.</span><span class="n">hcpu</span> <span class="o">=</span> <span class="n">hcpu</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">cpu_hotplug_begin</span><span class="p">();</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__cpu_notify</span><span class="p">(</span><span class="n">CPU_DOWN_PREPARE</span> <span class="o">|</span> <span class="n">mod</span><span class="p">,</span> <span class="n">hcpu</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_calls</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr_calls</span><span class="o">--</span><span class="p">;</span>
		<span class="n">__cpu_notify</span><span class="p">(</span><span class="n">CPU_DOWN_FAILED</span> <span class="o">|</span> <span class="n">mod</span><span class="p">,</span> <span class="n">hcpu</span><span class="p">,</span> <span class="n">nr_calls</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: attempt to take down CPU %u failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__stop_machine</span><span class="p">(</span><span class="n">take_cpu_down</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcd_param</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* CPU didn&#39;t die: tell everyone.  Can&#39;t complain. */</span>
		<span class="n">cpu_notify_nofail</span><span class="p">(</span><span class="n">CPU_DOWN_FAILED</span> <span class="o">|</span> <span class="n">mod</span><span class="p">,</span> <span class="n">hcpu</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * The migration_call() CPU_DYING callback will have removed all</span>
<span class="cm">	 * runnable tasks from the cpu, there&#39;s only the idle task left now</span>
<span class="cm">	 * that the migration thread is done doing the stop_machine thing.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Wait for the stop thread to go away.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="cm">/* This actually kills the CPU. */</span>
	<span class="n">__cpu_die</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/* CPU is completely dead: tell everyone.  Too late to complain. */</span>
	<span class="n">cpu_notify_nofail</span><span class="p">(</span><span class="n">CPU_DEAD</span> <span class="o">|</span> <span class="n">mod</span><span class="p">,</span> <span class="n">hcpu</span><span class="p">);</span>

	<span class="n">check_for_tasks</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

<span class="nl">out_release:</span>
	<span class="n">cpu_hotplug_done</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">cpu_notify_nofail</span><span class="p">(</span><span class="n">CPU_POST_DEAD</span> <span class="o">|</span> <span class="n">mod</span><span class="p">,</span> <span class="n">hcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__ref</span> <span class="nf">cpu_down</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">cpu_maps_update_begin</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_hotplug_disabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">_cpu_down</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">cpu_maps_update_done</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cpu_down</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/*CONFIG_HOTPLUG_CPU*/</span><span class="cp"></span>

<span class="cm">/* Requires cpu_add_remove_lock to be held */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">_cpu_up</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tasks_frozen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">nr_calls</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">tasks_frozen</span> <span class="o">?</span> <span class="n">CPU_TASKS_FROZEN</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">cpu_present</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">cpu_hotplug_begin</span><span class="p">();</span>

	<span class="n">idle</span> <span class="o">=</span> <span class="n">idle_thread_get</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">idle</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">idle</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__cpu_notify</span><span class="p">(</span><span class="n">CPU_UP_PREPARE</span> <span class="o">|</span> <span class="n">mod</span><span class="p">,</span> <span class="n">hcpu</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_calls</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr_calls</span><span class="o">--</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: attempt to bring up CPU %u failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_notify</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Arch-specific enabling code. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__cpu_up</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">idle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_notify</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>

	<span class="cm">/* Now call notifier in preparation. */</span>
	<span class="n">cpu_notify</span><span class="p">(</span><span class="n">CPU_ONLINE</span> <span class="o">|</span> <span class="n">mod</span><span class="p">,</span> <span class="n">hcpu</span><span class="p">);</span>

<span class="nl">out_notify:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">__cpu_notify</span><span class="p">(</span><span class="n">CPU_UP_CANCELED</span> <span class="o">|</span> <span class="n">mod</span><span class="p">,</span> <span class="n">hcpu</span><span class="p">,</span> <span class="n">nr_calls</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">cpu_hotplug_done</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">cpu_up</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef	CONFIG_MEMORY_HOTPLUG</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>
	<span class="n">pg_data_t</span>	<span class="o">*</span><span class="n">pgdat</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_possible</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;can&#39;t online cpu %d because it is not &quot;</span>
			<span class="s">&quot;configured as may-hotadd at boot time</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="cp">#if defined(CONFIG_IA64)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;please check additional_cpus= boot &quot;</span>
				<span class="s">&quot;parameter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef	CONFIG_MEMORY_HOTPLUG</span>
	<span class="n">nid</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_online</span><span class="p">(</span><span class="n">nid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">mem_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pgdat</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgdat</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			<span class="s">&quot;Can&#39;t online cpu %d due to NULL pgdat</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_zonelists</span><span class="o">-&gt;</span><span class="n">_zonerefs</span><span class="o">-&gt;</span><span class="n">zone</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zonelists_mutex</span><span class="p">);</span>
		<span class="n">build_all_zonelists</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zonelists_mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">cpu_maps_update_begin</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_hotplug_disabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">_cpu_up</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">cpu_maps_update_done</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cpu_up</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP_SMP</span>
<span class="k">static</span> <span class="n">cpumask_var_t</span> <span class="n">frozen_cpus</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">__weak</span> <span class="nf">arch_disable_nonboot_cpus_begin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__weak</span> <span class="nf">arch_disable_nonboot_cpus_end</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">disable_nonboot_cpus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">first_cpu</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cpu_maps_update_begin</span><span class="p">();</span>
	<span class="n">first_cpu</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We take down all of the non-boot CPUs in one shot to avoid races</span>
<span class="cm">	 * with the userspace trying to use the CPU hotplug at the same time</span>
<span class="cm">	 */</span>
	<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">frozen_cpus</span><span class="p">);</span>
	<span class="n">arch_disable_nonboot_cpus_begin</span><span class="p">();</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Disabling non-boot CPUs ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">first_cpu</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">_cpu_down</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
			<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">frozen_cpus</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Error taking CPU%d down: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cpu</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">arch_disable_nonboot_cpus_end</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* Make sure the CPUs won&#39;t be enabled by someone else */</span>
		<span class="n">cpu_hotplug_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Non-boot CPUs are not disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cpu_maps_update_done</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__weak</span> <span class="nf">arch_enable_nonboot_cpus_begin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__weak</span> <span class="nf">arch_enable_nonboot_cpus_end</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__ref</span> <span class="nf">enable_nonboot_cpus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* Allow everyone to use the CPU hotplug again */</span>
	<span class="n">cpu_maps_update_begin</span><span class="p">();</span>
	<span class="n">cpu_hotplug_disabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">frozen_cpus</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Enabling non-boot CPUs ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">arch_enable_nonboot_cpus_begin</span><span class="p">();</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">frozen_cpus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">_cpu_up</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;CPU%d is up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Error taking CPU%d up: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">arch_enable_nonboot_cpus_end</span><span class="p">();</span>

	<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">frozen_cpus</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">cpu_maps_update_done</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">alloc_frozen_cpus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frozen_cpus</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">__GFP_ZERO</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">core_initcall</span><span class="p">(</span><span class="n">alloc_frozen_cpus</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Prevent regular CPU hotplug from racing with the freezer, by disabling CPU</span>
<span class="cm"> * hotplug when tasks are about to be frozen. Also, don&#39;t allow the freezer</span>
<span class="cm"> * to continue until any currently running CPU hotplug operation gets</span>
<span class="cm"> * completed.</span>
<span class="cm"> * To modify the &#39;cpu_hotplug_disabled&#39; flag, we need to acquire the</span>
<span class="cm"> * &#39;cpu_add_remove_lock&#39;. And this same lock is also taken by the regular</span>
<span class="cm"> * CPU hotplug path and released only after it is complete. Thus, we</span>
<span class="cm"> * (and hence the freezer) will block here until any currently running CPU</span>
<span class="cm"> * hotplug operation gets completed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cpu_hotplug_disable_before_freeze</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpu_maps_update_begin</span><span class="p">();</span>
	<span class="n">cpu_hotplug_disabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cpu_maps_update_done</span><span class="p">();</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * When tasks have been thawed, re-enable regular CPU hotplug (which had been</span>
<span class="cm"> * disabled while beginning to freeze tasks).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cpu_hotplug_enable_after_thaw</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpu_maps_update_begin</span><span class="p">();</span>
	<span class="n">cpu_hotplug_disabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpu_maps_update_done</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When callbacks for CPU hotplug notifications are being executed, we must</span>
<span class="cm"> * ensure that the state of the system with respect to the tasks being frozen</span>
<span class="cm"> * or not, as reported by the notification, remains unchanged *throughout the</span>
<span class="cm"> * duration* of the execution of the callbacks.</span>
<span class="cm"> * Hence we need to prevent the freezer from racing with regular CPU hotplug.</span>
<span class="cm"> *</span>
<span class="cm"> * This synchronization is implemented by mutually excluding regular CPU</span>
<span class="cm"> * hotplug and Suspend/Hibernate call paths by hooking onto the Suspend/</span>
<span class="cm"> * Hibernate notifications.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cpu_hotplug_pm_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">PM_SUSPEND_PREPARE</span>:
	<span class="k">case</span> <span class="n">PM_HIBERNATION_PREPARE</span>:
		<span class="n">cpu_hotplug_disable_before_freeze</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PM_POST_SUSPEND</span>:
	<span class="k">case</span> <span class="n">PM_POST_HIBERNATION</span>:
		<span class="n">cpu_hotplug_enable_after_thaw</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cpu_hotplug_pm_sync_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pm_notifier</span><span class="p">(</span><span class="n">cpu_hotplug_pm_callback</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">core_initcall</span><span class="p">(</span><span class="n">cpu_hotplug_pm_sync_init</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PM_SLEEP_SMP */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * notify_cpu_starting(cpu) - call the CPU_STARTING notifiers</span>
<span class="cm"> * @cpu: cpu that just started</span>
<span class="cm"> *</span>
<span class="cm"> * This function calls the cpu_chain notifiers with CPU_STARTING.</span>
<span class="cm"> * It must be called by the arch code on the new cpu, before the new cpu</span>
<span class="cm"> * enables interrupts and before the &quot;boot&quot; cpu returns from __cpu_up().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__cpuinit</span> <span class="nf">notify_cpu_starting</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="n">CPU_STARTING</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP_SMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frozen_cpus</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">frozen_cpus</span><span class="p">))</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">CPU_STARTING_FROZEN</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM_SLEEP_SMP */</span><span class="cp"></span>
	<span class="n">cpu_notify</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * cpu_bit_bitmap[] is a special, &quot;compressed&quot; data structure that</span>
<span class="cm"> * represents all NR_CPUS bits binary values of 1&lt;&lt;nr.</span>
<span class="cm"> *</span>
<span class="cm"> * It is used by cpumask_of() to get a constant address to a CPU</span>
<span class="cm"> * mask value that has a single bit set only.</span>
<span class="cm"> */</span>

<span class="cm">/* cpu_bit_bitmap[0] is empty - so we can back into it */</span>
<span class="cp">#define MASK_DECLARE_1(x)	[x+1][0] = (1UL &lt;&lt; (x))</span>
<span class="cp">#define MASK_DECLARE_2(x)	MASK_DECLARE_1(x), MASK_DECLARE_1(x+1)</span>
<span class="cp">#define MASK_DECLARE_4(x)	MASK_DECLARE_2(x), MASK_DECLARE_2(x+2)</span>
<span class="cp">#define MASK_DECLARE_8(x)	MASK_DECLARE_4(x), MASK_DECLARE_4(x+4)</span>

<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu_bit_bitmap</span><span class="p">[</span><span class="n">BITS_PER_LONG</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">NR_CPUS</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span>

	<span class="n">MASK_DECLARE_8</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>	<span class="n">MASK_DECLARE_8</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
	<span class="n">MASK_DECLARE_8</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span>	<span class="n">MASK_DECLARE_8</span><span class="p">(</span><span class="mi">24</span><span class="p">),</span>
<span class="cp">#if BITS_PER_LONG &gt; 32</span>
	<span class="n">MASK_DECLARE_8</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>	<span class="n">MASK_DECLARE_8</span><span class="p">(</span><span class="mi">40</span><span class="p">),</span>
	<span class="n">MASK_DECLARE_8</span><span class="p">(</span><span class="mi">48</span><span class="p">),</span>	<span class="n">MASK_DECLARE_8</span><span class="p">(</span><span class="mi">56</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cpu_bit_bitmap</span><span class="p">);</span>

<span class="k">const</span> <span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">cpu_all_bits</span><span class="p">,</span> <span class="n">NR_CPUS</span><span class="p">)</span> <span class="o">=</span> <span class="n">CPU_BITS_ALL</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cpu_all_bits</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_INIT_ALL_POSSIBLE</span>
<span class="k">static</span> <span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">cpu_possible_bits</span><span class="p">,</span> <span class="n">CONFIG_NR_CPUS</span><span class="p">)</span> <span class="n">__read_mostly</span>
	<span class="o">=</span> <span class="n">CPU_BITS_ALL</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">cpu_possible_bits</span><span class="p">,</span> <span class="n">CONFIG_NR_CPUS</span><span class="p">)</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="k">const</span> <span class="n">cpu_possible_mask</span> <span class="o">=</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">cpu_possible_bits</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cpu_possible_mask</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">cpu_online_bits</span><span class="p">,</span> <span class="n">CONFIG_NR_CPUS</span><span class="p">)</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="k">const</span> <span class="n">cpu_online_mask</span> <span class="o">=</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">cpu_online_bits</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">cpu_present_bits</span><span class="p">,</span> <span class="n">CONFIG_NR_CPUS</span><span class="p">)</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="k">const</span> <span class="n">cpu_present_mask</span> <span class="o">=</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">cpu_present_bits</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cpu_present_mask</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">cpu_active_bits</span><span class="p">,</span> <span class="n">CONFIG_NR_CPUS</span><span class="p">)</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="k">const</span> <span class="n">cpu_active_mask</span> <span class="o">=</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">cpu_active_bits</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cpu_active_mask</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">set_cpu_possible</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">possible</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">possible</span><span class="p">)</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">cpu_possible_bits</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">cpu_possible_bits</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_cpu_present</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">present</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">present</span><span class="p">)</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">cpu_present_bits</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">cpu_present_bits</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_cpu_online</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">online</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">online</span><span class="p">)</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">cpu_online_bits</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">cpu_online_bits</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_cpu_active</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">active</span><span class="p">)</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">cpu_active_bits</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">cpu_active_bits</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_cpu_present</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">to_cpumask</span><span class="p">(</span><span class="n">cpu_present_bits</span><span class="p">),</span> <span class="n">src</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_cpu_possible</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">to_cpumask</span><span class="p">(</span><span class="n">cpu_possible_bits</span><span class="p">),</span> <span class="n">src</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_cpu_online</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">to_cpumask</span><span class="p">(</span><span class="n">cpu_online_bits</span><span class="p">),</span> <span class="n">src</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
