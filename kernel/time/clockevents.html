<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › time › clockevents.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>clockevents.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/kernel/time/clockevents.c</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains functions which manage clock event devices.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(C) 2005-2006, Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="cm"> * Copyright(C) 2005-2007, Red Hat, Inc., Ingo Molnar</span>
<span class="cm"> * Copyright(C) 2006-2007, Timesys Corp., Thomas Gleixner</span>
<span class="cm"> *</span>
<span class="cm"> * This code is licenced under the GPL version 2. For details see</span>
<span class="cm"> * kernel-base/COPYING.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/clockchips.h&gt;</span>
<span class="cp">#include &lt;linux/hrtimer.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>

<span class="cp">#include &quot;tick-internal.h&quot;</span>

<span class="cm">/* The registered clock event devices */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">clockevent_devices</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">clockevents_released</span><span class="p">);</span>

<span class="cm">/* Notification for clock events */</span>
<span class="k">static</span> <span class="n">RAW_NOTIFIER_HEAD</span><span class="p">(</span><span class="n">clockevents_chain</span><span class="p">);</span>

<span class="cm">/* Protection for the above */</span>
<span class="k">static</span> <span class="n">DEFINE_RAW_SPINLOCK</span><span class="p">(</span><span class="n">clockevents_lock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clockevents_delta2ns - Convert a latch value (device ticks) to nanoseconds</span>
<span class="cm"> * @latch:	value to convert</span>
<span class="cm"> * @evt:	pointer to clock event device descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * Math helper, returns latch value converted to nanoseconds (bound checked)</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">clockevent_delta2ns</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">latch</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">evt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">clc</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">latch</span> <span class="o">&lt;&lt;</span> <span class="n">evt</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">evt</span><span class="o">-&gt;</span><span class="n">mult</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">do_div</span><span class="p">(</span><span class="n">clc</span><span class="p">,</span> <span class="n">evt</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clc</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span>
		<span class="n">clc</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clc</span> <span class="o">&gt;</span> <span class="n">KTIME_MAX</span><span class="p">)</span>
		<span class="n">clc</span> <span class="o">=</span> <span class="n">KTIME_MAX</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">clc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clockevent_delta2ns</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clockevents_set_mode - set the operating mode of a clock event device</span>
<span class="cm"> * @dev:	device to modify</span>
<span class="cm"> * @mode:	new mode</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with interrupts disabled !</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clockevents_set_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">clock_event_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">set_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * A nsec2cyc multiplicator of 0 is invalid and we&#39;d crash</span>
<span class="cm">		 * on it, so fix it up and emit a warning:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">CLOCK_EVT_MODE_ONESHOT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mult</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clockevents_shutdown - shutdown the device and clear next_event</span>
<span class="cm"> * @dev:	device to shutdown</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clockevents_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clockevents_set_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">CLOCK_EVT_MODE_SHUTDOWN</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">next_event</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">KTIME_MAX</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST</span>

<span class="cm">/* Limit min_delta to a jiffie */</span>
<span class="cp">#define MIN_DELTA_LIMIT		(NSEC_PER_SEC / HZ)</span>

<span class="cm">/**</span>
<span class="cm"> * clockevents_increase_min_delta - raise minimum delta of a clock event device</span>
<span class="cm"> * @dev:       device to increase the minimum delta</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -ETIME when the minimum delta reached the limit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">clockevents_increase_min_delta</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Nothing to do if we already reached the limit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">min_delta_ns</span> <span class="o">&gt;=</span> <span class="n">MIN_DELTA_LIMIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;CE: Reprogramming failure. Giving up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">next_event</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">KTIME_MAX</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">min_delta_ns</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">min_delta_ns</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">min_delta_ns</span> <span class="o">+=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">min_delta_ns</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">min_delta_ns</span> <span class="o">&gt;</span> <span class="n">MIN_DELTA_LIMIT</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">min_delta_ns</span> <span class="o">=</span> <span class="n">MIN_DELTA_LIMIT</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;CE: %s increased min_delta_ns to %llu nsec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;?&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">min_delta_ns</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clockevents_program_min_delta - Set clock event device to the minimum delay.</span>
<span class="cm"> * @dev:	device to program</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -ETIME when the retry loop failed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">clockevents_program_min_delta</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">clc</span><span class="p">;</span>
	<span class="kt">int64_t</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;)</span> <span class="p">{</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">min_delta_ns</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">next_event</span> <span class="o">=</span> <span class="n">ktime_add_ns</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">(),</span> <span class="n">delta</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">CLOCK_EVT_MODE_SHUTDOWN</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">retries</span><span class="o">++</span><span class="p">;</span>
		<span class="n">clc</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">set_next_event</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">clc</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We tried 3 times to program the device with the</span>
<span class="cm">			 * given min_delta_ns. Try to increase the minimum</span>
<span class="cm">			 * delta, if that fails as well get out of here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">clockevents_increase_min_delta</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else  </span><span class="cm">/* CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * clockevents_program_min_delta - Set clock event device to the minimum delay.</span>
<span class="cm"> * @dev:	device to program</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -ETIME when the retry loop failed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">clockevents_program_min_delta</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">clc</span><span class="p">;</span>
	<span class="kt">int64_t</span> <span class="n">delta</span><span class="p">;</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">min_delta_ns</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">next_event</span> <span class="o">=</span> <span class="n">ktime_add_ns</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">(),</span> <span class="n">delta</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">CLOCK_EVT_MODE_SHUTDOWN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">retries</span><span class="o">++</span><span class="p">;</span>
	<span class="n">clc</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">set_next_event</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">clc</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * clockevents_program_event - Reprogram the clock event device.</span>
<span class="cm"> * @dev:	device to program</span>
<span class="cm"> * @expires:	absolute expiry time (monotonic clock)</span>
<span class="cm"> * @force:	program minimum delay if expires can not be set</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -ETIME when the event is in the past.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clockevents_program_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">expires</span><span class="p">,</span>
			      <span class="n">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">clc</span><span class="p">;</span>
	<span class="kt">int64_t</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">expires</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">next_event</span> <span class="o">=</span> <span class="n">expires</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">CLOCK_EVT_MODE_SHUTDOWN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Shortcut for clockevent devices that can deal with ktime. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">CLOCK_EVT_FEAT_KTIME</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">set_next_ktime</span><span class="p">(</span><span class="n">expires</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">expires</span><span class="p">,</span> <span class="n">ktime_get</span><span class="p">()));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">force</span> <span class="o">?</span> <span class="n">clockevents_program_min_delta</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_delta_ns</span><span class="p">);</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">min_delta_ns</span><span class="p">);</span>

	<span class="n">clc</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">set_next_event</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">clc</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="n">force</span><span class="p">)</span> <span class="o">?</span> <span class="n">clockevents_program_min_delta</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">:</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clockevents_register_notifier - register a clock events change listener</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clockevents_register_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clockevents_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">raw_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clockevents_chain</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clockevents_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Notify about a clock event change. Called with clockevents_lock</span>
<span class="cm"> * held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">clockevents_do_notify</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reason</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clockevents_chain</span><span class="p">,</span> <span class="n">reason</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called after a notify add to make devices available which were</span>
<span class="cm"> * released from the notifier call.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">clockevents_notify_released</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clockevents_released</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">clockevents_released</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">clock_event_device</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clockevent_devices</span><span class="p">);</span>
		<span class="n">clockevents_do_notify</span><span class="p">(</span><span class="n">CLOCK_EVT_NOTIFY_ADD</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clockevents_register_device - register a clock event device</span>
<span class="cm"> * @dev:	device to register</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clockevents_register_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">CLOCK_EVT_MODE_UNUSED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cpumask</span> <span class="o">=</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clockevents_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clockevent_devices</span><span class="p">);</span>
	<span class="n">clockevents_do_notify</span><span class="p">(</span><span class="n">CLOCK_EVT_NOTIFY_ADD</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">clockevents_notify_released</span><span class="p">();</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clockevents_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clockevents_register_device</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">clockevents_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">sec</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">CLOCK_EVT_FEAT_ONESHOT</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the maximum number of seconds we can sleep. Limit</span>
<span class="cm">	 * to 10 minutes for hardware which can program more than</span>
<span class="cm">	 * 32bit ticks so we still get reasonable conversion values.</span>
<span class="cm">	 */</span>
	<span class="n">sec</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_delta_ticks</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sec</span><span class="p">)</span>
		<span class="n">sec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sec</span> <span class="o">&gt;</span> <span class="mi">600</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_delta_ticks</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
		<span class="n">sec</span> <span class="o">=</span> <span class="mi">600</span><span class="p">;</span>

	<span class="n">clockevents_calc_mult_shift</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">sec</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">min_delta_ns</span> <span class="o">=</span> <span class="n">clockevent_delta2ns</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">min_delta_ticks</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_delta_ns</span> <span class="o">=</span> <span class="n">clockevent_delta2ns</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_delta_ticks</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clockevents_config_and_register - Configure and register a clock event device</span>
<span class="cm"> * @dev:	device to register</span>
<span class="cm"> * @freq:	The clock frequency</span>
<span class="cm"> * @min_delta:	The minimum clock ticks to program in oneshot mode</span>
<span class="cm"> * @max_delta:	The maximum clock ticks to program in oneshot mode</span>
<span class="cm"> *</span>
<span class="cm"> * min/max_delta can be 0 for devices which do not support oneshot mode.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clockevents_config_and_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">freq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_delta</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">min_delta_ticks</span> <span class="o">=</span> <span class="n">min_delta</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_delta_ticks</span> <span class="o">=</span> <span class="n">max_delta</span><span class="p">;</span>
	<span class="n">clockevents_config</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
	<span class="n">clockevents_register_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clockevents_update_freq - Update frequency and reprogram a clock event device.</span>
<span class="cm"> * @dev:	device to modify</span>
<span class="cm"> * @freq:	new device frequency</span>
<span class="cm"> *</span>
<span class="cm"> * Reconfigure and reprogram a clock event device in oneshot</span>
<span class="cm"> * mode. Must be called on the cpu for which the device delivers per</span>
<span class="cm"> * cpu timer events with interrupts disabled!  Returns 0 on success,</span>
<span class="cm"> * -ETIME when the event is in the past.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clockevents_update_freq</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clockevents_config</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">CLOCK_EVT_MODE_ONESHOT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">clockevents_program_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">next_event</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Noop handler when we shut down an event device</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clockevents_handle_noop</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clockevents_exchange_device - release and request clock devices</span>
<span class="cm"> * @old:	device to release (can be NULL)</span>
<span class="cm"> * @new:	device to request (can be NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Called from the notifier chain. clockevents_lock is held already</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clockevents_exchange_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Caller releases a clock event device. We queue it into the</span>
<span class="cm">	 * released list and do a notify add later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clockevents_set_mode</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">CLOCK_EVT_MODE_UNUSED</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clockevents_released</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">CLOCK_EVT_MODE_UNUSED</span><span class="p">);</span>
		<span class="n">clockevents_shutdown</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_GENERIC_CLOCKEVENTS</span>
<span class="cm">/**</span>
<span class="cm"> * clockevents_notify - notification about relevant events</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clockevents_notify</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reason</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clockevents_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">clockevents_do_notify</span><span class="p">(</span><span class="n">reason</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reason</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CLOCK_EVT_NOTIFY_CPU_DEAD</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Unregister the clock event devices which were</span>
<span class="cm">		 * released from the users in the notify chain.</span>
<span class="cm">		 */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clockevents_released</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Now check whether the CPU has left unused per cpu devices</span>
<span class="cm">		 */</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clockevent_devices</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">cpumask_weight</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">tick_is_broadcast_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">CLOCK_EVT_MODE_UNUSED</span><span class="p">);</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clockevents_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">clockevents_notify</span><span class="p">);</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
