<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › time › timekeeping.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>timekeeping.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/kernel/time/timekeeping.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Kernel timekeeping code and accessor functions</span>
<span class="cm"> *</span>
<span class="cm"> *  This code was moved from linux/kernel/timer.c.</span>
<span class="cm"> *  Please see that file for copyright and history logs.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/syscore_ops.h&gt;</span>
<span class="cp">#include &lt;linux/clocksource.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/tick.h&gt;</span>
<span class="cp">#include &lt;linux/stop_machine.h&gt;</span>

<span class="cm">/* Structure holding internal timekeeping values. */</span>
<span class="k">struct</span> <span class="n">timekeeper</span> <span class="p">{</span>
	<span class="cm">/* Current clocksource used for timekeeping. */</span>
	<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">clock</span><span class="p">;</span>
	<span class="cm">/* NTP adjusted clock multiplier */</span>
	<span class="n">u32</span>	<span class="n">mult</span><span class="p">;</span>
	<span class="cm">/* The shift value of the current clocksource. */</span>
	<span class="kt">int</span>	<span class="n">shift</span><span class="p">;</span>

	<span class="cm">/* Number of clock cycles in one NTP interval. */</span>
	<span class="n">cycle_t</span> <span class="n">cycle_interval</span><span class="p">;</span>
	<span class="cm">/* Number of clock shifted nano seconds in one NTP interval. */</span>
	<span class="n">u64</span>	<span class="n">xtime_interval</span><span class="p">;</span>
	<span class="cm">/* shifted nano seconds left over when rounding cycle_interval */</span>
	<span class="n">s64</span>	<span class="n">xtime_remainder</span><span class="p">;</span>
	<span class="cm">/* Raw nano seconds accumulated per NTP interval. */</span>
	<span class="n">u32</span>	<span class="n">raw_interval</span><span class="p">;</span>

	<span class="cm">/* Clock shifted nano seconds remainder not stored in xtime.tv_nsec. */</span>
	<span class="n">u64</span>	<span class="n">xtime_nsec</span><span class="p">;</span>
	<span class="cm">/* Difference between accumulated time and NTP time in ntp</span>
<span class="cm">	 * shifted nano seconds. */</span>
	<span class="n">s64</span>	<span class="n">ntp_error</span><span class="p">;</span>
	<span class="cm">/* Shift conversion between clock shifted nano seconds and</span>
<span class="cm">	 * ntp shifted nano seconds. */</span>
	<span class="kt">int</span>	<span class="n">ntp_error_shift</span><span class="p">;</span>

	<span class="cm">/* The current time */</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">xtime</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * wall_to_monotonic is what we need to add to xtime (or xtime corrected</span>
<span class="cm">	 * for sub jiffie times) to get to monotonic time.  Monotonic is pegged</span>
<span class="cm">	 * at zero at system boot time, so wall_to_monotonic will be negative,</span>
<span class="cm">	 * however, we will ALWAYS keep the tv_nsec part positive so we can use</span>
<span class="cm">	 * the usual normalization.</span>
<span class="cm">	 *</span>
<span class="cm">	 * wall_to_monotonic is moved after resume from suspend for the</span>
<span class="cm">	 * monotonic time not to jump. We need to add total_sleep_time to</span>
<span class="cm">	 * wall_to_monotonic to get the real boot based time offset.</span>
<span class="cm">	 *</span>
<span class="cm">	 * - wall_to_monotonic is no longer the boot time, getboottime must be</span>
<span class="cm">	 * used instead.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">wall_to_monotonic</span><span class="p">;</span>
	<span class="cm">/* time spent in suspend */</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">total_sleep_time</span><span class="p">;</span>
	<span class="cm">/* The raw monotonic time for the CLOCK_MONOTONIC_RAW posix clock. */</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">raw_time</span><span class="p">;</span>

	<span class="cm">/* Seqlock for all timekeeper values */</span>
	<span class="n">seqlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">timekeeper</span> <span class="n">timekeeper</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This read-write spinlock protects us from races in SMP while</span>
<span class="cm"> * playing with xtime.</span>
<span class="cm"> */</span>
<span class="n">__cacheline_aligned_in_smp</span> <span class="n">DEFINE_SEQLOCK</span><span class="p">(</span><span class="n">xtime_lock</span><span class="p">);</span>


<span class="cm">/* flag for if timekeeping is suspended */</span>
<span class="kt">int</span> <span class="n">__read_mostly</span> <span class="n">timekeeping_suspended</span><span class="p">;</span>



<span class="cm">/**</span>
<span class="cm"> * timekeeper_setup_internals - Set up internals to use clocksource clock.</span>
<span class="cm"> *</span>
<span class="cm"> * @clock:		Pointer to clocksource.</span>
<span class="cm"> *</span>
<span class="cm"> * Calculates a fixed cycle/nsec interval for a given clocksource/adjustment</span>
<span class="cm"> * pair and interval request.</span>
<span class="cm"> *</span>
<span class="cm"> * Unless you&#39;re the timekeeping code, you should not be using this!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">timekeeper_setup_internals</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">clock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cycle_t</span> <span class="n">interval</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ntpinterval</span><span class="p">;</span>

	<span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span> <span class="o">=</span> <span class="n">clock</span><span class="p">;</span>
	<span class="n">clock</span><span class="o">-&gt;</span><span class="n">cycle_last</span> <span class="o">=</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">clock</span><span class="p">);</span>

	<span class="cm">/* Do the ns -&gt; cycle conversion first, using original mult */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">NTP_INTERVAL_LENGTH</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">&lt;&lt;=</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">;</span>
	<span class="n">ntpinterval</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">+=</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">mult</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">cycle_t</span><span class="p">)</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">cycle_interval</span> <span class="o">=</span> <span class="n">interval</span><span class="p">;</span>

	<span class="cm">/* Go back from cycles -&gt; shifted ns */</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">interval</span> <span class="o">*</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_remainder</span> <span class="o">=</span> <span class="n">ntpinterval</span> <span class="o">-</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_interval</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">raw_interval</span> <span class="o">=</span>
		<span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="n">interval</span> <span class="o">*</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">;</span>

	<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">shift</span> <span class="o">=</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">;</span>

	<span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error_shift</span> <span class="o">=</span> <span class="n">NTP_SCALE_SHIFT</span> <span class="o">-</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The timekeeper keeps its own mult values for the currently</span>
<span class="cm">	 * active clocksource. These value will be adjusted via NTP</span>
<span class="cm">	 * to counteract clock drifting.</span>
<span class="cm">	 */</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">mult</span> <span class="o">=</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Timekeeper helper functions. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">timekeeping_get_ns</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cycle_t</span> <span class="n">cycle_now</span><span class="p">,</span> <span class="n">cycle_delta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">clock</span><span class="p">;</span>

	<span class="cm">/* read clocksource: */</span>
	<span class="n">clock</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="p">;</span>
	<span class="n">cycle_now</span> <span class="o">=</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">clock</span><span class="p">);</span>

	<span class="cm">/* calculate the delta since the last update_wall_time: */</span>
	<span class="n">cycle_delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">cycle_now</span> <span class="o">-</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">cycle_last</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>

	<span class="cm">/* return delta convert to nanoseconds using ntp adjusted mult. */</span>
	<span class="k">return</span> <span class="n">clocksource_cyc2ns</span><span class="p">(</span><span class="n">cycle_delta</span><span class="p">,</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">mult</span><span class="p">,</span>
				  <span class="n">timekeeper</span><span class="p">.</span><span class="n">shift</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">timekeeping_get_ns_raw</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cycle_t</span> <span class="n">cycle_now</span><span class="p">,</span> <span class="n">cycle_delta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">clock</span><span class="p">;</span>

	<span class="cm">/* read clocksource: */</span>
	<span class="n">clock</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="p">;</span>
	<span class="n">cycle_now</span> <span class="o">=</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">clock</span><span class="p">);</span>

	<span class="cm">/* calculate the delta since the last update_wall_time: */</span>
	<span class="n">cycle_delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">cycle_now</span> <span class="o">-</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">cycle_last</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>

	<span class="cm">/* return delta convert to nanoseconds. */</span>
	<span class="k">return</span> <span class="n">clocksource_cyc2ns</span><span class="p">(</span><span class="n">cycle_delta</span><span class="p">,</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">,</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* must hold write on timekeeper.lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">timekeeping_update</span><span class="p">(</span><span class="n">bool</span> <span class="n">clearntp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clearntp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ntp_clear</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">update_vsyscall</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span><span class="p">,</span>
			 <span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="p">,</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">mult</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * timekeeping_forward_now - update clock to the current time</span>
<span class="cm"> *</span>
<span class="cm"> * Forward the current clock to update its state since the last call to</span>
<span class="cm"> * update_wall_time(). This is useful before significant clock changes,</span>
<span class="cm"> * as it avoids having to deal with this time offset explicitly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">timekeeping_forward_now</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cycle_t</span> <span class="n">cycle_now</span><span class="p">,</span> <span class="n">cycle_delta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">clock</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">nsec</span><span class="p">;</span>

	<span class="n">clock</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="p">;</span>
	<span class="n">cycle_now</span> <span class="o">=</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">clock</span><span class="p">);</span>
	<span class="n">cycle_delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">cycle_now</span> <span class="o">-</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">cycle_last</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">clock</span><span class="o">-&gt;</span><span class="n">cycle_last</span> <span class="o">=</span> <span class="n">cycle_now</span><span class="p">;</span>

	<span class="n">nsec</span> <span class="o">=</span> <span class="n">clocksource_cyc2ns</span><span class="p">(</span><span class="n">cycle_delta</span><span class="p">,</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">mult</span><span class="p">,</span>
				  <span class="n">timekeeper</span><span class="p">.</span><span class="n">shift</span><span class="p">);</span>

	<span class="cm">/* If arch requires, add in gettimeoffset() */</span>
	<span class="n">nsec</span> <span class="o">+=</span> <span class="n">arch_gettimeoffset</span><span class="p">();</span>

	<span class="n">timespec_add_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">,</span> <span class="n">nsec</span><span class="p">);</span>

	<span class="n">nsec</span> <span class="o">=</span> <span class="n">clocksource_cyc2ns</span><span class="p">(</span><span class="n">cycle_delta</span><span class="p">,</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">,</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">);</span>
	<span class="n">timespec_add_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">raw_time</span><span class="p">,</span> <span class="n">nsec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * getnstimeofday - Returns the time of day in a timespec</span>
<span class="cm"> * @ts:		pointer to the timespec to be set</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the time of day in a timespec.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">getnstimeofday</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">nsecs</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">timekeeping_suspended</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">;</span>
		<span class="n">nsecs</span> <span class="o">=</span> <span class="n">timekeeping_get_ns</span><span class="p">();</span>

		<span class="cm">/* If arch requires, add in gettimeoffset() */</span>
		<span class="n">nsecs</span> <span class="o">+=</span> <span class="n">arch_gettimeoffset</span><span class="p">();</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>

	<span class="n">timespec_add_ns</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">nsecs</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">getnstimeofday</span><span class="p">);</span>

<span class="n">ktime_t</span> <span class="nf">ktime_get</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">secs</span><span class="p">,</span> <span class="n">nsecs</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">timekeeping_suspended</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">secs</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span>
				<span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="n">nsecs</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">+</span>
				<span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
		<span class="n">nsecs</span> <span class="o">+=</span> <span class="n">timekeeping_get_ns</span><span class="p">();</span>
		<span class="cm">/* If arch requires, add in gettimeoffset() */</span>
		<span class="n">nsecs</span> <span class="o">+=</span> <span class="n">arch_gettimeoffset</span><span class="p">();</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Use ktime_set/ktime_add_ns to create a proper ktime on</span>
<span class="cm">	 * 32-bit architectures without CONFIG_KTIME_SCALAR.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">ktime_add_ns</span><span class="p">(</span><span class="n">ktime_set</span><span class="p">(</span><span class="n">secs</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">nsecs</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ktime_get_ts - get the monotonic clock in timespec format</span>
<span class="cm"> * @ts:		pointer to timespec variable</span>
<span class="cm"> *</span>
<span class="cm"> * The function calculates the monotonic clock from the realtime</span>
<span class="cm"> * clock and the wall_to_monotonic offset and stores the result</span>
<span class="cm"> * in normalized timespec format in the variable pointed to by @ts.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ktime_get_ts</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">tomono</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">nsecs</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">timekeeping_suspended</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">;</span>
		<span class="n">tomono</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span><span class="p">;</span>
		<span class="n">nsecs</span> <span class="o">=</span> <span class="n">timekeeping_get_ns</span><span class="p">();</span>
		<span class="cm">/* If arch requires, add in gettimeoffset() */</span>
		<span class="n">nsecs</span> <span class="o">+=</span> <span class="n">arch_gettimeoffset</span><span class="p">();</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>

	<span class="n">set_normalized_timespec</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="n">tomono</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
				<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">+</span> <span class="n">tomono</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">+</span> <span class="n">nsecs</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ktime_get_ts</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NTP_PPS</span>

<span class="cm">/**</span>
<span class="cm"> * getnstime_raw_and_real - get day and raw monotonic time in timespec format</span>
<span class="cm"> * @ts_raw:	pointer to the timespec to be set to raw monotonic time</span>
<span class="cm"> * @ts_real:	pointer to the timespec to be set to the time of day</span>
<span class="cm"> *</span>
<span class="cm"> * This function reads both the time of day and raw monotonic time at the</span>
<span class="cm"> * same time atomically and stores the resulting timestamps in timespec</span>
<span class="cm"> * format.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">getnstime_raw_and_real</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts_raw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts_real</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">nsecs_raw</span><span class="p">,</span> <span class="n">nsecs_real</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">timekeeping_suspended</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">arch_offset</span><span class="p">;</span>

		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="o">*</span><span class="n">ts_raw</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">raw_time</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ts_real</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">;</span>

		<span class="n">nsecs_raw</span> <span class="o">=</span> <span class="n">timekeeping_get_ns_raw</span><span class="p">();</span>
		<span class="n">nsecs_real</span> <span class="o">=</span> <span class="n">timekeeping_get_ns</span><span class="p">();</span>

		<span class="cm">/* If arch requires, add in gettimeoffset() */</span>
		<span class="n">arch_offset</span> <span class="o">=</span> <span class="n">arch_gettimeoffset</span><span class="p">();</span>
		<span class="n">nsecs_raw</span> <span class="o">+=</span> <span class="n">arch_offset</span><span class="p">;</span>
		<span class="n">nsecs_real</span> <span class="o">+=</span> <span class="n">arch_offset</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>

	<span class="n">timespec_add_ns</span><span class="p">(</span><span class="n">ts_raw</span><span class="p">,</span> <span class="n">nsecs_raw</span><span class="p">);</span>
	<span class="n">timespec_add_ns</span><span class="p">(</span><span class="n">ts_real</span><span class="p">,</span> <span class="n">nsecs_real</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">getnstime_raw_and_real</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_NTP_PPS */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * do_gettimeofday - Returns the time of day in a timeval</span>
<span class="cm"> * @tv:		pointer to the timeval to be set</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Users should be converted to using getnstimeofday()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">do_gettimeofday</span><span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">tv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">getnstimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
	<span class="n">tv</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">tv</span><span class="o">-&gt;</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_nsec</span><span class="o">/</span><span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">do_gettimeofday</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * do_settimeofday - Sets the time of day</span>
<span class="cm"> * @tv:		pointer to the timespec variable containing the new time</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the time of day to the new time and update NTP and notify hrtimers</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">do_settimeofday</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts_delta</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tv</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">&gt;=</span> <span class="n">NSEC_PER_SEC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">write_seqlock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">timekeeping_forward_now</span><span class="p">();</span>

	<span class="n">ts_delta</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">tv</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">ts_delta</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">tv</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span> <span class="o">=</span>
			<span class="n">timespec_sub</span><span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span><span class="p">,</span> <span class="n">ts_delta</span><span class="p">);</span>

	<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span> <span class="o">=</span> <span class="o">*</span><span class="n">tv</span><span class="p">;</span>
	<span class="n">timekeeping_update</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

	<span class="n">write_sequnlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* signal hrtimers about time change */</span>
	<span class="n">clock_was_set</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">do_settimeofday</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * timekeeping_inject_offset - Adds or subtracts from the current time.</span>
<span class="cm"> * @tv:		pointer to the timespec variable containing the offset</span>
<span class="cm"> *</span>
<span class="cm"> * Adds or subtracts an offset value from the current time.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">timekeeping_inject_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">&gt;=</span> <span class="n">NSEC_PER_SEC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">write_seqlock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">timekeeping_forward_now</span><span class="p">();</span>

	<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span> <span class="o">=</span> <span class="n">timespec_add</span><span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">,</span> <span class="o">*</span><span class="n">ts</span><span class="p">);</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span> <span class="o">=</span>
				<span class="n">timespec_sub</span><span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span><span class="p">,</span> <span class="o">*</span><span class="n">ts</span><span class="p">);</span>

	<span class="n">timekeeping_update</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

	<span class="n">write_sequnlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* signal hrtimers about time change */</span>
	<span class="n">clock_was_set</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">timekeeping_inject_offset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * change_clocksource - Swaps clocksources if a new one is available</span>
<span class="cm"> *</span>
<span class="cm"> * Accumulates current time interval and initializes new clocksource</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">change_clocksource</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">write_seqlock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">timekeeping_forward_now</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">enable</span> <span class="o">||</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">enable</span><span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">old</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="p">;</span>
		<span class="n">timekeeper_setup_internals</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">disable</span><span class="p">)</span>
			<span class="n">old</span><span class="o">-&gt;</span><span class="n">disable</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">timekeeping_update</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

	<span class="n">write_sequnlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * timekeeping_notify - Install a new clock source</span>
<span class="cm"> * @clock:		pointer to the clock source</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from clocksource.c after a new, better clock</span>
<span class="cm"> * source has been registered. The caller holds the clocksource_mutex.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">timekeeping_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">clock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span> <span class="o">==</span> <span class="n">clock</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">stop_machine</span><span class="p">(</span><span class="n">change_clocksource</span><span class="p">,</span> <span class="n">clock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">tick_clock_notify</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ktime_get_real - get the real (wall-) time in ktime_t format</span>
<span class="cm"> *</span>
<span class="cm"> * returns the time in ktime_t format</span>
<span class="cm"> */</span>
<span class="n">ktime_t</span> <span class="nf">ktime_get_real</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">getnstimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">timespec_to_ktime</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ktime_get_real</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * getrawmonotonic - Returns the raw monotonic time in a timespec</span>
<span class="cm"> * @ts:		pointer to the timespec to be set</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the raw monotonic time (completely un-modified by ntp)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">getrawmonotonic</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">nsecs</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">nsecs</span> <span class="o">=</span> <span class="n">timekeeping_get_ns_raw</span><span class="p">();</span>
		<span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">raw_time</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>

	<span class="n">timespec_add_ns</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">nsecs</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">getrawmonotonic</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * timekeeping_valid_for_hres - Check if timekeeping is suitable for hres</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">timekeeping_valid_for_hres</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLOCK_SOURCE_VALID_FOR_HRES</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * timekeeping_max_deferment - Returns max time the clocksource can be deferred</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">timekeeping_max_deferment</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">max_idle_ns</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * read_persistent_clock -  Return time from the persistent clock.</span>
<span class="cm"> *</span>
<span class="cm"> * Weak dummy function for arches that do not yet support it.</span>
<span class="cm"> * Reads the time from the battery backed persistent clock.</span>
<span class="cm"> * Returns a timespec with tv_sec=0 and tv_nsec=0 if unsupported.</span>
<span class="cm"> *</span>
<span class="cm"> *  XXX - Do be sure to remove it once all arches implement it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">read_persistent_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * read_boot_clock -  Return time of the system start.</span>
<span class="cm"> *</span>
<span class="cm"> * Weak dummy function for arches that do not yet support it.</span>
<span class="cm"> * Function to read the exact time the system has been started.</span>
<span class="cm"> * Returns a timespec with tv_sec=0 and tv_nsec=0 if unsupported.</span>
<span class="cm"> *</span>
<span class="cm"> *  XXX - Do be sure to remove it once all arches implement it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">read_boot_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * timekeeping_init - Initializes the clocksource and common timekeeping values</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">timekeeping_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">clock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">,</span> <span class="n">boot</span><span class="p">;</span>

	<span class="n">read_persistent_clock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
	<span class="n">read_boot_clock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boot</span><span class="p">);</span>

	<span class="n">seqlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">ntp_init</span><span class="p">();</span>

	<span class="n">write_seqlock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">clock</span> <span class="o">=</span> <span class="n">clocksource_default_clock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">enable</span><span class="p">)</span>
		<span class="n">clock</span><span class="o">-&gt;</span><span class="n">enable</span><span class="p">(</span><span class="n">clock</span><span class="p">);</span>
	<span class="n">timekeeper_setup_internals</span><span class="p">(</span><span class="n">clock</span><span class="p">);</span>

	<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">raw_time</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">raw_time</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">boot</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">boot</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="n">boot</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">set_normalized_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span><span class="p">,</span>
				<span class="o">-</span><span class="n">boot</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="o">-</span><span class="n">boot</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">total_sleep_time</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">total_sleep_time</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">write_sequnlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* time in seconds when suspend began */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">timekeeping_suspend_time</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * __timekeeping_inject_sleeptime - Internal function to add sleep interval</span>
<span class="cm"> * @delta: pointer to a timespec delta value</span>
<span class="cm"> *</span>
<span class="cm"> * Takes a timespec offset measuring a suspend interval and properly</span>
<span class="cm"> * adds the sleep offset to the timekeeping variables.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__timekeeping_inject_sleeptime</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timespec_valid</span><span class="p">(</span><span class="n">delta</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;__timekeeping_inject_sleeptime: Invalid &quot;</span>
					<span class="s">&quot;sleep delta value!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span> <span class="o">=</span> <span class="n">timespec_add</span><span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">,</span> <span class="o">*</span><span class="n">delta</span><span class="p">);</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span> <span class="o">=</span>
			<span class="n">timespec_sub</span><span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span><span class="p">,</span> <span class="o">*</span><span class="n">delta</span><span class="p">);</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">total_sleep_time</span> <span class="o">=</span> <span class="n">timespec_add</span><span class="p">(</span>
					<span class="n">timekeeper</span><span class="p">.</span><span class="n">total_sleep_time</span><span class="p">,</span> <span class="o">*</span><span class="n">delta</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * timekeeping_inject_sleeptime - Adds suspend interval to timeekeeping values</span>
<span class="cm"> * @delta: pointer to a timespec delta value</span>
<span class="cm"> *</span>
<span class="cm"> * This hook is for architectures that cannot support read_persistent_clock</span>
<span class="cm"> * because their RTC/persistent clock is only accessible when irqs are enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * This function should only be called by rtc_resume(), and allows</span>
<span class="cm"> * a suspend offset to be injected into the timekeeping values.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">timekeeping_inject_sleeptime</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>

	<span class="cm">/* Make sure we don&#39;t set the clock twice */</span>
	<span class="n">read_persistent_clock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">write_seqlock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">timekeeping_forward_now</span><span class="p">();</span>

	<span class="n">__timekeeping_inject_sleeptime</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>

	<span class="n">timekeeping_update</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

	<span class="n">write_sequnlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* signal hrtimers about time change */</span>
	<span class="n">clock_was_set</span><span class="p">();</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * timekeeping_resume - Resumes the generic timekeeping subsystem.</span>
<span class="cm"> *</span>
<span class="cm"> * This is for the generic clocksource timekeeping.</span>
<span class="cm"> * xtime/wall_to_monotonic/jiffies/etc are</span>
<span class="cm"> * still managed by arch specific suspend/resume code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">timekeeping_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>

	<span class="n">read_persistent_clock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>

	<span class="n">clocksource_resume</span><span class="p">();</span>

	<span class="n">write_seqlock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timespec_compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timekeeping_suspend_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ts</span> <span class="o">=</span> <span class="n">timespec_sub</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">timekeeping_suspend_time</span><span class="p">);</span>
		<span class="n">__timekeeping_inject_sleeptime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* re-base the last cycle value */</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">cycle_last</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="p">);</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">timekeeping_suspended</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">write_sequnlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">touch_softlockup_watchdog</span><span class="p">();</span>

	<span class="n">clockevents_notify</span><span class="p">(</span><span class="n">CLOCK_EVT_NOTIFY_RESUME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Resume hrtimers */</span>
	<span class="n">hrtimers_resume</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">timekeeping_suspend</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span>		<span class="n">delta</span><span class="p">,</span> <span class="n">delta_delta</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">timespec</span>	<span class="n">old_delta</span><span class="p">;</span>

	<span class="n">read_persistent_clock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeping_suspend_time</span><span class="p">);</span>

	<span class="n">write_seqlock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">timekeeping_forward_now</span><span class="p">();</span>
	<span class="n">timekeeping_suspended</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * To avoid drift caused by repeated suspend/resumes,</span>
<span class="cm">	 * which each can add ~1 second drift error,</span>
<span class="cm">	 * try to compensate so the difference in system time</span>
<span class="cm">	 * and persistent_clock time stays close to constant.</span>
<span class="cm">	 */</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">timespec_sub</span><span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">,</span> <span class="n">timekeeping_suspend_time</span><span class="p">);</span>
	<span class="n">delta_delta</span> <span class="o">=</span> <span class="n">timespec_sub</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">old_delta</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">delta_delta</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span>  <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if delta_delta is too large, assume time correction</span>
<span class="cm">		 * has occured and set old_delta to the current delta.</span>
<span class="cm">		 */</span>
		<span class="n">old_delta</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Otherwise try to adjust old_system to compensate */</span>
		<span class="n">timekeeping_suspend_time</span> <span class="o">=</span>
			<span class="n">timespec_add</span><span class="p">(</span><span class="n">timekeeping_suspend_time</span><span class="p">,</span> <span class="n">delta_delta</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_sequnlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">clockevents_notify</span><span class="p">(</span><span class="n">CLOCK_EVT_NOTIFY_SUSPEND</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">clocksource_suspend</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* sysfs resume/suspend bits for timekeeping */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">syscore_ops</span> <span class="n">timekeeping_syscore_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">timekeeping_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">timekeeping_suspend</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">timekeeping_init_ops</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">register_syscore_ops</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeping_syscore_ops</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">device_initcall</span><span class="p">(</span><span class="n">timekeeping_init_ops</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * If the error is already larger, we look ahead even further</span>
<span class="cm"> * to compensate for late or lost adjustments.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">int</span> <span class="nf">timekeeping_bigadjust</span><span class="p">(</span><span class="n">s64</span> <span class="n">error</span><span class="p">,</span> <span class="n">s64</span> <span class="o">*</span><span class="n">interval</span><span class="p">,</span>
						 <span class="n">s64</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">tick_error</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">look_ahead</span><span class="p">,</span> <span class="n">adj</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">error2</span><span class="p">,</span> <span class="n">mult</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use the current error value to determine how much to look ahead.</span>
<span class="cm">	 * The larger the error the slower we adjust for it to avoid problems</span>
<span class="cm">	 * with losing too many ticks, otherwise we would overadjust and</span>
<span class="cm">	 * produce an even larger error.  The smaller the adjustment the</span>
<span class="cm">	 * faster we try to adjust for it, as lost ticks can do less harm</span>
<span class="cm">	 * here.  This is tuned so that an error of about 1 msec is adjusted</span>
<span class="cm">	 * within about 1 sec (or 2^20 nsec in 2^SHIFT_HZ ticks).</span>
<span class="cm">	 */</span>
	<span class="n">error2</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">NTP_SCALE_SHIFT</span> <span class="o">+</span> <span class="mi">22</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SHIFT_HZ</span><span class="p">);</span>
	<span class="n">error2</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">error2</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">look_ahead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">error2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">look_ahead</span><span class="o">++</span><span class="p">)</span>
		<span class="n">error2</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now calculate the error in (1 &lt;&lt; look_ahead) ticks, but first</span>
<span class="cm">	 * remove the single look ahead already included in the error.</span>
<span class="cm">	 */</span>
	<span class="n">tick_error</span> <span class="o">=</span> <span class="n">ntp_tick_length</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error_shift</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">tick_error</span> <span class="o">-=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_interval</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="p">((</span><span class="n">error</span> <span class="o">-</span> <span class="n">tick_error</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">look_ahead</span><span class="p">)</span> <span class="o">+</span> <span class="n">tick_error</span><span class="p">;</span>

	<span class="cm">/* Finally calculate the adjustment shift value.  */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">interval</span><span class="p">;</span>
	<span class="n">mult</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
		<span class="o">*</span><span class="n">interval</span> <span class="o">=</span> <span class="o">-*</span><span class="n">interval</span><span class="p">;</span>
		<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="o">-*</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">mult</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">adj</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">error</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">adj</span><span class="o">++</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="o">*</span><span class="n">interval</span> <span class="o">&lt;&lt;=</span> <span class="n">adj</span><span class="p">;</span>
	<span class="o">*</span><span class="n">offset</span> <span class="o">&lt;&lt;=</span> <span class="n">adj</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mult</span> <span class="o">&lt;&lt;</span> <span class="n">adj</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Adjust the multiplier to reduce the error value,</span>
<span class="cm"> * this is optimized for the most common adjustments of -1,0,1,</span>
<span class="cm"> * for other values we can do a bit more work.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">timekeeping_adjust</span><span class="p">(</span><span class="n">s64</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">error</span><span class="p">,</span> <span class="n">interval</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">cycle_interval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">adj</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The point of this is to check if the error is greater than half</span>
<span class="cm">	 * an interval.</span>
<span class="cm">	 *</span>
<span class="cm">	 * First we shift it down from NTP_SHIFT to clocksource-&gt;shifted nsecs.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note we subtract one in the shift, so that error is really error*2.</span>
<span class="cm">	 * This &quot;saves&quot; dividing(shifting) interval twice, but keeps the</span>
<span class="cm">	 * (error &gt; interval) comparison as still measuring if error is</span>
<span class="cm">	 * larger than half an interval.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: It does not &quot;save&quot; on aggravation when reading the code.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error_shift</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&gt;</span> <span class="n">interval</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We now divide error by 4(via shift), which checks if</span>
<span class="cm">		 * the error is greater than twice the interval.</span>
<span class="cm">		 * If it is greater, we need a bigadjust, if its smaller,</span>
<span class="cm">		 * we can adjust by 1.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * XXX - In update_wall_time, we round up to the next</span>
<span class="cm">		 * nanosecond, and store the amount rounded up into</span>
<span class="cm">		 * the error. This causes the likely below to be unlikely.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The proper fix is to avoid rounding up by using</span>
<span class="cm">		 * the high precision timekeeper.xtime_nsec instead of</span>
<span class="cm">		 * xtime.tv_nsec everywhere. Fixing this will take some</span>
<span class="cm">		 * time.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">error</span> <span class="o">&lt;=</span> <span class="n">interval</span><span class="p">))</span>
			<span class="n">adj</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">adj</span> <span class="o">=</span> <span class="n">timekeeping_bigadjust</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">interval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">interval</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* See comment above, this is just switched for the negative */</span>
		<span class="n">error</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">error</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">interval</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">adj</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">interval</span> <span class="o">=</span> <span class="o">-</span><span class="n">interval</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">offset</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">adj</span> <span class="o">=</span> <span class="n">timekeeping_bigadjust</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">interval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="cm">/* No adjustment needed */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">maxadj</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">mult</span> <span class="o">+</span> <span class="n">adj</span> <span class="o">&gt;</span>
			<span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">mult</span> <span class="o">+</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">maxadj</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;Adjusting %s more than 11%% (%ld vs %ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">mult</span> <span class="o">+</span> <span class="n">adj</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">mult</span> <span class="o">+</span>
				<span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">maxadj</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * So the following can be confusing.</span>
<span class="cm">	 *</span>
<span class="cm">	 * To keep things simple, lets assume adj == 1 for now.</span>
<span class="cm">	 *</span>
<span class="cm">	 * When adj != 1, remember that the interval and offset values</span>
<span class="cm">	 * have been appropriately scaled so the math is the same.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The basic idea here is that we&#39;re increasing the multiplier</span>
<span class="cm">	 * by one, this causes the xtime_interval to be incremented by</span>
<span class="cm">	 * one cycle_interval. This is because:</span>
<span class="cm">	 *	xtime_interval = cycle_interval * mult</span>
<span class="cm">	 * So if mult is being incremented by one:</span>
<span class="cm">	 *	xtime_interval = cycle_interval * (mult + 1)</span>
<span class="cm">	 * Its the same as:</span>
<span class="cm">	 *	xtime_interval = (cycle_interval * mult) + cycle_interval</span>
<span class="cm">	 * Which can be shortened to:</span>
<span class="cm">	 *	xtime_interval += cycle_interval</span>
<span class="cm">	 *</span>
<span class="cm">	 * So offset stores the non-accumulated cycles. Thus the current</span>
<span class="cm">	 * time (in shifted nanoseconds) is:</span>
<span class="cm">	 *	now = (offset * adj) + xtime_nsec</span>
<span class="cm">	 * Now, even though we&#39;re adjusting the clock frequency, we have</span>
<span class="cm">	 * to keep time consistent. In other words, we can&#39;t jump back</span>
<span class="cm">	 * in time, and we also want to avoid jumping forward in time.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So given the same offset value, we need the time to be the same</span>
<span class="cm">	 * both before and after the freq adjustment.</span>
<span class="cm">	 *	now = (offset * adj_1) + xtime_nsec_1</span>
<span class="cm">	 *	now = (offset * adj_2) + xtime_nsec_2</span>
<span class="cm">	 * So:</span>
<span class="cm">	 *	(offset * adj_1) + xtime_nsec_1 =</span>
<span class="cm">	 *		(offset * adj_2) + xtime_nsec_2</span>
<span class="cm">	 * And we know:</span>
<span class="cm">	 *	adj_2 = adj_1 + 1</span>
<span class="cm">	 * So:</span>
<span class="cm">	 *	(offset * adj_1) + xtime_nsec_1 =</span>
<span class="cm">	 *		(offset * (adj_1+1)) + xtime_nsec_2</span>
<span class="cm">	 *	(offset * adj_1) + xtime_nsec_1 =</span>
<span class="cm">	 *		(offset * adj_1) + offset + xtime_nsec_2</span>
<span class="cm">	 * Canceling the sides:</span>
<span class="cm">	 *	xtime_nsec_1 = offset + xtime_nsec_2</span>
<span class="cm">	 * Which gives us:</span>
<span class="cm">	 *	xtime_nsec_2 = xtime_nsec_1 - offset</span>
<span class="cm">	 * Which simplfies to:</span>
<span class="cm">	 *	xtime_nsec -= offset</span>
<span class="cm">	 *</span>
<span class="cm">	 * XXX - TODO: Doc ntp_error calculation.</span>
<span class="cm">	 */</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">mult</span> <span class="o">+=</span> <span class="n">adj</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_interval</span> <span class="o">+=</span> <span class="n">interval</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_nsec</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error</span> <span class="o">-=</span> <span class="p">(</span><span class="n">interval</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
				<span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error_shift</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * logarithmic_accumulation - shifted accumulation of cycles</span>
<span class="cm"> *</span>
<span class="cm"> * This functions accumulates a shifted interval of cycles into</span>
<span class="cm"> * into a shifted interval nanoseconds. Allows for O(log) accumulation</span>
<span class="cm"> * loop.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the unconsumed cycles.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">cycle_t</span> <span class="nf">logarithmic_accumulation</span><span class="p">(</span><span class="n">cycle_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">nsecps</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">NSEC_PER_SEC</span> <span class="o">&lt;&lt;</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">shift</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">raw_nsecs</span><span class="p">;</span>

	<span class="cm">/* If the offset is smaller than a shifted interval, do nothing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">cycle_interval</span><span class="o">&lt;&lt;</span><span class="n">shift</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>

	<span class="cm">/* Accumulate one shifted interval */</span>
	<span class="n">offset</span> <span class="o">-=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">cycle_interval</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">cycle_last</span> <span class="o">+=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">cycle_interval</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>

	<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_nsec</span> <span class="o">+=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_interval</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_nsec</span> <span class="o">&gt;=</span> <span class="n">nsecps</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">leap</span><span class="p">;</span>
		<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_nsec</span> <span class="o">-=</span> <span class="n">nsecps</span><span class="p">;</span>
		<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="o">++</span><span class="p">;</span>
		<span class="n">leap</span> <span class="o">=</span> <span class="n">second_overflow</span><span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
		<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+=</span> <span class="n">leap</span><span class="p">;</span>
		<span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-=</span> <span class="n">leap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Accumulate raw time */</span>
	<span class="n">raw_nsecs</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">raw_interval</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="n">raw_nsecs</span> <span class="o">+=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">raw_time</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">raw_nsecs</span> <span class="o">&gt;=</span> <span class="n">NSEC_PER_SEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">raw_secs</span> <span class="o">=</span> <span class="n">raw_nsecs</span><span class="p">;</span>
		<span class="n">raw_nsecs</span> <span class="o">=</span> <span class="n">do_div</span><span class="p">(</span><span class="n">raw_secs</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span><span class="p">);</span>
		<span class="n">timekeeper</span><span class="p">.</span><span class="n">raw_time</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+=</span> <span class="n">raw_secs</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">raw_time</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">raw_nsecs</span><span class="p">;</span>

	<span class="cm">/* Accumulate error between NTP and clock interval */</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error</span> <span class="o">+=</span> <span class="n">ntp_tick_length</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error</span> <span class="o">-=</span>
	    <span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_interval</span> <span class="o">+</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_remainder</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
				<span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error_shift</span> <span class="o">+</span> <span class="n">shift</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * update_wall_time - Uses the current clocksource to increment the wall time</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_wall_time</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">clock</span><span class="p">;</span>
	<span class="n">cycle_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxshift</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">write_seqlock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Make sure we&#39;re fully resumed: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">timekeeping_suspended</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">clock</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">clock</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_ARCH_USES_GETTIMEOFFSET</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">cycle_interval</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">clock</span><span class="p">)</span> <span class="o">-</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">cycle_last</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_nsec</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">&lt;&lt;</span>
						<span class="n">timekeeper</span><span class="p">.</span><span class="n">shift</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * With NO_HZ we may have to accumulate many cycle_intervals</span>
<span class="cm">	 * (think &quot;ticks&quot;) worth of time at once. To do this efficiently,</span>
<span class="cm">	 * we calculate the largest doubling multiple of cycle_intervals</span>
<span class="cm">	 * that is smaller than the offset.  We then accumulate that</span>
<span class="cm">	 * chunk in one go, and then try to consume the next smaller</span>
<span class="cm">	 * doubled multiple.</span>
<span class="cm">	 */</span>
	<span class="n">shift</span> <span class="o">=</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">-</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">cycle_interval</span><span class="p">);</span>
	<span class="n">shift</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>
	<span class="cm">/* Bound shift to one less than what overflows tick_length */</span>
	<span class="n">maxshift</span> <span class="o">=</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="p">(</span><span class="n">ilog2</span><span class="p">(</span><span class="n">ntp_tick_length</span><span class="p">())</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">shift</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">maxshift</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">cycle_interval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">logarithmic_accumulation</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">cycle_interval</span><span class="o">&lt;&lt;</span><span class="n">shift</span><span class="p">)</span>
			<span class="n">shift</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* correct the clock when NTP error is too big */</span>
	<span class="n">timekeeping_adjust</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since in the loop above, we accumulate any amount of time</span>
<span class="cm">	 * in xtime_nsec over a second into xtime.tv_sec, its possible for</span>
<span class="cm">	 * xtime_nsec to be fairly small after the loop. Further, if we&#39;re</span>
<span class="cm">	 * slightly speeding the clocksource up in timekeeping_adjust(),</span>
<span class="cm">	 * its possible the required corrective factor to xtime_nsec could</span>
<span class="cm">	 * cause it to underflow.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Now, we cannot simply roll the accumulated second back, since</span>
<span class="cm">	 * the NTP subsystem has been notified via second_overflow. So</span>
<span class="cm">	 * instead we push xtime_nsec forward by the amount we underflowed,</span>
<span class="cm">	 * and add that amount into the error.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We&#39;ll correct this error next time through this function, when</span>
<span class="cm">	 * xtime_nsec is not as small.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_nsec</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">s64</span> <span class="n">neg</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">s64</span><span class="p">)</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_nsec</span><span class="p">;</span>
		<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error</span> <span class="o">+=</span> <span class="n">neg</span> <span class="o">&lt;&lt;</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error_shift</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/*</span>
<span class="cm">	 * Store full nanoseconds into xtime after rounding it up and</span>
<span class="cm">	 * add the remainder to the error difference.</span>
<span class="cm">	 */</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_nsec</span> <span class="o">&gt;&gt;</span>
						<span class="n">timekeeper</span><span class="p">.</span><span class="n">shift</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_nsec</span> <span class="o">-=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">&lt;&lt;</span>
						<span class="n">timekeeper</span><span class="p">.</span><span class="n">shift</span><span class="p">;</span>
	<span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error</span> <span class="o">+=</span>	<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime_nsec</span> <span class="o">&lt;&lt;</span>
				<span class="n">timekeeper</span><span class="p">.</span><span class="n">ntp_error_shift</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finally, make sure that after the rounding</span>
<span class="cm">	 * xtime.tv_nsec isn&#39;t larger than NSEC_PER_SEC</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">&gt;=</span> <span class="n">NSEC_PER_SEC</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">leap</span><span class="p">;</span>
		<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-=</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>
		<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="o">++</span><span class="p">;</span>
		<span class="n">leap</span> <span class="o">=</span> <span class="n">second_overflow</span><span class="p">(</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
		<span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+=</span> <span class="n">leap</span><span class="p">;</span>
		<span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-=</span> <span class="n">leap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">timekeeping_update</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">write_sequnlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * getboottime - Return the real time of system boot.</span>
<span class="cm"> * @ts:		pointer to the timespec to be set</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the wall-time of boot in a timespec.</span>
<span class="cm"> *</span>
<span class="cm"> * This is based on the wall_to_monotonic offset and the total suspend</span>
<span class="cm"> * time. Calls to settimeofday will affect the value returned (which</span>
<span class="cm"> * basically means that however wrong your real time clock is at boot time,</span>
<span class="cm"> * you get the right time here).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">getboottime</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">boottime</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span>
				<span class="n">timekeeper</span><span class="p">.</span><span class="n">total_sleep_time</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">+</span>
				<span class="n">timekeeper</span><span class="p">.</span><span class="n">total_sleep_time</span><span class="p">.</span><span class="n">tv_nsec</span>
	<span class="p">};</span>

	<span class="n">set_normalized_timespec</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="o">-</span><span class="n">boottime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="o">-</span><span class="n">boottime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">getboottime</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * get_monotonic_boottime - Returns monotonic time since boot</span>
<span class="cm"> * @ts:		pointer to the timespec to be set</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the monotonic time since boot in a timespec.</span>
<span class="cm"> *</span>
<span class="cm"> * This is similar to CLOCK_MONTONIC/ktime_get_ts, but also</span>
<span class="cm"> * includes the time spent in suspend.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">get_monotonic_boottime</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">tomono</span><span class="p">,</span> <span class="n">sleep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">nsecs</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">timekeeping_suspended</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">;</span>
		<span class="n">tomono</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span><span class="p">;</span>
		<span class="n">sleep</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">total_sleep_time</span><span class="p">;</span>
		<span class="n">nsecs</span> <span class="o">=</span> <span class="n">timekeeping_get_ns</span><span class="p">();</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>

	<span class="n">set_normalized_timespec</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="n">tomono</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="n">sleep</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
			<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">+</span> <span class="n">tomono</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">+</span> <span class="n">sleep</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">+</span> <span class="n">nsecs</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">get_monotonic_boottime</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ktime_get_boottime - Returns monotonic time since boot in a ktime</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the monotonic time since boot in a ktime</span>
<span class="cm"> *</span>
<span class="cm"> * This is similar to CLOCK_MONTONIC/ktime_get, but also</span>
<span class="cm"> * includes the time spent in suspend.</span>
<span class="cm"> */</span>
<span class="n">ktime_t</span> <span class="nf">ktime_get_boottime</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>

	<span class="n">get_monotonic_boottime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">timespec_to_ktime</span><span class="p">(</span><span class="n">ts</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ktime_get_boottime</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * monotonic_to_bootbased - Convert the monotonic time to boot based.</span>
<span class="cm"> * @ts:		pointer to the timespec to be converted</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">monotonic_to_bootbased</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="n">timespec_add</span><span class="p">(</span><span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">total_sleep_time</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">monotonic_to_bootbased</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_seconds</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_seconds</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">timespec</span> <span class="nf">__current_kernel_time</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">timespec</span> <span class="nf">current_kernel_time</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seq</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">now</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">now</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">current_kernel_time</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">timespec</span> <span class="nf">get_monotonic_coarse</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">,</span> <span class="n">mono</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seq</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">now</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">;</span>
		<span class="n">mono</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>

	<span class="n">set_normalized_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">,</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="n">mono</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
				<span class="n">now</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">+</span> <span class="n">mono</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">now</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The 64-bit jiffies value is not atomic - you MUST NOT read it</span>
<span class="cm"> * without sampling the sequence number in xtime_lock.</span>
<span class="cm"> * jiffies is defined in the linker script...</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">do_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ticks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">jiffies_64</span> <span class="o">+=</span> <span class="n">ticks</span><span class="p">;</span>
	<span class="n">update_wall_time</span><span class="p">();</span>
	<span class="n">calc_global_load</span><span class="p">(</span><span class="n">ticks</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_xtime_and_monotonic_and_sleep_offset() - get xtime, wall_to_monotonic,</span>
<span class="cm"> *    and sleep offsets.</span>
<span class="cm"> * @xtim:	pointer to timespec to be set with xtime</span>
<span class="cm"> * @wtom:	pointer to timespec to be set with wall_to_monotonic</span>
<span class="cm"> * @sleep:	pointer to timespec to be set with time in suspend</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">get_xtime_and_monotonic_and_sleep_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">xtim</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">wtom</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">sleep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seq</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="o">*</span><span class="n">xtim</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">xtime</span><span class="p">;</span>
		<span class="o">*</span><span class="n">wtom</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span><span class="p">;</span>
		<span class="o">*</span><span class="n">sleep</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">total_sleep_time</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ktime_get_monotonic_offset() - get wall_to_monotonic in ktime_t format</span>
<span class="cm"> */</span>
<span class="n">ktime_t</span> <span class="nf">ktime_get_monotonic_offset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">wtom</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">wtom</span> <span class="o">=</span> <span class="n">timekeeper</span><span class="p">.</span><span class="n">wall_to_monotonic</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timekeeper</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">timespec_to_ktime</span><span class="p">(</span><span class="n">wtom</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ktime_get_monotonic_offset</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * xtime_update() - advances the timekeeping infrastructure</span>
<span class="cm"> * @ticks:	number of ticks, that have elapsed since the last call.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with interrupts disabled.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xtime_update</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ticks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_seqlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xtime_lock</span><span class="p">);</span>
	<span class="n">do_timer</span><span class="p">(</span><span class="n">ticks</span><span class="p">);</span>
	<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xtime_lock</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
