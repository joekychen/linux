<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › time › tick-sched.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tick-sched.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/kernel/time/tick-sched.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright(C) 2005-2006, Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="cm"> *  Copyright(C) 2005-2007, Red Hat, Inc., Ingo Molnar</span>
<span class="cm"> *  Copyright(C) 2006-2007  Timesys Corp., Thomas Gleixner</span>
<span class="cm"> *</span>
<span class="cm"> *  No idle tick implementation for low and high resolution timers</span>
<span class="cm"> *</span>
<span class="cm"> *  Started by: Thomas Gleixner and Ingo Molnar</span>
<span class="cm"> *</span>
<span class="cm"> *  Distribute under GPLv2.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/hrtimer.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/profile.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;asm/irq_regs.h&gt;</span>

<span class="cp">#include &quot;tick-internal.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Per cpu nohz control structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">tick_sched</span><span class="p">,</span> <span class="n">tick_cpu_sched</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The time, when the last jiffy update happened. Protected by xtime_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ktime_t</span> <span class="n">last_jiffies_update</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="nf">tick_get_tick_sched</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Must be called with interrupts disabled !</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tick_do_update_jiffies64</span><span class="p">(</span><span class="n">ktime_t</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ticks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">delta</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do a quick check without holding xtime_lock:</span>
<span class="cm">	 */</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">last_jiffies_update</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&lt;</span> <span class="n">tick_period</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Reevalute with xtime_lock held */</span>
	<span class="n">write_seqlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xtime_lock</span><span class="p">);</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">last_jiffies_update</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&gt;=</span> <span class="n">tick_period</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">delta</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">tick_period</span><span class="p">);</span>
		<span class="n">last_jiffies_update</span> <span class="o">=</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">last_jiffies_update</span><span class="p">,</span>
						<span class="n">tick_period</span><span class="p">);</span>

		<span class="cm">/* Slow path for long timeouts */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">delta</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&gt;=</span> <span class="n">tick_period</span><span class="p">.</span><span class="n">tv64</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">s64</span> <span class="n">incr</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">tick_period</span><span class="p">);</span>

			<span class="n">ticks</span> <span class="o">=</span> <span class="n">ktime_divns</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">incr</span><span class="p">);</span>

			<span class="n">last_jiffies_update</span> <span class="o">=</span> <span class="n">ktime_add_ns</span><span class="p">(</span><span class="n">last_jiffies_update</span><span class="p">,</span>
							   <span class="n">incr</span> <span class="o">*</span> <span class="n">ticks</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">do_timer</span><span class="p">(</span><span class="o">++</span><span class="n">ticks</span><span class="p">);</span>

		<span class="cm">/* Keep the tick_next_period variable up to date */</span>
		<span class="n">tick_next_period</span> <span class="o">=</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">last_jiffies_update</span><span class="p">,</span> <span class="n">tick_period</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xtime_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize and return retrieve the jiffies update.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ktime_t</span> <span class="nf">tick_init_jiffy_update</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span> <span class="n">period</span><span class="p">;</span>

	<span class="n">write_seqlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xtime_lock</span><span class="p">);</span>
	<span class="cm">/* Did we start the jiffies update yet ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_jiffies_update</span><span class="p">.</span><span class="n">tv64</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">last_jiffies_update</span> <span class="o">=</span> <span class="n">tick_next_period</span><span class="p">;</span>
	<span class="n">period</span> <span class="o">=</span> <span class="n">last_jiffies_update</span><span class="p">;</span>
	<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xtime_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">period</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NOHZ - aka dynamic tick functionality</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_NO_HZ</span>
<span class="cm">/*</span>
<span class="cm"> * NO HZ enabled ?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">tick_nohz_enabled</span> <span class="n">__read_mostly</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Enable / Disable tickless mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_tick_nohz</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">))</span>
		<span class="n">tick_nohz_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">))</span>
		<span class="n">tick_nohz_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;nohz=&quot;</span><span class="p">,</span> <span class="n">setup_tick_nohz</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tick_nohz_update_jiffies - update jiffies when idle was interrupted</span>
<span class="cm"> *</span>
<span class="cm"> * Called from interrupt entry when the CPU was idle</span>
<span class="cm"> *</span>
<span class="cm"> * In case the sched_tick was stopped on this CPU, we have to check if jiffies</span>
<span class="cm"> * must be updated. Otherwise an interrupt handler could use a stale jiffy</span>
<span class="cm"> * value. We do this unconditionally on any cpu, as we don&#39;t know whether the</span>
<span class="cm"> * cpu, which has the update task assigned is in a long sleep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tick_nohz_update_jiffies</span><span class="p">(</span><span class="n">ktime_t</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_waketime</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">tick_do_update_jiffies64</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">touch_softlockup_watchdog</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Updates the per cpu time idle statistics counters</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">update_ts_time_stats</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">now</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">last_update_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span> <span class="n">delta</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_entrytime</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_iowait_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ts</span><span class="o">-&gt;</span><span class="n">iowait_sleeptime</span> <span class="o">=</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">iowait_sleeptime</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_sleeptime</span> <span class="o">=</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_sleeptime</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
		<span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_entrytime</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_update_time</span><span class="p">)</span>
		<span class="o">*</span><span class="n">last_update_time</span> <span class="o">=</span> <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tick_nohz_stop_idle</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">update_ts_time_stats</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sched_clock_idle_wakeup_event</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ktime_t</span> <span class="nf">tick_nohz_start_idle</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>

	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_entrytime</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sched_clock_idle_sleep_event</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">now</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_cpu_idle_time_us - get the total idle time of a cpu</span>
<span class="cm"> * @cpu: CPU number to query</span>
<span class="cm"> * @last_update_time: variable to store update time in. Do not update</span>
<span class="cm"> * counters if NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the cummulative idle time (since boot) for a given</span>
<span class="cm"> * CPU, in microseconds.</span>
<span class="cm"> *</span>
<span class="cm"> * This time is measured via accounting rather than sampling,</span>
<span class="cm"> * and is as accurate as ktime_get() is.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if NOHZ is not enabled.</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">get_cpu_idle_time_us</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">last_update_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">ktime_t</span> <span class="n">now</span><span class="p">,</span> <span class="n">idle</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tick_nohz_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_update_time</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">update_ts_time_stats</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">last_update_time</span><span class="p">);</span>
		<span class="n">idle</span> <span class="o">=</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_sleeptime</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_active</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nr_iowait_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ktime_t</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_entrytime</span><span class="p">);</span>

			<span class="n">idle</span> <span class="o">=</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_sleeptime</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">idle</span> <span class="o">=</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_sleeptime</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">idle</span><span class="p">);</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">get_cpu_idle_time_us</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * get_cpu_iowait_time_us - get the total iowait time of a cpu</span>
<span class="cm"> * @cpu: CPU number to query</span>
<span class="cm"> * @last_update_time: variable to store update time in. Do not update</span>
<span class="cm"> * counters if NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the cummulative iowait time (since boot) for a given</span>
<span class="cm"> * CPU, in microseconds.</span>
<span class="cm"> *</span>
<span class="cm"> * This time is measured via accounting rather than sampling,</span>
<span class="cm"> * and is as accurate as ktime_get() is.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if NOHZ is not enabled.</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">get_cpu_iowait_time_us</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">last_update_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">ktime_t</span> <span class="n">now</span><span class="p">,</span> <span class="n">iowait</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tick_nohz_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_update_time</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">update_ts_time_stats</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">last_update_time</span><span class="p">);</span>
		<span class="n">iowait</span> <span class="o">=</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">iowait_sleeptime</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_active</span> <span class="o">&amp;&amp;</span> <span class="n">nr_iowait_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ktime_t</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_entrytime</span><span class="p">);</span>

			<span class="n">iowait</span> <span class="o">=</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">iowait_sleeptime</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">iowait</span> <span class="o">=</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">iowait_sleeptime</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">iowait</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">get_cpu_iowait_time_us</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tick_nohz_stop_sched_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seq</span><span class="p">,</span> <span class="n">last_jiffies</span><span class="p">,</span> <span class="n">next_jiffies</span><span class="p">,</span> <span class="n">delta_jiffies</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rcu_delta_jiffies</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">last_update</span><span class="p">,</span> <span class="n">expires</span><span class="p">,</span> <span class="n">now</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tick_cpu_device</span><span class="p">).</span><span class="n">evtdev</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">time_delta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">tick_nohz_start_idle</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">ts</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this cpu is offline and it is the one which updates</span>
<span class="cm">	 * jiffies, then give up the assignment and let it be taken by</span>
<span class="cm">	 * the cpu which runs the tick timer next. If we don&#39;t drop</span>
<span class="cm">	 * this here the jiffies might be stale and do_timer() never</span>
<span class="cm">	 * invoked.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">tick_do_timer_cpu</span><span class="p">)</span>
			<span class="n">tick_do_timer_cpu</span> <span class="o">=</span> <span class="n">TICK_DO_TIMER_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">nohz_mode</span> <span class="o">==</span> <span class="n">NOHZ_MODE_INACTIVE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">local_softirq_pending</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">static</span> <span class="kt">int</span> <span class="n">ratelimit</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ratelimit</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NOHZ: local_softirq_pending %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">local_softirq_pending</span><span class="p">());</span>
			<span class="n">ratelimit</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_calls</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* Read jiffies and the time when jiffies were updated last */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xtime_lock</span><span class="p">);</span>
		<span class="n">last_update</span> <span class="o">=</span> <span class="n">last_jiffies_update</span><span class="p">;</span>
		<span class="n">last_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">time_delta</span> <span class="o">=</span> <span class="n">timekeeping_max_deferment</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xtime_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_needs_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcu_delta_jiffies</span><span class="p">)</span> <span class="o">||</span> <span class="n">printk_needs_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">arch_needs_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">next_jiffies</span> <span class="o">=</span> <span class="n">last_jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">delta_jiffies</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Get the next timer wheel timer */</span>
		<span class="n">next_jiffies</span> <span class="o">=</span> <span class="n">get_next_timer_interrupt</span><span class="p">(</span><span class="n">last_jiffies</span><span class="p">);</span>
		<span class="n">delta_jiffies</span> <span class="o">=</span> <span class="n">next_jiffies</span> <span class="o">-</span> <span class="n">last_jiffies</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcu_delta_jiffies</span> <span class="o">&lt;</span> <span class="n">delta_jiffies</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">next_jiffies</span> <span class="o">=</span> <span class="n">last_jiffies</span> <span class="o">+</span> <span class="n">rcu_delta_jiffies</span><span class="p">;</span>
			<span class="n">delta_jiffies</span> <span class="o">=</span> <span class="n">rcu_delta_jiffies</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Do not stop the tick, if we are only one off</span>
<span class="cm">	 * or if the cpu is required for rcu</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">tick_stopped</span> <span class="o">&amp;&amp;</span> <span class="n">delta_jiffies</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Schedule the tick, if we are at least one jiffie off */</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">delta_jiffies</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * If this cpu is the one which updates jiffies, then</span>
<span class="cm">		 * give up the assignment and let it be taken by the</span>
<span class="cm">		 * cpu which runs the tick timer next, which might be</span>
<span class="cm">		 * this cpu as well. If we don&#39;t drop this here the</span>
<span class="cm">		 * jiffies might be stale and do_timer() never</span>
<span class="cm">		 * invoked. Keep track of the fact that it was the one</span>
<span class="cm">		 * which had the do_timer() duty last. If this cpu is</span>
<span class="cm">		 * the one which had the do_timer() duty last, we</span>
<span class="cm">		 * limit the sleep time to the timekeeping</span>
<span class="cm">		 * max_deferement value which we retrieved</span>
<span class="cm">		 * above. Otherwise we can sleep as long as we want.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">tick_do_timer_cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tick_do_timer_cpu</span> <span class="o">=</span> <span class="n">TICK_DO_TIMER_NONE</span><span class="p">;</span>
			<span class="n">ts</span><span class="o">-&gt;</span><span class="n">do_timer_last</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tick_do_timer_cpu</span> <span class="o">!=</span> <span class="n">TICK_DO_TIMER_NONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">time_delta</span> <span class="o">=</span> <span class="n">KTIME_MAX</span><span class="p">;</span>
			<span class="n">ts</span><span class="o">-&gt;</span><span class="n">do_timer_last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">do_timer_last</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">time_delta</span> <span class="o">=</span> <span class="n">KTIME_MAX</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * calculate the expiry time for the next timer wheel</span>
<span class="cm">		 * timer. delta_jiffies &gt;= NEXT_TIMER_MAX_DELTA signals</span>
<span class="cm">		 * that there is no timer pending or at least extremely</span>
<span class="cm">		 * far into the future (12 days for HZ=1000). In this</span>
<span class="cm">		 * case we set the expiry to the end of time.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">delta_jiffies</span> <span class="o">&lt;</span> <span class="n">NEXT_TIMER_MAX_DELTA</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Calculate the time delta for the next timer event.</span>
<span class="cm">			 * If the time delta exceeds the maximum time delta</span>
<span class="cm">			 * permitted by the current clocksource then adjust</span>
<span class="cm">			 * the time delta accordingly to ensure the</span>
<span class="cm">			 * clocksource does not wrap.</span>
<span class="cm">			 */</span>
			<span class="n">time_delta</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">time_delta</span><span class="p">,</span>
					   <span class="n">tick_period</span><span class="p">.</span><span class="n">tv64</span> <span class="o">*</span> <span class="n">delta_jiffies</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_delta</span> <span class="o">&lt;</span> <span class="n">KTIME_MAX</span><span class="p">)</span>
			<span class="n">expires</span> <span class="o">=</span> <span class="n">ktime_add_ns</span><span class="p">(</span><span class="n">last_update</span><span class="p">,</span> <span class="n">time_delta</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">expires</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">KTIME_MAX</span><span class="p">;</span>

		<span class="cm">/* Skip reprogram of event if its not changed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">tick_stopped</span> <span class="o">&amp;&amp;</span> <span class="n">ktime_equal</span><span class="p">(</span><span class="n">expires</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">next_event</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * nohz_stop_sched_tick can be called several times before</span>
<span class="cm">		 * the nohz_restart_sched_tick is called. This happens when</span>
<span class="cm">		 * interrupts arrive which do not cause a reschedule. In the</span>
<span class="cm">		 * first call we save the current tick time, so we can restart</span>
<span class="cm">		 * the scheduler tick in nohz_restart_sched_tick.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">tick_stopped</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">select_nohz_load_balancer</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

			<span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_tick</span> <span class="o">=</span> <span class="n">hrtimer_get_expires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">);</span>
			<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tick_stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_jiffies</span> <span class="o">=</span> <span class="n">last_jiffies</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_sleeps</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Mark expires */</span>
		<span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_expires</span> <span class="o">=</span> <span class="n">expires</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the expiration time == KTIME_MAX, then</span>
<span class="cm">		 * in this case we simply stop the tick timer.</span>
<span class="cm">		 */</span>
		 <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">expires</span><span class="p">.</span><span class="n">tv64</span> <span class="o">==</span> <span class="n">KTIME_MAX</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">nohz_mode</span> <span class="o">==</span> <span class="n">NOHZ_MODE_HIGHRES</span><span class="p">)</span>
				<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">nohz_mode</span> <span class="o">==</span> <span class="n">NOHZ_MODE_HIGHRES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hrtimer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">,</span> <span class="n">expires</span><span class="p">,</span>
				      <span class="n">HRTIMER_MODE_ABS_PINNED</span><span class="p">);</span>
			<span class="cm">/* Check, if the timer was already in the past */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hrtimer_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tick_program_event</span><span class="p">(</span><span class="n">expires</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are past the event already. So we crossed a</span>
<span class="cm">		 * jiffie boundary. Update jiffies and raise the</span>
<span class="cm">		 * softirq.</span>
<span class="cm">		 */</span>
		<span class="n">tick_do_update_jiffies64</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">raise_softirq_irqoff</span><span class="p">(</span><span class="n">TIMER_SOFTIRQ</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">next_jiffies</span> <span class="o">=</span> <span class="n">next_jiffies</span><span class="p">;</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">last_jiffies</span> <span class="o">=</span> <span class="n">last_jiffies</span><span class="p">;</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">sleep_length</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">next_event</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tick_nohz_idle_enter - stop the idle tick from the idle task</span>
<span class="cm"> *</span>
<span class="cm"> * When the next event is more than a tick into the future, stop the idle tick</span>
<span class="cm"> * Called when we start the idle loop.</span>
<span class="cm"> *</span>
<span class="cm"> * The arch is responsible of calling:</span>
<span class="cm"> *</span>
<span class="cm"> * - rcu_idle_enter() after its last use of RCU before the CPU is put</span>
<span class="cm"> *  to sleep.</span>
<span class="cm"> * - rcu_idle_exit() before the first use of RCU after the CPU is woken up.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tick_nohz_idle_enter</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="cm">/*</span>
<span class="cm"> 	 * Update the idle state in the scheduler domain hierarchy</span>
<span class="cm"> 	 * when tick_nohz_stop_sched_tick() is called from the idle loop.</span>
<span class="cm"> 	 * State will be updated to busy during the first busy tick after</span>
<span class="cm"> 	 * exiting idle.</span>
<span class="cm"> 	 */</span>
	<span class="n">set_cpu_sd_state_idle</span><span class="p">();</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * set ts-&gt;inidle unconditionally. even if the system did not</span>
<span class="cm">	 * switch to nohz mode the cpu frequency governers rely on the</span>
<span class="cm">	 * update of the idle time accounting in tick_nohz_start_idle().</span>
<span class="cm">	 */</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">inidle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tick_nohz_stop_sched_tick</span><span class="p">(</span><span class="n">ts</span><span class="p">);</span>

	<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tick_nohz_irq_exit - update next tick event from interrupt exit</span>
<span class="cm"> *</span>
<span class="cm"> * When an interrupt fires while we are idle and it doesn&#39;t cause</span>
<span class="cm"> * a reschedule, it may still add, modify or delete a timer, enqueue</span>
<span class="cm"> * an RCU callback, etc...</span>
<span class="cm"> * So we need to re-calculate and reprogram the next tick event.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tick_nohz_irq_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">inidle</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tick_nohz_stop_sched_tick</span><span class="p">(</span><span class="n">ts</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tick_nohz_get_sleep_length - return the length of the current sleep</span>
<span class="cm"> *</span>
<span class="cm"> * Called from power state control code with interrupts disabled</span>
<span class="cm"> */</span>
<span class="n">ktime_t</span> <span class="nf">tick_nohz_get_sleep_length</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">sleep_length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tick_nohz_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">);</span>
	<span class="n">hrtimer_set_expires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">,</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_tick</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Forward the time to expire in the future */</span>
		<span class="n">hrtimer_forward</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">tick_period</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">nohz_mode</span> <span class="o">==</span> <span class="n">NOHZ_MODE_HIGHRES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hrtimer_start_expires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">,</span>
					      <span class="n">HRTIMER_MODE_ABS_PINNED</span><span class="p">);</span>
			<span class="cm">/* Check, if the timer was already in the past */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hrtimer_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tick_program_event</span><span class="p">(</span>
				<span class="n">hrtimer_get_expires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Reread time and update jiffies */</span>
		<span class="n">now</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
		<span class="n">tick_do_update_jiffies64</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tick_nohz_idle_exit - restart the idle tick from the idle task</span>
<span class="cm"> *</span>
<span class="cm"> * Restart the idle tick when the CPU is woken up from idle</span>
<span class="cm"> * This also exit the RCU extended quiescent state. The CPU</span>
<span class="cm"> * can use RCU again after this function is called.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tick_nohz_idle_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_VIRT_CPU_ACCOUNTING</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ticks</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">ktime_t</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">inidle</span><span class="p">);</span>

	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">inidle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_active</span> <span class="o">||</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">tick_stopped</span><span class="p">)</span>
		<span class="n">now</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_active</span><span class="p">)</span>
		<span class="n">tick_nohz_stop_idle</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">tick_stopped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Update jiffies first */</span>
	<span class="n">select_nohz_load_balancer</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">tick_do_update_jiffies64</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
	<span class="n">update_cpu_load_nohz</span><span class="p">();</span>

<span class="cp">#ifndef CONFIG_VIRT_CPU_ACCOUNTING</span>
	<span class="cm">/*</span>
<span class="cm">	 * We stopped the tick in idle. Update process times would miss the</span>
<span class="cm">	 * time we slept as update_process_times does only a 1 tick</span>
<span class="cm">	 * accounting. Enforce that this is accounted to idle !</span>
<span class="cm">	 */</span>
	<span class="n">ticks</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_jiffies</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We might be one off. Do not randomly account a huge number of ticks!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ticks</span> <span class="o">&amp;&amp;</span> <span class="n">ticks</span> <span class="o">&lt;</span> <span class="n">LONG_MAX</span><span class="p">)</span>
		<span class="n">account_idle_ticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">touch_softlockup_watchdog</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Cancel the scheduled timer and restore the tick</span>
<span class="cm">	 */</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">tick_stopped</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_exittime</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">tick_nohz_restart</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>

	<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tick_nohz_reprogram</span><span class="p">(</span><span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hrtimer_forward</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">tick_period</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tick_program_event</span><span class="p">(</span><span class="n">hrtimer_get_expires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The nohz low res interrupt handler</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tick_nohz_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">get_irq_regs</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">ktime_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">next_event</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">KTIME_MAX</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the do_timer duty was dropped. We don&#39;t care about</span>
<span class="cm">	 * concurrency: This happens only when the cpu in charge went</span>
<span class="cm">	 * into a long sleep. If two cpus happen to assign themself to</span>
<span class="cm">	 * this duty, then the jiffies update is still serialized by</span>
<span class="cm">	 * xtime_lock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tick_do_timer_cpu</span> <span class="o">==</span> <span class="n">TICK_DO_TIMER_NONE</span><span class="p">))</span>
		<span class="n">tick_do_timer_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* Check, if the jiffies need an update */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tick_do_timer_cpu</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span>
		<span class="n">tick_do_update_jiffies64</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * When we are idle and the tick is stopped, we have to touch</span>
<span class="cm">	 * the watchdog as we might not schedule for a really long</span>
<span class="cm">	 * time. This happens on complete idle SMP systems while</span>
<span class="cm">	 * waiting on the login prompt. We also increment the &quot;start</span>
<span class="cm">	 * of idle&quot; jiffy stamp so the idle accounting adjustment we</span>
<span class="cm">	 * do when we go busy again does not account too much ticks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">tick_stopped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">touch_softlockup_watchdog</span><span class="p">();</span>
		<span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_jiffies</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">update_process_times</span><span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>
	<span class="n">profile_tick</span><span class="p">(</span><span class="n">CPU_PROFILING</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">tick_nohz_reprogram</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">now</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">now</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
		<span class="n">tick_do_update_jiffies64</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tick_nohz_switch_to_nohz - switch to nohz mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tick_nohz_switch_to_nohz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">);</span>
	<span class="n">ktime_t</span> <span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tick_nohz_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tick_switch_to_oneshot</span><span class="p">(</span><span class="n">tick_nohz_handler</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">nohz_mode</span> <span class="o">=</span> <span class="n">NOHZ_MODE_LOWRES</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Recycle the hrtimer in ts, so we can share the</span>
<span class="cm">	 * hrtimer_forward with the highres code.</span>
<span class="cm">	 */</span>
	<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
	<span class="cm">/* Get the next period */</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">tick_init_jiffy_update</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">hrtimer_set_expires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tick_program_event</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">ktime_add</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">tick_period</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When NOHZ is enabled and the tick is stopped, we need to kick the</span>
<span class="cm"> * tick timer from irq_enter() so that the jiffies update is kept</span>
<span class="cm"> * alive during long running softirqs. That&#39;s ugly as hell, but</span>
<span class="cm"> * correctness is key even if we need to fix the offending softirq in</span>
<span class="cm"> * the first place.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, this is different to tick_nohz_restart. We just kick the</span>
<span class="cm"> * timer and do not touch the other magic bits which need to be done</span>
<span class="cm"> * when idle is left.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tick_nohz_kick_tick</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* Switch back to 2.6.27 behaviour */</span>

<span class="c">	struct tick_sched *ts = &amp;per_cpu(tick_cpu_sched, cpu);</span>
<span class="c">	ktime_t delta;</span>

<span class="c">	/*</span>
<span class="c">	 * Do not touch the tick device, when the next expiry is either</span>
<span class="c">	 * already reached or less/equal than the tick period.</span>
<span class="c">	 */</span>
<span class="c">	delta =	ktime_sub(hrtimer_get_expires(&amp;ts-&gt;sched_timer), now);</span>
<span class="c">	if (delta.tv64 &lt;= tick_period.tv64)</span>
<span class="c">		return;</span>

<span class="c">	tick_nohz_restart(ts, now);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tick_check_nohz</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">ktime_t</span> <span class="n">now</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_active</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">tick_stopped</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">now</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_active</span><span class="p">)</span>
		<span class="n">tick_nohz_stop_idle</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">tick_stopped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tick_nohz_update_jiffies</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
		<span class="n">tick_nohz_kick_tick</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tick_nohz_switch_to_nohz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tick_check_nohz</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* NO_HZ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Called from irq_enter to notify about the possible interruption of idle()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tick_check_idle</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tick_check_oneshot_broadcast</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">tick_check_nohz</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * High resolution timer specific code</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_HIGH_RES_TIMERS</span>
<span class="cm">/*</span>
<span class="cm"> * We rearm the timer until we get disabled by the idle code.</span>
<span class="cm"> * Called with interrupts disabled and timer-&gt;base-&gt;cpu_base-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">tick_sched_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tick_sched</span><span class="p">,</span> <span class="n">sched_timer</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">get_irq_regs</span><span class="p">();</span>
	<span class="n">ktime_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_NO_HZ</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check if the do_timer duty was dropped. We don&#39;t care about</span>
<span class="cm">	 * concurrency: This happens only when the cpu in charge went</span>
<span class="cm">	 * into a long sleep. If two cpus happen to assign themself to</span>
<span class="cm">	 * this duty, then the jiffies update is still serialized by</span>
<span class="cm">	 * xtime_lock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tick_do_timer_cpu</span> <span class="o">==</span> <span class="n">TICK_DO_TIMER_NONE</span><span class="p">))</span>
		<span class="n">tick_do_timer_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Check, if the jiffies need an update */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tick_do_timer_cpu</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span>
		<span class="n">tick_do_update_jiffies64</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do not call, when we are not in irq context and have</span>
<span class="cm">	 * no valid regs pointer</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * When we are idle and the tick is stopped, we have to touch</span>
<span class="cm">		 * the watchdog as we might not schedule for a really long</span>
<span class="cm">		 * time. This happens on complete idle SMP systems while</span>
<span class="cm">		 * waiting on the login prompt. We also increment the &quot;start of</span>
<span class="cm">		 * idle&quot; jiffy stamp so the idle accounting adjustment we do</span>
<span class="cm">		 * when we go busy again does not account too much ticks.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">tick_stopped</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">touch_softlockup_watchdog</span><span class="p">();</span>
			<span class="n">ts</span><span class="o">-&gt;</span><span class="n">idle_jiffies</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">update_process_times</span><span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>
		<span class="n">profile_tick</span><span class="p">(</span><span class="n">CPU_PROFILING</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hrtimer_forward</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">tick_period</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">HRTIMER_RESTART</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sched_skew_tick</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">skew_tick</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sched_skew_tick</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;skew_tick&quot;</span><span class="p">,</span> <span class="n">skew_tick</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tick_setup_sched_timer - setup the tick emulation timer</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tick_setup_sched_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">);</span>
	<span class="n">ktime_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Emulate tick processing via per-CPU hrtimers:</span>
<span class="cm">	 */</span>
	<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">tick_sched_timer</span><span class="p">;</span>

	<span class="cm">/* Get the next period (per cpu) */</span>
	<span class="n">hrtimer_set_expires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">,</span> <span class="n">tick_init_jiffy_update</span><span class="p">());</span>

	<span class="cm">/* Offset the tick to avert xtime_lock contention. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sched_skew_tick</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">tick_period</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">num_possible_cpus</span><span class="p">());</span>
		<span class="n">offset</span> <span class="o">*=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
		<span class="n">hrtimer_add_expires_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">hrtimer_forward</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">tick_period</span><span class="p">);</span>
		<span class="n">hrtimer_start_expires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">,</span>
				      <span class="n">HRTIMER_MODE_ABS_PINNED</span><span class="p">);</span>
		<span class="cm">/* Check, if the timer was already in the past */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hrtimer_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">now</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NO_HZ</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tick_nohz_enabled</span><span class="p">)</span>
		<span class="n">ts</span><span class="o">-&gt;</span><span class="n">nohz_mode</span> <span class="o">=</span> <span class="n">NOHZ_MODE_HIGHRES</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* HIGH_RES_TIMERS */</span><span class="cp"></span>

<span class="cp">#if defined CONFIG_NO_HZ || defined CONFIG_HIGH_RES_TIMERS</span>
<span class="kt">void</span> <span class="nf">tick_cancel_sched_timer</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

<span class="cp"># ifdef CONFIG_HIGH_RES_TIMERS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">.</span><span class="n">base</span><span class="p">)</span>
		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">sched_timer</span><span class="p">);</span>
<span class="cp"># endif</span>

	<span class="n">ts</span><span class="o">-&gt;</span><span class="n">nohz_mode</span> <span class="o">=</span> <span class="n">NOHZ_MODE_INACTIVE</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * Async notification about clocksource changes</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tick_clock_notify</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">check_clocks</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Async notification about clock event changes</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tick_oneshot_notify</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">check_clocks</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Check, if a change happened, which makes oneshot possible.</span>
<span class="cm"> *</span>
<span class="cm"> * Called cyclic from the hrtimer softirq (driven by the timer</span>
<span class="cm"> * softirq) allow_nohz signals, that we can switch into low-res nohz</span>
<span class="cm"> * mode, because high resolution timers are disabled (either compile</span>
<span class="cm"> * or runtime).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tick_check_oneshot_change</span><span class="p">(</span><span class="kt">int</span> <span class="n">allow_nohz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tick_sched</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tick_cpu_sched</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">check_clocks</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">nohz_mode</span> <span class="o">!=</span> <span class="n">NOHZ_MODE_INACTIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timekeeping_valid_for_hres</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">tick_is_oneshot_available</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allow_nohz</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">tick_nohz_switch_to_nohz</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
