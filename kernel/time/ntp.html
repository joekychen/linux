<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › time › ntp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ntp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * NTP state machine interfaces and logic.</span>
<span class="cm"> *</span>
<span class="cm"> * This code was mainly moved from kernel/timer.c and kernel/time.c</span>
<span class="cm"> * Please see those files for relevant copyright info and historical</span>
<span class="cm"> * changelogs.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/clocksource.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/hrtimer.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/math64.h&gt;</span>
<span class="cp">#include &lt;linux/timex.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &quot;tick-internal.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * NTP timekeeping variables:</span>
<span class="cm"> */</span>

<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">ntp_lock</span><span class="p">);</span>


<span class="cm">/* USER_HZ period (usecs): */</span>
<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">tick_usec</span> <span class="o">=</span> <span class="n">TICK_USEC</span><span class="p">;</span>

<span class="cm">/* ACTHZ period (nsecs): */</span>
<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">tick_nsec</span><span class="p">;</span>

<span class="k">static</span> <span class="n">u64</span>			<span class="n">tick_length</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u64</span>			<span class="n">tick_length_base</span><span class="p">;</span>

<span class="cp">#define MAX_TICKADJ		500LL		</span><span class="cm">/* usecs */</span><span class="cp"></span>
<span class="cp">#define MAX_TICKADJ_SCALED \</span>
<span class="cp">	(((MAX_TICKADJ * NSEC_PER_USEC) &lt;&lt; NTP_SCALE_SHIFT) / NTP_INTERVAL_FREQ)</span>

<span class="cm">/*</span>
<span class="cm"> * phase-lock loop variables</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * clock synchronization status</span>
<span class="cm"> *</span>
<span class="cm"> * (TIME_ERROR prevents overwriting the CMOS clock)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">time_state</span> <span class="o">=</span> <span class="n">TIME_OK</span><span class="p">;</span>

<span class="cm">/* clock status bits:							*/</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">time_status</span> <span class="o">=</span> <span class="n">STA_UNSYNC</span><span class="p">;</span>

<span class="cm">/* TAI offset (secs):							*/</span>
<span class="k">static</span> <span class="kt">long</span>			<span class="n">time_tai</span><span class="p">;</span>

<span class="cm">/* time adjustment (nsecs):						*/</span>
<span class="k">static</span> <span class="n">s64</span>			<span class="n">time_offset</span><span class="p">;</span>

<span class="cm">/* pll time constant:							*/</span>
<span class="k">static</span> <span class="kt">long</span>			<span class="n">time_constant</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="cm">/* maximum error (usecs):						*/</span>
<span class="k">static</span> <span class="kt">long</span>			<span class="n">time_maxerror</span> <span class="o">=</span> <span class="n">NTP_PHASE_LIMIT</span><span class="p">;</span>

<span class="cm">/* estimated error (usecs):						*/</span>
<span class="k">static</span> <span class="kt">long</span>			<span class="n">time_esterror</span> <span class="o">=</span> <span class="n">NTP_PHASE_LIMIT</span><span class="p">;</span>

<span class="cm">/* frequency offset (scaled nsecs/secs):				*/</span>
<span class="k">static</span> <span class="n">s64</span>			<span class="n">time_freq</span><span class="p">;</span>

<span class="cm">/* time at last adjustment (secs):					*/</span>
<span class="k">static</span> <span class="kt">long</span>			<span class="n">time_reftime</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">long</span>			<span class="n">time_adjust</span><span class="p">;</span>

<span class="cm">/* constant (boot-param configurable) NTP tick adjustment (upscaled)	*/</span>
<span class="k">static</span> <span class="n">s64</span>			<span class="n">ntp_tick_adj</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NTP_PPS</span>

<span class="cm">/*</span>
<span class="cm"> * The following variables are used when a pulse-per-second (PPS) signal</span>
<span class="cm"> * is available. They establish the engineering parameters of the clock</span>
<span class="cm"> * discipline loop when controlled by the PPS signal.</span>
<span class="cm"> */</span>
<span class="cp">#define PPS_VALID	10	</span><span class="cm">/* PPS signal watchdog max (s) */</span><span class="cp"></span>
<span class="cp">#define PPS_POPCORN	4	</span><span class="cm">/* popcorn spike threshold (shift) */</span><span class="cp"></span>
<span class="cp">#define PPS_INTMIN	2	</span><span class="cm">/* min freq interval (s) (shift) */</span><span class="cp"></span>
<span class="cp">#define PPS_INTMAX	8	</span><span class="cm">/* max freq interval (s) (shift) */</span><span class="cp"></span>
<span class="cp">#define PPS_INTCOUNT	4	</span><span class="cm">/* number of consecutive good intervals to</span>
<span class="cm">				   increase pps_shift or consecutive bad</span>
<span class="cm">				   intervals to decrease it */</span><span class="cp"></span>
<span class="cp">#define PPS_MAXWANDER	100000	</span><span class="cm">/* max PPS freq wander (ns/s) */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pps_valid</span><span class="p">;</span>		<span class="cm">/* signal watchdog counter */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">pps_tf</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* phase median filter */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">pps_jitter</span><span class="p">;</span>		<span class="cm">/* current jitter (ns) */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">pps_fbase</span><span class="p">;</span> <span class="cm">/* beginning of the last freq interval */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pps_shift</span><span class="p">;</span>		<span class="cm">/* current interval duration (s) (shift) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pps_intcnt</span><span class="p">;</span>		<span class="cm">/* interval counter */</span>
<span class="k">static</span> <span class="n">s64</span> <span class="n">pps_freq</span><span class="p">;</span>		<span class="cm">/* frequency offset (scaled ns/s) */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">pps_stabil</span><span class="p">;</span>		<span class="cm">/* current stability (scaled ns/s) */</span>

<span class="cm">/*</span>
<span class="cm"> * PPS signal quality monitors</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">pps_calcnt</span><span class="p">;</span>		<span class="cm">/* calibration intervals */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">pps_jitcnt</span><span class="p">;</span>		<span class="cm">/* jitter limit exceeded */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">pps_stbcnt</span><span class="p">;</span>		<span class="cm">/* stability limit exceeded */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">pps_errcnt</span><span class="p">;</span>		<span class="cm">/* calibration errors */</span>


<span class="cm">/* PPS kernel consumer compensates the whole phase error immediately.</span>
<span class="cm"> * Otherwise, reduce the offset by a fixed factor times the time constant.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">ntp_offset_chunk</span><span class="p">(</span><span class="n">s64</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_PPSTIME</span> <span class="o">&amp;&amp;</span> <span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_PPSSIGNAL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">shift_right</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">SHIFT_PLL</span> <span class="o">+</span> <span class="n">time_constant</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pps_reset_freq_interval</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* the PPS calibration interval may end</span>
<span class="cm">	   surprisingly early */</span>
	<span class="n">pps_shift</span> <span class="o">=</span> <span class="n">PPS_INTMIN</span><span class="p">;</span>
	<span class="n">pps_intcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pps_clear - Clears the PPS state variables</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called while holding a write on the ntp_lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pps_clear</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pps_reset_freq_interval</span><span class="p">();</span>
	<span class="n">pps_tf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pps_tf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pps_tf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pps_fbase</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">pps_fbase</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pps_freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Decrease pps_valid to indicate that another second has passed since</span>
<span class="cm"> * the last PPS signal. When it reaches 0, indicate that PPS signal is</span>
<span class="cm"> * missing.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called while holding a write on the ntp_lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pps_dec_valid</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pps_valid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pps_valid</span><span class="o">--</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">time_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">STA_PPSSIGNAL</span> <span class="o">|</span> <span class="n">STA_PPSJITTER</span> <span class="o">|</span>
				 <span class="n">STA_PPSWANDER</span> <span class="o">|</span> <span class="n">STA_PPSERROR</span><span class="p">);</span>
		<span class="n">pps_clear</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pps_set_freq</span><span class="p">(</span><span class="n">s64</span> <span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pps_freq</span> <span class="o">=</span> <span class="n">freq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_error_status</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">STA_UNSYNC</span><span class="o">|</span><span class="n">STA_CLOCKERR</span><span class="p">))</span>
		<span class="cm">/* PPS signal lost when either PPS time or</span>
<span class="cm">		 * PPS frequency synchronization requested</span>
<span class="cm">		 */</span>
		<span class="o">||</span> <span class="p">((</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">STA_PPSFREQ</span><span class="o">|</span><span class="n">STA_PPSTIME</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_PPSSIGNAL</span><span class="p">))</span>
		<span class="cm">/* PPS jitter exceeded when</span>
<span class="cm">		 * PPS time synchronization requested */</span>
		<span class="o">||</span> <span class="p">((</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">STA_PPSTIME</span><span class="o">|</span><span class="n">STA_PPSJITTER</span><span class="p">))</span>
			<span class="o">==</span> <span class="p">(</span><span class="n">STA_PPSTIME</span><span class="o">|</span><span class="n">STA_PPSJITTER</span><span class="p">))</span>
		<span class="cm">/* PPS wander exceeded or calibration error when</span>
<span class="cm">		 * PPS frequency synchronization requested</span>
<span class="cm">		 */</span>
		<span class="o">||</span> <span class="p">((</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_PPSFREQ</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">STA_PPSWANDER</span><span class="o">|</span><span class="n">STA_PPSERROR</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pps_fill_timex</span><span class="p">(</span><span class="k">struct</span> <span class="n">timex</span> <span class="o">*</span><span class="n">txc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">ppsfreq</span>	   <span class="o">=</span> <span class="n">shift_right</span><span class="p">((</span><span class="n">pps_freq</span> <span class="o">&gt;&gt;</span> <span class="n">PPM_SCALE_INV_SHIFT</span><span class="p">)</span> <span class="o">*</span>
					 <span class="n">PPM_SCALE_INV</span><span class="p">,</span> <span class="n">NTP_SCALE_SHIFT</span><span class="p">);</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">jitter</span>	   <span class="o">=</span> <span class="n">pps_jitter</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_NANO</span><span class="p">))</span>
		<span class="n">txc</span><span class="o">-&gt;</span><span class="n">jitter</span> <span class="o">/=</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">shift</span>	   <span class="o">=</span> <span class="n">pps_shift</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">stabil</span>	   <span class="o">=</span> <span class="n">pps_stabil</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">jitcnt</span>	   <span class="o">=</span> <span class="n">pps_jitcnt</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">calcnt</span>	   <span class="o">=</span> <span class="n">pps_calcnt</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">errcnt</span>	   <span class="o">=</span> <span class="n">pps_errcnt</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">stbcnt</span>	   <span class="o">=</span> <span class="n">pps_stbcnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_NTP_PPS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">ntp_offset_chunk</span><span class="p">(</span><span class="n">s64</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">shift_right</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">SHIFT_PLL</span> <span class="o">+</span> <span class="n">time_constant</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pps_reset_freq_interval</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pps_clear</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pps_dec_valid</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pps_set_freq</span><span class="p">(</span><span class="n">s64</span> <span class="n">freq</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_error_status</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">STA_UNSYNC</span><span class="o">|</span><span class="n">STA_CLOCKERR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pps_fill_timex</span><span class="p">(</span><span class="k">struct</span> <span class="n">timex</span> <span class="o">*</span><span class="n">txc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* PPS is not implemented, so these are zero */</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">ppsfreq</span>	   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">jitter</span>	   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">shift</span>	   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">stabil</span>	   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">jitcnt</span>	   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">calcnt</span>	   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">errcnt</span>	   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">stbcnt</span>	   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_NTP_PPS */</span><span class="cp"></span>


<span class="cm">/**</span>
<span class="cm"> * ntp_synced - Returns 1 if the NTP status is not UNSYNC</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ntp_synced</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_UNSYNC</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NTP methods:</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Update (tick_length, tick_length_base, tick_nsec), based</span>
<span class="cm"> * on (tick_usec, ntp_tick_adj, time_freq):</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ntp_update_frequency</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">second_length</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">new_base</span><span class="p">;</span>

	<span class="n">second_length</span>		 <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="n">tick_usec</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span> <span class="o">*</span> <span class="n">USER_HZ</span><span class="p">)</span>
						<span class="o">&lt;&lt;</span> <span class="n">NTP_SCALE_SHIFT</span><span class="p">;</span>

	<span class="n">second_length</span>		<span class="o">+=</span> <span class="n">ntp_tick_adj</span><span class="p">;</span>
	<span class="n">second_length</span>		<span class="o">+=</span> <span class="n">time_freq</span><span class="p">;</span>

	<span class="n">tick_nsec</span>		 <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">second_length</span><span class="p">,</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">NTP_SCALE_SHIFT</span><span class="p">;</span>
	<span class="n">new_base</span>		 <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">second_length</span><span class="p">,</span> <span class="n">NTP_INTERVAL_FREQ</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t wait for the next second_overflow, apply</span>
<span class="cm">	 * the change to the tick length immediately:</span>
<span class="cm">	 */</span>
	<span class="n">tick_length</span>		<span class="o">+=</span> <span class="n">new_base</span> <span class="o">-</span> <span class="n">tick_length_base</span><span class="p">;</span>
	<span class="n">tick_length_base</span>	 <span class="o">=</span> <span class="n">new_base</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">ntp_update_offset_fll</span><span class="p">(</span><span class="n">s64</span> <span class="n">offset64</span><span class="p">,</span> <span class="kt">long</span> <span class="n">secs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">time_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">STA_MODE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">secs</span> <span class="o">&lt;</span> <span class="n">MINSEC</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_FLL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">secs</span> <span class="o">&lt;=</span> <span class="n">MAXSEC</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">time_status</span> <span class="o">|=</span> <span class="n">STA_MODE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">div64_long</span><span class="p">(</span><span class="n">offset64</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">NTP_SCALE_SHIFT</span> <span class="o">-</span> <span class="n">SHIFT_FLL</span><span class="p">),</span> <span class="n">secs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ntp_update_offset</span><span class="p">(</span><span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">freq_adj</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">offset64</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">secs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_PLL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_NANO</span><span class="p">))</span>
		<span class="n">offset</span> <span class="o">*=</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Scale the phase adjustment and</span>
<span class="cm">	 * clamp to the operating range.</span>
<span class="cm">	 */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">MAXPHASE</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="o">-</span><span class="n">MAXPHASE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Select how the frequency is to be controlled</span>
<span class="cm">	 * and in which mode (PLL or FLL).</span>
<span class="cm">	 */</span>
	<span class="n">secs</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_reftime</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_FREQHOLD</span><span class="p">))</span>
		<span class="n">secs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">time_reftime</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>

	<span class="n">offset64</span>    <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">freq_adj</span>    <span class="o">=</span> <span class="n">ntp_update_offset_fll</span><span class="p">(</span><span class="n">offset64</span><span class="p">,</span> <span class="n">secs</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clamp update interval to reduce PLL gain with low</span>
<span class="cm">	 * sampling rate (e.g. intermittent network connection)</span>
<span class="cm">	 * to avoid instability.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">secs</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">SHIFT_PLL</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">time_constant</span><span class="p">)))</span>
		<span class="n">secs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">SHIFT_PLL</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">time_constant</span><span class="p">);</span>

	<span class="n">freq_adj</span>    <span class="o">+=</span> <span class="p">(</span><span class="n">offset64</span> <span class="o">*</span> <span class="n">secs</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
			<span class="p">(</span><span class="n">NTP_SCALE_SHIFT</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">SHIFT_PLL</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">time_constant</span><span class="p">));</span>

	<span class="n">freq_adj</span>    <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">freq_adj</span> <span class="o">+</span> <span class="n">time_freq</span><span class="p">,</span> <span class="n">MAXFREQ_SCALED</span><span class="p">);</span>

	<span class="n">time_freq</span>   <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">freq_adj</span><span class="p">,</span> <span class="o">-</span><span class="n">MAXFREQ_SCALED</span><span class="p">);</span>

	<span class="n">time_offset</span> <span class="o">=</span> <span class="n">div_s64</span><span class="p">(</span><span class="n">offset64</span> <span class="o">&lt;&lt;</span> <span class="n">NTP_SCALE_SHIFT</span><span class="p">,</span> <span class="n">NTP_INTERVAL_FREQ</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ntp_clear - Clears the NTP state variables</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ntp_clear</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">time_adjust</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* stop active adjtime() */</span>
	<span class="n">time_status</span>	<span class="o">|=</span> <span class="n">STA_UNSYNC</span><span class="p">;</span>
	<span class="n">time_maxerror</span>	<span class="o">=</span> <span class="n">NTP_PHASE_LIMIT</span><span class="p">;</span>
	<span class="n">time_esterror</span>	<span class="o">=</span> <span class="n">NTP_PHASE_LIMIT</span><span class="p">;</span>

	<span class="n">ntp_update_frequency</span><span class="p">();</span>

	<span class="n">tick_length</span>	<span class="o">=</span> <span class="n">tick_length_base</span><span class="p">;</span>
	<span class="n">time_offset</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Clear PPS state variables */</span>
	<span class="n">pps_clear</span><span class="p">();</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="p">}</span>


<span class="n">u64</span> <span class="nf">ntp_tick_length</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">tick_length</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * this routine handles the overflow of the microsecond field</span>
<span class="cm"> *</span>
<span class="cm"> * The tricky bits of code to handle the accurate clock support</span>
<span class="cm"> * were provided by Dave Mills (Mills@UDEL.EDU) of NTP fame.</span>
<span class="cm"> * They were originally developed for SUN and DEC kernels.</span>
<span class="cm"> * All the kudos should go to Dave for this stuff.</span>
<span class="cm"> *</span>
<span class="cm"> * Also handles leap second processing, and returns leap offset</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">second_overflow</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">secs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Leap second processing. If in leap-insert state at the end of the</span>
<span class="cm">	 * day, the system clock is set back one second; if in leap-delete</span>
<span class="cm">	 * state, the system clock is set ahead one second.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">time_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TIME_OK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_INS</span><span class="p">)</span>
			<span class="n">time_state</span> <span class="o">=</span> <span class="n">TIME_INS</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_DEL</span><span class="p">)</span>
			<span class="n">time_state</span> <span class="o">=</span> <span class="n">TIME_DEL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIME_INS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">secs</span> <span class="o">%</span> <span class="mi">86400</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">leap</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">time_state</span> <span class="o">=</span> <span class="n">TIME_OOP</span><span class="p">;</span>
			<span class="n">time_tai</span><span class="o">++</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
				<span class="s">&quot;Clock: inserting leap second 23:59:60 UTC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIME_DEL</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">secs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">86400</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">leap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">time_tai</span><span class="o">--</span><span class="p">;</span>
			<span class="n">time_state</span> <span class="o">=</span> <span class="n">TIME_WAIT</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
				<span class="s">&quot;Clock: deleting leap second 23:59:59 UTC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIME_OOP</span>:
		<span class="n">time_state</span> <span class="o">=</span> <span class="n">TIME_WAIT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TIME_WAIT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">STA_INS</span> <span class="o">|</span> <span class="n">STA_DEL</span><span class="p">)))</span>
			<span class="n">time_state</span> <span class="o">=</span> <span class="n">TIME_OK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* Bump the maxerror field */</span>
	<span class="n">time_maxerror</span> <span class="o">+=</span> <span class="n">MAXFREQ</span> <span class="o">/</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_maxerror</span> <span class="o">&gt;</span> <span class="n">NTP_PHASE_LIMIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">time_maxerror</span> <span class="o">=</span> <span class="n">NTP_PHASE_LIMIT</span><span class="p">;</span>
		<span class="n">time_status</span> <span class="o">|=</span> <span class="n">STA_UNSYNC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Compute the phase adjustment for the next second */</span>
	<span class="n">tick_length</span>	 <span class="o">=</span> <span class="n">tick_length_base</span><span class="p">;</span>

	<span class="n">delta</span>		 <span class="o">=</span> <span class="n">ntp_offset_chunk</span><span class="p">(</span><span class="n">time_offset</span><span class="p">);</span>
	<span class="n">time_offset</span>	<span class="o">-=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="n">tick_length</span>	<span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>

	<span class="cm">/* Check PPS signal */</span>
	<span class="n">pps_dec_valid</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_adjust</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_adjust</span> <span class="o">&gt;</span> <span class="n">MAX_TICKADJ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">time_adjust</span> <span class="o">-=</span> <span class="n">MAX_TICKADJ</span><span class="p">;</span>
		<span class="n">tick_length</span> <span class="o">+=</span> <span class="n">MAX_TICKADJ_SCALED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_adjust</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">MAX_TICKADJ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">time_adjust</span> <span class="o">+=</span> <span class="n">MAX_TICKADJ</span><span class="p">;</span>
		<span class="n">tick_length</span> <span class="o">-=</span> <span class="n">MAX_TICKADJ_SCALED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tick_length</span> <span class="o">+=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)(</span><span class="n">time_adjust</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span> <span class="o">/</span> <span class="n">NTP_INTERVAL_FREQ</span><span class="p">)</span>
							 <span class="o">&lt;&lt;</span> <span class="n">NTP_SCALE_SHIFT</span><span class="p">;</span>
	<span class="n">time_adjust</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">leap</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_GENERIC_CMOS_UPDATE</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sync_cmos_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DECLARE_DELAYED_WORK</span><span class="p">(</span><span class="n">sync_cmos_work</span><span class="p">,</span> <span class="n">sync_cmos_clock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sync_cmos_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fail</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have an externally synchronized Linux clock, then update</span>
<span class="cm">	 * CMOS clock accordingly every ~11 minutes. Set_rtc_mmss() has to be</span>
<span class="cm">	 * called as close as possible to 500 ms before the new second starts.</span>
<span class="cm">	 * This code is run on a timer.  If the clock is set, that timer</span>
<span class="cm">	 * may not expire at the correct time.  Thus, we adjust...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ntp_synced</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Not synced, exit, do not restart a timer (if one is</span>
<span class="cm">		 * running, let it run out).</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">getnstimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="p">(</span><span class="n">NSEC_PER_SEC</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">tick_nsec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">fail</span> <span class="o">=</span> <span class="n">update_persistent_clock</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>

	<span class="n">next</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="p">(</span><span class="n">NSEC_PER_SEC</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="p">(</span><span class="n">TICK_NSEC</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">next</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">+=</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fail</span><span class="p">)</span>
		<span class="n">next</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">659</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">next</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">&gt;=</span> <span class="n">NSEC_PER_SEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span><span class="p">.</span><span class="n">tv_sec</span><span class="o">++</span><span class="p">;</span>
		<span class="n">next</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-=</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_cmos_work</span><span class="p">,</span> <span class="n">timespec_to_jiffies</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">notify_cmos_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_cmos_work</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">notify_cmos_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> * Propagate a new txc-&gt;status value into the NTP state:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">process_adj_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">timex</span> <span class="o">*</span><span class="n">txc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_PLL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STA_PLL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">time_state</span> <span class="o">=</span> <span class="n">TIME_OK</span><span class="p">;</span>
		<span class="n">time_status</span> <span class="o">=</span> <span class="n">STA_UNSYNC</span><span class="p">;</span>
		<span class="cm">/* restart PPS frequency calibration */</span>
		<span class="n">pps_reset_freq_interval</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we turn on PLL adjustments then reset the</span>
<span class="cm">	 * reference time to current time.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_PLL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STA_PLL</span><span class="p">))</span>
		<span class="n">time_reftime</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>

	<span class="cm">/* only set allowed bits */</span>
	<span class="n">time_status</span> <span class="o">&amp;=</span> <span class="n">STA_RONLY</span><span class="p">;</span>
	<span class="n">time_status</span> <span class="o">|=</span> <span class="n">txc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">STA_RONLY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called with ntp_lock held, so we can access and modify</span>
<span class="cm"> * all the global NTP state:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">process_adjtimex_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">timex</span> <span class="o">*</span><span class="n">txc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_STATUS</span><span class="p">)</span>
		<span class="n">process_adj_status</span><span class="p">(</span><span class="n">txc</span><span class="p">,</span> <span class="n">ts</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_NANO</span><span class="p">)</span>
		<span class="n">time_status</span> <span class="o">|=</span> <span class="n">STA_NANO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_MICRO</span><span class="p">)</span>
		<span class="n">time_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">STA_NANO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_FREQUENCY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">time_freq</span> <span class="o">=</span> <span class="n">txc</span><span class="o">-&gt;</span><span class="n">freq</span> <span class="o">*</span> <span class="n">PPM_SCALE</span><span class="p">;</span>
		<span class="n">time_freq</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">time_freq</span><span class="p">,</span> <span class="n">MAXFREQ_SCALED</span><span class="p">);</span>
		<span class="n">time_freq</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">time_freq</span><span class="p">,</span> <span class="o">-</span><span class="n">MAXFREQ_SCALED</span><span class="p">);</span>
		<span class="cm">/* update pps_freq */</span>
		<span class="n">pps_set_freq</span><span class="p">(</span><span class="n">time_freq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_MAXERROR</span><span class="p">)</span>
		<span class="n">time_maxerror</span> <span class="o">=</span> <span class="n">txc</span><span class="o">-&gt;</span><span class="n">maxerror</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_ESTERROR</span><span class="p">)</span>
		<span class="n">time_esterror</span> <span class="o">=</span> <span class="n">txc</span><span class="o">-&gt;</span><span class="n">esterror</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_TIMECONST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">time_constant</span> <span class="o">=</span> <span class="n">txc</span><span class="o">-&gt;</span><span class="n">constant</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_NANO</span><span class="p">))</span>
			<span class="n">time_constant</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">time_constant</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">time_constant</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">MAXTC</span><span class="p">);</span>
		<span class="n">time_constant</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">time_constant</span><span class="p">,</span> <span class="mi">0l</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_TAI</span> <span class="o">&amp;&amp;</span> <span class="n">txc</span><span class="o">-&gt;</span><span class="n">constant</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">time_tai</span> <span class="o">=</span> <span class="n">txc</span><span class="o">-&gt;</span><span class="n">constant</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_OFFSET</span><span class="p">)</span>
		<span class="n">ntp_update_offset</span><span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_TICK</span><span class="p">)</span>
		<span class="n">tick_usec</span> <span class="o">=</span> <span class="n">txc</span><span class="o">-&gt;</span><span class="n">tick</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ADJ_TICK</span><span class="o">|</span><span class="n">ADJ_FREQUENCY</span><span class="o">|</span><span class="n">ADJ_OFFSET</span><span class="p">))</span>
		<span class="n">ntp_update_frequency</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * adjtimex mainly allows reading (and writing, if superuser) of</span>
<span class="cm"> * kernel time-keeping variables. used by xntpd.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">do_adjtimex</span><span class="p">(</span><span class="k">struct</span> <span class="n">timex</span> <span class="o">*</span><span class="n">txc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* Validate the data before disabling interrupts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_ADJTIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* singleshot must not be used with any other mode bits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_OFFSET_SINGLESHOT</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_OFFSET_READONLY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_TIME</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* In order to modify anything, you gotta be super-user! */</span>
		 <span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_TIME</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * if the quartz is off by more than 10% then</span>
<span class="cm">		 * something is VERY wrong!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_TICK</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">tick</span> <span class="o">&lt;</span>  <span class="mi">900000</span><span class="o">/</span><span class="n">USER_HZ</span> <span class="o">||</span>
		     <span class="n">txc</span><span class="o">-&gt;</span><span class="n">tick</span> <span class="o">&gt;</span> <span class="mi">1100000</span><span class="o">/</span><span class="n">USER_HZ</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_SETOFFSET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">timespec</span> <span class="n">delta</span><span class="p">;</span>
		<span class="n">delta</span><span class="p">.</span><span class="n">tv_sec</span>  <span class="o">=</span> <span class="n">txc</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="n">delta</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">txc</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_TIME</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_NANO</span><span class="p">))</span>
			<span class="n">delta</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">*=</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">timekeeping_inject_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delta</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">getnstimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntp_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_ADJTIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">save_adjust</span> <span class="o">=</span> <span class="n">time_adjust</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">ADJ_OFFSET_READONLY</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* adjtime() is independent from ntp_adjtime() */</span>
			<span class="n">time_adjust</span> <span class="o">=</span> <span class="n">txc</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">ntp_update_frequency</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">txc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">save_adjust</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="cm">/* If there are input parameters, then process them: */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">txc</span><span class="o">-&gt;</span><span class="n">modes</span><span class="p">)</span>
			<span class="n">process_adjtimex_modes</span><span class="p">(</span><span class="n">txc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>

		<span class="n">txc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">shift_right</span><span class="p">(</span><span class="n">time_offset</span> <span class="o">*</span> <span class="n">NTP_INTERVAL_FREQ</span><span class="p">,</span>
				  <span class="n">NTP_SCALE_SHIFT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_NANO</span><span class="p">))</span>
			<span class="n">txc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">/=</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">time_state</span><span class="p">;</span>	<span class="cm">/* mostly `TIME_OK&#39; */</span>
	<span class="cm">/* check for errors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_error_status</span><span class="p">(</span><span class="n">time_status</span><span class="p">))</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">TIME_ERROR</span><span class="p">;</span>

	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">freq</span>	   <span class="o">=</span> <span class="n">shift_right</span><span class="p">((</span><span class="n">time_freq</span> <span class="o">&gt;&gt;</span> <span class="n">PPM_SCALE_INV_SHIFT</span><span class="p">)</span> <span class="o">*</span>
					 <span class="n">PPM_SCALE_INV</span><span class="p">,</span> <span class="n">NTP_SCALE_SHIFT</span><span class="p">);</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">maxerror</span>	   <span class="o">=</span> <span class="n">time_maxerror</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">esterror</span>	   <span class="o">=</span> <span class="n">time_esterror</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">status</span>	   <span class="o">=</span> <span class="n">time_status</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">constant</span>	   <span class="o">=</span> <span class="n">time_constant</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">precision</span>	   <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">tolerance</span>	   <span class="o">=</span> <span class="n">MAXFREQ_SCALED</span> <span class="o">/</span> <span class="n">PPM_SCALE</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">tick</span>	   <span class="o">=</span> <span class="n">tick_usec</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">tai</span>	   <span class="o">=</span> <span class="n">time_tai</span><span class="p">;</span>

	<span class="cm">/* fill PPS status fields */</span>
	<span class="n">pps_fill_timex</span><span class="p">(</span><span class="n">txc</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntp_lock</span><span class="p">);</span>

	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">txc</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_NANO</span><span class="p">))</span>
		<span class="n">txc</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">/=</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>

	<span class="n">notify_cmos_timer</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef	CONFIG_NTP_PPS</span>

<span class="cm">/* actually struct pps_normtime is good old struct timespec, but it is</span>
<span class="cm"> * semantically different (and it is the reason why it was invented):</span>
<span class="cm"> * pps_normtime.nsec has a range of ( -NSEC_PER_SEC / 2, NSEC_PER_SEC / 2 ]</span>
<span class="cm"> * while timespec.tv_nsec has a range of [0, NSEC_PER_SEC) */</span>
<span class="k">struct</span> <span class="n">pps_normtime</span> <span class="p">{</span>
	<span class="n">__kernel_time_t</span>	<span class="n">sec</span><span class="p">;</span>	<span class="cm">/* seconds */</span>
	<span class="kt">long</span>		<span class="n">nsec</span><span class="p">;</span>	<span class="cm">/* nanoseconds */</span>
<span class="p">};</span>

<span class="cm">/* normalize the timestamp so that nsec is in the</span>
<span class="cm">   ( -NSEC_PER_SEC / 2, NSEC_PER_SEC / 2 ] interval */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pps_normtime</span> <span class="nf">pps_normalize_ts</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pps_normtime</span> <span class="n">norm</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sec</span> <span class="o">=</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nsec</span> <span class="o">=</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">norm</span><span class="p">.</span><span class="n">nsec</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">NSEC_PER_SEC</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">norm</span><span class="p">.</span><span class="n">nsec</span> <span class="o">-=</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>
		<span class="n">norm</span><span class="p">.</span><span class="n">sec</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">norm</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* get current phase correction and jitter */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">pps_phase_filter_get</span><span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="n">jitter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">jitter</span> <span class="o">=</span> <span class="n">pps_tf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pps_tf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">jitter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">jitter</span> <span class="o">=</span> <span class="o">-*</span><span class="n">jitter</span><span class="p">;</span>

	<span class="cm">/* TODO: test various filters */</span>
	<span class="k">return</span> <span class="n">pps_tf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* add the sample to the phase filter */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pps_phase_filter_add</span><span class="p">(</span><span class="kt">long</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pps_tf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pps_tf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">pps_tf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pps_tf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">pps_tf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* decrease frequency calibration interval length.</span>
<span class="cm"> * It is halved after four consecutive unstable intervals.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pps_dec_freq_interval</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">pps_intcnt</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">PPS_INTCOUNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pps_intcnt</span> <span class="o">=</span> <span class="o">-</span><span class="n">PPS_INTCOUNT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pps_shift</span> <span class="o">&gt;</span> <span class="n">PPS_INTMIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pps_shift</span><span class="o">--</span><span class="p">;</span>
			<span class="n">pps_intcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* increase frequency calibration interval length.</span>
<span class="cm"> * It is doubled after four consecutive stable intervals.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pps_inc_freq_interval</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">pps_intcnt</span> <span class="o">&gt;=</span> <span class="n">PPS_INTCOUNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pps_intcnt</span> <span class="o">=</span> <span class="n">PPS_INTCOUNT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pps_shift</span> <span class="o">&lt;</span> <span class="n">PPS_INTMAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pps_shift</span><span class="o">++</span><span class="p">;</span>
			<span class="n">pps_intcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* update clock frequency based on MONOTONIC_RAW clock PPS signal</span>
<span class="cm"> * timestamps</span>
<span class="cm"> *</span>
<span class="cm"> * At the end of the calibration interval the difference between the</span>
<span class="cm"> * first and last MONOTONIC_RAW clock timestamps divided by the length</span>
<span class="cm"> * of the interval becomes the frequency update. If the interval was</span>
<span class="cm"> * too long, the data are discarded.</span>
<span class="cm"> * Returns the difference between old and new frequency values.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">hardpps_update_freq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pps_normtime</span> <span class="n">freq_norm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">delta</span><span class="p">,</span> <span class="n">delta_mod</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">ftemp</span><span class="p">;</span>

	<span class="cm">/* check if the frequency interval was too long */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freq_norm</span><span class="p">.</span><span class="n">sec</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">pps_shift</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">time_status</span> <span class="o">|=</span> <span class="n">STA_PPSERROR</span><span class="p">;</span>
		<span class="n">pps_errcnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pps_dec_freq_interval</span><span class="p">();</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;hardpps: PPSERROR: interval too long - %ld s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">freq_norm</span><span class="p">.</span><span class="n">sec</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* here the raw frequency offset and wander (stability) is</span>
<span class="cm">	 * calculated. If the wander is less than the wander threshold</span>
<span class="cm">	 * the interval is increased; otherwise it is decreased.</span>
<span class="cm">	 */</span>
	<span class="n">ftemp</span> <span class="o">=</span> <span class="n">div_s64</span><span class="p">(((</span><span class="n">s64</span><span class="p">)(</span><span class="o">-</span><span class="n">freq_norm</span><span class="p">.</span><span class="n">nsec</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">NTP_SCALE_SHIFT</span><span class="p">,</span>
			<span class="n">freq_norm</span><span class="p">.</span><span class="n">sec</span><span class="p">);</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">shift_right</span><span class="p">(</span><span class="n">ftemp</span> <span class="o">-</span> <span class="n">pps_freq</span><span class="p">,</span> <span class="n">NTP_SCALE_SHIFT</span><span class="p">);</span>
	<span class="n">pps_freq</span> <span class="o">=</span> <span class="n">ftemp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">PPS_MAXWANDER</span> <span class="o">||</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">PPS_MAXWANDER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;hardpps: PPSWANDER: change=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
		<span class="n">time_status</span> <span class="o">|=</span> <span class="n">STA_PPSWANDER</span><span class="p">;</span>
		<span class="n">pps_stbcnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pps_dec_freq_interval</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* good sample */</span>
		<span class="n">pps_inc_freq_interval</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* the stability metric is calculated as the average of recent</span>
<span class="cm">	 * frequency changes, but is used only for performance</span>
<span class="cm">	 * monitoring</span>
<span class="cm">	 */</span>
	<span class="n">delta_mod</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta_mod</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">delta_mod</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta_mod</span><span class="p">;</span>
	<span class="n">pps_stabil</span> <span class="o">+=</span> <span class="p">(</span><span class="n">div_s64</span><span class="p">(((</span><span class="n">s64</span><span class="p">)</span><span class="n">delta_mod</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
				<span class="p">(</span><span class="n">NTP_SCALE_SHIFT</span> <span class="o">-</span> <span class="n">SHIFT_USEC</span><span class="p">),</span>
				<span class="n">NSEC_PER_USEC</span><span class="p">)</span> <span class="o">-</span> <span class="n">pps_stabil</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PPS_INTMIN</span><span class="p">;</span>

	<span class="cm">/* if enabled, the system clock frequency is updated */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_PPSFREQ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_FREQHOLD</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">time_freq</span> <span class="o">=</span> <span class="n">pps_freq</span><span class="p">;</span>
		<span class="n">ntp_update_frequency</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* correct REALTIME clock phase error against PPS signal */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hardpps_update_phase</span><span class="p">(</span><span class="kt">long</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">correction</span> <span class="o">=</span> <span class="o">-</span><span class="n">error</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">jitter</span><span class="p">;</span>

	<span class="cm">/* add the sample to the median filter */</span>
	<span class="n">pps_phase_filter_add</span><span class="p">(</span><span class="n">correction</span><span class="p">);</span>
	<span class="n">correction</span> <span class="o">=</span> <span class="n">pps_phase_filter_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jitter</span><span class="p">);</span>

	<span class="cm">/* Nominal jitter is due to PPS signal noise. If it exceeds the</span>
<span class="cm">	 * threshold, the sample is discarded; otherwise, if so enabled,</span>
<span class="cm">	 * the time offset is updated.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jitter</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">pps_jitter</span> <span class="o">&lt;&lt;</span> <span class="n">PPS_POPCORN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;hardpps: PPSJITTER: jitter=%ld, limit=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">jitter</span><span class="p">,</span> <span class="p">(</span><span class="n">pps_jitter</span> <span class="o">&lt;&lt;</span> <span class="n">PPS_POPCORN</span><span class="p">));</span>
		<span class="n">time_status</span> <span class="o">|=</span> <span class="n">STA_PPSJITTER</span><span class="p">;</span>
		<span class="n">pps_jitcnt</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">time_status</span> <span class="o">&amp;</span> <span class="n">STA_PPSTIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* correct the time using the phase offset */</span>
		<span class="n">time_offset</span> <span class="o">=</span> <span class="n">div_s64</span><span class="p">(((</span><span class="n">s64</span><span class="p">)</span><span class="n">correction</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">NTP_SCALE_SHIFT</span><span class="p">,</span>
				<span class="n">NTP_INTERVAL_FREQ</span><span class="p">);</span>
		<span class="cm">/* cancel running adjtime() */</span>
		<span class="n">time_adjust</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* update jitter */</span>
	<span class="n">pps_jitter</span> <span class="o">+=</span> <span class="p">(</span><span class="n">jitter</span> <span class="o">-</span> <span class="n">pps_jitter</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PPS_INTMIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * hardpps() - discipline CPU clock oscillator to external PPS signal</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called at each PPS signal arrival in order to</span>
<span class="cm"> * discipline the CPU clock oscillator to the PPS signal. It takes two</span>
<span class="cm"> * parameters: REALTIME and MONOTONIC_RAW clock timestamps. The former</span>
<span class="cm"> * is used to correct clock phase error and the latter is used to</span>
<span class="cm"> * correct the frequency.</span>
<span class="cm"> *</span>
<span class="cm"> * This code is based on David Mills&#39;s reference nanokernel</span>
<span class="cm"> * implementation. It was mostly rewritten but keeps the same idea.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">hardpps</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">phase_ts</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">raw_ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pps_normtime</span> <span class="n">pts_norm</span><span class="p">,</span> <span class="n">freq_norm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">pts_norm</span> <span class="o">=</span> <span class="n">pps_normalize_ts</span><span class="p">(</span><span class="o">*</span><span class="n">phase_ts</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* clear the error bits, they will be set again if needed */</span>
	<span class="n">time_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">STA_PPSJITTER</span> <span class="o">|</span> <span class="n">STA_PPSWANDER</span> <span class="o">|</span> <span class="n">STA_PPSERROR</span><span class="p">);</span>

	<span class="cm">/* indicate signal presence */</span>
	<span class="n">time_status</span> <span class="o">|=</span> <span class="n">STA_PPSSIGNAL</span><span class="p">;</span>
	<span class="n">pps_valid</span> <span class="o">=</span> <span class="n">PPS_VALID</span><span class="p">;</span>

	<span class="cm">/* when called for the first time,</span>
<span class="cm">	 * just start the frequency interval */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pps_fbase</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pps_fbase</span> <span class="o">=</span> <span class="o">*</span><span class="n">raw_ts</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ok, now we have a base for frequency calculation */</span>
	<span class="n">freq_norm</span> <span class="o">=</span> <span class="n">pps_normalize_ts</span><span class="p">(</span><span class="n">timespec_sub</span><span class="p">(</span><span class="o">*</span><span class="n">raw_ts</span><span class="p">,</span> <span class="n">pps_fbase</span><span class="p">));</span>

	<span class="cm">/* check that the signal is in the range</span>
<span class="cm">	 * [1s - MAXFREQ us, 1s + MAXFREQ us], otherwise reject it */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">freq_norm</span><span class="p">.</span><span class="n">sec</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">freq_norm</span><span class="p">.</span><span class="n">nsec</span> <span class="o">&gt;</span> <span class="n">MAXFREQ</span> <span class="o">*</span> <span class="n">freq_norm</span><span class="p">.</span><span class="n">sec</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">freq_norm</span><span class="p">.</span><span class="n">nsec</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">MAXFREQ</span> <span class="o">*</span> <span class="n">freq_norm</span><span class="p">.</span><span class="n">sec</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">time_status</span> <span class="o">|=</span> <span class="n">STA_PPSJITTER</span><span class="p">;</span>
		<span class="cm">/* restart the frequency calibration interval */</span>
		<span class="n">pps_fbase</span> <span class="o">=</span> <span class="o">*</span><span class="n">raw_ts</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;hardpps: PPSJITTER: bad pulse</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* signal is ok */</span>

	<span class="cm">/* check if the current frequency interval is finished */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freq_norm</span><span class="p">.</span><span class="n">sec</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pps_shift</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pps_calcnt</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* restart the frequency calibration interval */</span>
		<span class="n">pps_fbase</span> <span class="o">=</span> <span class="o">*</span><span class="n">raw_ts</span><span class="p">;</span>
		<span class="n">hardpps_update_freq</span><span class="p">(</span><span class="n">freq_norm</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hardpps_update_phase</span><span class="p">(</span><span class="n">pts_norm</span><span class="p">.</span><span class="n">nsec</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">hardpps</span><span class="p">);</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_NTP_PPS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ntp_tick_adj_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ntp_tick_adj</span> <span class="o">=</span> <span class="n">simple_strtol</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ntp_tick_adj</span> <span class="o">&lt;&lt;=</span> <span class="n">NTP_SCALE_SHIFT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;ntp_tick_adj=&quot;</span><span class="p">,</span> <span class="n">ntp_tick_adj_setup</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">ntp_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ntp_clear</span><span class="p">();</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
