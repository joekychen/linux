<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › time › clocksource.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>clocksource.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/kernel/time/clocksource.c</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains the functions which manage clocksource drivers.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004, 2005 IBM, John Stultz (johnstul@us.ibm.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO WishList:</span>
<span class="cm"> *   o Allow clocksource drivers to be unregistered</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/clocksource.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt; </span><span class="cm">/* for spin_unlock_irq() using preempt_count() m68k */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/tick.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>

<span class="kt">void</span> <span class="nf">timecounter_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">timecounter</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">cyclecounter</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span>
		      <span class="n">u64</span> <span class="n">start_tstamp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tc</span><span class="o">-&gt;</span><span class="n">cc</span> <span class="o">=</span> <span class="n">cc</span><span class="p">;</span>
	<span class="n">tc</span><span class="o">-&gt;</span><span class="n">cycle_last</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
	<span class="n">tc</span><span class="o">-&gt;</span><span class="n">nsec</span> <span class="o">=</span> <span class="n">start_tstamp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">timecounter_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * timecounter_read_delta - get nanoseconds since last call of this function</span>
<span class="cm"> * @tc:         Pointer to time counter</span>
<span class="cm"> *</span>
<span class="cm"> * When the underlying cycle counter runs over, this will be handled</span>
<span class="cm"> * correctly as long as it does not run over more than once between</span>
<span class="cm"> * calls.</span>
<span class="cm"> *</span>
<span class="cm"> * The first call to this function for a new time counter initializes</span>
<span class="cm"> * the time tracking and returns an undefined result.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">timecounter_read_delta</span><span class="p">(</span><span class="k">struct</span> <span class="n">timecounter</span> <span class="o">*</span><span class="n">tc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cycle_t</span> <span class="n">cycle_now</span><span class="p">,</span> <span class="n">cycle_delta</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ns_offset</span><span class="p">;</span>

	<span class="cm">/* read cycle counter: */</span>
	<span class="n">cycle_now</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">cc</span><span class="p">);</span>

	<span class="cm">/* calculate the delta since the last timecounter_read_delta(): */</span>
	<span class="n">cycle_delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">cycle_now</span> <span class="o">-</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">cycle_last</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>

	<span class="cm">/* convert to nanoseconds: */</span>
	<span class="n">ns_offset</span> <span class="o">=</span> <span class="n">cyclecounter_cyc2ns</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">cc</span><span class="p">,</span> <span class="n">cycle_delta</span><span class="p">);</span>

	<span class="cm">/* update time stamp of timecounter_read_delta() call: */</span>
	<span class="n">tc</span><span class="o">-&gt;</span><span class="n">cycle_last</span> <span class="o">=</span> <span class="n">cycle_now</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ns_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="nf">timecounter_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">timecounter</span> <span class="o">*</span><span class="n">tc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">nsec</span><span class="p">;</span>

	<span class="cm">/* increment time by nanoseconds since last call */</span>
	<span class="n">nsec</span> <span class="o">=</span> <span class="n">timecounter_read_delta</span><span class="p">(</span><span class="n">tc</span><span class="p">);</span>
	<span class="n">nsec</span> <span class="o">+=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">nsec</span><span class="p">;</span>
	<span class="n">tc</span><span class="o">-&gt;</span><span class="n">nsec</span> <span class="o">=</span> <span class="n">nsec</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nsec</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">timecounter_read</span><span class="p">);</span>

<span class="n">u64</span> <span class="nf">timecounter_cyc2time</span><span class="p">(</span><span class="k">struct</span> <span class="n">timecounter</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span>
			 <span class="n">cycle_t</span> <span class="n">cycle_tstamp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">cycle_delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">cycle_tstamp</span> <span class="o">-</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">cycle_last</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">nsec</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Instead of always treating cycle_tstamp as more recent</span>
<span class="cm">	 * than tc-&gt;cycle_last, detect when it is too far in the</span>
<span class="cm">	 * future and treat it as old time stamp instead.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cycle_delta</span> <span class="o">&gt;</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cycle_delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">cycle_last</span> <span class="o">-</span> <span class="n">cycle_tstamp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">nsec</span> <span class="o">=</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">nsec</span> <span class="o">-</span> <span class="n">cyclecounter_cyc2ns</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">cc</span><span class="p">,</span> <span class="n">cycle_delta</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">nsec</span> <span class="o">=</span> <span class="n">cyclecounter_cyc2ns</span><span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">cc</span><span class="p">,</span> <span class="n">cycle_delta</span><span class="p">)</span> <span class="o">+</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">nsec</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">nsec</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">timecounter_cyc2time</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clocks_calc_mult_shift - calculate mult/shift factors for scaled math of clocks</span>
<span class="cm"> * @mult:	pointer to mult variable</span>
<span class="cm"> * @shift:	pointer to shift variable</span>
<span class="cm"> * @from:	frequency to convert from</span>
<span class="cm"> * @to:		frequency to convert to</span>
<span class="cm"> * @maxsec:	guaranteed runtime conversion range in seconds</span>
<span class="cm"> *</span>
<span class="cm"> * The function evaluates the shift/mult pair for the scaled math</span>
<span class="cm"> * operations of clocksources and clockevents.</span>
<span class="cm"> *</span>
<span class="cm"> * @to and @from are frequency values in HZ. For clock sources @to is</span>
<span class="cm"> * NSEC_PER_SEC == 1GHz and @from is the counter frequency. For clock</span>
<span class="cm"> * event @to is the counter frequency and @from is NSEC_PER_SEC.</span>
<span class="cm"> *</span>
<span class="cm"> * The @maxsec conversion range argument controls the time frame in</span>
<span class="cm"> * seconds which must be covered by the runtime conversion with the</span>
<span class="cm"> * calculated mult and shift factors. This guarantees that no 64bit</span>
<span class="cm"> * overflow happens when the input value of the conversion is</span>
<span class="cm"> * multiplied with the calculated mult factor. Larger ranges may</span>
<span class="cm"> * reduce the conversion accuracy by chosing smaller mult and shift</span>
<span class="cm"> * factors.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">clocks_calc_mult_shift</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">mult</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">shift</span><span class="p">,</span> <span class="n">u32</span> <span class="n">from</span><span class="p">,</span> <span class="n">u32</span> <span class="n">to</span><span class="p">,</span> <span class="n">u32</span> <span class="n">maxsec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sft</span><span class="p">,</span> <span class="n">sftacc</span><span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the shift factor which is limiting the conversion</span>
<span class="cm">	 * range:</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">maxsec</span> <span class="o">*</span> <span class="n">from</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">sftacc</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find the conversion shift/mult pair which has the best</span>
<span class="cm">	 * accuracy and fits the maxsec conversion range:</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">sft</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span> <span class="n">sft</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sft</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">to</span> <span class="o">&lt;&lt;</span> <span class="n">sft</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">+=</span> <span class="n">from</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="n">sftacc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">mult</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="o">*</span><span class="n">shift</span> <span class="o">=</span> <span class="n">sft</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*[Clocksource internal variables]---------</span>
<span class="cm"> * curr_clocksource:</span>
<span class="cm"> *	currently selected clocksource.</span>
<span class="cm"> * clocksource_list:</span>
<span class="cm"> *	linked list with the registered clocksources</span>
<span class="cm"> * clocksource_mutex:</span>
<span class="cm"> *	protects manipulations to curr_clocksource and the clocksource_list</span>
<span class="cm"> * override_name:</span>
<span class="cm"> *	Name of the user-specified clocksource.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">curr_clocksource</span><span class="p">;</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">clocksource_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">clocksource_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">override_name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">finished_booting</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_CLOCKSOURCE_WATCHDOG</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">clocksource_watchdog_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">watchdog_list</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">watchdog</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">watchdog_timer</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">watchdog_work</span><span class="p">,</span> <span class="n">clocksource_watchdog_work</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">watchdog_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">watchdog_running</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">watchdog_reset_pending</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">clocksource_watchdog_kthread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__clocksource_change_rating</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rating</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Interval: 0.5sec Threshold: 0.0625s</span>
<span class="cm"> */</span>
<span class="cp">#define WATCHDOG_INTERVAL (HZ &gt;&gt; 1)</span>
<span class="cp">#define WATCHDOG_THRESHOLD (NSEC_PER_SEC &gt;&gt; 4)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clocksource_watchdog_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If kthread_run fails the next watchdog scan over the</span>
<span class="cm">	 * watchdog_list will find the unstable clock again.</span>
<span class="cm">	 */</span>
	<span class="n">kthread_run</span><span class="p">(</span><span class="n">clocksource_watchdog_kthread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;kwatchdog&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__clocksource_unstable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CLOCK_SOURCE_VALID_FOR_HRES</span> <span class="o">|</span> <span class="n">CLOCK_SOURCE_WATCHDOG</span><span class="p">);</span>
	<span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CLOCK_SOURCE_UNSTABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">finished_booting</span><span class="p">)</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clocksource_unstable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Clocksource %s unstable (delta = %Ld ns)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">cs</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
	<span class="n">__clocksource_unstable</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clocksource_mark_unstable - mark clocksource unstable via watchdog</span>
<span class="cm"> * @cs:		clocksource to be marked unstable</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called instead of clocksource_change_rating from</span>
<span class="cm"> * cpu hotplug code to avoid a deadlock between the clocksource mutex</span>
<span class="cm"> * and the cpu hotplug mutex. It defers the update of the clocksource</span>
<span class="cm"> * to the watchdog thread.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clocksource_mark_unstable</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLOCK_SOURCE_UNSTABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">wd_list</span><span class="p">))</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">wd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">watchdog_list</span><span class="p">);</span>
		<span class="n">__clocksource_unstable</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clocksource_watchdog</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>
	<span class="n">cycle_t</span> <span class="n">csnow</span><span class="p">,</span> <span class="n">wdnow</span><span class="p">;</span>
	<span class="kt">int64_t</span> <span class="n">wd_nsec</span><span class="p">,</span> <span class="n">cs_nsec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next_cpu</span><span class="p">,</span> <span class="n">reset_pending</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">watchdog_running</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">reset_pending</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_reset_pending</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">watchdog_list</span><span class="p">,</span> <span class="n">wd_list</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Clocksource already marked unstable? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLOCK_SOURCE_UNSTABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">finished_booting</span><span class="p">)</span>
				<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_work</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="n">csnow</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
		<span class="n">wdnow</span> <span class="o">=</span> <span class="n">watchdog</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">watchdog</span><span class="p">);</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>

		<span class="cm">/* Clocksource initialized ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLOCK_SOURCE_WATCHDOG</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_reset_pending</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CLOCK_SOURCE_WATCHDOG</span><span class="p">;</span>
			<span class="n">cs</span><span class="o">-&gt;</span><span class="n">wd_last</span> <span class="o">=</span> <span class="n">wdnow</span><span class="p">;</span>
			<span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_last</span> <span class="o">=</span> <span class="n">csnow</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">wd_nsec</span> <span class="o">=</span> <span class="n">clocksource_cyc2ns</span><span class="p">((</span><span class="n">wdnow</span> <span class="o">-</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">wd_last</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">watchdog</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">,</span>
					     <span class="n">watchdog</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">,</span> <span class="n">watchdog</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">);</span>

		<span class="n">cs_nsec</span> <span class="o">=</span> <span class="n">clocksource_cyc2ns</span><span class="p">((</span><span class="n">csnow</span> <span class="o">-</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_last</span><span class="p">)</span> <span class="o">&amp;</span>
					     <span class="n">cs</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">,</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">,</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">);</span>
		<span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_last</span> <span class="o">=</span> <span class="n">csnow</span><span class="p">;</span>
		<span class="n">cs</span><span class="o">-&gt;</span><span class="n">wd_last</span> <span class="o">=</span> <span class="n">wdnow</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_reset_pending</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Check the deviation from the watchdog clocksource. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">abs</span><span class="p">(</span><span class="n">cs_nsec</span> <span class="o">-</span> <span class="n">wd_nsec</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">WATCHDOG_THRESHOLD</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">clocksource_unstable</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">cs_nsec</span> <span class="o">-</span> <span class="n">wd_nsec</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLOCK_SOURCE_VALID_FOR_HRES</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLOCK_SOURCE_IS_CONTINUOUS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">watchdog</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLOCK_SOURCE_IS_CONTINUOUS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CLOCK_SOURCE_VALID_FOR_HRES</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * We just marked the clocksource as highres-capable,</span>
<span class="cm">			 * notify the rest of the system as well so that we</span>
<span class="cm">			 * transition into high-res mode:</span>
<span class="cm">			 */</span>
			<span class="n">tick_clock_notify</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We only clear the watchdog_reset_pending, when we did a</span>
<span class="cm">	 * full cycle through all clocksources.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reset_pending</span><span class="p">)</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_reset_pending</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cycle through CPUs to check if the CPUs stay synchronized</span>
<span class="cm">	 * to each other.</span>
<span class="cm">	 */</span>
	<span class="n">next_cpu</span> <span class="o">=</span> <span class="n">cpumask_next</span><span class="p">(</span><span class="n">raw_smp_processor_id</span><span class="p">(),</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
		<span class="n">next_cpu</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="n">watchdog_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">+=</span> <span class="n">WATCHDOG_INTERVAL</span><span class="p">;</span>
	<span class="n">add_timer_on</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_timer</span><span class="p">,</span> <span class="n">next_cpu</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clocksource_start_watchdog</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">watchdog_running</span> <span class="o">||</span> <span class="o">!</span><span class="n">watchdog</span> <span class="o">||</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_timer</span><span class="p">);</span>
	<span class="n">watchdog_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">clocksource_watchdog</span><span class="p">;</span>
	<span class="n">watchdog_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">WATCHDOG_INTERVAL</span><span class="p">;</span>
	<span class="n">add_timer_on</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_timer</span><span class="p">,</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">cpu_online_mask</span><span class="p">));</span>
	<span class="n">watchdog_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clocksource_stop_watchdog</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">watchdog_running</span> <span class="o">||</span> <span class="p">(</span><span class="n">watchdog</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_list</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_timer</span><span class="p">);</span>
	<span class="n">watchdog_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clocksource_reset_watchdog</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">watchdog_list</span><span class="p">,</span> <span class="n">wd_list</span><span class="p">)</span>
		<span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CLOCK_SOURCE_WATCHDOG</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clocksource_resume_watchdog</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_reset_pending</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clocksource_enqueue_watchdog</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLOCK_SOURCE_MUST_VERIFY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* cs is a clocksource to be watched. */</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">wd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">watchdog_list</span><span class="p">);</span>
		<span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CLOCK_SOURCE_WATCHDOG</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* cs is a watchdog. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLOCK_SOURCE_IS_CONTINUOUS</span><span class="p">)</span>
			<span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CLOCK_SOURCE_VALID_FOR_HRES</span><span class="p">;</span>
		<span class="cm">/* Pick the best watchdog. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">watchdog</span> <span class="o">||</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">rating</span> <span class="o">&gt;</span> <span class="n">watchdog</span><span class="o">-&gt;</span><span class="n">rating</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">watchdog</span> <span class="o">=</span> <span class="n">cs</span><span class="p">;</span>
			<span class="cm">/* Reset watchdog cycles */</span>
			<span class="n">clocksource_reset_watchdog</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Check if the watchdog timer needs to be started. */</span>
	<span class="n">clocksource_start_watchdog</span><span class="p">();</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clocksource_dequeue_watchdog</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLOCK_SOURCE_MUST_VERIFY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* cs is a watched clocksource. */</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">wd_list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cs</span> <span class="o">==</span> <span class="n">watchdog</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Reset watchdog cycles */</span>
		<span class="n">clocksource_reset_watchdog</span><span class="p">();</span>
		<span class="cm">/* Current watchdog is removed. Find an alternative. */</span>
		<span class="n">watchdog</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clocksource_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">cs</span> <span class="o">||</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLOCK_SOURCE_MUST_VERIFY</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">watchdog</span> <span class="o">||</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">rating</span> <span class="o">&gt;</span> <span class="n">watchdog</span><span class="o">-&gt;</span><span class="n">rating</span><span class="p">)</span>
				<span class="n">watchdog</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CLOCK_SOURCE_WATCHDOG</span><span class="p">;</span>
	<span class="cm">/* Check if the watchdog timer needs to be stopped. */</span>
	<span class="n">clocksource_stop_watchdog</span><span class="p">();</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">clocksource_watchdog_kthread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">unstable</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">watchdog_list</span><span class="p">,</span> <span class="n">wd_list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLOCK_SOURCE_UNSTABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">wd_list</span><span class="p">);</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">wd_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unstable</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="cm">/* Check if the watchdog timer needs to be stopped. */</span>
	<span class="n">clocksource_stop_watchdog</span><span class="p">();</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">watchdog_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Needs to be done outside of watchdog lock */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unstable</span><span class="p">,</span> <span class="n">wd_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">wd_list</span><span class="p">);</span>
		<span class="n">__clocksource_change_rating</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_CLOCKSOURCE_WATCHDOG */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clocksource_enqueue_watchdog</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLOCK_SOURCE_IS_CONTINUOUS</span><span class="p">)</span>
		<span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CLOCK_SOURCE_VALID_FOR_HRES</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clocksource_dequeue_watchdog</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clocksource_resume_watchdog</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">clocksource_watchdog_kthread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_CLOCKSOURCE_WATCHDOG */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * clocksource_suspend - suspend the clocksource(s)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clocksource_suspend</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>

	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clocksource_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">)</span>
			<span class="n">cs</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clocksource_resume - resume the clocksource(s)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clocksource_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clocksource_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">)</span>
			<span class="n">cs</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>

	<span class="n">clocksource_resume_watchdog</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clocksource_touch_watchdog - Update watchdog</span>
<span class="cm"> *</span>
<span class="cm"> * Update the watchdog after exception contexts such as kgdb so as not</span>
<span class="cm"> * to incorrectly trip the watchdog. This might fail when the kernel</span>
<span class="cm"> * was stopped in code which holds watchdog_lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clocksource_touch_watchdog</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clocksource_resume_watchdog</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clocksource_max_adjustment- Returns max adjustment amount</span>
<span class="cm"> * @cs:         Pointer to clocksource</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">clocksource_max_adjustment</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We won&#39;t try to correct for more than 11% adjustments (110,000 ppm),</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">mult</span> <span class="o">*</span> <span class="mi">11</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clocksource_max_deferment - Returns max time the clocksource can be deferred</span>
<span class="cm"> * @cs:         Pointer to clocksource</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">clocksource_max_deferment</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">max_nsecs</span><span class="p">,</span> <span class="n">max_cycles</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the maximum number of cycles that we can pass to the</span>
<span class="cm">	 * cyc2ns function without overflowing a 64-bit signed result. The</span>
<span class="cm">	 * maximum number of cycles is equal to ULLONG_MAX/(cs-&gt;mult+cs-&gt;maxadj)</span>
<span class="cm">	 * which is equivalent to the below.</span>
<span class="cm">	 * max_cycles &lt; (2^63)/(cs-&gt;mult + cs-&gt;maxadj)</span>
<span class="cm">	 * max_cycles &lt; 2^(log2((2^63)/(cs-&gt;mult + cs-&gt;maxadj)))</span>
<span class="cm">	 * max_cycles &lt; 2^(log2(2^63) - log2(cs-&gt;mult + cs-&gt;maxadj))</span>
<span class="cm">	 * max_cycles &lt; 2^(63 - log2(cs-&gt;mult + cs-&gt;maxadj))</span>
<span class="cm">	 * max_cycles &lt; 1 &lt;&lt; (63 - log2(cs-&gt;mult + cs-&gt;maxadj))</span>
<span class="cm">	 * Please note that we add 1 to the result of the log2 to account for</span>
<span class="cm">	 * any rounding errors, ensure the above inequality is satisfied and</span>
<span class="cm">	 * no overflow will occur.</span>
<span class="cm">	 */</span>
	<span class="n">max_cycles</span> <span class="o">=</span> <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">63</span> <span class="o">-</span> <span class="p">(</span><span class="n">ilog2</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">mult</span> <span class="o">+</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">maxadj</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * The actual maximum number of cycles we can defer the clocksource is</span>
<span class="cm">	 * determined by the minimum of max_cycles and cs-&gt;mask.</span>
<span class="cm">	 * Note: Here we subtract the maxadj to make sure we don&#39;t sleep for</span>
<span class="cm">	 * too long if there&#39;s a large negative adjustment.</span>
<span class="cm">	 */</span>
	<span class="n">max_cycles</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">max_cycles</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">);</span>
	<span class="n">max_nsecs</span> <span class="o">=</span> <span class="n">clocksource_cyc2ns</span><span class="p">(</span><span class="n">max_cycles</span><span class="p">,</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">mult</span> <span class="o">-</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">maxadj</span><span class="p">,</span>
					<span class="n">cs</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * To ensure that the clocksource does not wrap whilst we are idle,</span>
<span class="cm">	 * limit the time the clocksource can be deferred by 12.5%. Please</span>
<span class="cm">	 * note a margin of 12.5% is used because this can be computed with</span>
<span class="cm">	 * a shift, versus say 10% which would require division.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">max_nsecs</span> <span class="o">-</span> <span class="p">(</span><span class="n">max_nsecs</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_ARCH_USES_GETTIMEOFFSET</span>

<span class="cm">/**</span>
<span class="cm"> * clocksource_select - Select the best clocksource available</span>
<span class="cm"> *</span>
<span class="cm"> * Private function. Must hold clocksource_mutex when called.</span>
<span class="cm"> *</span>
<span class="cm"> * Select the clocksource with the best rating, or the clocksource,</span>
<span class="cm"> * which is selected by userspace override.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">clocksource_select</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">best</span><span class="p">,</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">finished_booting</span> <span class="o">||</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* First clocksource on the list has the best rating. */</span>
	<span class="n">best</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clocksource</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="cm">/* Check for the override clocksource. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clocksource_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">override_name</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check to make sure we don&#39;t switch to a non-highres</span>
<span class="cm">		 * capable clocksource if the tick code is in oneshot</span>
<span class="cm">		 * mode (highres or nohz)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLOCK_SOURCE_VALID_FOR_HRES</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">tick_oneshot_mode_active</span><span class="p">())</span> <span class="p">{</span>
			<span class="cm">/* Override clocksource cannot be used. */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Override clocksource %s is not &quot;</span>
			       <span class="s">&quot;HRT compatible. Cannot switch while in &quot;</span>
			       <span class="s">&quot;HRT/NOHZ mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">override_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/* Override clocksource can be used. */</span>
			<span class="n">best</span> <span class="o">=</span> <span class="n">cs</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curr_clocksource</span> <span class="o">!=</span> <span class="n">best</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Switching to clocksource %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">best</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">curr_clocksource</span> <span class="o">=</span> <span class="n">best</span><span class="p">;</span>
		<span class="n">timekeeping_notify</span><span class="p">(</span><span class="n">curr_clocksource</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_ARCH_USES_GETTIMEOFFSET */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clocksource_select</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * clocksource_done_booting - Called near the end of core bootup</span>
<span class="cm"> *</span>
<span class="cm"> * Hack to avoid lots of clocksource churn at boot time.</span>
<span class="cm"> * We use fs_initcall because we want this to start before</span>
<span class="cm"> * device_initcall but after subsys_initcall.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">clocksource_done_booting</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
	<span class="n">curr_clocksource</span> <span class="o">=</span> <span class="n">clocksource_default_clock</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>

	<span class="n">finished_booting</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Run the watchdog first to eliminate unstable clock sources</span>
<span class="cm">	 */</span>
	<span class="n">clocksource_watchdog_kthread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
	<span class="n">clocksource_select</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">fs_initcall</span><span class="p">(</span><span class="n">clocksource_done_booting</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Enqueue the clocksource sorted by rating</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">clocksource_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">clocksource_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clocksource_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="cm">/* Keep track of the place, where to insert */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">rating</span> <span class="o">&gt;=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">rating</span><span class="p">)</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __clocksource_updatefreq_scale - Used update clocksource with new freq</span>
<span class="cm"> * @cs:		clocksource to be registered</span>
<span class="cm"> * @scale:	Scale factor multiplied against freq to get clocksource hz</span>
<span class="cm"> * @freq:	clocksource frequency (cycles per second) divided by scale</span>
<span class="cm"> *</span>
<span class="cm"> * This should only be called from the clocksource-&gt;enable() method.</span>
<span class="cm"> *</span>
<span class="cm"> * This *SHOULD NOT* be called directly! Please use the</span>
<span class="cm"> * clocksource_updatefreq_hz() or clocksource_updatefreq_khz helper functions.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__clocksource_updatefreq_scale</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">scale</span><span class="p">,</span> <span class="n">u32</span> <span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">sec</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Calc the maximum number of seconds which we can run before</span>
<span class="cm">	 * wrapping around. For clocksources which have a mask &gt; 32bit</span>
<span class="cm">	 * we need to limit the max sleep time to have a good</span>
<span class="cm">	 * conversion precision. 10 minutes is still a reasonable</span>
<span class="cm">	 * amount. That results in a shift value of 24 for a</span>
<span class="cm">	 * clocksource with mask &gt;= 40bit and f &gt;= 4GHz. That maps to</span>
<span class="cm">	 * ~ 0.06ppm granularity for NTP. We apply the same 12.5%</span>
<span class="cm">	 * margin as we do in clocksource_max_deferment()</span>
<span class="cm">	 */</span>
	<span class="n">sec</span> <span class="o">=</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">-</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">));</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">scale</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sec</span><span class="p">)</span>
		<span class="n">sec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sec</span> <span class="o">&gt;</span> <span class="mi">600</span> <span class="o">&amp;&amp;</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
		<span class="n">sec</span> <span class="o">=</span> <span class="mi">600</span><span class="p">;</span>

	<span class="n">clocks_calc_mult_shift</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span>
			       <span class="n">NSEC_PER_SEC</span> <span class="o">/</span> <span class="n">scale</span><span class="p">,</span> <span class="n">sec</span> <span class="o">*</span> <span class="n">scale</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * for clocksources that have large mults, to avoid overflow.</span>
<span class="cm">	 * Since mult may be adjusted by ntp, add an safety extra margin</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="n">cs</span><span class="o">-&gt;</span><span class="n">maxadj</span> <span class="o">=</span> <span class="n">clocksource_max_adjustment</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">mult</span> <span class="o">+</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">maxadj</span> <span class="o">&lt;</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">mult</span> <span class="o">-</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">maxadj</span> <span class="o">&gt;</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cs</span><span class="o">-&gt;</span><span class="n">mult</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cs</span><span class="o">-&gt;</span><span class="n">shift</span><span class="o">--</span><span class="p">;</span>
		<span class="n">cs</span><span class="o">-&gt;</span><span class="n">maxadj</span> <span class="o">=</span> <span class="n">clocksource_max_adjustment</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cs</span><span class="o">-&gt;</span><span class="n">max_idle_ns</span> <span class="o">=</span> <span class="n">clocksource_max_deferment</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__clocksource_updatefreq_scale</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __clocksource_register_scale - Used to install new clocksources</span>
<span class="cm"> * @cs:		clocksource to be registered</span>
<span class="cm"> * @scale:	Scale factor multiplied against freq to get clocksource hz</span>
<span class="cm"> * @freq:	clocksource frequency (cycles per second) divided by scale</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -EBUSY if registration fails, zero otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * This *SHOULD NOT* be called directly! Please use the</span>
<span class="cm"> * clocksource_register_hz() or clocksource_register_khz helper functions.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__clocksource_register_scale</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">scale</span><span class="p">,</span> <span class="n">u32</span> <span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* Initialize mult/shift and max_idle_ns */</span>
	<span class="n">__clocksource_updatefreq_scale</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>

	<span class="cm">/* Add clocksource to the clcoksource list */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
	<span class="n">clocksource_enqueue</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="n">clocksource_enqueue_watchdog</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="n">clocksource_select</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__clocksource_register_scale</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * clocksource_register - Used to install new clocksources</span>
<span class="cm"> * @cs:		clocksource to be registered</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -EBUSY if registration fails, zero otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clocksource_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* calculate max adjustment for given mult/shift */</span>
	<span class="n">cs</span><span class="o">-&gt;</span><span class="n">maxadj</span> <span class="o">=</span> <span class="n">clocksource_max_adjustment</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">mult</span> <span class="o">+</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">maxadj</span> <span class="o">&lt;</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">mult</span><span class="p">,</span>
		<span class="s">&quot;Clocksource %s might overflow on 11%% adjustment</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cs</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* calculate max idle time permitted for this clocksource */</span>
	<span class="n">cs</span><span class="o">-&gt;</span><span class="n">max_idle_ns</span> <span class="o">=</span> <span class="n">clocksource_max_deferment</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
	<span class="n">clocksource_enqueue</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="n">clocksource_enqueue_watchdog</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="n">clocksource_select</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">clocksource_register</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__clocksource_change_rating</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rating</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">cs</span><span class="o">-&gt;</span><span class="n">rating</span> <span class="o">=</span> <span class="n">rating</span><span class="p">;</span>
	<span class="n">clocksource_enqueue</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="n">clocksource_select</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clocksource_change_rating - Change the rating of a registered clocksource</span>
<span class="cm"> * @cs:		clocksource to be changed</span>
<span class="cm"> * @rating:	new rating</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clocksource_change_rating</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rating</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
	<span class="n">__clocksource_change_rating</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">rating</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">clocksource_change_rating</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * clocksource_unregister - remove a registered clocksource</span>
<span class="cm"> * @cs:	clocksource to be unregistered</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clocksource_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
	<span class="n">clocksource_dequeue_watchdog</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">clocksource_select</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">clocksource_unregister</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SYSFS</span>
<span class="cm">/**</span>
<span class="cm"> * sysfs_show_current_clocksources - sysfs interface for current clocksource</span>
<span class="cm"> * @dev:	unused</span>
<span class="cm"> * @attr:	unused</span>
<span class="cm"> * @buf:	char buffer to be filled with clocksource list</span>
<span class="cm"> *</span>
<span class="cm"> * Provides sysfs interface for listing current clocksource.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sysfs_show_current_clocksources</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">curr_clocksource</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sysfs_override_clocksource - interface for manually overriding clocksource</span>
<span class="cm"> * @dev:	unused</span>
<span class="cm"> * @attr:	unused</span>
<span class="cm"> * @buf:	name of override clocksource</span>
<span class="cm"> * @count:	length of buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Takes input from sysfs interface for manually overriding the default</span>
<span class="cm"> * clocksource selection.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sysfs_override_clocksource</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/* strings from sysfs write are not 0 terminated! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">override_name</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* strip of \n: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="n">count</span><span class="o">--</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">override_name</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">override_name</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">clocksource_select</span><span class="p">();</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sysfs_show_available_clocksources - sysfs interface for listing clocksource</span>
<span class="cm"> * @dev:	unused</span>
<span class="cm"> * @attr:	unused</span>
<span class="cm"> * @buf:	char buffer to be filled with clocksource list</span>
<span class="cm"> *</span>
<span class="cm"> * Provides sysfs interface for listing registered clocksources</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sysfs_show_available_clocksources</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clocksource</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clocksource_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t show non-HRES clocksource if the tick code is</span>
<span class="cm">		 * in one shot mode (highres=on or nohz=on)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tick_oneshot_mode_active</span><span class="p">()</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLOCK_SOURCE_VALID_FOR_HRES</span><span class="p">))</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">count</span><span class="p">,</span>
				  <span class="n">max</span><span class="p">((</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">count</span><span class="p">,</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span><span class="mi">0</span><span class="p">),</span>
				  <span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>

	<span class="n">count</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">count</span><span class="p">,</span>
			  <span class="n">max</span><span class="p">((</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">count</span><span class="p">,</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sysfs setup bits:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">current_clocksource</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">sysfs_show_current_clocksources</span><span class="p">,</span>
		   <span class="n">sysfs_override_clocksource</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">available_clocksource</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span>
		   <span class="n">sysfs_show_available_clocksources</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">clocksource_subsys</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;clocksource&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_name</span> <span class="o">=</span> <span class="s">&quot;clocksource&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device</span> <span class="n">device_clocksource</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">id</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bus</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">clocksource_subsys</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_clocksource_sysfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">subsys_system_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_subsys</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_clocksource</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">device_clocksource</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dev_attr_current_clocksource</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">device_clocksource</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dev_attr_available_clocksource</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">device_initcall</span><span class="p">(</span><span class="n">init_clocksource_sysfs</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SYSFS */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * boot_override_clocksource - boot clock override</span>
<span class="cm"> * @str:	override name</span>
<span class="cm"> *</span>
<span class="cm"> * Takes a clocksource= boot argument and uses it</span>
<span class="cm"> * as the clocksource override name.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">boot_override_clocksource</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">)</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">override_name</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">override_name</span><span class="p">));</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clocksource_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;clocksource=&quot;</span><span class="p">,</span> <span class="n">boot_override_clocksource</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * boot_override_clock - Compatibility layer for deprecated boot option</span>
<span class="cm"> * @str:	override name</span>
<span class="cm"> *</span>
<span class="cm"> * DEPRECATED! Takes a clock= boot argument and uses it</span>
<span class="cm"> * as the clocksource override name</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">boot_override_clock</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;pmtmr&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Warning: clock=pmtmr is deprecated. &quot;</span>
			<span class="s">&quot;Use clocksource=acpi_pm.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">boot_override_clocksource</span><span class="p">(</span><span class="s">&quot;acpi_pm&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Warning! clock= boot option is deprecated. &quot;</span>
		<span class="s">&quot;Use clocksource=xyz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">boot_override_clocksource</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;clock=&quot;</span><span class="p">,</span> <span class="n">boot_override_clock</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
