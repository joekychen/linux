<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › time › timer_stats.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>timer_stats.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * kernel/time/timer_stats.c</span>
<span class="cm"> *</span>
<span class="cm"> * Collect timer usage statistics.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(C) 2006, Red Hat, Inc., Ingo Molnar</span>
<span class="cm"> * Copyright(C) 2006 Timesys Corp., Thomas Gleixner &lt;tglx@timesys.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * timer_stats is based on timer_top, a similar functionality which was part of</span>
<span class="cm"> * Con Kolivas dyntick patch set. It was developed by Daniel Petrini at the</span>
<span class="cm"> * Instituto Nokia de Tecnologia - INdT - Manaus. timer_top&#39;s design was based</span>
<span class="cm"> * on dynamic allocation of the statistics entries and linear search based</span>
<span class="cm"> * lookup combined with a global lock, rather than the static array, hash</span>
<span class="cm"> * and per-CPU locking which is used by timer_stats. It was written for the</span>
<span class="cm"> * pre hrtimer kernel code and therefore did not take hrtimers into account.</span>
<span class="cm"> * Nevertheless it provided the base for the timer_stats implementation and</span>
<span class="cm"> * was a helpful source of inspiration. Kudos to Daniel and the Nokia folks</span>
<span class="cm"> * for this effort.</span>
<span class="cm"> *</span>
<span class="cm"> * timer_top.c is</span>
<span class="cm"> *	Copyright (C) 2005 Instituto Nokia de Tecnologia - INdT - Manaus</span>
<span class="cm"> *	Written by Daniel Petrini &lt;d.pensator@gmail.com&gt;</span>
<span class="cm"> *	timer_top.c was released under the GNU General Public License version 2</span>
<span class="cm"> *</span>
<span class="cm"> * We export the addresses and counting of timer functions being called,</span>
<span class="cm"> * the pid and cmdline from the owner process if applicable.</span>
<span class="cm"> *</span>
<span class="cm"> * Start/stop data collection:</span>
<span class="cm"> * # echo [1|0] &gt;/proc/timer_stats</span>
<span class="cm"> *</span>
<span class="cm"> * Display the information collected so far:</span>
<span class="cm"> * # cat /proc/timer_stats</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * This is our basic unit of interest: a timer expiry event identified</span>
<span class="cm"> * by the timer, its start/expire functions and the PID of the task that</span>
<span class="cm"> * started the timer. We count the number of times an event happens:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">entry</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Hash list:</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">entry</span>		<span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Hash keys:</span>
<span class="cm">	 */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">timer</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">start_func</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">expire_func</span><span class="p">;</span>
	<span class="n">pid_t</span>			<span class="n">pid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Number of timeout events:</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">timer_flag</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We save the command-line string to preserve</span>
<span class="cm">	 * this information past task exit:</span>
<span class="cm">	 */</span>
	<span class="kt">char</span>			<span class="n">comm</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

<span class="p">}</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Spinlock protecting the tables - not taken during lookup:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_RAW_SPINLOCK</span><span class="p">(</span><span class="n">table_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Per-CPU lookup locks for fast hash lookup:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">raw_spinlock_t</span><span class="p">,</span> <span class="n">tstats_lookup_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Mutex to serialize state changes with show-stats activities:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">show_mutex</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Collection status, active/inactive:</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__read_mostly</span> <span class="n">timer_stats_active</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Beginning/end timestamps of measurement:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ktime_t</span> <span class="n">time_start</span><span class="p">,</span> <span class="n">time_stop</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * tstat entry structs only get allocated while collection is</span>
<span class="cm"> * active and never freed during that time - this simplifies</span>
<span class="cm"> * things quite a bit.</span>
<span class="cm"> *</span>
<span class="cm"> * They get freed when a new collection period is started.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_ENTRIES_BITS	10</span>
<span class="cp">#define MAX_ENTRIES		(1UL &lt;&lt; MAX_ENTRIES_BITS)</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_entries</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">entry</span> <span class="n">entries</span><span class="p">[</span><span class="n">MAX_ENTRIES</span><span class="p">];</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">overflow_count</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The entries are in a hash-table, for fast lookup:</span>
<span class="cm"> */</span>
<span class="cp">#define TSTAT_HASH_BITS		(MAX_ENTRIES_BITS - 1)</span>
<span class="cp">#define TSTAT_HASH_SIZE		(1UL &lt;&lt; TSTAT_HASH_BITS)</span>
<span class="cp">#define TSTAT_HASH_MASK		(TSTAT_HASH_SIZE - 1)</span>

<span class="cp">#define __tstat_hashfn(entry)						\</span>
<span class="cp">	(((unsigned long)(entry)-&gt;timer       ^				\</span>
<span class="cp">	  (unsigned long)(entry)-&gt;start_func  ^				\</span>
<span class="cp">	  (unsigned long)(entry)-&gt;expire_func ^				\</span>
<span class="cp">	  (unsigned long)(entry)-&gt;pid		) &amp; TSTAT_HASH_MASK)</span>

<span class="cp">#define tstat_hashentry(entry)	(tstat_hash_table + __tstat_hashfn(entry))</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">entry</span> <span class="o">*</span><span class="n">tstat_hash_table</span><span class="p">[</span><span class="n">TSTAT_HASH_SIZE</span><span class="p">]</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_entries</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nr_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">entries</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tstat_hash_table</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tstat_hash_table</span><span class="p">));</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">overflow_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">entry</span> <span class="o">*</span><span class="nf">alloc_entry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_entries</span> <span class="o">&gt;=</span> <span class="n">MAX_ENTRIES</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">entries</span> <span class="o">+</span> <span class="n">nr_entries</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">match_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">entry</span> <span class="o">*</span><span class="n">entry1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">entry</span> <span class="o">*</span><span class="n">entry2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">entry1</span><span class="o">-&gt;</span><span class="n">timer</span>       <span class="o">==</span> <span class="n">entry2</span><span class="o">-&gt;</span><span class="n">timer</span>	  <span class="o">&amp;&amp;</span>
	       <span class="n">entry1</span><span class="o">-&gt;</span><span class="n">start_func</span>  <span class="o">==</span> <span class="n">entry2</span><span class="o">-&gt;</span><span class="n">start_func</span>  <span class="o">&amp;&amp;</span>
	       <span class="n">entry1</span><span class="o">-&gt;</span><span class="n">expire_func</span> <span class="o">==</span> <span class="n">entry2</span><span class="o">-&gt;</span><span class="n">expire_func</span> <span class="o">&amp;&amp;</span>
	       <span class="n">entry1</span><span class="o">-&gt;</span><span class="n">pid</span>	   <span class="o">==</span> <span class="n">entry2</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up whether an entry matching this item is present</span>
<span class="cm"> * in the hash already. Must be called with irqs off and the</span>
<span class="cm"> * lookup lock held:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">entry</span> <span class="o">*</span><span class="nf">tstat_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">comm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">entry</span> <span class="o">**</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">tstat_hashentry</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">curr</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The fastpath is when the entry is already hashed,</span>
<span class="cm">	 * we do this with the lookup lock held, but with the</span>
<span class="cm">	 * table lock not held:</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_entries</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">entry</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">curr</span><span class="p">;</span>

		<span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Slowpath: allocate, set up and link a new hash entry:</span>
<span class="cm">	 */</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">curr</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure we have not raced with another CPU:</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match_entries</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">entry</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

		<span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">curr</span> <span class="o">=</span> <span class="n">alloc_entry</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">TASK_COMM_LEN</span><span class="p">);</span>

		<span class="n">smp_mb</span><span class="p">();</span> <span class="cm">/* Ensure that curr is initialized before insert */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span>
			<span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out_unlock:</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">curr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * timer_stats_update_stats - Update the statistics for a timer.</span>
<span class="cm"> * @timer:	pointer to either a timer_list or a hrtimer</span>
<span class="cm"> * @pid:	the pid of the task which set up the timer</span>
<span class="cm"> * @startf:	pointer to the function which did the timer setup</span>
<span class="cm"> * @timerf:	pointer to the timer callback function of the timer</span>
<span class="cm"> * @comm:	name of the process which set up the timer</span>
<span class="cm"> *</span>
<span class="cm"> * When the timer is already registered, then the event counter is</span>
<span class="cm"> * incremented. Otherwise the timer is registered in a free slot.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">timer_stats_update_stats</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">startf</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">timerf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">comm</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timer_flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * It doesn&#39;t matter which lock we take:</span>
<span class="cm">	 */</span>
	<span class="n">raw_spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="n">input</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">timer_stats_active</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">tstats_lookup_lock</span><span class="p">,</span> <span class="n">raw_smp_processor_id</span><span class="p">());</span>

	<span class="n">input</span><span class="p">.</span><span class="n">timer</span> <span class="o">=</span> <span class="n">timer</span><span class="p">;</span>
	<span class="n">input</span><span class="p">.</span><span class="n">start_func</span> <span class="o">=</span> <span class="n">startf</span><span class="p">;</span>
	<span class="n">input</span><span class="p">.</span><span class="n">expire_func</span> <span class="o">=</span> <span class="n">timerf</span><span class="p">;</span>
	<span class="n">input</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
	<span class="n">input</span><span class="p">.</span><span class="n">timer_flag</span> <span class="o">=</span> <span class="n">timer_flag</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer_stats_active</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">tstat_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">,</span> <span class="n">comm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">overflow_count</span><span class="p">);</span>

 <span class="nl">out_unlock:</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_name_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">symname</span><span class="p">[</span><span class="n">KSYM_NAME_LEN</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lookup_symbol_name</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">symname</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;&lt;%p&gt;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">symname</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tstats_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">period</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ms</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">show_mutex</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If still active then calculate up to now:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer_stats_active</span><span class="p">)</span>
		<span class="n">time_stop</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>

	<span class="n">time</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">time_stop</span><span class="p">,</span> <span class="n">time_start</span><span class="p">);</span>

	<span class="n">period</span> <span class="o">=</span> <span class="n">ktime_to_timespec</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>
	<span class="n">ms</span> <span class="o">=</span> <span class="n">period</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">;</span>

	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Timer Stats Version: v0.2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Sample period: %ld.%03ld s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">period</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">overflow_count</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Overflow: %d entries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">overflow_count</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">entries</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
 		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">timer_flag</span> <span class="o">&amp;</span> <span class="n">TIMER_STATS_FLAG_DEFERRABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%4luD, %5d %-16s &quot;</span><span class="p">,</span>
				<span class="n">entry</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; %4lu, %5d %-16s &quot;</span><span class="p">,</span>
				<span class="n">entry</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">print_name_offset</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">start_func</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; (&quot;</span><span class="p">);</span>
		<span class="n">print_name_offset</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">expire_func</span><span class="p">);</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">events</span> <span class="o">+=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ms</span> <span class="o">+=</span> <span class="n">period</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ms</span><span class="p">)</span>
		<span class="n">ms</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;&amp;</span> <span class="n">period</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%ld total events, %ld.%03ld events/sec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">events</span><span class="p">,</span> <span class="n">events</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">ms</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">events</span> <span class="o">*</span> <span class="mi">1000000</span> <span class="o">/</span> <span class="n">ms</span><span class="p">)</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%ld total events</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">events</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">show_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * After a state change, make sure all concurrent lookup/update</span>
<span class="cm"> * activities have stopped:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sync_access</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spinlock_t</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">tstats_lookup_lock</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* nothing */</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">tstats_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">ctl</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span> <span class="o">*</span><span class="n">offs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">ctl</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">show_mutex</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ctl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;0&#39;</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">timer_stats_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">timer_stats_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">time_stop</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
			<span class="n">sync_access</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="sc">&#39;1&#39;</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer_stats_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reset_entries</span><span class="p">();</span>
			<span class="n">time_start</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
			<span class="n">smp_mb</span><span class="p">();</span>
			<span class="n">timer_stats_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">show_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tstats_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">tstats_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tstats_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tstats_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">tstats_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_timer_stats</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">tstats_lookup_lock</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_tstats_procfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">pe</span><span class="p">;</span>

	<span class="n">pe</span> <span class="o">=</span> <span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;timer_stats&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tstats_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pe</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__initcall</span><span class="p">(</span><span class="n">init_tstats_procfs</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
