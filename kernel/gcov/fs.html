<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › gcov › fs.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>fs.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  This code exports profiling data as debugfs files to userspace.</span>
<span class="cm"> *</span>
<span class="cm"> *    Copyright IBM Corp. 2009</span>
<span class="cm"> *    Author(s): Peter Oberparleiter &lt;oberpar@linux.vnet.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *    Uses gcc-internal data definitions.</span>
<span class="cm"> *    Based on the gcov-kernel patch by:</span>
<span class="cm"> *		 Hubertus Franke &lt;frankeh@us.ibm.com&gt;</span>
<span class="cm"> *		 Nigel Hinds &lt;nhinds@us.ibm.com&gt;</span>
<span class="cm"> *		 Rajan Ravindran &lt;rajancr@us.ibm.com&gt;</span>
<span class="cm"> *		 Peter Oberparleiter &lt;oberpar@linux.vnet.ibm.com&gt;</span>
<span class="cm"> *		 Paul Larson</span>
<span class="cm"> *		 Yi CDL Yang</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt)	&quot;gcov: &quot; fmt</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &quot;gcov.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * struct gcov_node - represents a debugfs entry</span>
<span class="cm"> * @list: list head for child node list</span>
<span class="cm"> * @children: child nodes</span>
<span class="cm"> * @all: list head for list of all nodes</span>
<span class="cm"> * @parent: parent node</span>
<span class="cm"> * @loaded_info: array of pointers to profiling data sets for loaded object</span>
<span class="cm"> *   files.</span>
<span class="cm"> * @num_loaded: number of profiling data sets for loaded object files.</span>
<span class="cm"> * @unloaded_info: accumulated copy of profiling data sets for unloaded</span>
<span class="cm"> *   object files. Used only when gcov_persist=1.</span>
<span class="cm"> * @dentry: main debugfs entry, either a directory or data file</span>
<span class="cm"> * @links: associated symbolic links</span>
<span class="cm"> * @name: data file basename</span>
<span class="cm"> *</span>
<span class="cm"> * struct gcov_node represents an entity within the gcov/ subdirectory</span>
<span class="cm"> * of debugfs. There are directory and data file nodes. The latter represent</span>
<span class="cm"> * the actual synthesized data file plus any associated symbolic links which</span>
<span class="cm"> * are needed by the gcov tool to work correctly.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gcov_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">children</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">all</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">**</span><span class="n">loaded_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="n">unloaded_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">**</span><span class="n">links</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_loaded</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">objtree</span><span class="p">[]</span> <span class="o">=</span> <span class="n">OBJTREE</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">srctree</span><span class="p">[]</span> <span class="o">=</span> <span class="n">SRCTREE</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gcov_node</span> <span class="n">root_node</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">reset_dentry</span><span class="p">;</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">all_head</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">node_lock</span><span class="p">);</span>

<span class="cm">/* If non-zero, keep copies of profiling data for unloaded modules. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">gcov_persist</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">gcov_persist_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strict_strtoul</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;invalid gcov_persist parameter &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">gcov_persist</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;setting gcov_persist to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gcov_persist</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;gcov_persist=&quot;</span><span class="p">,</span> <span class="n">gcov_persist_setup</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * seq_file.start() implementation for gcov data files. Note that the</span>
<span class="cm"> * gcov_iterator interface is designed to be more restrictive than seq_file</span>
<span class="cm"> * (no start from arbitrary position, etc.), to simplify the iterator</span>
<span class="cm"> * implementation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">gcov_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">gcov_iter_start</span><span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gcov_iter_next</span><span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* seq_file.next() implementation for gcov data files. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">gcov_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gcov_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gcov_iter_next</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">iter</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* seq_file.show() implementation for gcov data files. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gcov_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gcov_iterator</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gcov_iter_write</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gcov_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Unused. */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">gcov_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">gcov_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>	<span class="o">=</span> <span class="n">gcov_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">gcov_seq_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>	<span class="o">=</span> <span class="n">gcov_seq_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Return a profiling data set associated with the given node. This is</span>
<span class="cm"> * either a data set for a loaded object file or a data set copy in case</span>
<span class="cm"> * all associated object files have been unloaded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="nf">get_node_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_loaded</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">unloaded_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return a newly allocated profiling data set which contains the sum of</span>
<span class="cm"> * all profiling data associated with the given node.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="nf">get_accumulated_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">unloaded_info</span><span class="p">)</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">gcov_info_dup</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">unloaded_info</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">gcov_info_dup</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">num_loaded</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">gcov_info_add</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">info</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * open() implementation for gcov data files. Create a copy of the profiling</span>
<span class="cm"> * data set and initialize the iterator and seq_file interface.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gcov_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gcov_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Read from a profiling data copy to minimize reference tracking</span>
<span class="cm">	 * complexity and concurrent access and to keep accumulating multiple</span>
<span class="cm">	 * profiling data sets associated with one node simple.</span>
<span class="cm">	 */</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">get_accumulated_info</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">iter</span> <span class="o">=</span> <span class="n">gcov_iter_new</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_info</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gcov_seq_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_iter_info</span><span class="p">;</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">iter</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="nl">err_free_iter_info:</span>
	<span class="n">gcov_iter_free</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="nl">err_free_info:</span>
	<span class="n">gcov_info_free</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * release() implementation for gcov data files. Release resources allocated</span>
<span class="cm"> * by open().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gcov_seq_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gcov_iterator</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">gcov_iter_get_info</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
	<span class="n">gcov_iter_free</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
	<span class="n">gcov_info_free</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">seq_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find a node by the associated data file name. Needs to be called with</span>
<span class="cm"> * node_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="nf">get_node_by_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">all_head</span><span class="p">,</span> <span class="n">all</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">get_node_info</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">node</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reset all profiling data associated with the specified node.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">unloaded_info</span><span class="p">)</span>
		<span class="n">gcov_info_reset</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">unloaded_info</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">num_loaded</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">gcov_info_reset</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">remove_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * write() implementation for gcov data files. Reset profiling data for the</span>
<span class="cm"> * corresponding file. If all associated object files have been unloaded,</span>
<span class="cm"> * remove the debug fs node as well.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">gcov_seq_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">gcov_iter_get_info</span><span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_lock</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">get_node_by_name</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Reset counts or remove node for unloaded modules. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_loaded</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">remove_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">reset_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Reset counts for open file. */</span>
	<span class="n">gcov_info_reset</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Given a string &lt;path&gt; representing a file path of format:</span>
<span class="cm"> *   path/to/file.gcda</span>
<span class="cm"> * construct and return a new string:</span>
<span class="cm"> *   &lt;dir/&gt;path/to/file.&lt;ext&gt;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">link_target</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ext</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">old_ext</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">copy</span><span class="p">;</span>

	<span class="n">copy</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copy</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">old_ext</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_ext</span><span class="p">)</span>
		<span class="o">*</span><span class="n">old_ext</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="p">)</span>
		<span class="n">target</span> <span class="o">=</span> <span class="n">kasprintf</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="s">&quot;%s/%s.%s&quot;</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">ext</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">target</span> <span class="o">=</span> <span class="n">kasprintf</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="s">&quot;%s.%s&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">ext</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">copy</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">target</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Construct a string representing the symbolic link target for the given</span>
<span class="cm"> * gcov data file name and link type. Depending on the link type and the</span>
<span class="cm"> * location of the data file, the link target can either point to a</span>
<span class="cm"> * subdirectory of srctree, objtree or in an external location.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_link_target</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">gcov_link</span> <span class="o">*</span><span class="n">ext</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rel</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">objtree</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">objtree</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rel</span> <span class="o">=</span> <span class="n">filename</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">objtree</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">==</span> <span class="n">SRC_TREE</span><span class="p">)</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">link_target</span><span class="p">(</span><span class="n">srctree</span><span class="p">,</span> <span class="n">rel</span><span class="p">,</span> <span class="n">ext</span><span class="o">-&gt;</span><span class="n">ext</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">link_target</span><span class="p">(</span><span class="n">objtree</span><span class="p">,</span> <span class="n">rel</span><span class="p">,</span> <span class="n">ext</span><span class="o">-&gt;</span><span class="n">ext</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* External compilation. */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">link_target</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">ext</span><span class="o">-&gt;</span><span class="n">ext</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define SKEW_PREFIX	&quot;.tmp_&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * For a filename .tmp_filename.ext return filename.ext. Needed to compensate</span>
<span class="cm"> * for filename skewing caused by the mod-versioning mechanism.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">deskew</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">basename</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">basename</span><span class="p">,</span> <span class="n">SKEW_PREFIX</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SKEW_PREFIX</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">basename</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SKEW_PREFIX</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">basename</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create links to additional files (usually .c and .gcno files) which the</span>
<span class="cm"> * gcov tool expects to find in the same directory as the gcov data file.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_links</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">basename</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">gcov_link</span><span class="p">[</span><span class="n">num</span><span class="p">].</span><span class="n">ext</span><span class="p">;</span> <span class="n">num</span><span class="o">++</span><span class="p">)</span>
		<span class="cm">/* Nothing. */</span><span class="p">;</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">links</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">target</span> <span class="o">=</span> <span class="n">get_link_target</span><span class="p">(</span><span class="n">get_node_info</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">gcov_link</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">target</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="n">basename</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">basename</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="n">basename</span><span class="o">++</span><span class="p">;</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">debugfs_create_symlink</span><span class="p">(</span><span class="n">deskew</span><span class="p">(</span><span class="n">basename</span><span class="p">),</span>
							<span class="n">parent</span><span class="p">,</span>	<span class="n">target</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">);</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">links</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">gcov_data_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">gcov_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">gcov_seq_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">gcov_seq_write</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Basic initialization of a new node. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">all</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">num_loaded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create a new node and associated debugfs entry. Needs to be called with</span>
<span class="cm"> * node_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="nf">new_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_node</span><span class="p">)</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_nomem</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="p">),</span>
					   <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_nomem</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">init_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="cm">/* Differentiate between gcov data file nodes and directory nodes. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">deskew</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span> <span class="mo">0600</span><span class="p">,</span>
					<span class="n">parent</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gcov_data_fops</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;could not create file</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span>
		<span class="n">add_links</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">all</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">all_head</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">node</span><span class="p">;</span>

<span class="nl">err_nomem:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remove symbolic links associated with node. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_links</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">gcov_link</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ext</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">links</span><span class="p">);</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">links</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove node from all lists and debugfs and release associated resources.</span>
<span class="cm"> * Needs to be called with node_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">all</span><span class="p">);</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">remove_links</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">unloaded_info</span><span class="p">)</span>
		<span class="n">gcov_info_free</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">unloaded_info</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Release node and empty parents. Needs to be called with node_lock held. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">node</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">root_node</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="n">release_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find child node with given basename. Needs to be called with node_lock</span>
<span class="cm"> * held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="nf">get_child_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
					   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">node</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * write() implementation for reset file. Reset all profiling data to zero</span>
<span class="cm"> * and remove nodes for which all associated object files are unloaded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">reset_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_lock</span><span class="p">);</span>
<span class="nl">restart:</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">all_head</span><span class="p">,</span> <span class="n">all</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_loaded</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">reset_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">remove_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
			<span class="cm">/* Several nodes may have gone - restart loop. */</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* read() implementation for reset file. Unused. */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">reset_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			  <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Allow read operation so that a recursive copy won&#39;t fail. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">gcov_reset_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">write</span>	<span class="o">=</span> <span class="n">reset_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>	<span class="o">=</span> <span class="n">reset_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Create a node for a given profiling data set and add it to all lists and</span>
<span class="cm"> * debugfs. Needs to be called with node_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">filename</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filename</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root_node</span><span class="p">;</span>
	<span class="cm">/* Create directory nodes along the path. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">curr</span> <span class="o">=</span> <span class="n">filename</span><span class="p">;</span> <span class="p">(</span><span class="n">next</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">));</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr</span> <span class="o">==</span> <span class="n">next</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="s">&quot;..&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_remove</span><span class="p">;</span>
			<span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">get_child_by_name</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_remove</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Create file node. */</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_remove</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">err_remove:</span>
	<span class="n">remove_node</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Associate a profiling data set with an existing node. Needs to be called</span>
<span class="cm"> * with node_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">**</span><span class="n">loaded_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">num_loaded</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prepare new array. This is done first to simplify cleanup in</span>
<span class="cm">	 * case the new data set is incompatible, the node only contains</span>
<span class="cm">	 * unloaded data sets and there&#39;s not enough memory for the array.</span>
<span class="cm">	 */</span>
	<span class="n">loaded_info</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loaded_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;could not add &#39;%s&#39; (out of memory)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">info</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">loaded_info</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span><span class="p">,</span>
	       <span class="n">num</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="p">));</span>
	<span class="n">loaded_info</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="cm">/* Check if the new data set is compatible. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * A module was unloaded, modified and reloaded. The new</span>
<span class="cm">		 * data set replaces the copy of the last one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gcov_info_is_compatible</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">unloaded_info</span><span class="p">,</span> <span class="n">info</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;discarding saved data for %s &quot;</span>
				   <span class="s">&quot;(incompatible version)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
			<span class="n">gcov_info_free</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">unloaded_info</span><span class="p">);</span>
			<span class="n">node</span><span class="o">-&gt;</span><span class="n">unloaded_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Two different versions of the same object file are loaded.</span>
<span class="cm">		 * The initial one takes precedence.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gcov_info_is_compatible</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">info</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;could not add &#39;%s&#39; (incompatible &quot;</span>
				   <span class="s">&quot;version)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">loaded_info</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Overwrite previous array. */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span><span class="p">);</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span> <span class="o">=</span> <span class="n">loaded_info</span><span class="p">;</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">num_loaded</span> <span class="o">=</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the index of a profiling data set associated with a node.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_info_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">num_loaded</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">info</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Save the data of a profiling data set which is being unloaded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">save_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">unloaded_info</span><span class="p">)</span>
		<span class="n">gcov_info_add</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">unloaded_info</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">unloaded_info</span> <span class="o">=</span> <span class="n">gcov_info_dup</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">unloaded_info</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;could not save data for &#39;%s&#39; &quot;</span>
				   <span class="s">&quot;(out of memory)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Disassociate a profiling data set from a node. Needs to be called with</span>
<span class="cm"> * node_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">get_info_index</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;could not remove &#39;%s&#39; (not found)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">info</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gcov_persist</span><span class="p">)</span>
		<span class="n">save_info</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="cm">/* Shrink array. */</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span><span class="p">[</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_loaded</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">num_loaded</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">num_loaded</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* Last loaded data set was removed. */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span><span class="p">);</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">loaded_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">num_loaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">unloaded_info</span><span class="p">)</span>
		<span class="n">remove_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Callback to create/remove profiling files when code compiled with</span>
<span class="cm"> * -fprofile-arcs is loaded/unloaded.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">gcov_event</span><span class="p">(</span><span class="k">enum</span> <span class="n">gcov_action</span> <span class="n">action</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gcov_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gcov_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_lock</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">get_node_by_name</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GCOV_ADD</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span>
			<span class="n">add_info</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">add_node</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GCOV_REMOVE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span>
			<span class="n">remove_info</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;could not remove &#39;%s&#39; (not found)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">info</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Create debugfs entries. */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">gcov_fs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">init_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_node</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * /sys/kernel/debug/gcov will be parent for the reset control file</span>
<span class="cm">	 * and all profiling files.</span>
<span class="cm">	 */</span>
	<span class="n">root_node</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;gcov&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root_node</span><span class="p">.</span><span class="n">dentry</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_remove</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Create reset file which resets all profiling counts when written</span>
<span class="cm">	 * to.</span>
<span class="cm">	 */</span>
	<span class="n">reset_dentry</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;reset&quot;</span><span class="p">,</span> <span class="mo">0600</span><span class="p">,</span> <span class="n">root_node</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span>
					   <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gcov_reset_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reset_dentry</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_remove</span><span class="p">;</span>
	<span class="cm">/* Replay previous events to get our fs hierarchy up-to-date. */</span>
	<span class="n">gcov_enable_events</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_remove:</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;init failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root_node</span><span class="p">.</span><span class="n">dentry</span><span class="p">)</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">root_node</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">device_initcall</span><span class="p">(</span><span class="n">gcov_fs_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
