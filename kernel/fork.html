<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › fork.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>fork.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/kernel/fork.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *  &#39;fork.c&#39; contains the help-routines for the &#39;fork&#39; system call</span>
<span class="cm"> * (see also entry.S and others).</span>
<span class="cm"> * Fork is rather simple, once you get the hang of it, but the memory</span>
<span class="cm"> * management can be a bitch. See &#39;mm/memory.c&#39;: &#39;copy_page_range()&#39;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/personality.h&gt;</span>
<span class="cp">#include &lt;linux/mempolicy.h&gt;</span>
<span class="cp">#include &lt;linux/sem.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fdtable.h&gt;</span>
<span class="cp">#include &lt;linux/iocontext.h&gt;</span>
<span class="cp">#include &lt;linux/key.h&gt;</span>
<span class="cp">#include &lt;linux/binfmts.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/mmu_notifier.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/cgroup.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/seccomp.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/futex.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/task_io_accounting_ops.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/memcontrol.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/profile.h&gt;</span>
<span class="cp">#include &lt;linux/rmap.h&gt;</span>
<span class="cp">#include &lt;linux/ksm.h&gt;</span>
<span class="cp">#include &lt;linux/acct.h&gt;</span>
<span class="cp">#include &lt;linux/tsacct_kern.h&gt;</span>
<span class="cp">#include &lt;linux/cn_proc.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/delayacct.h&gt;</span>
<span class="cp">#include &lt;linux/taskstats_kern.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/fs_struct.h&gt;</span>
<span class="cp">#include &lt;linux/magic.h&gt;</span>
<span class="cp">#include &lt;linux/perf_event.h&gt;</span>
<span class="cp">#include &lt;linux/posix-timers.h&gt;</span>
<span class="cp">#include &lt;linux/user-return-notifier.h&gt;</span>
<span class="cp">#include &lt;linux/oom.h&gt;</span>
<span class="cp">#include &lt;linux/khugepaged.h&gt;</span>
<span class="cp">#include &lt;linux/signalfd.h&gt;</span>
<span class="cp">#include &lt;linux/uprobes.h&gt;</span>

<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/pgalloc.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>

<span class="cp">#include &lt;trace/events/sched.h&gt;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/task.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Protected counters by write_lock_irq(&amp;tasklist_lock)</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_forks</span><span class="p">;</span>	<span class="cm">/* Handle normal Linux uptimes. */</span>
<span class="kt">int</span> <span class="n">nr_threads</span><span class="p">;</span>			<span class="cm">/* The idle threads do not count.. */</span>

<span class="kt">int</span> <span class="n">max_threads</span><span class="p">;</span>		<span class="cm">/* tunable limit on nr_threads */</span>

<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">process_counts</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">__cacheline_aligned</span> <span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">tasklist_lock</span><span class="p">);</span>  <span class="cm">/* outer */</span>

<span class="cp">#ifdef CONFIG_PROVE_RCU</span>
<span class="kt">int</span> <span class="nf">lockdep_tasklist_lock_is_held</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">lockdep_tasklist_lock_is_held</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_PROVE_RCU */</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">nr_processes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">process_counts</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">task_struct_cachep</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">alloc_task_struct_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmem_cache_alloc_node</span><span class="p">(</span><span class="n">task_struct_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__weak</span> <span class="nf">arch_release_task_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_task_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">arch_release_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">task_struct_cachep</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CONFIG_ARCH_THREAD_INFO_ALLOCATOR</span>
<span class="kt">void</span> <span class="n">__weak</span> <span class="nf">arch_release_thread_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate pages if THREAD_SIZE is &gt;= PAGE_SIZE, otherwise use a</span>
<span class="cm"> * kmemcache based allocator.</span>
<span class="cm"> */</span>
<span class="cp"># if THREAD_SIZE &gt;= PAGE_SIZE</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="nf">alloc_thread_info_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">THREADINFO_GFP</span><span class="p">,</span>
					     <span class="n">THREAD_SIZE_ORDER</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">page</span> <span class="o">?</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_thread_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">arch_release_thread_info</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ti</span><span class="p">,</span> <span class="n">THREAD_SIZE_ORDER</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp"># else</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">thread_info_cache</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="nf">alloc_thread_info_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmem_cache_alloc_node</span><span class="p">(</span><span class="n">thread_info_cache</span><span class="p">,</span> <span class="n">THREADINFO_GFP</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_thread_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">arch_release_thread_info</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">thread_info_cache</span><span class="p">,</span> <span class="n">ti</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread_info_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">thread_info_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;thread_info&quot;</span><span class="p">,</span> <span class="n">THREAD_SIZE</span><span class="p">,</span>
					      <span class="n">THREAD_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">thread_info_cache</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>

<span class="cm">/* SLAB cache for signal_struct structures (tsk-&gt;signal) */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">signal_cachep</span><span class="p">;</span>

<span class="cm">/* SLAB cache for sighand_struct structures (tsk-&gt;sighand) */</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">sighand_cachep</span><span class="p">;</span>

<span class="cm">/* SLAB cache for files_struct structures (tsk-&gt;files) */</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">files_cachep</span><span class="p">;</span>

<span class="cm">/* SLAB cache for fs_struct structures (tsk-&gt;fs) */</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">fs_cachep</span><span class="p">;</span>

<span class="cm">/* SLAB cache for vm_area_struct structures */</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">vm_area_cachep</span><span class="p">;</span>

<span class="cm">/* SLAB cache for mm_struct structures (tsk-&gt;mm) */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">mm_cachep</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">account_kernel_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span> <span class="kt">int</span> <span class="n">account</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">page_zone</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">ti</span><span class="p">));</span>

	<span class="n">mod_zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_KERNEL_STACK</span><span class="p">,</span> <span class="n">account</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">account_kernel_stack</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">stack</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">free_thread_info</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">stack</span><span class="p">);</span>
	<span class="n">rt_mutex_debug_task_free</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">ftrace_graph_exit_task</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">put_seccomp_filter</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">free_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">free_task</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_signal_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">taskstats_tgid_free</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
	<span class="n">sched_autogroup_exit</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">signal_cachep</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_signal_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">sigcnt</span><span class="p">))</span>
		<span class="n">free_signal_struct</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__put_task_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_state</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">tsk</span> <span class="o">==</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">security_task_free</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">exit_creds</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">delayacct_tsk_free</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">put_signal_struct</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">profile_handoff_task</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
		<span class="n">free_task</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__put_task_struct</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="n">__weak</span> <span class="nf">arch_task_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">fork_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mempages</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR</span>
<span class="cp">#ifndef ARCH_MIN_TASKALIGN</span>
<span class="cp">#define ARCH_MIN_TASKALIGN	L1_CACHE_BYTES</span>
<span class="cp">#endif</span>
	<span class="cm">/* create a slab on which task_structs can be allocated */</span>
	<span class="n">task_struct_cachep</span> <span class="o">=</span>
		<span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;task_struct&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span><span class="p">),</span>
			<span class="n">ARCH_MIN_TASKALIGN</span><span class="p">,</span> <span class="n">SLAB_PANIC</span> <span class="o">|</span> <span class="n">SLAB_NOTRACK</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* do the arch specific task caches init */</span>
	<span class="n">arch_task_cache_init</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * The default maximum number of threads is set to a safe</span>
<span class="cm">	 * value: the thread structures can take up at most half</span>
<span class="cm">	 * of memory.</span>
<span class="cm">	 */</span>
	<span class="n">max_threads</span> <span class="o">=</span> <span class="n">mempages</span> <span class="o">/</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">THREAD_SIZE</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we need to allow at least 20 threads to boot a system</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_threads</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">)</span>
		<span class="n">max_threads</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

	<span class="n">init_task</span><span class="p">.</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_NPROC</span><span class="p">].</span><span class="n">rlim_cur</span> <span class="o">=</span> <span class="n">max_threads</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">init_task</span><span class="p">.</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_NPROC</span><span class="p">].</span><span class="n">rlim_max</span> <span class="o">=</span> <span class="n">max_threads</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">init_task</span><span class="p">.</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_SIGPENDING</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">init_task</span><span class="p">.</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_NPROC</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">arch_dup_task_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">dup_task_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">orig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">stackend</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">tsk_fork_get_node</span><span class="p">(</span><span class="n">orig</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">tsk</span> <span class="o">=</span> <span class="n">alloc_task_struct_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ti</span> <span class="o">=</span> <span class="n">alloc_thread_info_node</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ti</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">arch_dup_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">orig</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">stack</span> <span class="o">=</span> <span class="n">ti</span><span class="p">;</span>

	<span class="n">setup_thread_stack</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">orig</span><span class="p">);</span>
	<span class="n">clear_user_return_notifier</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">clear_tsk_need_resched</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">stackend</span> <span class="o">=</span> <span class="n">end_of_stack</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="o">*</span><span class="n">stackend</span> <span class="o">=</span> <span class="n">STACK_END_MAGIC</span><span class="p">;</span>	<span class="cm">/* for overflow detection */</span>

<span class="cp">#ifdef CONFIG_CC_STACKPROTECTOR</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">stack_canary</span> <span class="o">=</span> <span class="n">get_random_int</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * One for us, one for whoever does the &quot;release_task()&quot; (usually</span>
<span class="cm">	 * parent)</span>
<span class="cm">	 */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_BLK_DEV_IO_TRACE</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">btrace_seq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">splice_pipe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">account_kernel_stack</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">tsk</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">free_thread_info</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span>
	<span class="n">free_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dup_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">oldmm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">mpnt</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="o">**</span><span class="n">pprev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">rb_link</span><span class="p">,</span> <span class="o">*</span><span class="n">rb_parent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">charge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldmm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">flush_cache_dup_mm</span><span class="p">(</span><span class="n">oldmm</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Not linked in yet - no deadlock potential:</span>
<span class="cm">	 */</span>
	<span class="n">down_write_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>

	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">locked_vm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span> <span class="o">=</span> <span class="n">oldmm</span><span class="o">-&gt;</span><span class="n">mmap_base</span><span class="p">;</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">cached_hole_size</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">mm_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">));</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_rb</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
	<span class="n">rb_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_rb</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="n">rb_parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pprev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ksm_fork</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">oldmm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">khugepaged_fork</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">oldmm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">mpnt</span> <span class="o">=</span> <span class="n">oldmm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span> <span class="n">mpnt</span><span class="p">;</span> <span class="n">mpnt</span> <span class="o">=</span> <span class="n">mpnt</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mpnt</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_DONTCOPY</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">long</span> <span class="n">pages</span> <span class="o">=</span> <span class="n">vma_pages</span><span class="p">(</span><span class="n">mpnt</span><span class="p">);</span>
			<span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span> <span class="o">-=</span> <span class="n">pages</span><span class="p">;</span>
			<span class="n">vm_stat_account</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">mpnt</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">,</span> <span class="n">mpnt</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">,</span>
								<span class="o">-</span><span class="n">pages</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">charge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mpnt</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_ACCOUNT</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">mpnt</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">mpnt</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">security_vm_enough_memory_mm</span><span class="p">(</span><span class="n">oldmm</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="cm">/* sic */</span>
				<span class="k">goto</span> <span class="n">fail_nomem</span><span class="p">;</span>
			<span class="n">charge</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_nomem</span><span class="p">;</span>
		<span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">mpnt</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">);</span>
		<span class="n">pol</span> <span class="o">=</span> <span class="n">mpol_dup</span><span class="p">(</span><span class="n">vma_policy</span><span class="p">(</span><span class="n">mpnt</span><span class="p">));</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pol</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pol</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">fail_nomem_policy</span><span class="p">;</span>
		<span class="n">vma_set_policy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">pol</span><span class="p">);</span>
		<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">anon_vma_fork</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">mpnt</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">fail_nomem_anon_vma_fork</span><span class="p">;</span>
		<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VM_LOCKED</span><span class="p">;</span>
		<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">file</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>

			<span class="n">get_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_DENYWRITE</span><span class="p">)</span>
				<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_writecount</span><span class="p">);</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">)</span>
				<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_writable</span><span class="o">++</span><span class="p">;</span>
			<span class="n">flush_dcache_mmap_lock</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
			<span class="cm">/* insert tmp into the share list, just after mpnt */</span>
			<span class="n">vma_prio_tree_add</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">mpnt</span><span class="p">);</span>
			<span class="n">flush_dcache_mmap_unlock</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Clear hugetlb-related page reserves for children. This only</span>
<span class="cm">		 * affects MAP_PRIVATE mappings. Faults generated by the child</span>
<span class="cm">		 * are not guaranteed to succeed, even if read-only</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
			<span class="n">reset_vma_resv_huge_pages</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Link in the new vma and copy the page table entries.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">pprev</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">pprev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
		<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="n">__vma_link_rb</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">rb_link</span><span class="p">,</span> <span class="n">rb_parent</span><span class="p">);</span>
		<span class="n">rb_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_rb</span><span class="p">.</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="n">rb_parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_rb</span><span class="p">;</span>

		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_page_range</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">oldmm</span><span class="p">,</span> <span class="n">mpnt</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">)</span>
			<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">&amp;&amp;</span> <span class="n">uprobe_mmap</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* a new mm has just been created */</span>
	<span class="n">arch_dup_mmap</span><span class="p">(</span><span class="n">oldmm</span><span class="p">,</span> <span class="n">mm</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">flush_tlb_mm</span><span class="p">(</span><span class="n">oldmm</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldmm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="nl">fail_nomem_anon_vma_fork:</span>
	<span class="n">mpol_put</span><span class="p">(</span><span class="n">pol</span><span class="p">);</span>
<span class="nl">fail_nomem_policy:</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
<span class="nl">fail_nomem:</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">vm_unacct_memory</span><span class="p">(</span><span class="n">charge</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mm_alloc_pgd</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mm_free_pgd</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_free</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define dup_mmap(mm, oldmm)	(0)</span>
<span class="cp">#define mm_alloc_pgd(mm)	(0)</span>
<span class="cp">#define mm_free_pgd(mm)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MMU */</span><span class="cp"></span>

<span class="n">__cacheline_aligned_in_smp</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">mmlist_lock</span><span class="p">);</span>

<span class="cp">#define allocate_mm()	(kmem_cache_alloc(mm_cachep, GFP_KERNEL))</span>
<span class="cp">#define free_mm(mm)	(kmem_cache_free(mm_cachep, (mm)))</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">default_dump_filter</span> <span class="o">=</span> <span class="n">MMF_DUMP_FILTER_DEFAULT</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">coredump_filter_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">default_dump_filter</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">simple_strtoul</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">MMF_DUMP_FILTER_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">MMF_DUMP_FILTER_MASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;coredump_filter=&quot;</span><span class="p">,</span> <span class="n">coredump_filter_setup</span><span class="p">);</span>

<span class="cp">#include &lt;linux/init_task.h&gt;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mm_init_aio</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_AIO</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">ioctx_lock</span><span class="p">);</span>
	<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">ioctx_list</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="nf">mm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmlist</span><span class="p">);</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="o">?</span>
		<span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MMF_INIT_MASK</span><span class="p">)</span> <span class="o">:</span> <span class="n">default_dump_filter</span><span class="p">;</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">core_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">nr_ptes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">rss_stat</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">rss_stat</span><span class="p">));</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span> <span class="o">=</span> <span class="n">TASK_UNMAPPED_BASE</span><span class="p">;</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">cached_hole_size</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
	<span class="n">mm_init_aio</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">mm_init_owner</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">mm_alloc_pgd</span><span class="p">(</span><span class="n">mm</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">def_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mmu_notifier_mm_init</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">mm</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">free_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_MM_COUNTERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">x</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">rss_stat</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;BUG: Bad rss-counter state &quot;</span>
					  <span class="s">&quot;mm:%p idx:%d val:%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pmd_huge_pte</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate and initialize an mm_struct.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="nf">mm_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>

	<span class="n">mm</span> <span class="o">=</span> <span class="n">allocate_mm</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mm</span><span class="p">));</span>
	<span class="n">mm_init_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mm_init</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when the last reference to the mm</span>
<span class="cm"> * is dropped: either by a lazy thread or by</span>
<span class="cm"> * mmput. Free the page directory and the mm.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__mmdrop</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mm</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">);</span>
	<span class="n">mm_free_pgd</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">destroy_context</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">mmu_notifier_mm_destroy</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">check_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">free_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__mmdrop</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Decrement the use count and release all resources for an mm.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mmput</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">uprobe_clear_state</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">exit_aio</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">ksm_exit</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">khugepaged_exit</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span> <span class="cm">/* must run before exit_mmap */</span>
		<span class="n">exit_mmap</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">set_mm_exe_file</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmlist</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmlist_lock</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmlist</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmlist_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">binfmt</span><span class="p">)</span>
			<span class="n">module_put</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">binfmt</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">);</span>
		<span class="n">mmdrop</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">mmput</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We added or removed a vma mapping the executable. The vmas are only mapped</span>
<span class="cm"> * during exec and are not mapped with the mmap system call.</span>
<span class="cm"> * Callers must hold down_write() on the mm&#39;s mmap_sem for these</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">added_exe_file_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">num_exe_file_vmas</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">removed_exe_file_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">num_exe_file_vmas</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">num_exe_file_vmas</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">exe_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">exe_file</span><span class="p">);</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">exe_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_mm_exe_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">new_exe_file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_exe_file</span><span class="p">)</span>
		<span class="n">get_file</span><span class="p">(</span><span class="n">new_exe_file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">exe_file</span><span class="p">)</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">exe_file</span><span class="p">);</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">exe_file</span> <span class="o">=</span> <span class="n">new_exe_file</span><span class="p">;</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">num_exe_file_vmas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">get_mm_exe_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">exe_file</span><span class="p">;</span>

	<span class="cm">/* We need mmap_sem to protect against races with removal of</span>
<span class="cm">	 * VM_EXECUTABLE vmas */</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">exe_file</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">exe_file</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exe_file</span><span class="p">)</span>
		<span class="n">get_file</span><span class="p">(</span><span class="n">exe_file</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">exe_file</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dup_mm_exe_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">oldmm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">newmm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* It&#39;s safe to write the exe_file pointer without exe_file_lock because</span>
<span class="cm">	 * this is called during fork when the task is not yet in /proc */</span>
	<span class="n">newmm</span><span class="o">-&gt;</span><span class="n">exe_file</span> <span class="o">=</span> <span class="n">get_mm_exe_file</span><span class="p">(</span><span class="n">oldmm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_task_mm - acquire a reference to the task&#39;s mm</span>
<span class="cm"> *</span>
<span class="cm"> * Returns %NULL if the task has no mm.  Checks PF_KTHREAD (meaning</span>
<span class="cm"> * this kernel workthread has transiently adopted a user mm with use_mm,</span>
<span class="cm"> * to do its AIO) is not set and if so returns a reference to it, after</span>
<span class="cm"> * bumping up the use count.  User must release the mm via mmput()</span>
<span class="cm"> * after use.  Typically used by /proc and ptrace.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="nf">get_task_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>

	<span class="n">task_lock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">mm</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_KTHREAD</span><span class="p">)</span>
			<span class="n">mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mm</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">get_task_mm</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="nf">mm_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span>  <span class="n">mutex_lock_killable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>

	<span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">&amp;&amp;</span> <span class="n">mm</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">ptrace_may_access</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">mm</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EACCES</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mm</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">complete_vfork_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">vfork</span><span class="p">;</span>

	<span class="n">task_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">vfork</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">vfork_done</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">vfork</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">vfork_done</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">complete</span><span class="p">(</span><span class="n">vfork</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_for_vfork_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">vfork</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">killed</span><span class="p">;</span>

	<span class="n">freezer_do_not_count</span><span class="p">();</span>
	<span class="n">killed</span> <span class="o">=</span> <span class="n">wait_for_completion_killable</span><span class="p">(</span><span class="n">vfork</span><span class="p">);</span>
	<span class="n">freezer_count</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">killed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task_lock</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
		<span class="n">child</span><span class="o">-&gt;</span><span class="n">vfork_done</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">killed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Please note the differences between mmput and mm_release.</span>
<span class="cm"> * mmput is called whenever we stop holding onto a mm_struct,</span>
<span class="cm"> * error success whatever.</span>
<span class="cm"> *</span>
<span class="cm"> * mm_release is called after a mm_struct has been removed</span>
<span class="cm"> * from the current process.</span>
<span class="cm"> *</span>
<span class="cm"> * This difference is important for error handling, when we</span>
<span class="cm"> * only half set up a mm_struct for a new process and need to restore</span>
<span class="cm"> * the old one.  Because we mmput the new mm_struct before</span>
<span class="cm"> * restoring the old one. . .</span>
<span class="cm"> * Eric Biederman 10 January 1998</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mm_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Get rid of any futexes when releasing the mm */</span>
<span class="cp">#ifdef CONFIG_FUTEX</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">robust_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">exit_robust_list</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">robust_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">compat_robust_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">compat_exit_robust_list</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">compat_robust_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pi_state_list</span><span class="p">)))</span>
		<span class="n">exit_pi_state_list</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">uprobe_free_utask</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="cm">/* Get rid of any cached register state */</span>
	<span class="n">deactivate_mm</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">mm</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re exiting normally, clear a user-space tid field if</span>
<span class="cm">	 * requested.  We leave this alone when dying by signal, to leave</span>
<span class="cm">	 * the value intact in a core dump, and to save the unnecessary</span>
<span class="cm">	 * trouble, say, a killed vfork parent shouldn&#39;t touch this mm.</span>
<span class="cm">	 * Userland only wants this done for a sys_exit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">clear_child_tid</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_SIGNALED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We don&#39;t check the error code - if userspace has</span>
<span class="cm">			 * not set up a proper pointer then tough luck.</span>
<span class="cm">			 */</span>
			<span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">clear_child_tid</span><span class="p">);</span>
			<span class="n">sys_futex</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">clear_child_tid</span><span class="p">,</span> <span class="n">FUTEX_WAKE</span><span class="p">,</span>
					<span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">clear_child_tid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * All done, finally we can wake up parent and return this mm to him.</span>
<span class="cm">	 * Also kthread_stop() uses this completion for synchronization.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">vfork_done</span><span class="p">)</span>
		<span class="n">complete_vfork_done</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a new mm structure and copy contents from the</span>
<span class="cm"> * mm structure of the passed in task structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="nf">dup_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="o">*</span><span class="n">oldmm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oldmm</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mm</span> <span class="o">=</span> <span class="n">allocate_mm</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_nomem</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">oldmm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mm</span><span class="p">));</span>
	<span class="n">mm_init_cpumask</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">pmd_huge_pte</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">uprobe_reset_state</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm_init</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">tsk</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_nomem</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">init_new_context</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">mm</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_nocontext</span><span class="p">;</span>

	<span class="n">dup_mm_exe_file</span><span class="p">(</span><span class="n">oldmm</span><span class="p">,</span> <span class="n">mm</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dup_mmap</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">oldmm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_pt</span><span class="p">;</span>

	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">hiwater_rss</span> <span class="o">=</span> <span class="n">get_mm_rss</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">hiwater_vm</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">binfmt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">binfmt</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">free_pt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mm</span><span class="p">;</span>

<span class="nl">free_pt:</span>
	<span class="cm">/* don&#39;t put binfmt in mmput, we haven&#39;t got module yet */</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">binfmt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

<span class="nl">fail_nomem:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">fail_nocontext:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If init_new_context() failed, we cannot use mmput() to free the mm</span>
<span class="cm">	 * because it calls destroy_context()</span>
<span class="cm">	 */</span>
	<span class="n">mm_free_pgd</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">free_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_mm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="o">*</span><span class="n">oldmm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">min_flt</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">maj_flt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">nvcsw</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">nivcsw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_DETECT_HUNG_TASK</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">last_switch_count</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">nvcsw</span> <span class="o">+</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">nivcsw</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Are we cloning a kernel thread?</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need to steal a active VM for that..</span>
<span class="cm">	 */</span>
	<span class="n">oldmm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oldmm</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_VM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldmm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">);</span>
		<span class="n">mm</span> <span class="o">=</span> <span class="n">oldmm</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">good_mm</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">mm</span> <span class="o">=</span> <span class="n">dup_mm</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_nomem</span><span class="p">;</span>

<span class="nl">good_mm:</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_nomem:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_fs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fs_struct</span> <span class="o">*</span><span class="n">fs</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_FS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* tsk-&gt;fs is already what we want */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">in_exec</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fs</span><span class="o">-&gt;</span><span class="n">users</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">fs</span> <span class="o">=</span> <span class="n">copy_fs_struct</span><span class="p">(</span><span class="n">fs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_files</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">oldf</span><span class="p">,</span> <span class="o">*</span><span class="n">newf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A background process may not have any files ...</span>
<span class="cm">	 */</span>
	<span class="n">oldf</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oldf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_FILES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldf</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">newf</span> <span class="o">=</span> <span class="n">dup_fd</span><span class="p">(</span><span class="n">oldf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">files</span> <span class="o">=</span> <span class="n">newf</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_io</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_BLOCK</span>
	<span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">ioc</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">io_context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">new_ioc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Share io context with parent, if CLONE_IO is set</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_IO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ioc_task_link</span><span class="p">(</span><span class="n">ioc</span><span class="p">);</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">io_context</span> <span class="o">=</span> <span class="n">ioc</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ioprio_valid</span><span class="p">(</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioprio</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">new_ioc</span> <span class="o">=</span> <span class="n">get_task_io_context</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">NUMA_NO_NODE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">new_ioc</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">new_ioc</span><span class="o">-&gt;</span><span class="n">ioprio</span> <span class="o">=</span> <span class="n">ioc</span><span class="o">-&gt;</span><span class="n">ioprio</span><span class="p">;</span>
		<span class="n">put_io_context</span><span class="p">(</span><span class="n">new_ioc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_sighand</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">sig</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_SIGHAND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sig</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">sighand_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sig</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__cleanup_sighand</span><span class="p">(</span><span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">sighand</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">signalfd_cleanup</span><span class="p">(</span><span class="n">sighand</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">sighand_cachep</span><span class="p">,</span> <span class="n">sighand</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Initialize POSIX timer handling for a thread group.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">posix_cpu_timers_init_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu_limit</span><span class="p">;</span>

	<span class="cm">/* Thread group counters. */</span>
	<span class="n">thread_group_cputime_init</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>

	<span class="n">cpu_limit</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_CPU</span><span class="p">].</span><span class="n">rlim_cur</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_limit</span> <span class="o">!=</span> <span class="n">RLIM_INFINITY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">prof_exp</span> <span class="o">=</span> <span class="n">secs_to_cputime</span><span class="p">(</span><span class="n">cpu_limit</span><span class="p">);</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">cputimer</span><span class="p">.</span><span class="n">running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The timer lists. */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">cpu_timers</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">cpu_timers</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">cpu_timers</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_signal</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_THREAD</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sig</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">signal_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sig</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">nr_threads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">live</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">sigcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">wait_chldexit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_NEWPID</span><span class="p">)</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SIGNAL_UNKILLABLE</span><span class="p">;</span>
	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">curr_target</span> <span class="o">=</span> <span class="n">tsk</span><span class="p">;</span>
	<span class="n">init_sigpending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">shared_pending</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">posix_timers</span><span class="p">);</span>

	<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">real_timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">real_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">it_real_fn</span><span class="p">;</span>

	<span class="n">task_lock</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">sig</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">);</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">);</span>

	<span class="n">posix_cpu_timers_init_group</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>

	<span class="n">tty_audit_fork</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
	<span class="n">sched_autogroup_fork</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_CGROUPS</span>
	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">group_rwsem</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">oom_adj</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_adj</span><span class="p">;</span>
	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">oom_score_adj</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj</span><span class="p">;</span>
	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">oom_score_adj_min</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj_min</span><span class="p">;</span>

	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">has_child_subreaper</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">has_child_subreaper</span> <span class="o">||</span>
				   <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">is_child_subreaper</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">copy_flags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_flags</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="n">new_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PF_SUPERPRIV</span> <span class="o">|</span> <span class="n">PF_WQ_WORKER</span><span class="p">);</span>
	<span class="n">new_flags</span> <span class="o">|=</span> <span class="n">PF_FORKNOEXEC</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">new_flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">set_tid_address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">tidptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">clear_child_tid</span> <span class="o">=</span> <span class="n">tidptr</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">rt_mutex_init_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_RT_MUTEXES</span>
	<span class="n">plist_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_waiters</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_blocked_on</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MM_OWNER</span>
<span class="kt">void</span> <span class="n">mm_init_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MM_OWNER */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Initialize POSIX timer handling for a single task.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">posix_cpu_timers_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">prof_exp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">virt_exp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cputime_expires</span><span class="p">.</span><span class="n">sched_exp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cpu_timers</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cpu_timers</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">cpu_timers</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This creates a new process as a copy of the old one,</span>
<span class="cm"> * but does not actually start it yet.</span>
<span class="cm"> *</span>
<span class="cm"> * It copies the registers, and all the appropriate</span>
<span class="cm"> * parts of the process environment (as per the clone</span>
<span class="cm"> * flags). The actual kick-off is left to the caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">copy_process</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_start</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_size</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">child_tidptr</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">trace</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cgroup_callbacks_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CLONE_NEWNS</span><span class="o">|</span><span class="n">CLONE_FS</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">CLONE_NEWNS</span><span class="o">|</span><span class="n">CLONE_FS</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Thread groups must share signals as well, and detached threads</span>
<span class="cm">	 * can only be started up within the thread group.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_THREAD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_SIGHAND</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Shared signal handlers imply shared VM. By way of the above,</span>
<span class="cm">	 * thread groups also imply shared VM. Blocking this case allows</span>
<span class="cm">	 * for various simplifications in other code.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_SIGHAND</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_VM</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Siblings of global init remain as zombies on exit since they are</span>
<span class="cm">	 * not reaped by their parent (swapper). To solve this and to avoid</span>
<span class="cm">	 * multi-rooted process trees, prevent global and container-inits</span>
<span class="cm">	 * from creating siblings.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_PARENT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_UNKILLABLE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_task_create</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fork_out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">dup_task_struct</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fork_out</span><span class="p">;</span>

	<span class="n">ftrace_graph_init_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">get_seccomp_filter</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">rt_mutex_init_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROVE_LOCKING</span>
	<span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">hardirqs_enabled</span><span class="p">);</span>
	<span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">softirqs_enabled</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">real_cred</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">processes</span><span class="p">)</span> <span class="o">&gt;=</span>
			<span class="n">task_rlimit</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">RLIMIT_NPROC</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RESOURCE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">p</span><span class="o">-&gt;</span><span class="n">real_cred</span><span class="o">-&gt;</span><span class="n">user</span> <span class="o">!=</span> <span class="n">INIT_USER</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bad_fork_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PF_NPROC_EXCEEDED</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_creds</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">clone_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_fork_free</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If multiple threads are within copy_process(), then this check</span>
<span class="cm">	 * triggers too late. This doesn&#39;t hurt, the check is only there</span>
<span class="cm">	 * to stop root fork bombs.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_threads</span> <span class="o">&gt;=</span> <span class="n">max_threads</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_fork_cleanup_count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">exec_domain</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad_fork_cleanup_count</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">did_exec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">delayacct_tsk_init</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>	<span class="cm">/* Must remain after dup_task_struct() */</span>
	<span class="n">copy_flags</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">);</span>
	<span class="n">rcu_copy_process</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">vfork_done</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">alloc_lock</span><span class="p">);</span>

	<span class="n">init_sigpending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">);</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">stime</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">gtime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">utimescaled</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">stimescaled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifndef CONFIG_VIRT_CPU_ACCOUNTING</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">prev_utime</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prev_stime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(SPLIT_RSS_COUNTING)</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rss_stat</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rss_stat</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">default_timer_slack_ns</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">timer_slack_ns</span><span class="p">;</span>

	<span class="n">task_io_accounting_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ioac</span><span class="p">);</span>
	<span class="n">acct_clear_integrals</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">posix_cpu_timers_init</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">do_posix_clock_monotonic_gettime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">start_time</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">real_start_time</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">start_time</span><span class="p">;</span>
	<span class="n">monotonic_to_bootbased</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">real_start_time</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">io_context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">audit_context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_THREAD</span><span class="p">)</span>
		<span class="n">threadgroup_change_begin</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">cgroup_fork</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">mempolicy</span> <span class="o">=</span> <span class="n">mpol_dup</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">mempolicy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_fork_cleanup_cgroup</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mpol_fix_fork_child_flag</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CPUSETS</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">cpuset_mem_spread_rotor</span> <span class="o">=</span> <span class="n">NUMA_NO_NODE</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">cpuset_slab_spread_rotor</span> <span class="o">=</span> <span class="n">NUMA_NO_NODE</span><span class="p">;</span>
	<span class="n">seqcount_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mems_allowed_seq</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_TRACE_IRQFLAGS</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">irq_events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">hardirqs_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">hardirqs_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">hardirq_enable_ip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">hardirq_enable_event</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">hardirq_disable_ip</span> <span class="o">=</span> <span class="n">_THIS_IP_</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">hardirq_disable_event</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">softirqs_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">softirq_enable_ip</span> <span class="o">=</span> <span class="n">_THIS_IP_</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">softirq_enable_event</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">softirq_disable_ip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">softirq_disable_event</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">hardirq_context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">softirq_context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">lockdep_depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* no locks held yet */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">curr_chain_key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">lockdep_recursion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_DEBUG_MUTEXES</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">blocked_on</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* not blocked yet */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">memcg_batch</span><span class="p">.</span><span class="n">do_batch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">memcg_batch</span><span class="p">.</span><span class="n">memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Perform scheduler related setup. Assign this task to a CPU. */</span>
	<span class="n">sched_fork</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">perf_event_init_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_fork_cleanup_policy</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">audit_alloc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_fork_cleanup_policy</span><span class="p">;</span>
	<span class="cm">/* copy all the process information */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_semundo</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_fork_cleanup_audit</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_files</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_fork_cleanup_semundo</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_fs</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_fork_cleanup_files</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_sighand</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_fork_cleanup_fs</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_signal</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_fork_cleanup_sighand</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_mm</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_fork_cleanup_signal</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_namespaces</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_fork_cleanup_mm</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_io</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_fork_cleanup_namespaces</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_thread</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">stack_start</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_fork_cleanup_io</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">init_struct_pid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">alloc_pid</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">pid_ns</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pid</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bad_fork_cleanup_io</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid_nr</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">tgid</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_THREAD</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">tgid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">set_child_tid</span> <span class="o">=</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_CHILD_SETTID</span><span class="p">)</span> <span class="o">?</span> <span class="n">child_tidptr</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clear TID on mm_release()?</span>
<span class="cm">	 */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">clear_child_tid</span> <span class="o">=</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_CHILD_CLEARTID</span><span class="p">)</span> <span class="o">?</span> <span class="n">child_tidptr</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_BLOCK</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">plug</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FUTEX</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">robust_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">compat_robust_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_state_list</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_state_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">uprobe_copy_process</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * sigaltstack should be cleared when sharing the same VM</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CLONE_VM</span><span class="o">|</span><span class="n">CLONE_VFORK</span><span class="p">))</span> <span class="o">==</span> <span class="n">CLONE_VM</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sas_ss_sp</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sas_ss_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Syscall tracing and stepping should be turned off in the</span>
<span class="cm">	 * child regardless of CLONE_PTRACE.</span>
<span class="cm">	 */</span>
	<span class="n">user_disable_single_step</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">clear_tsk_thread_flag</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">TIF_SYSCALL_TRACE</span><span class="p">);</span>
<span class="cp">#ifdef TIF_SYSCALL_EMU</span>
	<span class="n">clear_tsk_thread_flag</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">TIF_SYSCALL_EMU</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">clear_all_latency_tracing</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/* ok, now we should be set up.. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_THREAD</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_signal</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_PARENT</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_signal</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">exit_signal</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_signal</span> <span class="o">=</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CSIGNAL</span><span class="p">);</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">pdeath_signal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_dirtied_pause</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">dirty_paused_when</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ok, make it visible to the rest of the system.</span>
<span class="cm">	 * We dont wake it up yet.</span>
<span class="cm">	 */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">thread_group</span><span class="p">);</span>
	<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">task_works</span><span class="p">);</span>

	<span class="cm">/* Now that the task is set up, run cgroup callbacks if</span>
<span class="cm">	 * necessary. We need to run them before the task is visible</span>
<span class="cm">	 * on the tasklist. */</span>
	<span class="n">cgroup_fork_callbacks</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">cgroup_callbacks_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Need tasklist lock for parent etc handling! */</span>
	<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="cm">/* CLONE_PARENT re-uses the old parent */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CLONE_PARENT</span><span class="o">|</span><span class="n">CLONE_THREAD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">parent_exec_id</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">parent_exec_id</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">parent_exec_id</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">self_exec_id</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Process group and session signals need to be delivered to just the</span>
<span class="cm">	 * parent before the fork or both the parent and the child after the</span>
<span class="cm">	 * fork. Restart if a signal comes in before we add the new process to</span>
<span class="cm">	 * it&#39;s process group.</span>
<span class="cm">	 * A fatal signal pending means that current will exit, so the new</span>
<span class="cm">	 * thread can&#39;t slip out of an OOM kill (or normal SIGKILL).</span>
<span class="cm">	*/</span>
	<span class="n">recalc_sigpending</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTNOINTR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_fork_free_pid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_THREAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">nr_threads</span><span class="o">++</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">live</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">sigcnt</span><span class="p">);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">;</span>
		<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">thread_group</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">thread_group</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ptrace_init_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_PTRACE</span><span class="p">)</span> <span class="o">||</span> <span class="n">trace</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">thread_group_leader</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_child_reaper</span><span class="p">(</span><span class="n">pid</span><span class="p">))</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">pid_ns</span><span class="o">-&gt;</span><span class="n">child_reaper</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

			<span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">leader_pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">=</span> <span class="n">tty_kref_get</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">);</span>
			<span class="n">attach_pid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PIDTYPE_PGID</span><span class="p">,</span> <span class="n">task_pgrp</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
			<span class="n">attach_pid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PIDTYPE_SID</span><span class="p">,</span> <span class="n">task_session</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>
			<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_task</span><span class="p">.</span><span class="n">tasks</span><span class="p">);</span>
			<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">process_counts</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">attach_pid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
		<span class="n">nr_threads</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">total_forks</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">proc_fork_connector</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">cgroup_post_fork</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_THREAD</span><span class="p">)</span>
		<span class="n">threadgroup_change_end</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">perf_event_fork</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">trace_task_newtask</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">clone_flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>

<span class="nl">bad_fork_free_pid:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">init_struct_pid</span><span class="p">)</span>
		<span class="n">free_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
<span class="nl">bad_fork_cleanup_io:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">io_context</span><span class="p">)</span>
		<span class="n">exit_io_context</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="nl">bad_fork_cleanup_namespaces:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_NEWPID</span><span class="p">))</span>
		<span class="n">pid_ns_release_proc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">pid_ns</span><span class="p">);</span>
	<span class="n">exit_task_namespaces</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="nl">bad_fork_cleanup_mm:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
		<span class="n">mmput</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
<span class="nl">bad_fork_cleanup_signal:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_THREAD</span><span class="p">))</span>
		<span class="n">free_signal_struct</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">);</span>
<span class="nl">bad_fork_cleanup_sighand:</span>
	<span class="n">__cleanup_sighand</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="p">);</span>
<span class="nl">bad_fork_cleanup_fs:</span>
	<span class="n">exit_fs</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* blocking */</span>
<span class="nl">bad_fork_cleanup_files:</span>
	<span class="n">exit_files</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* blocking */</span>
<span class="nl">bad_fork_cleanup_semundo:</span>
	<span class="n">exit_sem</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="nl">bad_fork_cleanup_audit:</span>
	<span class="n">audit_free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="nl">bad_fork_cleanup_policy:</span>
	<span class="n">perf_event_free_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="n">mpol_put</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">);</span>
<span class="nl">bad_fork_cleanup_cgroup:</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_THREAD</span><span class="p">)</span>
		<span class="n">threadgroup_change_end</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">cgroup_exit</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cgroup_callbacks_done</span><span class="p">);</span>
	<span class="n">delayacct_tsk_free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">exec_domain</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">);</span>
<span class="nl">bad_fork_cleanup_count:</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">processes</span><span class="p">);</span>
	<span class="n">exit_creds</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="nl">bad_fork_free:</span>
	<span class="n">free_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="nl">fork_out:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">noinline</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span> <span class="n">__cpuinit</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">idle_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">regs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">init_idle_pids</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid_link</span> <span class="o">*</span><span class="n">links</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">pid_type</span> <span class="n">type</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">type</span> <span class="o">=</span> <span class="n">PIDTYPE_PID</span><span class="p">;</span> <span class="n">type</span> <span class="o">&lt;</span> <span class="n">PIDTYPE_MAX</span><span class="p">;</span> <span class="o">++</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">links</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">node</span><span class="p">);</span> <span class="cm">/* not really needed */</span>
		<span class="n">links</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">pid</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_struct_pid</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span> <span class="n">__cpuinit</span> <span class="n">fork_idle</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="n">regs</span><span class="p">;</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">copy_process</span><span class="p">(</span><span class="n">CLONE_VM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idle_regs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">init_struct_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">init_idle_pids</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pids</span><span class="p">);</span>
		<span class="n">init_idle</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">task</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Ok, this is the main fork-routine.</span>
<span class="cm"> *</span>
<span class="cm"> * It copies the process, and if successful kick-starts</span>
<span class="cm"> * it and waits for it to finish using the VM if required.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">do_fork</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span>
	      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_start</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
	      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_size</span><span class="p">,</span>
	      <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">parent_tidptr</span><span class="p">,</span>
	      <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">child_tidptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">trace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">nr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do some preliminary argument and permissions checking before we</span>
<span class="cm">	 * actually start allocating stuff</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_NEWUSER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_THREAD</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="cm">/* hopefully this check will go away when userns support is</span>
<span class="cm">		 * complete</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SETUID</span><span class="p">)</span> <span class="o">||</span>
				<span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SETGID</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine whether and which event to report to ptracer.  When</span>
<span class="cm">	 * called from kernel_thread or CLONE_UNTRACED is explicitly</span>
<span class="cm">	 * requested, no event is reported; otherwise, report if the event</span>
<span class="cm">	 * for the type of forking is enabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_UNTRACED</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_VFORK</span><span class="p">)</span>
			<span class="n">trace</span> <span class="o">=</span> <span class="n">PTRACE_EVENT_VFORK</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CSIGNAL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SIGCHLD</span><span class="p">)</span>
			<span class="n">trace</span> <span class="o">=</span> <span class="n">PTRACE_EVENT_CLONE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">trace</span> <span class="o">=</span> <span class="n">PTRACE_EVENT_FORK</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ptrace_event_enabled</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">trace</span><span class="p">)))</span>
			<span class="n">trace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">copy_process</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">stack_start</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">,</span>
			 <span class="n">child_tidptr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">trace</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Do this prior waking up the new thread - the thread pointer</span>
<span class="cm">	 * might get invalid after that point, if the thread exits quickly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">completion</span> <span class="n">vfork</span><span class="p">;</span>

		<span class="n">trace_sched_process_fork</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

		<span class="n">nr</span> <span class="o">=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_PARENT_SETTID</span><span class="p">)</span>
			<span class="n">put_user</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">parent_tidptr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_VFORK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">vfork_done</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vfork</span><span class="p">;</span>
			<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfork</span><span class="p">);</span>
			<span class="n">get_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">wake_up_new_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

		<span class="cm">/* forking complete and child started to run, tell ptracer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">trace</span><span class="p">))</span>
			<span class="n">ptrace_event</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_VFORK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait_for_vfork_done</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vfork</span><span class="p">))</span>
				<span class="n">ptrace_event</span><span class="p">(</span><span class="n">PTRACE_EVENT_VFORK_DONE</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef ARCH_MIN_MMSTRUCT_ALIGN</span>
<span class="cp">#define ARCH_MIN_MMSTRUCT_ALIGN 0</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sighand_ctor</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">sighand</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">signalfd_wqh</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="n">proc_caches_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sighand_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;sighand_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sighand_struct</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="o">|</span><span class="n">SLAB_DESTROY_BY_RCU</span><span class="o">|</span>
			<span class="n">SLAB_NOTRACK</span><span class="p">,</span> <span class="n">sighand_ctor</span><span class="p">);</span>
	<span class="n">signal_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;signal_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">signal_struct</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="o">|</span><span class="n">SLAB_NOTRACK</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">files_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;files_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">files_struct</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="o">|</span><span class="n">SLAB_NOTRACK</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">fs_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;fs_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fs_struct</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="o">|</span><span class="n">SLAB_NOTRACK</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * FIXME! The &quot;sizeof(struct mm_struct)&quot; currently includes the</span>
<span class="cm">	 * whole struct cpumask for the OFFSTACK case. We could change</span>
<span class="cm">	 * this to *only* allocate as much of it as required by the</span>
<span class="cm">	 * maximum number of CPU&#39;s we can ever have.  The cpumask_allocation</span>
<span class="cm">	 * is at the end of the structure, exactly for that reason.</span>
<span class="cm">	 */</span>
	<span class="n">mm_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;mm_struct&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span><span class="p">),</span> <span class="n">ARCH_MIN_MMSTRUCT_ALIGN</span><span class="p">,</span>
			<span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="o">|</span><span class="n">SLAB_NOTRACK</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">vm_area_cachep</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">vm_area_struct</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">);</span>
	<span class="n">mmap_init</span><span class="p">();</span>
	<span class="n">nsproxy_cache_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check constraints on flags passed to the unshare system call.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">check_unshare_flags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unshare_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unshare_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">CLONE_THREAD</span><span class="o">|</span><span class="n">CLONE_FS</span><span class="o">|</span><span class="n">CLONE_NEWNS</span><span class="o">|</span><span class="n">CLONE_SIGHAND</span><span class="o">|</span>
				<span class="n">CLONE_VM</span><span class="o">|</span><span class="n">CLONE_FILES</span><span class="o">|</span><span class="n">CLONE_SYSVSEM</span><span class="o">|</span>
				<span class="n">CLONE_NEWUTS</span><span class="o">|</span><span class="n">CLONE_NEWIPC</span><span class="o">|</span><span class="n">CLONE_NEWNET</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Not implemented, but pretend it works if there is nothing to</span>
<span class="cm">	 * unshare. Note that unsharing CLONE_THREAD or CLONE_SIGHAND</span>
<span class="cm">	 * needs to unshare vm.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unshare_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CLONE_THREAD</span> <span class="o">|</span> <span class="n">CLONE_SIGHAND</span> <span class="o">|</span> <span class="n">CLONE_VM</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* FIXME: get_task_mm() increments -&gt;mm_users */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unshare the filesystem structure if it is being shared</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unshare_fs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unshare_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fs_struct</span> <span class="o">**</span><span class="n">new_fsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fs_struct</span> <span class="o">*</span><span class="n">fs</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">unshare_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_FS</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">fs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* don&#39;t need lock here; in the worst case we&#39;ll do useless copy */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">new_fsp</span> <span class="o">=</span> <span class="n">copy_fs_struct</span><span class="p">(</span><span class="n">fs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">new_fsp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unshare file descriptor table if it is being shared</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unshare_fd</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unshare_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">files_struct</span> <span class="o">**</span><span class="n">new_fdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">fd</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">unshare_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_FILES</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">fd</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">new_fdp</span> <span class="o">=</span> <span class="n">dup_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">new_fdp</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * unshare allows a process to &#39;unshare&#39; part of the process</span>
<span class="cm"> * context which was originally shared using clone.  copy_*</span>
<span class="cm"> * functions used by do_fork() cannot be used here directly</span>
<span class="cm"> * because they modify an inactive task_struct that is being</span>
<span class="cm"> * constructed. Here we are modifying the current, active,</span>
<span class="cm"> * task_struct.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">unshare</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">unshare_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fs_struct</span> <span class="o">*</span><span class="n">fs</span><span class="p">,</span> <span class="o">*</span><span class="n">new_fs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">fd</span><span class="p">,</span> <span class="o">*</span><span class="n">new_fd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nsproxy</span> <span class="o">*</span><span class="n">new_nsproxy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_sysvsem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">check_unshare_flags</span><span class="p">(</span><span class="n">unshare_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_unshare_out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If unsharing namespace, must also unshare filesystem information.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unshare_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_NEWNS</span><span class="p">)</span>
		<span class="n">unshare_flags</span> <span class="o">|=</span> <span class="n">CLONE_FS</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * CLONE_NEWIPC must also detach from the undolist: after switching</span>
<span class="cm">	 * to a new ipc namespace, the semaphore arrays from the old</span>
<span class="cm">	 * namespace are unreachable.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unshare_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CLONE_NEWIPC</span><span class="o">|</span><span class="n">CLONE_SYSVSEM</span><span class="p">))</span>
		<span class="n">do_sysvsem</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">unshare_fs</span><span class="p">(</span><span class="n">unshare_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_fs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_unshare_out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">unshare_fd</span><span class="p">(</span><span class="n">unshare_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_fd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_unshare_cleanup_fs</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">unshare_nsproxy_namespaces</span><span class="p">(</span><span class="n">unshare_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_nsproxy</span><span class="p">,</span> <span class="n">new_fs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_unshare_cleanup_fd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_fs</span> <span class="o">||</span> <span class="n">new_fd</span> <span class="o">||</span> <span class="n">do_sysvsem</span> <span class="o">||</span> <span class="n">new_nsproxy</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_sysvsem</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * CLONE_SYSVSEM is equivalent to sys_exit().</span>
<span class="cm">			 */</span>
			<span class="n">exit_sem</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">new_nsproxy</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">switch_task_namespaces</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">new_nsproxy</span><span class="p">);</span>
			<span class="n">new_nsproxy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">task_lock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">new_fs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fs</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span> <span class="o">=</span> <span class="n">new_fs</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span>
				<span class="n">new_fs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">new_fs</span> <span class="o">=</span> <span class="n">fs</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">new_fd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fd</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span> <span class="o">=</span> <span class="n">new_fd</span><span class="p">;</span>
			<span class="n">new_fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">task_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_nsproxy</span><span class="p">)</span>
		<span class="n">put_nsproxy</span><span class="p">(</span><span class="n">new_nsproxy</span><span class="p">);</span>

<span class="nl">bad_unshare_cleanup_fd:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_fd</span><span class="p">)</span>
		<span class="n">put_files_struct</span><span class="p">(</span><span class="n">new_fd</span><span class="p">);</span>

<span class="nl">bad_unshare_cleanup_fs:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_fs</span><span class="p">)</span>
		<span class="n">free_fs_struct</span><span class="p">(</span><span class="n">new_fs</span><span class="p">);</span>

<span class="nl">bad_unshare_out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Helper to unshare the files of the current task.</span>
<span class="cm"> *	We don&#39;t want to expose copy_files internals to</span>
<span class="cm"> *	the exec layer of the kernel.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">unshare_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">files_struct</span> <span class="o">**</span><span class="n">displaced</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">copy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">unshare_fd</span><span class="p">(</span><span class="n">CLONE_FILES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">copy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">||</span> <span class="o">!</span><span class="n">copy</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">displaced</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">displaced</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>
	<span class="n">task_lock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">files</span> <span class="o">=</span> <span class="n">copy</span><span class="p">;</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
