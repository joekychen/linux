<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › kexec.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>kexec.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * kexec.c - kexec system call</span>
<span class="cm"> * Copyright (C) 2002-2004 Eric Biederman  &lt;ebiederm@xmission.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This source code is licensed under the GNU General Public License,</span>
<span class="cm"> * Version 2.  See the file COPYING for more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/kexec.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;linux/elfcore.h&gt;</span>
<span class="cp">#include &lt;generated/utsrelease.h&gt;</span>
<span class="cp">#include &lt;linux/utsname.h&gt;</span>
<span class="cp">#include &lt;linux/numa.h&gt;</span>
<span class="cp">#include &lt;linux/suspend.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/syscore_ops.h&gt;</span>

<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>

<span class="cm">/* Per cpu memory for storing cpu states in case of system crash. */</span>
<span class="n">note_buf_t</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">crash_notes</span><span class="p">;</span>

<span class="cm">/* vmcoreinfo stuff */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">vmcoreinfo_data</span><span class="p">[</span><span class="n">VMCOREINFO_BYTES</span><span class="p">];</span>
<span class="n">u32</span> <span class="n">vmcoreinfo_note</span><span class="p">[</span><span class="n">VMCOREINFO_NOTE_SIZE</span><span class="o">/</span><span class="mi">4</span><span class="p">];</span>
<span class="kt">size_t</span> <span class="n">vmcoreinfo_size</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">vmcoreinfo_max_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vmcoreinfo_data</span><span class="p">);</span>

<span class="cm">/* Location of the reserved area for the crash kernel */</span>
<span class="k">struct</span> <span class="n">resource</span> <span class="n">crashk_res</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>  <span class="o">=</span> <span class="s">&quot;Crash kernel&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">end</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_BUSY</span> <span class="o">|</span> <span class="n">IORESOURCE_MEM</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">kexec_should_crash</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_interrupt</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">||</span> <span class="n">is_global_init</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="n">panic_on_oops</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When kexec transitions to the new kernel there is a one-to-one</span>
<span class="cm"> * mapping between physical and virtual addresses.  On processors</span>
<span class="cm"> * where you can disable the MMU this is trivial, and easy.  For</span>
<span class="cm"> * others it is still a simple predictable page table to setup.</span>
<span class="cm"> *</span>
<span class="cm"> * In that environment kexec copies the new kernel to its final</span>
<span class="cm"> * resting place.  This means I can only support memory whose</span>
<span class="cm"> * physical address can fit in an unsigned long.  In particular</span>
<span class="cm"> * addresses where (pfn &lt;&lt; PAGE_SHIFT) &gt; ULONG_MAX cannot be handled.</span>
<span class="cm"> * If the assembly stub has more restrictive requirements</span>
<span class="cm"> * KEXEC_SOURCE_MEMORY_LIMIT and KEXEC_DEST_MEMORY_LIMIT can be</span>
<span class="cm"> * defined more restrictively in &lt;asm/kexec.h&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * The code for the transition from the current kernel to the</span>
<span class="cm"> * the new kernel is placed in the control_code_buffer, whose size</span>
<span class="cm"> * is given by KEXEC_CONTROL_PAGE_SIZE.  In the best case only a single</span>
<span class="cm"> * page of memory is necessary, but some architectures require more.</span>
<span class="cm"> * Because this memory must be identity mapped in the transition from</span>
<span class="cm"> * virtual to physical addresses it must live in the range</span>
<span class="cm"> * 0 - TASK_SIZE, as only the user space mappings are arbitrarily</span>
<span class="cm"> * modifiable.</span>
<span class="cm"> *</span>
<span class="cm"> * The assembly stub in the control code buffer is passed a linked list</span>
<span class="cm"> * of descriptor pages detailing the source pages of the new kernel,</span>
<span class="cm"> * and the destination addresses of those source pages.  As this data</span>
<span class="cm"> * structure is not used in the context of the current OS, it must</span>
<span class="cm"> * be self-contained.</span>
<span class="cm"> *</span>
<span class="cm"> * The code has been made to work with highmem pages and will use a</span>
<span class="cm"> * destination page in its final resting place (if it happens</span>
<span class="cm"> * to allocate it).  The end product of this is that most of the</span>
<span class="cm"> * physical address space, and most of RAM can be used.</span>
<span class="cm"> *</span>
<span class="cm"> * Future directions include:</span>
<span class="cm"> *  - allocating a page table with the control code buffer identity</span>
<span class="cm"> *    mapped, to simplify machine_kexec and make kexec_on_panic more</span>
<span class="cm"> *    reliable.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * KIMAGE_NO_DEST is an impossible destination address..., for</span>
<span class="cm"> * allocating pages whose destination address we do not care about.</span>
<span class="cm"> */</span>
<span class="cp">#define KIMAGE_NO_DEST (-1UL)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">kimage_is_destination_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">kimage_alloc_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span>
				       <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dest</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_kimage_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">**</span><span class="n">rimage</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entry</span><span class="p">,</span>
	                    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segments</span><span class="p">,</span>
                            <span class="k">struct</span> <span class="n">kexec_segment</span> <span class="n">__user</span> <span class="o">*</span><span class="n">segments</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">segment_bytes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* Allocate a controlling structure */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">image</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">image</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">image</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">image</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">image</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="n">image</span><span class="o">-&gt;</span><span class="n">last_entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="n">image</span><span class="o">-&gt;</span><span class="n">control_page</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span> <span class="cm">/* By default this does not apply */</span>
	<span class="n">image</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">image</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">KEXEC_TYPE_DEFAULT</span><span class="p">;</span>

	<span class="cm">/* Initialize the list of control pages */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">control_pages</span><span class="p">);</span>

	<span class="cm">/* Initialize the list of destination pages */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">dest_pages</span><span class="p">);</span>

	<span class="cm">/* Initialize the list of unusable pages */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">unuseable_pages</span><span class="p">);</span>

	<span class="cm">/* Read in the segments */</span>
	<span class="n">image</span><span class="o">-&gt;</span><span class="n">nr_segments</span> <span class="o">=</span> <span class="n">nr_segments</span><span class="p">;</span>
	<span class="n">segment_bytes</span> <span class="o">=</span> <span class="n">nr_segments</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">segments</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">,</span> <span class="n">segments</span><span class="p">,</span> <span class="n">segment_bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Verify we have good destination addresses.  The caller is</span>
<span class="cm">	 * responsible for making certain we don&#39;t attempt to load</span>
<span class="cm">	 * the new image into invalid or reserved areas of RAM.  This</span>
<span class="cm">	 * just verifies it is an address we can use.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Since the kernel does everything in page size chunks ensure</span>
<span class="cm">	 * the destination addresses are page aligned.  Too many</span>
<span class="cm">	 * special cases crop of when we don&#39;t do this.  The most</span>
<span class="cm">	 * insidious is getting overlapping destination addresses</span>
<span class="cm">	 * simply because addresses are changed to page size</span>
<span class="cm">	 * granularity.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_segments</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mstart</span><span class="p">,</span> <span class="n">mend</span><span class="p">;</span>

		<span class="n">mstart</span> <span class="o">=</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem</span><span class="p">;</span>
		<span class="n">mend</span>   <span class="o">=</span> <span class="n">mstart</span> <span class="o">+</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">memsz</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mstart</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">mend</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mend</span> <span class="o">&gt;=</span> <span class="n">KEXEC_DESTINATION_MEMORY_LIMIT</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Verify our destination addresses do not overlap.</span>
<span class="cm">	 * If we alloed overlapping destination addresses</span>
<span class="cm">	 * through very weird things can happen with no</span>
<span class="cm">	 * easy explanation as one segment stops on another.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_segments</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mstart</span><span class="p">,</span> <span class="n">mend</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">;</span>

		<span class="n">mstart</span> <span class="o">=</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem</span><span class="p">;</span>
		<span class="n">mend</span>   <span class="o">=</span> <span class="n">mstart</span> <span class="o">+</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">memsz</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pstart</span><span class="p">,</span> <span class="n">pend</span><span class="p">;</span>
			<span class="n">pstart</span> <span class="o">=</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">mem</span><span class="p">;</span>
			<span class="n">pend</span>   <span class="o">=</span> <span class="n">pstart</span> <span class="o">+</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">memsz</span><span class="p">;</span>
			<span class="cm">/* Do the segments overlap ? */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">mend</span> <span class="o">&gt;</span> <span class="n">pstart</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mstart</span> <span class="o">&lt;</span> <span class="n">pend</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Ensure our buffer sizes are strictly less than</span>
<span class="cm">	 * our memory sizes.  This should always be the case,</span>
<span class="cm">	 * and it is easier to check up front than to be surprised</span>
<span class="cm">	 * later on.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_segments</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bufsz</span> <span class="o">&gt;</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">memsz</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">rimage</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kimage_normal_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">**</span><span class="n">rimage</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entry</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segments</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kexec_segment</span> <span class="n">__user</span> <span class="o">*</span><span class="n">segments</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">;</span>

	<span class="cm">/* Allocate and initialize a controlling structure */</span>
	<span class="n">image</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">do_kimage_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">nr_segments</span><span class="p">,</span> <span class="n">segments</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="o">*</span><span class="n">rimage</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find a location for the control code buffer, and add it</span>
<span class="cm">	 * the vector of segments so that it&#39;s pages will also be</span>
<span class="cm">	 * counted as destination pages.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">image</span><span class="o">-&gt;</span><span class="n">control_code_page</span> <span class="o">=</span> <span class="n">kimage_alloc_control_pages</span><span class="p">(</span><span class="n">image</span><span class="p">,</span>
					   <span class="n">get_order</span><span class="p">(</span><span class="n">KEXEC_CONTROL_PAGE_SIZE</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">control_code_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Could not allocate control_code_buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">image</span><span class="o">-&gt;</span><span class="n">swap_page</span> <span class="o">=</span> <span class="n">kimage_alloc_control_pages</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">swap_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Could not allocate swap buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">rimage</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kimage_crash_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">**</span><span class="n">rimage</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entry</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segments</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kexec_segment</span> <span class="n">__user</span> <span class="o">*</span><span class="n">segments</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">image</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* Verify we have a valid entry point */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">entry</span> <span class="o">&lt;</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">start</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&gt;</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate and initialize a controlling structure */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">do_kimage_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">nr_segments</span><span class="p">,</span> <span class="n">segments</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Enable the special crash kernel control page</span>
<span class="cm">	 * allocation policy.</span>
<span class="cm">	 */</span>
	<span class="n">image</span><span class="o">-&gt;</span><span class="n">control_page</span> <span class="o">=</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
	<span class="n">image</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">KEXEC_TYPE_CRASH</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Verify we have good destination addresses.  Normally</span>
<span class="cm">	 * the caller is responsible for making certain we don&#39;t</span>
<span class="cm">	 * attempt to load the new image into invalid or reserved</span>
<span class="cm">	 * areas of RAM.  But crash kernels are preloaded into a</span>
<span class="cm">	 * reserved area of ram.  We must ensure the addresses</span>
<span class="cm">	 * are in the reserved area otherwise preloading the</span>
<span class="cm">	 * kernel could corrupt things.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_segments</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mstart</span><span class="p">,</span> <span class="n">mend</span><span class="p">;</span>

		<span class="n">mstart</span> <span class="o">=</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem</span><span class="p">;</span>
		<span class="n">mend</span> <span class="o">=</span> <span class="n">mstart</span> <span class="o">+</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">memsz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Ensure we are within the crash kernel limits */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mstart</span> <span class="o">&lt;</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">start</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">mend</span> <span class="o">&gt;</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find a location for the control code buffer, and add</span>
<span class="cm">	 * the vector of segments so that it&#39;s pages will also be</span>
<span class="cm">	 * counted as destination pages.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">image</span><span class="o">-&gt;</span><span class="n">control_code_page</span> <span class="o">=</span> <span class="n">kimage_alloc_control_pages</span><span class="p">(</span><span class="n">image</span><span class="p">,</span>
					   <span class="n">get_order</span><span class="p">(</span><span class="n">KEXEC_CONTROL_PAGE_SIZE</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">control_code_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Could not allocate control_code_buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">rimage</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kimage_is_destination_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">nr_segments</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mstart</span><span class="p">,</span> <span class="n">mend</span><span class="p">;</span>

		<span class="n">mstart</span> <span class="o">=</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem</span><span class="p">;</span>
		<span class="n">mend</span> <span class="o">=</span> <span class="n">mstart</span> <span class="o">+</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">memsz</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">mstart</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">mend</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">kimage_alloc_pages</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">;</span>

	<span class="n">pages</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">pages</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">set_page_private</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">SetPageReserved</span><span class="p">(</span><span class="n">pages</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pages</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kimage_free_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">order</span> <span class="o">=</span> <span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">page</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">__free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kimage_free_page_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
		<span class="n">kimage_free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">kimage_alloc_normal_control_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span>
							<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Control pages are special, they are the intermediaries</span>
<span class="cm">	 * that are needed while we copy the rest of the pages</span>
<span class="cm">	 * to their final resting place.  As such they must</span>
<span class="cm">	 * not conflict with either the destination addresses</span>
<span class="cm">	 * or memory the kernel is already using.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The only case where we really need more than one of</span>
<span class="cm">	 * these are for architectures where we cannot disable</span>
<span class="cm">	 * the MMU and must instead generate an identity mapped</span>
<span class="cm">	 * page table for all of the memory.</span>
<span class="cm">	 *</span>
<span class="cm">	 * At worst this runs in O(N) of the image size.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">extra_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extra_pages</span><span class="p">);</span>

	<span class="cm">/* Loop while I can allocate a page and the page allocated</span>
<span class="cm">	 * is a destination page.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">epfn</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">eaddr</span><span class="p">;</span>

		<span class="n">pages</span> <span class="o">=</span> <span class="n">kimage_alloc_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">pfn</span>   <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
		<span class="n">epfn</span>  <span class="o">=</span> <span class="n">pfn</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">addr</span>  <span class="o">=</span> <span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">eaddr</span> <span class="o">=</span> <span class="n">epfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">epfn</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">KEXEC_CONTROL_MEMORY_LIMIT</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span> <span class="o">||</span>
			      <span class="n">kimage_is_destination_range</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">eaddr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pages</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extra_pages</span><span class="p">);</span>
			<span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Remember the allocated page... */</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pages</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">control_pages</span><span class="p">);</span>

		<span class="cm">/* Because the page is already in it&#39;s destination</span>
<span class="cm">		 * location we will never allocate another page at</span>
<span class="cm">		 * that address.  Therefore kimage_alloc_pages</span>
<span class="cm">		 * will not return it (again) and we don&#39;t need</span>
<span class="cm">		 * to give it an entry in image-&gt;segment[].</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
	<span class="cm">/* Deal with the destination pages I have inadvertently allocated.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Ideally I would convert multi-page allocations into single</span>
<span class="cm">	 * page allocations, and add everything to image-&gt;dest_pages.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For now it is simpler to just free the pages.</span>
<span class="cm">	 */</span>
	<span class="n">kimage_free_page_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extra_pages</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pages</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">kimage_alloc_crash_control_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span>
						      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Control pages are special, they are the intermediaries</span>
<span class="cm">	 * that are needed while we copy the rest of the pages</span>
<span class="cm">	 * to their final resting place.  As such they must</span>
<span class="cm">	 * not conflict with either the destination addresses</span>
<span class="cm">	 * or memory the kernel is already using.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Control pages are also the only pags we must allocate</span>
<span class="cm">	 * when loading a crash kernel.  All of the other pages</span>
<span class="cm">	 * are specified by the segments and we just memcpy</span>
<span class="cm">	 * into them directly.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The only case where we really need more than one of</span>
<span class="cm">	 * these are for architectures where we cannot disable</span>
<span class="cm">	 * the MMU and must instead generate an identity mapped</span>
<span class="cm">	 * page table for all of the memory.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Given the low demand this implements a very simple</span>
<span class="cm">	 * allocator that finds the first hole of the appropriate</span>
<span class="cm">	 * size in the reserved memory region, and allocates all</span>
<span class="cm">	 * of the memory up to and including the hole.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hole_start</span><span class="p">,</span> <span class="n">hole_end</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">;</span>

	<span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">hole_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">control_page</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">hole_end</span>   <span class="o">=</span> <span class="n">hole_start</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">hole_end</span> <span class="o">&lt;=</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hole_end</span> <span class="o">&gt;</span> <span class="n">KEXEC_CRASH_CONTROL_MEMORY_LIMIT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hole_end</span> <span class="o">&gt;</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* See if I overlap any of the segments */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">nr_segments</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mstart</span><span class="p">,</span> <span class="n">mend</span><span class="p">;</span>

			<span class="n">mstart</span> <span class="o">=</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem</span><span class="p">;</span>
			<span class="n">mend</span>   <span class="o">=</span> <span class="n">mstart</span> <span class="o">+</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">memsz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">hole_end</span> <span class="o">&gt;=</span> <span class="n">mstart</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hole_start</span> <span class="o">&lt;=</span> <span class="n">mend</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Advance the hole to the end of the segment */</span>
				<span class="n">hole_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">mend</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">hole_end</span>   <span class="o">=</span> <span class="n">hole_start</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* If I don&#39;t overlap any segments I have found my hole! */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">nr_segments</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pages</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">hole_start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span>
		<span class="n">image</span><span class="o">-&gt;</span><span class="n">control_page</span> <span class="o">=</span> <span class="n">hole_end</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pages</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">kimage_alloc_control_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KEXEC_TYPE_DEFAULT</span>:
		<span class="n">pages</span> <span class="o">=</span> <span class="n">kimage_alloc_normal_control_pages</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KEXEC_TYPE_CRASH</span>:
		<span class="n">pages</span> <span class="o">=</span> <span class="n">kimage_alloc_crash_control_pages</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pages</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kimage_add_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span> <span class="n">kimage_entry_t</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">image</span><span class="o">-&gt;</span><span class="n">entry</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">==</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">last_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kimage_entry_t</span> <span class="o">*</span><span class="n">ind_page</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">kimage_alloc_page</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">KIMAGE_NO_DEST</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">ind_page</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="o">*</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">ind_page</span><span class="p">)</span> <span class="o">|</span> <span class="n">IND_INDIRECTION</span><span class="p">;</span>
		<span class="n">image</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="n">ind_page</span><span class="p">;</span>
		<span class="n">image</span><span class="o">-&gt;</span><span class="n">last_entry</span> <span class="o">=</span> <span class="n">ind_page</span> <span class="o">+</span>
				      <span class="p">((</span><span class="n">PAGE_SIZE</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">kimage_entry_t</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">image</span><span class="o">-&gt;</span><span class="n">entry</span><span class="o">++</span><span class="p">;</span>
	<span class="o">*</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kimage_set_destination</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">destination</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">destination</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">kimage_add_entry</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">destination</span> <span class="o">|</span> <span class="n">IND_DESTINATION</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">image</span><span class="o">-&gt;</span><span class="n">destination</span> <span class="o">=</span> <span class="n">destination</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">kimage_add_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">kimage_add_entry</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">page</span> <span class="o">|</span> <span class="n">IND_SOURCE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">image</span><span class="o">-&gt;</span><span class="n">destination</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">kimage_free_extra_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Walk through and free any extra destination pages I may have */</span>
	<span class="n">kimage_free_page_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">dest_pages</span><span class="p">);</span>

	<span class="cm">/* Walk through and free any unusable pages I have cached */</span>
	<span class="n">kimage_free_page_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">unuseable_pages</span><span class="p">);</span>

<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kimage_terminate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">image</span><span class="o">-&gt;</span><span class="n">entry</span><span class="o">++</span><span class="p">;</span>

	<span class="o">*</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="n">IND_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define for_each_kimage_entry(image, ptr, entry) \</span>
<span class="cp">	for (ptr = &amp;image-&gt;head; (entry = *ptr) &amp;&amp; !(entry &amp; IND_DONE); \</span>
<span class="cp">		ptr = (entry &amp; IND_INDIRECTION)? \</span>
<span class="cp">			phys_to_virt((entry &amp; PAGE_MASK)): ptr +1)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kimage_free_entry</span><span class="p">(</span><span class="n">kimage_entry_t</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">entry</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">kimage_free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kimage_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kimage_entry_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">kimage_entry_t</span> <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">image</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">kimage_free_extra_pages</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>
	<span class="n">for_each_kimage_entry</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&amp;</span> <span class="n">IND_INDIRECTION</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Free the previous indirection page */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&amp;</span> <span class="n">IND_INDIRECTION</span><span class="p">)</span>
				<span class="n">kimage_free_entry</span><span class="p">(</span><span class="n">ind</span><span class="p">);</span>
			<span class="cm">/* Save this indirection page until we are</span>
<span class="cm">			 * done with it.</span>
<span class="cm">			 */</span>
			<span class="n">ind</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&amp;</span> <span class="n">IND_SOURCE</span><span class="p">)</span>
			<span class="n">kimage_free_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Free the final indirection page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&amp;</span> <span class="n">IND_INDIRECTION</span><span class="p">)</span>
		<span class="n">kimage_free_entry</span><span class="p">(</span><span class="n">ind</span><span class="p">);</span>

	<span class="cm">/* Handle any machine specific cleanup */</span>
	<span class="n">machine_kexec_cleanup</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>

	<span class="cm">/* Free the kexec control pages... */</span>
	<span class="n">kimage_free_page_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">control_pages</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">kimage_entry_t</span> <span class="o">*</span><span class="nf">kimage_dst_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kimage_entry_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">destination</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_kimage_entry</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&amp;</span> <span class="n">IND_DESTINATION</span><span class="p">)</span>
			<span class="n">destination</span> <span class="o">=</span> <span class="n">entry</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&amp;</span> <span class="n">IND_SOURCE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">destination</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
			<span class="n">destination</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">kimage_alloc_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span>
					<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">destination</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Here we implement safeguards to ensure that a source page</span>
<span class="cm">	 * is not copied to its destination page before the data on</span>
<span class="cm">	 * the destination page is no longer useful.</span>
<span class="cm">	 *</span>
<span class="cm">	 * To do this we maintain the invariant that a source page is</span>
<span class="cm">	 * either its own destination page, or it is not a</span>
<span class="cm">	 * destination page at all.</span>
<span class="cm">	 *</span>
<span class="cm">	 * That is slightly stronger than required, but the proof</span>
<span class="cm">	 * that no problems will not occur is trivial, and the</span>
<span class="cm">	 * implementation is simply to verify.</span>
<span class="cm">	 *</span>
<span class="cm">	 * When allocating all pages normally this algorithm will run</span>
<span class="cm">	 * in O(N) time, but in the worst case it will run in O(N^2)</span>
<span class="cm">	 * time.   If the runtime is a problem the data structures can</span>
<span class="cm">	 * be fixed.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Walk through the list of destination pages, and see if I</span>
<span class="cm">	 * have a match.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">dest_pages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kimage_entry_t</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>

		<span class="cm">/* Allocate a page, if we run out of memory give up */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">kimage_alloc_pages</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/* If the page cannot be used file it away */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&gt;</span>
				<span class="p">(</span><span class="n">KEXEC_SOURCE_MEMORY_LIMIT</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">unuseable_pages</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

		<span class="cm">/* If it is the destination page we want use it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="n">destination</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* If the page is not a destination page use it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kimage_is_destination_range</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
						  <span class="n">addr</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * I know that the page is someones destination page.</span>
<span class="cm">		 * See if there is already a source page for this</span>
<span class="cm">		 * destination page.  And if so swap the source pages.</span>
<span class="cm">		 */</span>
		<span class="n">old</span> <span class="o">=</span> <span class="n">kimage_dst_used</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If so move it */</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_addr</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">old_page</span><span class="p">;</span>

			<span class="n">old_addr</span> <span class="o">=</span> <span class="o">*</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
			<span class="n">old_page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">old_addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
			<span class="n">copy_highpage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">old_page</span><span class="p">);</span>
			<span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">|</span> <span class="p">(</span><span class="o">*</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">);</span>

			<span class="cm">/* The old page I have found cannot be a</span>
<span class="cm">			 * destination page, so return it if it&#39;s</span>
<span class="cm">			 * gfp_flags honor the ones passed in.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_HIGHMEM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">PageHighMem</span><span class="p">(</span><span class="n">old_page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">kimage_free_pages</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">old_addr</span><span class="p">;</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">old_page</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Place the page on the destination list I</span>
<span class="cm">			 * will use it later.</span>
<span class="cm">			 */</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">dest_pages</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kimage_load_normal_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">kexec_segment</span> <span class="o">*</span><span class="n">segment</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ubytes</span><span class="p">,</span> <span class="n">mbytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">segment</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">ubytes</span> <span class="o">=</span> <span class="n">segment</span><span class="o">-&gt;</span><span class="n">bufsz</span><span class="p">;</span>
	<span class="n">mbytes</span> <span class="o">=</span> <span class="n">segment</span><span class="o">-&gt;</span><span class="n">memsz</span><span class="p">;</span>
	<span class="n">maddr</span> <span class="o">=</span> <span class="n">segment</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">kimage_set_destination</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">maddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">mbytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">uchunk</span><span class="p">,</span> <span class="n">mchunk</span><span class="p">;</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">kimage_alloc_page</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">GFP_HIGHUSER</span><span class="p">,</span> <span class="n">maddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span>  <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">kimage_add_page</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">)</span>
								<span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">ptr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/* Start with a clear page */</span>
		<span class="n">clear_page</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">maddr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="n">mchunk</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">maddr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mchunk</span> <span class="o">&gt;</span> <span class="n">mbytes</span><span class="p">)</span>
			<span class="n">mchunk</span> <span class="o">=</span> <span class="n">mbytes</span><span class="p">;</span>

		<span class="n">uchunk</span> <span class="o">=</span> <span class="n">mchunk</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uchunk</span> <span class="o">&gt;</span> <span class="n">ubytes</span><span class="p">)</span>
			<span class="n">uchunk</span> <span class="o">=</span> <span class="n">ubytes</span><span class="p">;</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">uchunk</span><span class="p">);</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ubytes</span> <span class="o">-=</span> <span class="n">uchunk</span><span class="p">;</span>
		<span class="n">maddr</span>  <span class="o">+=</span> <span class="n">mchunk</span><span class="p">;</span>
		<span class="n">buf</span>    <span class="o">+=</span> <span class="n">mchunk</span><span class="p">;</span>
		<span class="n">mbytes</span> <span class="o">-=</span> <span class="n">mchunk</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kimage_load_crash_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kexec_segment</span> <span class="o">*</span><span class="n">segment</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* For crash dumps kernels we simply copy the data from</span>
<span class="cm">	 * user space to it&#39;s destination.</span>
<span class="cm">	 * We do things a page at a time for the sake of kmap.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ubytes</span><span class="p">,</span> <span class="n">mbytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">segment</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">ubytes</span> <span class="o">=</span> <span class="n">segment</span><span class="o">-&gt;</span><span class="n">bufsz</span><span class="p">;</span>
	<span class="n">mbytes</span> <span class="o">=</span> <span class="n">segment</span><span class="o">-&gt;</span><span class="n">memsz</span><span class="p">;</span>
	<span class="n">maddr</span> <span class="o">=</span> <span class="n">segment</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">mbytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">uchunk</span><span class="p">,</span> <span class="n">mchunk</span><span class="p">;</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">maddr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span>  <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">maddr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="n">mchunk</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">maddr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mchunk</span> <span class="o">&gt;</span> <span class="n">mbytes</span><span class="p">)</span>
			<span class="n">mchunk</span> <span class="o">=</span> <span class="n">mbytes</span><span class="p">;</span>

		<span class="n">uchunk</span> <span class="o">=</span> <span class="n">mchunk</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uchunk</span> <span class="o">&gt;</span> <span class="n">ubytes</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uchunk</span> <span class="o">=</span> <span class="n">ubytes</span><span class="p">;</span>
			<span class="cm">/* Zero the trailing part of the page */</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">uchunk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mchunk</span> <span class="o">-</span> <span class="n">uchunk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">uchunk</span><span class="p">);</span>
		<span class="n">kexec_flush_icache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ubytes</span> <span class="o">-=</span> <span class="n">uchunk</span><span class="p">;</span>
		<span class="n">maddr</span>  <span class="o">+=</span> <span class="n">mchunk</span><span class="p">;</span>
		<span class="n">buf</span>    <span class="o">+=</span> <span class="n">mchunk</span><span class="p">;</span>
		<span class="n">mbytes</span> <span class="o">-=</span> <span class="n">mchunk</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kimage_load_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kexec_segment</span> <span class="o">*</span><span class="n">segment</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KEXEC_TYPE_DEFAULT</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">kimage_load_normal_segment</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">segment</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">KEXEC_TYPE_CRASH</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">kimage_load_crash_segment</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">segment</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Exec Kernel system call: for obvious reasons only root may call it.</span>
<span class="cm"> *</span>
<span class="cm"> * This call breaks up into three pieces.</span>
<span class="cm"> * - A generic part which loads the new kernel from the current</span>
<span class="cm"> *   address space, and very carefully places the data in the</span>
<span class="cm"> *   allocated pages.</span>
<span class="cm"> *</span>
<span class="cm"> * - A generic part that interacts with the kernel and tells all of</span>
<span class="cm"> *   the devices to shut down.  Preventing on-going dmas, and placing</span>
<span class="cm"> *   the devices in a consistent state so a later kernel can</span>
<span class="cm"> *   reinitialize them.</span>
<span class="cm"> *</span>
<span class="cm"> * - A machine specific part that includes the syscall number</span>
<span class="cm"> *   and the copies the image to it&#39;s final destination.  And</span>
<span class="cm"> *   jumps into the image at entry.</span>
<span class="cm"> *</span>
<span class="cm"> * kexec does not sync, or unmount filesystems so if you need</span>
<span class="cm"> * that to happen you need to do that yourself.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">kexec_image</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">kexec_crash_image</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">kexec_mutex</span><span class="p">);</span>

<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">kexec_load</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">nr_segments</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kexec_segment</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">segments</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kimage</span> <span class="o">**</span><span class="n">dest_image</span><span class="p">,</span> <span class="o">*</span><span class="n">image</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* We only trust the superuser with rebooting the system. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_BOOT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Verify we have a legal set of flags</span>
<span class="cm">	 * This leaves us room for future extensions.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KEXEC_FLAGS</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">KEXEC_ARCH_MASK</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Verify we are on the appropriate architecture */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KEXEC_ARCH_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">KEXEC_ARCH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KEXEC_ARCH_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">KEXEC_ARCH_DEFAULT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Put an artificial cap on the number</span>
<span class="cm">	 * of segments passed to kexec_load.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_segments</span> <span class="o">&gt;</span> <span class="n">KEXEC_SEGMENT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">image</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Because we write directly to the reserved memory</span>
<span class="cm">	 * region when loading crash kernels we need a mutex here to</span>
<span class="cm">	 * prevent multiple crash  kernels from attempting to load</span>
<span class="cm">	 * simultaneously, and to prevent a crash kernel from loading</span>
<span class="cm">	 * over the top of a in use crash kernel.</span>
<span class="cm">	 *</span>
<span class="cm">	 * KISS: always take the mutex.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_mutex</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">dest_image</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kexec_image</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KEXEC_ON_CRASH</span><span class="p">)</span>
		<span class="n">dest_image</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kexec_crash_image</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_segments</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/* Loading another kernel to reboot into */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KEXEC_ON_CRASH</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">kimage_normal_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span>
							<span class="n">nr_segments</span><span class="p">,</span> <span class="n">segments</span><span class="p">);</span>
		<span class="cm">/* Loading another kernel to switch to if this one crashes */</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KEXEC_ON_CRASH</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Free any current crash dump kernel before</span>
<span class="cm">			 * we corrupt it.</span>
<span class="cm">			 */</span>
			<span class="n">kimage_free</span><span class="p">(</span><span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_crash_image</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">kimage_crash_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span>
						     <span class="n">nr_segments</span><span class="p">,</span> <span class="n">segments</span><span class="p">);</span>
			<span class="n">crash_map_reserved_pages</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KEXEC_PRESERVE_CONTEXT</span><span class="p">)</span>
			<span class="n">image</span><span class="o">-&gt;</span><span class="n">preserve_context</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">machine_kexec_prepare</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_segments</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">kimage_load_segment</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kimage_terminate</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KEXEC_ON_CRASH</span><span class="p">)</span>
			<span class="n">crash_unmap_reserved_pages</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="cm">/* Install the new kernel, and  Uninstall the old */</span>
	<span class="n">image</span> <span class="o">=</span> <span class="n">xchg</span><span class="p">(</span><span class="n">dest_image</span><span class="p">,</span> <span class="n">image</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_mutex</span><span class="p">);</span>
	<span class="n">kimage_free</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add and remove page tables for crashkernel memory</span>
<span class="cm"> *</span>
<span class="cm"> * Provide an empty default implementation here -- architecture</span>
<span class="cm"> * code may override this</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__weak</span> <span class="n">crash_map_reserved_pages</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{}</span>

<span class="kt">void</span> <span class="n">__weak</span> <span class="n">crash_unmap_reserved_pages</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="n">asmlinkage</span> <span class="kt">long</span> <span class="n">compat_sys_kexec_load</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entry</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segments</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">compat_kexec_segment</span> <span class="n">__user</span> <span class="o">*</span><span class="n">segments</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">compat_kexec_segment</span> <span class="n">in</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kexec_segment</span> <span class="n">out</span><span class="p">,</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ksegments</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t allow clients that don&#39;t understand the native</span>
<span class="cm">	 * architecture to do anything.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KEXEC_ARCH_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">KEXEC_ARCH_DEFAULT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_segments</span> <span class="o">&gt;</span> <span class="n">KEXEC_SEGMENT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ksegments</span> <span class="o">=</span> <span class="n">compat_alloc_user_space</span><span class="p">(</span><span class="n">nr_segments</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_segments</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">segments</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">in</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">out</span><span class="p">.</span><span class="n">buf</span>   <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">out</span><span class="p">.</span><span class="n">bufsz</span> <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">bufsz</span><span class="p">;</span>
		<span class="n">out</span><span class="p">.</span><span class="n">mem</span>   <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">mem</span><span class="p">;</span>
		<span class="n">out</span><span class="p">.</span><span class="n">memsz</span> <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">memsz</span><span class="p">;</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksegments</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sys_kexec_load</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">nr_segments</span><span class="p">,</span> <span class="n">ksegments</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">crash_kexec</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Take the kexec_mutex here to prevent sys_kexec_load</span>
<span class="cm">	 * running on one cpu from replacing the crash kernel</span>
<span class="cm">	 * we are using after a panic on a different cpu.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the crash kernel was not located in a fixed area</span>
<span class="cm">	 * of memory the xchg(&amp;kexec_crash_image) would be</span>
<span class="cm">	 * sufficient.  But since I reuse the memory...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_mutex</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kexec_crash_image</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">pt_regs</span> <span class="n">fixed_regs</span><span class="p">;</span>

			<span class="n">crash_setup_regs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fixed_regs</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
			<span class="n">crash_save_vmcoreinfo</span><span class="p">();</span>
			<span class="n">machine_crash_shutdown</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fixed_regs</span><span class="p">);</span>
			<span class="n">machine_kexec</span><span class="p">(</span><span class="n">kexec_crash_image</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="n">crash_get_memory_size</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span> <span class="o">!=</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">start</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">resource_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crashk_res</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__weak</span> <span class="n">crash_free_reserved_phys_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">begin</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
		<span class="n">init_page_count</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
		<span class="n">totalram_pages</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">crash_shrink_memory</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">ram_res</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kexec_crash_image</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span><span class="p">;</span>
	<span class="n">old_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&gt;=</span> <span class="n">old_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">==</span> <span class="n">old_size</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ram_res</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ram_res</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ram_res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">KEXEC_CRASH_MEM_ALIGN</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">new_size</span><span class="p">,</span> <span class="n">KEXEC_CRASH_MEM_ALIGN</span><span class="p">);</span>

	<span class="n">crash_map_reserved_pages</span><span class="p">();</span>
	<span class="n">crash_free_reserved_phys_range</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">crashk_res</span><span class="p">.</span><span class="n">parent</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">release_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crashk_res</span><span class="p">);</span>

	<span class="n">ram_res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">ram_res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span><span class="p">;</span>
	<span class="n">ram_res</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_BUSY</span> <span class="o">|</span> <span class="n">IORESOURCE_MEM</span><span class="p">;</span>
	<span class="n">ram_res</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;System RAM&quot;</span><span class="p">;</span>

	<span class="n">crashk_res</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">insert_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="n">ram_res</span><span class="p">);</span>
	<span class="n">crash_unmap_reserved_pages</span><span class="p">();</span>

<span class="nl">unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="o">*</span><span class="n">append_elf_note</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">data_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elf_note</span> <span class="n">note</span><span class="p">;</span>

	<span class="n">note</span><span class="p">.</span><span class="n">n_namesz</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">note</span><span class="p">.</span><span class="n">n_descsz</span> <span class="o">=</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="n">note</span><span class="p">.</span><span class="n">n_type</span>   <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">note</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">note</span><span class="p">));</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">note</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">note</span><span class="p">.</span><span class="n">n_namesz</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="p">(</span><span class="n">note</span><span class="p">.</span><span class="n">n_namesz</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">note</span><span class="p">.</span><span class="n">n_descsz</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="p">(</span><span class="n">note</span><span class="p">.</span><span class="n">n_descsz</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">final_note</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elf_note</span> <span class="n">note</span><span class="p">;</span>

	<span class="n">note</span><span class="p">.</span><span class="n">n_namesz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">note</span><span class="p">.</span><span class="n">n_descsz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">note</span><span class="p">.</span><span class="n">n_type</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">note</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">note</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">crash_save_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elf_prstatus</span> <span class="n">prstatus</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cpu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Using ELF notes here is opportunistic.</span>
<span class="cm">	 * I need a well defined structure format</span>
<span class="cm">	 * for the data I pass, and I need tags</span>
<span class="cm">	 * on the data to indicate what information I have</span>
<span class="cm">	 * squirrelled away.  ELF notes happen to provide</span>
<span class="cm">	 * all of that, so there is no need to invent something new.</span>
<span class="cm">	 */</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="o">*</span><span class="p">)</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">crash_notes</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prstatus</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">prstatus</span><span class="p">));</span>
	<span class="n">prstatus</span><span class="p">.</span><span class="n">pr_pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="n">elf_core_copy_kernel_regs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prstatus</span><span class="p">.</span><span class="n">pr_reg</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">append_elf_note</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">KEXEC_CORE_NOTE_NAME</span><span class="p">,</span> <span class="n">NT_PRSTATUS</span><span class="p">,</span>
		      	      <span class="o">&amp;</span><span class="n">prstatus</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">prstatus</span><span class="p">));</span>
	<span class="n">final_note</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">crash_notes_memory_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Allocate memory for saving cpu registers. */</span>
	<span class="n">crash_notes</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="n">note_buf_t</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">crash_notes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Kexec: Memory allocation for saving cpu register&quot;</span>
		<span class="s">&quot; states failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">crash_notes_memory_init</span><span class="p">)</span>


<span class="cm">/*</span>
<span class="cm"> * parsing the &quot;crashkernel&quot; commandline</span>
<span class="cm"> *</span>
<span class="cm"> * this code is intended to be called from architecture specific code</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * This function parses command lines in the format</span>
<span class="cm"> *</span>
<span class="cm"> *   crashkernel=ramsize-range:size[,...][@offset]</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns 0 on success and -EINVAL on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">parse_crashkernel_mem</span><span class="p">(</span><span class="kt">char</span> 			<span class="o">*</span><span class="n">cmdline</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>	<span class="n">system_ram</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>	<span class="o">*</span><span class="n">crash_size</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>	<span class="o">*</span><span class="n">crash_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">cmdline</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* for each entry of the comma-separated list */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">ULLONG_MAX</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

		<span class="cm">/* get the start of the range */</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;crashkernel: Memory value expected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span> <span class="o">!=</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;crashkernel: &#39;-&#39; expected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cur</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* if no &#39;:&#39; is here, than we read the end */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span> <span class="o">!=</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;crashkernel: Memory &quot;</span>
						<span class="s">&quot;value expected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cur</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;crashkernel: end &lt;= start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span> <span class="o">!=</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;crashkernel: &#39;:&#39; expected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cur</span><span class="o">++</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Memory value expected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">system_ram</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;crashkernel: invalid size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* match ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">system_ram</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">system_ram</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">crash_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="o">++</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">crash_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">cur</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">cur</span> <span class="o">!=</span> <span class="sc">&#39;@&#39;</span><span class="p">)</span>
			<span class="n">cur</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span> <span class="o">==</span> <span class="sc">&#39;@&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cur</span><span class="o">++</span><span class="p">;</span>
			<span class="o">*</span><span class="n">crash_base</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Memory value expected &quot;</span>
						<span class="s">&quot;after &#39;@&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * That function parses &quot;simple&quot; (old) crashkernel command lines like</span>
<span class="cm"> *</span>
<span class="cm"> * 	crashkernel=size[@offset]</span>
<span class="cm"> *</span>
<span class="cm"> * It returns 0 on success and -EINVAL on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">parse_crashkernel_simple</span><span class="p">(</span><span class="kt">char</span> 		<span class="o">*</span><span class="n">cmdline</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> 	<span class="o">*</span><span class="n">crash_size</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> 	<span class="o">*</span><span class="n">crash_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">cmdline</span><span class="p">;</span>

	<span class="o">*</span><span class="n">crash_size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">cmdline</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmdline</span> <span class="o">==</span> <span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;crashkernel: memory value expected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span> <span class="o">==</span> <span class="sc">&#39;@&#39;</span><span class="p">)</span>
		<span class="o">*</span><span class="n">crash_base</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">);</span>
	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">cur</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;crashkernel: unrecognized char</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * That function is the entry point for command line parsing and should be</span>
<span class="cm"> * called from the arch-specific code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="n">parse_crashkernel</span><span class="p">(</span><span class="kt">char</span> 		 <span class="o">*</span><span class="n">cmdline</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">system_ram</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">crash_size</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">crash_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> 	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cmdline</span><span class="p">,</span> <span class="o">*</span><span class="n">ck_cmdline</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">first_colon</span><span class="p">,</span> <span class="o">*</span><span class="n">first_space</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">crash_size</span> <span class="o">||</span> <span class="o">!</span><span class="n">crash_base</span><span class="p">);</span>
	<span class="o">*</span><span class="n">crash_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">crash_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* find crashkernel and use the last one if there are more */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;crashkernel=&quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ck_cmdline</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;crashkernel=&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ck_cmdline</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ck_cmdline</span> <span class="o">+=</span> <span class="mi">12</span><span class="p">;</span> <span class="cm">/* strlen(&quot;crashkernel=&quot;) */</span>

	<span class="cm">/*</span>
<span class="cm">	 * if the commandline contains a &#39;:&#39;, then that&#39;s the extended</span>
<span class="cm">	 * syntax -- if not, it must be the classic syntax</span>
<span class="cm">	 */</span>
	<span class="n">first_colon</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">ck_cmdline</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">);</span>
	<span class="n">first_space</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">ck_cmdline</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_colon</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">first_space</span> <span class="o">||</span> <span class="n">first_colon</span> <span class="o">&lt;</span> <span class="n">first_space</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">parse_crashkernel_mem</span><span class="p">(</span><span class="n">ck_cmdline</span><span class="p">,</span> <span class="n">system_ram</span><span class="p">,</span>
				<span class="n">crash_size</span><span class="p">,</span> <span class="n">crash_base</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">parse_crashkernel_simple</span><span class="p">(</span><span class="n">ck_cmdline</span><span class="p">,</span> <span class="n">crash_size</span><span class="p">,</span>
				<span class="n">crash_base</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">update_vmcoreinfo_note</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">vmcoreinfo_note</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmcoreinfo_size</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">append_elf_note</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">VMCOREINFO_NOTE_NAME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vmcoreinfo_data</span><span class="p">,</span>
			      <span class="n">vmcoreinfo_size</span><span class="p">);</span>
	<span class="n">final_note</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">crash_save_vmcoreinfo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcoreinfo_append_str</span><span class="p">(</span><span class="s">&quot;CRASHTIME=%ld&quot;</span><span class="p">,</span> <span class="n">get_seconds</span><span class="p">());</span>
	<span class="n">update_vmcoreinfo_note</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">vmcoreinfo_append_str</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mh">0x50</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">vsnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">vmcoreinfo_size</span> <span class="o">&gt;</span> <span class="n">vmcoreinfo_max_size</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">vmcoreinfo_max_size</span> <span class="o">-</span> <span class="n">vmcoreinfo_size</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmcoreinfo_data</span><span class="p">[</span><span class="n">vmcoreinfo_size</span><span class="p">],</span> <span class="n">buf</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

	<span class="n">vmcoreinfo_size</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * provide an empty default implementation here -- architecture</span>
<span class="cm"> * code may override this</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">arch_crash_save_vmcoreinfo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">paddr_vmcoreinfo_note</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pa</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vmcoreinfo_note</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">crash_save_vmcoreinfo_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VMCOREINFO_OSRELEASE</span><span class="p">(</span><span class="n">init_uts_ns</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">release</span><span class="p">);</span>
	<span class="n">VMCOREINFO_PAGESIZE</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">VMCOREINFO_SYMBOL</span><span class="p">(</span><span class="n">init_uts_ns</span><span class="p">);</span>
	<span class="n">VMCOREINFO_SYMBOL</span><span class="p">(</span><span class="n">node_online_map</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_MMU</span>
	<span class="n">VMCOREINFO_SYMBOL</span><span class="p">(</span><span class="n">swapper_pg_dir</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">VMCOREINFO_SYMBOL</span><span class="p">(</span><span class="n">_stext</span><span class="p">);</span>
	<span class="n">VMCOREINFO_SYMBOL</span><span class="p">(</span><span class="n">vmlist</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_NEED_MULTIPLE_NODES</span>
	<span class="n">VMCOREINFO_SYMBOL</span><span class="p">(</span><span class="n">mem_map</span><span class="p">);</span>
	<span class="n">VMCOREINFO_SYMBOL</span><span class="p">(</span><span class="n">contig_page_data</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SPARSEMEM</span>
	<span class="n">VMCOREINFO_SYMBOL</span><span class="p">(</span><span class="n">mem_section</span><span class="p">);</span>
	<span class="n">VMCOREINFO_LENGTH</span><span class="p">(</span><span class="n">mem_section</span><span class="p">,</span> <span class="n">NR_SECTION_ROOTS</span><span class="p">);</span>
	<span class="n">VMCOREINFO_STRUCT_SIZE</span><span class="p">(</span><span class="n">mem_section</span><span class="p">);</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">mem_section</span><span class="p">,</span> <span class="n">section_mem_map</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">VMCOREINFO_STRUCT_SIZE</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">VMCOREINFO_STRUCT_SIZE</span><span class="p">(</span><span class="n">pglist_data</span><span class="p">);</span>
	<span class="n">VMCOREINFO_STRUCT_SIZE</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>
	<span class="n">VMCOREINFO_STRUCT_SIZE</span><span class="p">(</span><span class="n">free_area</span><span class="p">);</span>
	<span class="n">VMCOREINFO_STRUCT_SIZE</span><span class="p">(</span><span class="n">list_head</span><span class="p">);</span>
	<span class="n">VMCOREINFO_SIZE</span><span class="p">(</span><span class="n">nodemask_t</span><span class="p">);</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">_count</span><span class="p">);</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">);</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">pglist_data</span><span class="p">,</span> <span class="n">node_zones</span><span class="p">);</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">pglist_data</span><span class="p">,</span> <span class="n">nr_zones</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_FLAT_NODE_MEM_MAP</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">pglist_data</span><span class="p">,</span> <span class="n">node_mem_map</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">pglist_data</span><span class="p">,</span> <span class="n">node_start_pfn</span><span class="p">);</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">pglist_data</span><span class="p">,</span> <span class="n">node_spanned_pages</span><span class="p">);</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">pglist_data</span><span class="p">,</span> <span class="n">node_id</span><span class="p">);</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">free_area</span><span class="p">);</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">vm_stat</span><span class="p">);</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">spanned_pages</span><span class="p">);</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">free_area</span><span class="p">,</span> <span class="n">free_list</span><span class="p">);</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">list_head</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">list_head</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
	<span class="n">VMCOREINFO_OFFSET</span><span class="p">(</span><span class="n">vm_struct</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">VMCOREINFO_LENGTH</span><span class="p">(</span><span class="n">zone</span><span class="p">.</span><span class="n">free_area</span><span class="p">,</span> <span class="n">MAX_ORDER</span><span class="p">);</span>
	<span class="n">log_buf_kexec_setup</span><span class="p">();</span>
	<span class="n">VMCOREINFO_LENGTH</span><span class="p">(</span><span class="n">free_area</span><span class="p">.</span><span class="n">free_list</span><span class="p">,</span> <span class="n">MIGRATE_TYPES</span><span class="p">);</span>
	<span class="n">VMCOREINFO_NUMBER</span><span class="p">(</span><span class="n">NR_FREE_PAGES</span><span class="p">);</span>
	<span class="n">VMCOREINFO_NUMBER</span><span class="p">(</span><span class="n">PG_lru</span><span class="p">);</span>
	<span class="n">VMCOREINFO_NUMBER</span><span class="p">(</span><span class="n">PG_private</span><span class="p">);</span>
	<span class="n">VMCOREINFO_NUMBER</span><span class="p">(</span><span class="n">PG_swapcache</span><span class="p">);</span>

	<span class="n">arch_crash_save_vmcoreinfo</span><span class="p">();</span>
	<span class="n">update_vmcoreinfo_note</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">crash_save_vmcoreinfo_init</span><span class="p">)</span>

<span class="cm">/*</span>
<span class="cm"> * Move into place and start executing a preloaded standalone</span>
<span class="cm"> * executable.  If nothing was preloaded return an error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">kernel_kexec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_mutex</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kexec_image</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">Unlock</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_KEXEC_JUMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kexec_image</span><span class="o">-&gt;</span><span class="n">preserve_context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lock_system_sleep</span><span class="p">();</span>
		<span class="n">pm_prepare_console</span><span class="p">();</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">freeze_processes</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">Restore_console</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">suspend_console</span><span class="p">();</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">dpm_suspend_start</span><span class="p">(</span><span class="n">PMSG_FREEZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">Resume_console</span><span class="p">;</span>
		<span class="cm">/* At this point, dpm_suspend_start() has been called,</span>
<span class="cm">		 * but *not* dpm_suspend_end(). We *must* call</span>
<span class="cm">		 * dpm_suspend_end() now.  Otherwise, drivers for</span>
<span class="cm">		 * some devices (e.g. interrupt controllers) become</span>
<span class="cm">		 * desynchronized with the actual state of the</span>
<span class="cm">		 * hardware at resume time, and evil weirdness ensues.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">dpm_suspend_end</span><span class="p">(</span><span class="n">PMSG_FREEZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">Resume_devices</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">disable_nonboot_cpus</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">Enable_cpus</span><span class="p">;</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">syscore_suspend</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">Enable_irqs</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
	<span class="p">{</span>
		<span class="n">kernel_restart_prepare</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;Starting new kernel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">machine_shutdown</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">machine_kexec</span><span class="p">(</span><span class="n">kexec_image</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_KEXEC_JUMP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kexec_image</span><span class="o">-&gt;</span><span class="n">preserve_context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">syscore_resume</span><span class="p">();</span>
 <span class="nl">Enable_irqs:</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
 <span class="nl">Enable_cpus:</span>
		<span class="n">enable_nonboot_cpus</span><span class="p">();</span>
		<span class="n">dpm_resume_start</span><span class="p">(</span><span class="n">PMSG_RESTORE</span><span class="p">);</span>
 <span class="nl">Resume_devices:</span>
		<span class="n">dpm_resume_end</span><span class="p">(</span><span class="n">PMSG_RESTORE</span><span class="p">);</span>
 <span class="nl">Resume_console:</span>
		<span class="n">resume_console</span><span class="p">();</span>
		<span class="n">thaw_processes</span><span class="p">();</span>
 <span class="nl">Restore_console:</span>
		<span class="n">pm_restore_console</span><span class="p">();</span>
		<span class="n">unlock_system_sleep</span><span class="p">();</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

 <span class="nl">Unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kexec_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
