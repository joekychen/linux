<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › padata.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>padata.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * padata.c - generic interface to process data streams in parallel</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/padata.txt for an api documentation.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008, 2009 secunet Security Networks AG</span>
<span class="cm"> * Copyright (C) 2008, 2009 Steffen Klassert &lt;steffen.klassert@secunet.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/padata.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sysfs.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>

<span class="cp">#define MAX_OBJ_NUM 1000</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">padata_index_to_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">target_cpu</span><span class="p">;</span>

	<span class="n">target_cpu</span> <span class="o">=</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">cpu_index</span><span class="p">;</span> <span class="n">cpu</span><span class="o">++</span><span class="p">)</span>
		<span class="n">target_cpu</span> <span class="o">=</span> <span class="n">cpumask_next</span><span class="p">(</span><span class="n">target_cpu</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">target_cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">padata_cpu_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu_index</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Hash the sequence numbers to the cpus by taking</span>
<span class="cm">	 * seq_nr mod. number of cpus in use.</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">seq_lock</span><span class="p">);</span>
	<span class="n">cpu_index</span> <span class="o">=</span>  <span class="n">pd</span><span class="o">-&gt;</span><span class="n">seq_nr</span> <span class="o">%</span> <span class="n">cpumask_weight</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">);</span>
	<span class="n">pd</span><span class="o">-&gt;</span><span class="n">seq_nr</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">seq_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">padata_index_to_cpu</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">cpu_index</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">padata_parallel_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">parallel_work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">padata_parallel_queue</span> <span class="o">*</span><span class="n">pqueue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">local_list</span><span class="p">);</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">pqueue</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">parallel_work</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">padata_parallel_queue</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="n">pd</span> <span class="o">=</span> <span class="n">pqueue</span><span class="o">-&gt;</span><span class="n">pd</span><span class="p">;</span>
	<span class="n">pinst</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">pinst</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="o">-&gt;</span><span class="n">parallel</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_replace_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="o">-&gt;</span><span class="n">parallel</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="o">-&gt;</span><span class="n">parallel</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">padata_priv</span> <span class="o">*</span><span class="n">padata</span><span class="p">;</span>

		<span class="n">padata</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">local_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">padata_priv</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">padata</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="n">padata</span><span class="o">-&gt;</span><span class="n">parallel</span><span class="p">(</span><span class="n">padata</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">local_bh_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * padata_do_parallel - padata parallelization function</span>
<span class="cm"> *</span>
<span class="cm"> * @pinst: padata instance</span>
<span class="cm"> * @padata: object to be parallelized</span>
<span class="cm"> * @cb_cpu: cpu the serialization callback function will run on,</span>
<span class="cm"> *          must be in the serial cpumask of padata(i.e. cpumask.cbcpu).</span>
<span class="cm"> *</span>
<span class="cm"> * The parallelization callback function will run with BHs off.</span>
<span class="cm"> * Note: Every object which is parallelized by padata_do_parallel</span>
<span class="cm"> * must be seen by padata_do_serial.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">padata_do_parallel</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">padata_priv</span> <span class="o">*</span><span class="n">padata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cb_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">target_cpu</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">padata_parallel_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>

	<span class="n">rcu_read_lock_bh</span><span class="p">();</span>

	<span class="n">pd</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">pd</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PADATA_INIT</span><span class="p">)</span> <span class="o">||</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PADATA_INVALID</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cb_cpu</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span>  <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PADATA_RESET</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">MAX_OBJ_NUM</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="n">padata</span><span class="o">-&gt;</span><span class="n">pd</span> <span class="o">=</span> <span class="n">pd</span><span class="p">;</span>
	<span class="n">padata</span><span class="o">-&gt;</span><span class="n">cb_cpu</span> <span class="o">=</span> <span class="n">cb_cpu</span><span class="p">;</span>

	<span class="n">target_cpu</span> <span class="o">=</span> <span class="n">padata_cpu_hash</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>
	<span class="n">queue</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">pqueue</span><span class="p">,</span> <span class="n">target_cpu</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">parallel</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">padata</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">parallel</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">parallel</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">queue_work_on</span><span class="p">(</span><span class="n">target_cpu</span><span class="p">,</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">rcu_read_unlock_bh</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">padata_do_parallel</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * padata_get_next - Get the next object that needs serialization.</span>
<span class="cm"> *</span>
<span class="cm"> * Return values are:</span>
<span class="cm"> *</span>
<span class="cm"> * A pointer to the control struct of the next object that needs</span>
<span class="cm"> * serialization, if present in one of the percpu reorder queues.</span>
<span class="cm"> *</span>
<span class="cm"> * NULL, if all percpu reorder queues are empty.</span>
<span class="cm"> *</span>
<span class="cm"> * -EINPROGRESS, if the next object that needs serialization will</span>
<span class="cm"> *  be parallel processed by another cpu and is not yet present in</span>
<span class="cm"> *  the cpu&#39;s reorder queue.</span>
<span class="cm"> *</span>
<span class="cm"> * -ENODATA, if this cpu has to do the parallel processing for</span>
<span class="cm"> *  the next object.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">padata_priv</span> <span class="o">*</span><span class="nf">padata_get_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">num_cpus</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next_nr</span><span class="p">,</span> <span class="n">next_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">padata_parallel_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="o">*</span><span class="n">next_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">padata_priv</span> <span class="o">*</span><span class="n">padata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">padata_list</span> <span class="o">*</span><span class="n">reorder</span><span class="p">;</span>

	<span class="n">num_cpus</span> <span class="o">=</span> <span class="n">cpumask_weight</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the percpu reorder queue and the sequence</span>
<span class="cm">	 * number of the next object.</span>
<span class="cm">	 */</span>
	<span class="n">next_nr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">processed</span><span class="p">;</span>
	<span class="n">next_index</span> <span class="o">=</span> <span class="n">next_nr</span> <span class="o">%</span> <span class="n">num_cpus</span><span class="p">;</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">padata_index_to_cpu</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">next_index</span><span class="p">);</span>
	<span class="n">next_queue</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">pqueue</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">padata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">reorder</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">next_queue</span><span class="o">-&gt;</span><span class="n">reorder</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reorder</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">padata</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">reorder</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">padata_priv</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reorder</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">padata</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">reorder_objects</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reorder</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">pd</span><span class="o">-&gt;</span><span class="n">processed</span><span class="o">++</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">queue</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">pqueue</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">cpu_index</span> <span class="o">==</span> <span class="n">next_queue</span><span class="o">-&gt;</span><span class="n">cpu_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">padata</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODATA</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">padata</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">padata</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">padata_reorder</span><span class="p">(</span><span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cb_cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">padata_priv</span> <span class="o">*</span><span class="n">padata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">padata_serial_queue</span> <span class="o">*</span><span class="n">squeue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">pinst</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to ensure that only one cpu can work on dequeueing of</span>
<span class="cm">	 * the reorder queue the time. Calculating in which percpu reorder</span>
<span class="cm">	 * queue the next object will arrive takes some time. A spinlock</span>
<span class="cm">	 * would be highly contended. Also it is not clear in which order</span>
<span class="cm">	 * the objects arrive to the reorder queues. So a cpu could wait to</span>
<span class="cm">	 * get the lock just to notice that there is nothing to do at the</span>
<span class="cm">	 * moment. Therefore we use a trylock and let the holder of the lock</span>
<span class="cm">	 * care for all the objects enqueued during the holdtime of the lock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">padata</span> <span class="o">=</span> <span class="n">padata_get_next</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * All reorder queues are empty, or the next object that needs</span>
<span class="cm">		 * serialization is parallel processed by another cpu and is</span>
<span class="cm">		 * still on it&#39;s way to the cpu&#39;s reorder queue, nothing to</span>
<span class="cm">		 * do for now.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">padata</span> <span class="o">||</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">padata</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * This cpu has to do the parallel processing of the next</span>
<span class="cm">		 * object. It&#39;s waiting in the cpu&#39;s parallelization queue,</span>
<span class="cm">		 * so exit immediately.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">padata</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cb_cpu</span> <span class="o">=</span> <span class="n">padata</span><span class="o">-&gt;</span><span class="n">cb_cpu</span><span class="p">;</span>
		<span class="n">squeue</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">,</span> <span class="n">cb_cpu</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">squeue</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">padata</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">squeue</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">squeue</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">queue_work_on</span><span class="p">(</span><span class="n">cb_cpu</span><span class="p">,</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">squeue</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The next object that needs serialization might have arrived to</span>
<span class="cm">	 * the reorder queues in the meantime, we will be called again</span>
<span class="cm">	 * from the timer function if no one else cares for it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">reorder_objects</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PADATA_RESET</span><span class="p">))</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">padata_reorder_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="n">padata_reorder</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">padata_serial_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">serial_work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">padata_serial_queue</span> <span class="o">*</span><span class="n">squeue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">local_list</span><span class="p">);</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">squeue</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">serial_work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">padata_serial_queue</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="n">pd</span> <span class="o">=</span> <span class="n">squeue</span><span class="o">-&gt;</span><span class="n">pd</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">squeue</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_replace_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">squeue</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">squeue</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">padata_priv</span> <span class="o">*</span><span class="n">padata</span><span class="p">;</span>

		<span class="n">padata</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">local_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">padata_priv</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">padata</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="n">padata</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">(</span><span class="n">padata</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * padata_do_serial - padata serialization function</span>
<span class="cm"> *</span>
<span class="cm"> * @padata: object to be serialized.</span>
<span class="cm"> *</span>
<span class="cm"> * padata_do_serial must be called for every parallelized object.</span>
<span class="cm"> * The serialization callback function will run with BHs off.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">padata_do_serial</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_priv</span> <span class="o">*</span><span class="n">padata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">padata_parallel_queue</span> <span class="o">*</span><span class="n">pqueue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>

	<span class="n">pd</span> <span class="o">=</span> <span class="n">padata</span><span class="o">-&gt;</span><span class="n">pd</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="n">pqueue</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">pqueue</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="o">-&gt;</span><span class="n">reorder</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">reorder_objects</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">padata</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pqueue</span><span class="o">-&gt;</span><span class="n">reorder</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="o">-&gt;</span><span class="n">reorder</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">put_cpu</span><span class="p">();</span>

	<span class="n">padata_reorder</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">padata_do_serial</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">padata_setup_cpumasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">pcpumask</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cbcpumask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">cpumask_and</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">,</span> <span class="n">pcpumask</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cpumask_and</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">,</span> <span class="n">cbcpumask</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__padata_list_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_list</span> <span class="o">*</span><span class="n">pd_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd_list</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd_list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Initialize all percpu queues used by serial workers */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">padata_init_squeues</span><span class="p">(</span><span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">padata_serial_queue</span> <span class="o">*</span><span class="n">squeue</span><span class="p">;</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">squeue</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">squeue</span><span class="o">-&gt;</span><span class="n">pd</span> <span class="o">=</span> <span class="n">pd</span><span class="p">;</span>
		<span class="n">__padata_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">squeue</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">);</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">squeue</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">padata_serial_worker</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Initialize all percpu queues used by parallel workers */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">padata_init_pqueues</span><span class="p">(</span><span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu_index</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">padata_parallel_queue</span> <span class="o">*</span><span class="n">pqueue</span><span class="p">;</span>

	<span class="n">cpu_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pqueue</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">pqueue</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">pqueue</span><span class="o">-&gt;</span><span class="n">pd</span> <span class="o">=</span> <span class="n">pd</span><span class="p">;</span>
		<span class="n">pqueue</span><span class="o">-&gt;</span><span class="n">cpu_index</span> <span class="o">=</span> <span class="n">cpu_index</span><span class="p">;</span>
		<span class="n">cpu_index</span><span class="o">++</span><span class="p">;</span>

		<span class="n">__padata_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="o">-&gt;</span><span class="n">reorder</span><span class="p">);</span>
		<span class="n">__padata_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="o">-&gt;</span><span class="n">parallel</span><span class="p">);</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">padata_parallel_worker</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="o">-&gt;</span><span class="n">num_obj</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Allocate and initialize the internal cpumask dependend resources. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="nf">padata_alloc_pd</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">,</span>
					     <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">pcpumask</span><span class="p">,</span>
					     <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cbcpumask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>

	<span class="n">pd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">parallel_data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pd</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pd</span><span class="o">-&gt;</span><span class="n">pqueue</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_parallel_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">pqueue</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_pd</span><span class="p">;</span>

	<span class="n">pd</span><span class="o">-&gt;</span><span class="n">squeue</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_serial_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_pqueue</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">padata_setup_cpumasks</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">pcpumask</span><span class="p">,</span> <span class="n">cbcpumask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_squeue</span><span class="p">;</span>

	<span class="n">padata_init_pqueues</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>
	<span class="n">padata_init_squeues</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">padata_reorder_timer</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pd</span><span class="p">);</span>
	<span class="n">pd</span><span class="o">-&gt;</span><span class="n">seq_nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">reorder_objects</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pd</span><span class="o">-&gt;</span><span class="n">pinst</span> <span class="o">=</span> <span class="n">pinst</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pd</span><span class="p">;</span>

<span class="nl">err_free_squeue:</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">);</span>
<span class="nl">err_free_pqueue:</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">pqueue</span><span class="p">);</span>
<span class="nl">err_free_pd:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">padata_free_pd</span><span class="p">(</span><span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">);</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">pqueue</span><span class="p">);</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Flush all objects out of the padata queues. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">padata_flush_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">padata_parallel_queue</span> <span class="o">*</span><span class="n">pqueue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">padata_serial_queue</span> <span class="o">*</span><span class="n">squeue</span><span class="p">;</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pqueue</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">pqueue</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">flush_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">reorder_objects</span><span class="p">))</span>
		<span class="n">padata_reorder</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>

	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">squeue</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">flush_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">squeue</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__padata_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pinst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PADATA_INIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__padata_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PADATA_INIT</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pinst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PADATA_INIT</span><span class="p">;</span>

	<span class="n">synchronize_rcu</span><span class="p">();</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">padata_flush_queues</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">pd</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Replace the internal control structure with a new one. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">padata_replace</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd_new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd_old</span> <span class="o">=</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">pd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">notification_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pinst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PADATA_RESET</span><span class="p">;</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">pd</span><span class="p">,</span> <span class="n">pd_new</span><span class="p">);</span>

	<span class="n">synchronize_rcu</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_equal</span><span class="p">(</span><span class="n">pd_old</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">,</span> <span class="n">pd_new</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">))</span>
		<span class="n">notification_mask</span> <span class="o">|=</span> <span class="n">PADATA_CPU_PARALLEL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_equal</span><span class="p">(</span><span class="n">pd_old</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">,</span> <span class="n">pd_new</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">))</span>
		<span class="n">notification_mask</span> <span class="o">|=</span> <span class="n">PADATA_CPU_SERIAL</span><span class="p">;</span>

	<span class="n">padata_flush_queues</span><span class="p">(</span><span class="n">pd_old</span><span class="p">);</span>
	<span class="n">padata_free_pd</span><span class="p">(</span><span class="n">pd_old</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">notification_mask</span><span class="p">)</span>
		<span class="n">blocking_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask_change_notifier</span><span class="p">,</span>
					     <span class="n">notification_mask</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">pd_new</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">);</span>

	<span class="n">pinst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PADATA_RESET</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * padata_register_cpumask_notifier - Registers a notifier that will be called</span>
<span class="cm"> *                             if either pcpu or cbcpu or both cpumasks change.</span>
<span class="cm"> *</span>
<span class="cm"> * @pinst: A poineter to padata instance</span>
<span class="cm"> * @nblock: A pointer to notifier block.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">padata_register_cpumask_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blocking_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask_change_notifier</span><span class="p">,</span>
						<span class="n">nblock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">padata_register_cpumask_notifier</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * padata_unregister_cpumask_notifier - Unregisters cpumask notifier</span>
<span class="cm"> *        registered earlier  using padata_register_cpumask_notifier</span>
<span class="cm"> *</span>
<span class="cm"> * @pinst: A pointer to data instance.</span>
<span class="cm"> * @nlock: A pointer to notifier block.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">padata_unregister_cpumask_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blocking_notifier_chain_unregister</span><span class="p">(</span>
		<span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask_change_notifier</span><span class="p">,</span>
		<span class="n">nblock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">padata_unregister_cpumask_notifier</span><span class="p">);</span>


<span class="cm">/* If cpumask contains no active cpu, we mark the instance as invalid. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">padata_validate_cpumask</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">cpumask</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pinst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PADATA_INVALID</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pinst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PADATA_INVALID</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__padata_set_cpumasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">,</span>
				 <span class="n">cpumask_var_t</span> <span class="n">pcpumask</span><span class="p">,</span>
				 <span class="n">cpumask_var_t</span> <span class="n">cbcpumask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">valid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>

	<span class="n">valid</span> <span class="o">=</span> <span class="n">padata_validate_cpumask</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">pcpumask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__padata_stop</span><span class="p">(</span><span class="n">pinst</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_replace</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">valid</span> <span class="o">=</span> <span class="n">padata_validate_cpumask</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">cbcpumask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid</span><span class="p">)</span>
		<span class="n">__padata_stop</span><span class="p">(</span><span class="n">pinst</span><span class="p">);</span>

<span class="nl">out_replace:</span>
	<span class="n">pd</span> <span class="o">=</span> <span class="n">padata_alloc_pd</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">pcpumask</span><span class="p">,</span> <span class="n">cbcpumask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">,</span> <span class="n">pcpumask</span><span class="p">);</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">,</span> <span class="n">cbcpumask</span><span class="p">);</span>

	<span class="n">padata_replace</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">pd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">valid</span><span class="p">)</span>
		<span class="n">__padata_start</span><span class="p">(</span><span class="n">pinst</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * padata_set_cpumasks - Set both parallel and serial cpumasks. The first</span>
<span class="cm"> *                       one is used by parallel workers and the second one</span>
<span class="cm"> *                       by the wokers doing serialization.</span>
<span class="cm"> *</span>
<span class="cm"> * @pinst: padata instance</span>
<span class="cm"> * @pcpumask: the cpumask to use for parallel workers</span>
<span class="cm"> * @cbcpumask: the cpumsak to use for serial workers</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">padata_set_cpumasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">,</span> <span class="n">cpumask_var_t</span> <span class="n">pcpumask</span><span class="p">,</span>
			<span class="n">cpumask_var_t</span> <span class="n">cbcpumask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">get_online_cpus</span><span class="p">();</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__padata_set_cpumasks</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">pcpumask</span><span class="p">,</span> <span class="n">cbcpumask</span><span class="p">);</span>

	<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">padata_set_cpumasks</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * padata_set_cpumask: Sets specified by @cpumask_type cpumask to the value</span>
<span class="cm"> *                     equivalent to @cpumask.</span>
<span class="cm"> *</span>
<span class="cm"> * @pinst: padata instance</span>
<span class="cm"> * @cpumask_type: PADATA_CPU_SERIAL or PADATA_CPU_PARALLEL corresponding</span>
<span class="cm"> *                to parallel and serial cpumasks respectively.</span>
<span class="cm"> * @cpumask: the cpumask to use</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">padata_set_cpumask</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpumask_type</span><span class="p">,</span>
		       <span class="n">cpumask_var_t</span> <span class="n">cpumask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">serial_mask</span><span class="p">,</span> <span class="o">*</span><span class="n">parallel_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">get_online_cpus</span><span class="p">();</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cpumask_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PADATA_CPU_PARALLEL</span>:
		<span class="n">serial_mask</span> <span class="o">=</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">;</span>
		<span class="n">parallel_mask</span> <span class="o">=</span> <span class="n">cpumask</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PADATA_CPU_SERIAL</span>:
		<span class="n">parallel_mask</span> <span class="o">=</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">;</span>
		<span class="n">serial_mask</span> <span class="o">=</span> <span class="n">cpumask</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		 <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span>  <span class="n">__padata_set_cpumasks</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">parallel_mask</span><span class="p">,</span> <span class="n">serial_mask</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">padata_set_cpumask</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__padata_add_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pd</span> <span class="o">=</span> <span class="n">padata_alloc_pd</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">,</span>
				     <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pd</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">padata_replace</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">pd</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">padata_validate_cpumask</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">padata_validate_cpumask</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">))</span>
			<span class="n">__padata_start</span><span class="p">(</span><span class="n">pinst</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

 <span class="cm">/**</span>
<span class="cm"> * padata_add_cpu - add a cpu to one or both(parallel and serial)</span>
<span class="cm"> *                  padata cpumasks.</span>
<span class="cm"> *</span>
<span class="cm"> * @pinst: padata instance</span>
<span class="cm"> * @cpu: cpu to add</span>
<span class="cm"> * @mask: bitmask of flags specifying to which cpumask @cpu shuld be added.</span>
<span class="cm"> *        The @mask may be any combination of the following flags:</span>
<span class="cm"> *          PADATA_CPU_SERIAL   - serial cpumask</span>
<span class="cm"> *          PADATA_CPU_PARALLEL - parallel cpumask</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">padata_add_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PADATA_CPU_SERIAL</span> <span class="o">|</span> <span class="n">PADATA_CPU_PARALLEL</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">PADATA_CPU_SERIAL</span><span class="p">)</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">PADATA_CPU_PARALLEL</span><span class="p">)</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__padata_add_cpu</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">padata_add_cpu</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__padata_remove_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">padata_validate_cpumask</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">padata_validate_cpumask</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">))</span>
			<span class="n">__padata_stop</span><span class="p">(</span><span class="n">pinst</span><span class="p">);</span>

		<span class="n">pd</span> <span class="o">=</span> <span class="n">padata_alloc_pd</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">,</span>
				     <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pd</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">padata_replace</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">pd</span><span class="p">);</span>

		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">);</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

 <span class="cm">/**</span>
<span class="cm"> * padata_remove_cpu - remove a cpu from the one or both(serial and parallel)</span>
<span class="cm"> *                     padata cpumasks.</span>
<span class="cm"> *</span>
<span class="cm"> * @pinst: padata instance</span>
<span class="cm"> * @cpu: cpu to remove</span>
<span class="cm"> * @mask: bitmask specifying from which cpumask @cpu should be removed</span>
<span class="cm"> *        The @mask may be any combination of the following flags:</span>
<span class="cm"> *          PADATA_CPU_SERIAL   - serial cpumask</span>
<span class="cm"> *          PADATA_CPU_PARALLEL - parallel cpumask</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">padata_remove_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PADATA_CPU_SERIAL</span> <span class="o">|</span> <span class="n">PADATA_CPU_PARALLEL</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">PADATA_CPU_SERIAL</span><span class="p">)</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">PADATA_CPU_PARALLEL</span><span class="p">)</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__padata_remove_cpu</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">padata_remove_cpu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * padata_start - start the parallel processing</span>
<span class="cm"> *</span>
<span class="cm"> * @pinst: padata instance to start</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">padata_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PADATA_INVALID</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=-</span><span class="n">EINVAL</span><span class="p">;</span>

	 <span class="n">__padata_start</span><span class="p">(</span><span class="n">pinst</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">padata_start</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * padata_stop - stop the parallel processing</span>
<span class="cm"> *</span>
<span class="cm"> * @pinst: padata instance to stop</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">padata_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">__padata_stop</span><span class="p">(</span><span class="n">pinst</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">padata_stop</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pinst_has_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">padata_cpu_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>

	<span class="n">pinst</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">nfb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">padata_instance</span><span class="p">,</span> <span class="n">cpu_notifier</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
	<span class="k">case</span> <span class="n">CPU_ONLINE_FROZEN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinst_has_cpu</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__padata_add_cpu</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE_FROZEN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinst_has_cpu</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__padata_remove_cpu</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CPU_UP_CANCELED</span>:
	<span class="k">case</span> <span class="n">CPU_UP_CANCELED_FROZEN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinst_has_cpu</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">__padata_remove_cpu</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED_FROZEN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinst_has_cpu</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">__padata_add_cpu</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__padata_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="n">unregister_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpu_notifier</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">padata_stop</span><span class="p">(</span><span class="n">pinst</span><span class="p">);</span>
	<span class="n">padata_free_pd</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">pd</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pinst</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define kobj2pinst(_kobj)					\</span>
<span class="cp">	container_of(_kobj, struct padata_instance, kobj)</span>
<span class="cp">#define attr2pentry(_attr)					\</span>
<span class="cp">	container_of(_attr, struct padata_sysfs_entry, attr)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">padata_sysfs_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span> <span class="o">=</span> <span class="n">kobj2pinst</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="n">__padata_free</span><span class="p">(</span><span class="n">pinst</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">padata_sysfs_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_cpumask</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;serial_cpumask&quot;</span><span class="p">))</span>
		<span class="n">cpumask</span> <span class="o">=</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cpumask</span> <span class="o">=</span> <span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">bitmap_scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">cpumask</span><span class="p">),</span>
			       <span class="n">nr_cpu_ids</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_cpumask</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_var_t</span> <span class="n">new_cpumask</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mask_type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_cpumask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">bitmap_parse</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">new_cpumask</span><span class="p">),</span>
			   <span class="n">nr_cpumask_bits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mask_type</span> <span class="o">=</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;serial_cpumask&quot;</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">PADATA_CPU_SERIAL</span> <span class="o">:</span> <span class="n">PADATA_CPU_PARALLEL</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">padata_set_cpumask</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">mask_type</span><span class="p">,</span> <span class="n">new_cpumask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">new_cpumask</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PADATA_ATTR_RW(_name, _show_name, _store_name)		\</span>
<span class="cp">	static struct padata_sysfs_entry _name##_attr =		\</span>
<span class="cp">		__ATTR(_name, 0644, _show_name, _store_name)</span>
<span class="cp">#define PADATA_ATTR_RO(_name, _show_name)		\</span>
<span class="cp">	static struct padata_sysfs_entry _name##_attr = \</span>
<span class="cp">		__ATTR(_name, 0400, _show_name, NULL)</span>

<span class="n">PADATA_ATTR_RW</span><span class="p">(</span><span class="n">serial_cpumask</span><span class="p">,</span> <span class="n">show_cpumask</span><span class="p">,</span> <span class="n">store_cpumask</span><span class="p">);</span>
<span class="n">PADATA_ATTR_RW</span><span class="p">(</span><span class="n">parallel_cpumask</span><span class="p">,</span> <span class="n">show_cpumask</span><span class="p">,</span> <span class="n">store_cpumask</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Padata sysfs provides the following objects:</span>
<span class="cm"> * serial_cpumask   [RW] - cpumask for serial workers</span>
<span class="cm"> * parallel_cpumask [RW] - cpumask for parallel workers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">padata_default_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">serial_cpumask_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">parallel_cpumask_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">padata_sysfs_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">padata_sysfs_entry</span> <span class="o">*</span><span class="n">pentry</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">pinst</span> <span class="o">=</span> <span class="n">kobj2pinst</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="n">pentry</span> <span class="o">=</span> <span class="n">attr2pentry</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pentry</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pentry</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">padata_sysfs_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">padata_sysfs_entry</span> <span class="o">*</span><span class="n">pentry</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">pinst</span> <span class="o">=</span> <span class="n">kobj2pinst</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="n">pentry</span> <span class="o">=</span> <span class="n">attr2pentry</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pentry</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pentry</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sysfs_ops</span> <span class="n">padata_sysfs_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">padata_sysfs_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">padata_sysfs_store</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">padata_attr_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sysfs_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">padata_sysfs_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">default_attrs</span> <span class="o">=</span> <span class="n">padata_default_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">padata_sysfs_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * padata_alloc_possible - Allocate and initialize padata instance.</span>
<span class="cm"> *                         Use the cpu_possible_mask for serial and</span>
<span class="cm"> *                         parallel workers.</span>
<span class="cm"> *</span>
<span class="cm"> * @wq: workqueue to use for the allocated padata instance</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="nf">padata_alloc_possible</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">padata_alloc</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">padata_alloc_possible</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * padata_alloc - allocate and initialize a padata instance and specify</span>
<span class="cm"> *                cpumasks for serial and parallel workers.</span>
<span class="cm"> *</span>
<span class="cm"> * @wq: workqueue to use for the allocated padata instance</span>
<span class="cm"> * @pcpumask: cpumask that will be used for padata parallelization</span>
<span class="cm"> * @cbcpumask: cpumask that will be used for padata serialization</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="nf">padata_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">pcpumask</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cbcpumask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parallel_data</span> <span class="o">*</span><span class="n">pd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pinst</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinst</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_free_inst</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_free_inst</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">padata_validate_cpumask</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">pcpumask</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">padata_validate_cpumask</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">cbcpumask</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_free_masks</span><span class="p">;</span>

	<span class="n">pd</span> <span class="o">=</span> <span class="n">padata_alloc_pd</span><span class="p">(</span><span class="n">pinst</span><span class="p">,</span> <span class="n">pcpumask</span><span class="p">,</span> <span class="n">cbcpumask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pd</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_masks</span><span class="p">;</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">pd</span><span class="p">,</span> <span class="n">pd</span><span class="p">);</span>

	<span class="n">pinst</span><span class="o">-&gt;</span><span class="n">wq</span> <span class="o">=</span> <span class="n">wq</span><span class="p">;</span>

	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">,</span> <span class="n">pcpumask</span><span class="p">);</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">,</span> <span class="n">cbcpumask</span><span class="p">);</span>

	<span class="n">pinst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpu_notifier</span><span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">padata_cpu_callback</span><span class="p">;</span>
	<span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpu_notifier</span><span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">register_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpu_notifier</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">put_online_cpus</span><span class="p">();</span>

	<span class="n">BLOCKING_INIT_NOTIFIER_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask_change_notifier</span><span class="p">);</span>
	<span class="n">kobject_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">padata_attr_type</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pinst</span><span class="p">;</span>

<span class="nl">err_free_masks:</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">pcpu</span><span class="p">);</span>
	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">.</span><span class="n">cbcpu</span><span class="p">);</span>
<span class="nl">err_free_inst:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pinst</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">padata_alloc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * padata_free - free a padata instance</span>
<span class="cm"> *</span>
<span class="cm"> * @padata_inst: padata instance to free</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">padata_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">padata_instance</span> <span class="o">*</span><span class="n">pinst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinst</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">padata_free</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
