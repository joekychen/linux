<!DOCTYPE html>
<html><head><title>joekychen/linux » kernel › rcutorture.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>rcutorture.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Read-Copy Update module-based torture test facility</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) IBM Corporation, 2005, 2006</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Paul E. McKenney &lt;paulmck@us.ibm.com&gt;</span>
<span class="cm"> *	  Josh Triplett &lt;josh@freedesktop.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * See also:  Documentation/RCU/torture.txt</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/srcu.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Paul E. McKenney &lt;paulmck@us.ibm.com&gt; and &quot;</span>
	      <span class="s">&quot;Josh Triplett &lt;josh@freedesktop.org&gt;&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">nreaders</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* # reader threads, defaults to 2*ncpus */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nfakewriters</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>	<span class="cm">/* # fake writer threads */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">stat_interval</span><span class="p">;</span>	<span class="cm">/* Interval between stats, in seconds. */</span>
				<span class="cm">/*  Defaults to &quot;only at end of test&quot;. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">verbose</span><span class="p">;</span>		<span class="cm">/* Print more debug info. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">test_no_idle_hz</span><span class="p">;</span>	<span class="cm">/* Test RCU&#39;s support for tickless idle CPUs. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">shuffle_interval</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* Interval between shuffles (in sec)*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">stutter</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>		<span class="cm">/* Start/stop testing interval (in sec) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irqreader</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* RCU readers from irq (timers). */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fqs_duration</span><span class="p">;</span>	<span class="cm">/* Duration of bursts (us), 0 to disable. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fqs_holdoff</span><span class="p">;</span>		<span class="cm">/* Hold time within burst (us). */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fqs_stutter</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* Wait time between bursts (s). */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">n_barrier_cbs</span><span class="p">;</span>	<span class="cm">/* Number of callbacks to test RCU barriers. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">onoff_interval</span><span class="p">;</span>	<span class="cm">/* Wait time between CPU hotplugs, 0=disable. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">onoff_holdoff</span><span class="p">;</span>	<span class="cm">/* Seconds after boot before CPU hotplugs. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">shutdown_secs</span><span class="p">;</span>	<span class="cm">/* Shutdown time (s).  &lt;=0 for no shutdown. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">stall_cpu</span><span class="p">;</span>		<span class="cm">/* CPU-stall duration (s).  0 for no stall. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">stall_cpu_holdoff</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="cm">/* Time to wait until stall (s).  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">test_boost</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Test RCU prio boost: 0=no, 1=maybe, 2=yes. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">test_boost_interval</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="cm">/* Interval between boost tests, seconds. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">test_boost_duration</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* Duration of each boost test, seconds. */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">torture_type</span> <span class="o">=</span> <span class="s">&quot;rcu&quot;</span><span class="p">;</span> <span class="cm">/* What RCU implementation to torture. */</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">nreaders</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">nreaders</span><span class="p">,</span> <span class="s">&quot;Number of RCU reader threads&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">nfakewriters</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">nfakewriters</span><span class="p">,</span> <span class="s">&quot;Number of RCU fake writer threads&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">stat_interval</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">stat_interval</span><span class="p">,</span> <span class="s">&quot;Number of seconds between stats printk()s&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span> <span class="s">&quot;Enable verbose debugging printk()s&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">test_no_idle_hz</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">test_no_idle_hz</span><span class="p">,</span> <span class="s">&quot;Test support for tickless idle CPUs&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">shuffle_interval</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">shuffle_interval</span><span class="p">,</span> <span class="s">&quot;Number of seconds between shuffles&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">stutter</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">stutter</span><span class="p">,</span> <span class="s">&quot;Number of seconds to run/halt test&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">irqreader</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">irqreader</span><span class="p">,</span> <span class="s">&quot;Allow RCU readers from irq handlers&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">fqs_duration</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">fqs_duration</span><span class="p">,</span> <span class="s">&quot;Duration of fqs bursts (us)&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">fqs_holdoff</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">fqs_holdoff</span><span class="p">,</span> <span class="s">&quot;Holdoff time within fqs bursts (us)&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">fqs_stutter</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">fqs_stutter</span><span class="p">,</span> <span class="s">&quot;Wait time between fqs bursts (s)&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">n_barrier_cbs</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">n_barrier_cbs</span><span class="p">,</span> <span class="s">&quot;# of callbacks/kthreads for barrier testing&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">onoff_interval</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">onoff_interval</span><span class="p">,</span> <span class="s">&quot;Time between CPU hotplugs (s), 0=disable&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">onoff_holdoff</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">onoff_holdoff</span><span class="p">,</span> <span class="s">&quot;Time after boot before CPU hotplugs (s)&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">shutdown_secs</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">shutdown_secs</span><span class="p">,</span> <span class="s">&quot;Shutdown time (s), zero to disable.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">stall_cpu</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">stall_cpu</span><span class="p">,</span> <span class="s">&quot;Stall duration (s), zero to disable.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">stall_cpu_holdoff</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">stall_cpu_holdoff</span><span class="p">,</span> <span class="s">&quot;Time to wait before starting stall (s).&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">test_boost</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">test_boost</span><span class="p">,</span> <span class="s">&quot;Test RCU prio boost: 0=no, 1=maybe, 2=yes.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">test_boost_interval</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">test_boost_interval</span><span class="p">,</span> <span class="s">&quot;Interval between boost tests, seconds.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">test_boost_duration</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">test_boost_duration</span><span class="p">,</span> <span class="s">&quot;Duration of each boost test, seconds.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">torture_type</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">torture_type</span><span class="p">,</span> <span class="s">&quot;Type of RCU to torture (rcu, rcu_bh, srcu)&quot;</span><span class="p">);</span>

<span class="cp">#define TORTURE_FLAG &quot;-torture:&quot;</span>
<span class="cp">#define PRINTK_STRING(s) \</span>
<span class="cp">	do { printk(KERN_ALERT &quot;%s&quot; TORTURE_FLAG s &quot;\n&quot;, torture_type); } while (0)</span>
<span class="cp">#define VERBOSE_PRINTK_STRING(s) \</span>
<span class="cp">	do { if (verbose) printk(KERN_ALERT &quot;%s&quot; TORTURE_FLAG s &quot;\n&quot;, torture_type); } while (0)</span>
<span class="cp">#define VERBOSE_PRINTK_ERRSTRING(s) \</span>
<span class="cp">	do { if (verbose) printk(KERN_ALERT &quot;%s&quot; TORTURE_FLAG &quot;!!! &quot; s &quot;\n&quot;, torture_type); } while (0)</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">printk_buf</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">nrealreaders</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">writer_task</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">**</span><span class="n">fakewriter_tasks</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">**</span><span class="n">reader_tasks</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">stats_task</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">shuffler_task</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">stutter_task</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">fqs_task</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">boost_tasks</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">shutdown_task</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">onoff_task</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">stall_task</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">**</span><span class="n">barrier_cbs_tasks</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">barrier_task</span><span class="p">;</span>

<span class="cp">#define RCU_TORTURE_PIPE_LEN 10</span>

<span class="k">struct</span> <span class="n">rcu_torture</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rtort_rcu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rtort_pipe_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rtort_free</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rtort_mbtest</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">rcu_torture_freelist</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">rcu_torture_current</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rcu_torture_current_version</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture</span> <span class="n">rcu_tortures</span><span class="p">[</span><span class="mi">10</span> <span class="o">*</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">];</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">rcu_torture_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">long</span> <span class="p">[</span><span class="n">RCU_TORTURE_PIPE_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">rcu_torture_count</span><span class="p">)</span> <span class="o">=</span>
	<span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">long</span> <span class="p">[</span><span class="n">RCU_TORTURE_PIPE_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">rcu_torture_batch</span><span class="p">)</span> <span class="o">=</span>
	<span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">rcu_torture_wcount</span><span class="p">[</span><span class="n">RCU_TORTURE_PIPE_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">n_rcu_torture_alloc</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">n_rcu_torture_alloc_fail</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">n_rcu_torture_free</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">n_rcu_torture_mberror</span><span class="p">;</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">n_rcu_torture_error</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">n_rcu_torture_barrier_error</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">n_rcu_torture_boost_ktrerror</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">n_rcu_torture_boost_rterror</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">n_rcu_torture_boost_failure</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">n_rcu_torture_boosts</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">n_rcu_torture_timers</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">n_offline_attempts</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">n_offline_successes</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">n_online_attempts</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">n_online_successes</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">n_barrier_attempts</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">n_barrier_successes</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">rcu_torture_removed</span><span class="p">;</span>
<span class="k">static</span> <span class="n">cpumask_var_t</span> <span class="n">shuffle_tmp_mask</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">stutter_pause_test</span><span class="p">;</span>

<span class="cp">#if defined(MODULE) || defined(CONFIG_RCU_TORTURE_TEST_RUNNABLE)</span>
<span class="cp">#define RCUTORTURE_RUNNABLE_INIT 1</span>
<span class="cp">#else</span>
<span class="cp">#define RCUTORTURE_RUNNABLE_INIT 0</span>
<span class="cp">#endif</span>
<span class="kt">int</span> <span class="n">rcutorture_runnable</span> <span class="o">=</span> <span class="n">RCUTORTURE_RUNNABLE_INIT</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">rcutorture_runnable</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">rcutorture_runnable</span><span class="p">,</span> <span class="s">&quot;Start rcutorture at boot&quot;</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_RCU_BOOST) &amp;&amp; !defined(CONFIG_HOTPLUG_CPU)</span>
<span class="cp">#define rcu_can_boost() 1</span>
<span class="cp">#else </span><span class="cm">/* #if defined(CONFIG_RCU_BOOST) &amp;&amp; !defined(CONFIG_HOTPLUG_CPU) */</span><span class="cp"></span>
<span class="cp">#define rcu_can_boost() 0</span>
<span class="cp">#endif </span><span class="cm">/* #else #if defined(CONFIG_RCU_BOOST) &amp;&amp; !defined(CONFIG_HOTPLUG_CPU) */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shutdown_time</span><span class="p">;</span>	<span class="cm">/* jiffies to system shutdown. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">boost_starttime</span><span class="p">;</span>	<span class="cm">/* jiffies of next boost test start. */</span>
<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">boost_mutex</span><span class="p">);</span>		<span class="cm">/* protect setting boost_starttime */</span>
					<span class="cm">/*  and boost task create/destroy. */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">barrier_cbs_count</span><span class="p">;</span>	<span class="cm">/* Barrier callbacks registered. */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">barrier_cbs_invoked</span><span class="p">;</span>	<span class="cm">/* Barrier callbacks invoked. */</span>
<span class="k">static</span> <span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">barrier_cbs_wq</span><span class="p">;</span> <span class="cm">/* Coordinate barrier testing. */</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">barrier_wq</span><span class="p">);</span>

<span class="cm">/* Mediate rmmod and system shutdown.  Concurrent rmmod &amp; shutdown illegal! */</span>

<span class="cp">#define FULLSTOP_DONTSTOP 0	</span><span class="cm">/* Normal operation. */</span><span class="cp"></span>
<span class="cp">#define FULLSTOP_SHUTDOWN 1	</span><span class="cm">/* System shutdown with rcutorture running. */</span><span class="cp"></span>
<span class="cp">#define FULLSTOP_RMMOD    2	</span><span class="cm">/* Normal rmmod of rcutorture. */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">fullstop</span> <span class="o">=</span> <span class="n">FULLSTOP_RMMOD</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * Protect fullstop transitions and spawning of kthreads.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">fullstop_mutex</span><span class="p">);</span>

<span class="cm">/* Forward reference. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">rcu_torture_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Detect and respond to a system shutdown.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rcutorture_shutdown_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">unused1</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unused2</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fullstop_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fullstop</span> <span class="o">==</span> <span class="n">FULLSTOP_DONTSTOP</span><span class="p">)</span>
		<span class="n">fullstop</span> <span class="o">=</span> <span class="n">FULLSTOP_SHUTDOWN</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="cm">/* but going down anyway, so... */</span>
		       <span class="s">&quot;Concurrent &#39;rmmod rcutorture&#39; and shutdown illegal!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fullstop_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Absorb kthreads into a kernel function that won&#39;t return, so that</span>
<span class="cm"> * they won&#39;t ever access module text or data again.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcutorture_shutdown_absorb</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">title</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">fullstop</span><span class="p">)</span> <span class="o">==</span> <span class="n">FULLSTOP_SHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
		       <span class="s">&quot;rcutorture thread %s parking due to system shutdown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">title</span><span class="p">);</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate an element from the rcu_tortures pool.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture</span> <span class="o">*</span>
<span class="nf">rcu_torture_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_torture_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_torture_freelist</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_alloc_fail</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_torture_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_alloc</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">rcu_torture_freelist</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_torture_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rcu_torture</span><span class="p">,</span> <span class="n">rtort_free</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free an element to the rcu_tortures pool.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rcu_torture_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_torture</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_free</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_torture_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rtort_free</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcu_torture_freelist</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_torture_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">rcu_random_state</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rrs_state</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">rrs_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define RCU_RANDOM_MULT 39916801  </span><span class="cm">/* prime */</span><span class="cp"></span>
<span class="cp">#define RCU_RANDOM_ADD	479001701 </span><span class="cm">/* prime */</span><span class="cp"></span>
<span class="cp">#define RCU_RANDOM_REFRESH 10000</span>

<span class="cp">#define DEFINE_RCU_RANDOM(name) struct rcu_random_state name = { 0, 0 }</span>

<span class="cm">/*</span>
<span class="cm"> * Crude but fast random-number generator.  Uses a linear congruential</span>
<span class="cm"> * generator, with occasional help from cpu_clock().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">rcu_random</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_random_state</span> <span class="o">*</span><span class="n">rrsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">rrsp</span><span class="o">-&gt;</span><span class="n">rrs_count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rrsp</span><span class="o">-&gt;</span><span class="n">rrs_state</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">local_clock</span><span class="p">();</span>
		<span class="n">rrsp</span><span class="o">-&gt;</span><span class="n">rrs_count</span> <span class="o">=</span> <span class="n">RCU_RANDOM_REFRESH</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rrsp</span><span class="o">-&gt;</span><span class="n">rrs_state</span> <span class="o">=</span> <span class="n">rrsp</span><span class="o">-&gt;</span><span class="n">rrs_state</span> <span class="o">*</span> <span class="n">RCU_RANDOM_MULT</span> <span class="o">+</span> <span class="n">RCU_RANDOM_ADD</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">swahw32</span><span class="p">(</span><span class="n">rrsp</span><span class="o">-&gt;</span><span class="n">rrs_state</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rcu_stutter_wait</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">title</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">stutter_pause_test</span> <span class="o">||</span> <span class="o">!</span><span class="n">rcutorture_runnable</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcutorture_runnable</span><span class="p">)</span>
			<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">round_jiffies_relative</span><span class="p">(</span><span class="n">HZ</span><span class="p">));</span>
		<span class="n">rcutorture_shutdown_absorb</span><span class="p">(</span><span class="n">title</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Operations vector for selecting different types of tests.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cleanup</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">readlock</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">read_delay</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rcu_random_state</span> <span class="o">*</span><span class="n">rrsp</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">readunlock</span><span class="p">)(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">completed</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">deferred_free</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rcu_torture</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sync</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">call</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rcu</span><span class="p">));</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cb_barrier</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fqs</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">stats</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">irq_capable</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">can_boost</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="o">*</span><span class="n">cur_ops</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Definitions for rcu torture testing.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_torture_read_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__acquires</span><span class="p">(</span><span class="n">RCU</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_read_delay</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_random_state</span> <span class="o">*</span><span class="n">rrsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shortdelay_us</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">longdelay_ms</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>

	<span class="cm">/* We want a short delay sometimes to make a reader delay the grace</span>
<span class="cm">	 * period, and we want a long delay occasionally to trigger</span>
<span class="cm">	 * force_quiescent_state. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rcu_random</span><span class="p">(</span><span class="n">rrsp</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">nrealreaders</span> <span class="o">*</span> <span class="mi">2000</span> <span class="o">*</span> <span class="n">longdelay_ms</span><span class="p">)))</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="n">longdelay_ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rcu_random</span><span class="p">(</span><span class="n">rrsp</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">nrealreaders</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">shortdelay_us</span><span class="p">)))</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">shortdelay_us</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PREEMPT</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">rcu_random</span><span class="p">(</span><span class="n">rrsp</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">nrealreaders</span> <span class="o">*</span> <span class="mi">20000</span><span class="p">)))</span>
		<span class="n">preempt_schedule</span><span class="p">();</span>  <span class="cm">/* No QS if preempt_disable() in effect */</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_torture_read_unlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="n">__releases</span><span class="p">(</span><span class="n">RCU</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_torture_completed</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rcu_batches_completed</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rcu_torture_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_torture</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rcu_torture</span><span class="p">,</span> <span class="n">rtort_rcu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fullstop</span> <span class="o">!=</span> <span class="n">FULLSTOP_DONTSTOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Test is ending, just drop callbacks on the floor. */</span>
		<span class="cm">/* The next initialization will pick up the pieces. */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rtort_pipe_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_torture_wcount</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rtort_pipe_count</span> <span class="o">&gt;=</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rtort_mbtest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rcu_torture_free</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">deferred_free</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_no_completed</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_torture_deferred_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_torture</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rtort_rcu</span><span class="p">,</span> <span class="n">rcu_torture_cb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="n">rcu_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cleanup</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readlock</span>	<span class="o">=</span> <span class="n">rcu_torture_read_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_delay</span>	<span class="o">=</span> <span class="n">rcu_read_delay</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readunlock</span>	<span class="o">=</span> <span class="n">rcu_torture_read_unlock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">completed</span>	<span class="o">=</span> <span class="n">rcu_torture_completed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">deferred_free</span>	<span class="o">=</span> <span class="n">rcu_torture_deferred_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync</span>		<span class="o">=</span> <span class="n">synchronize_rcu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">call</span>		<span class="o">=</span> <span class="n">call_rcu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cb_barrier</span>	<span class="o">=</span> <span class="n">rcu_barrier</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fqs</span>		<span class="o">=</span> <span class="n">rcu_force_quiescent_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stats</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_capable</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_boost</span>	<span class="o">=</span> <span class="n">rcu_can_boost</span><span class="p">(),</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;rcu&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_sync_torture_deferred_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_torture</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_torture</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_torture</span> <span class="o">*</span><span class="n">rp1</span><span class="p">;</span>

	<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">();</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rtort_free</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcu_torture_removed</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">rp1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcu_torture_removed</span><span class="p">,</span> <span class="n">rtort_free</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">rtort_pipe_count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_torture_wcount</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rtort_pipe_count</span> <span class="o">&gt;=</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rtort_mbtest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rtort_free</span><span class="p">);</span>
			<span class="n">rcu_torture_free</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_sync_torture_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_torture_removed</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="n">rcu_sync_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">rcu_sync_torture_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cleanup</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readlock</span>	<span class="o">=</span> <span class="n">rcu_torture_read_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_delay</span>	<span class="o">=</span> <span class="n">rcu_read_delay</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readunlock</span>	<span class="o">=</span> <span class="n">rcu_torture_read_unlock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">completed</span>	<span class="o">=</span> <span class="n">rcu_torture_completed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">deferred_free</span>	<span class="o">=</span> <span class="n">rcu_sync_torture_deferred_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync</span>		<span class="o">=</span> <span class="n">synchronize_rcu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">call</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cb_barrier</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fqs</span>		<span class="o">=</span> <span class="n">rcu_force_quiescent_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stats</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_capable</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_boost</span>	<span class="o">=</span> <span class="n">rcu_can_boost</span><span class="p">(),</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;rcu_sync&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="n">rcu_expedited_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">rcu_sync_torture_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cleanup</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readlock</span>	<span class="o">=</span> <span class="n">rcu_torture_read_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_delay</span>	<span class="o">=</span> <span class="n">rcu_read_delay</span><span class="p">,</span>  <span class="cm">/* just reuse rcu&#39;s version. */</span>
	<span class="p">.</span><span class="n">readunlock</span>	<span class="o">=</span> <span class="n">rcu_torture_read_unlock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">completed</span>	<span class="o">=</span> <span class="n">rcu_no_completed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">deferred_free</span>	<span class="o">=</span> <span class="n">rcu_sync_torture_deferred_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync</span>		<span class="o">=</span> <span class="n">synchronize_rcu_expedited</span><span class="p">,</span>
	<span class="p">.</span><span class="n">call</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cb_barrier</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fqs</span>		<span class="o">=</span> <span class="n">rcu_force_quiescent_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stats</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_capable</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_boost</span>	<span class="o">=</span> <span class="n">rcu_can_boost</span><span class="p">(),</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;rcu_expedited&quot;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Definitions for rcu_bh torture testing.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_bh_torture_read_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__acquires</span><span class="p">(</span><span class="n">RCU_BH</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_read_lock_bh</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_bh_torture_read_unlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="n">__releases</span><span class="p">(</span><span class="n">RCU_BH</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_read_unlock_bh</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_bh_torture_completed</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rcu_batches_completed_bh</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_bh_torture_deferred_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_torture</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">call_rcu_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rtort_rcu</span><span class="p">,</span> <span class="n">rcu_torture_cb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="n">rcu_bh_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cleanup</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readlock</span>	<span class="o">=</span> <span class="n">rcu_bh_torture_read_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_delay</span>	<span class="o">=</span> <span class="n">rcu_read_delay</span><span class="p">,</span>  <span class="cm">/* just reuse rcu&#39;s version. */</span>
	<span class="p">.</span><span class="n">readunlock</span>	<span class="o">=</span> <span class="n">rcu_bh_torture_read_unlock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">completed</span>	<span class="o">=</span> <span class="n">rcu_bh_torture_completed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">deferred_free</span>	<span class="o">=</span> <span class="n">rcu_bh_torture_deferred_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync</span>		<span class="o">=</span> <span class="n">synchronize_rcu_bh</span><span class="p">,</span>
	<span class="p">.</span><span class="n">call</span>		<span class="o">=</span> <span class="n">call_rcu_bh</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cb_barrier</span>	<span class="o">=</span> <span class="n">rcu_barrier_bh</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fqs</span>		<span class="o">=</span> <span class="n">rcu_bh_force_quiescent_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stats</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_capable</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;rcu_bh&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="n">rcu_bh_sync_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">rcu_sync_torture_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cleanup</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readlock</span>	<span class="o">=</span> <span class="n">rcu_bh_torture_read_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_delay</span>	<span class="o">=</span> <span class="n">rcu_read_delay</span><span class="p">,</span>  <span class="cm">/* just reuse rcu&#39;s version. */</span>
	<span class="p">.</span><span class="n">readunlock</span>	<span class="o">=</span> <span class="n">rcu_bh_torture_read_unlock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">completed</span>	<span class="o">=</span> <span class="n">rcu_bh_torture_completed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">deferred_free</span>	<span class="o">=</span> <span class="n">rcu_sync_torture_deferred_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync</span>		<span class="o">=</span> <span class="n">synchronize_rcu_bh</span><span class="p">,</span>
	<span class="p">.</span><span class="n">call</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cb_barrier</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fqs</span>		<span class="o">=</span> <span class="n">rcu_bh_force_quiescent_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stats</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_capable</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;rcu_bh_sync&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="n">rcu_bh_expedited_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">rcu_sync_torture_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cleanup</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readlock</span>	<span class="o">=</span> <span class="n">rcu_bh_torture_read_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_delay</span>	<span class="o">=</span> <span class="n">rcu_read_delay</span><span class="p">,</span>  <span class="cm">/* just reuse rcu&#39;s version. */</span>
	<span class="p">.</span><span class="n">readunlock</span>	<span class="o">=</span> <span class="n">rcu_bh_torture_read_unlock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">completed</span>	<span class="o">=</span> <span class="n">rcu_bh_torture_completed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">deferred_free</span>	<span class="o">=</span> <span class="n">rcu_sync_torture_deferred_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync</span>		<span class="o">=</span> <span class="n">synchronize_rcu_bh_expedited</span><span class="p">,</span>
	<span class="p">.</span><span class="n">call</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cb_barrier</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fqs</span>		<span class="o">=</span> <span class="n">rcu_bh_force_quiescent_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stats</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_capable</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;rcu_bh_expedited&quot;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Definitions for srcu torture testing.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">srcu_struct</span> <span class="n">srcu_ctl</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">srcu_torture_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">init_srcu_struct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">);</span>
	<span class="n">rcu_sync_torture_init</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">srcu_torture_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">synchronize_srcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">);</span>
	<span class="n">cleanup_srcu_struct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">srcu_torture_read_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">srcu_read_delay</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_random_state</span> <span class="o">*</span><span class="n">rrsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">delay</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">long</span> <span class="n">uspertick</span> <span class="o">=</span> <span class="mi">1000000</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">long</span> <span class="n">longdelay</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="cm">/* We want there to be long-running readers, but not all the time. */</span>

	<span class="n">delay</span> <span class="o">=</span> <span class="n">rcu_random</span><span class="p">(</span><span class="n">rrsp</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">nrealreaders</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">longdelay</span> <span class="o">*</span> <span class="n">uspertick</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">delay</span><span class="p">)</span>
		<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">longdelay</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rcu_read_delay</span><span class="p">(</span><span class="n">rrsp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">srcu_torture_read_unlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">srcu_torture_completed</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">srcu_batches_completed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">srcu_torture_deferred_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_torture</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">call_srcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">rtort_rcu</span><span class="p">,</span> <span class="n">rcu_torture_cb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">srcu_torture_synchronize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">synchronize_srcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">srcu_torture_stats</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">srcu_ctl</span><span class="p">.</span><span class="n">completed</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">;</span>

	<span class="n">cnt</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="s">&quot;%s%s per-CPU(idx=%d):&quot;</span><span class="p">,</span>
		       <span class="n">torture_type</span><span class="p">,</span> <span class="n">TORTURE_FLAG</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cnt</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="s">&quot; %d(%lu,%lu)&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span>
			       <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">srcu_ctl</span><span class="p">.</span><span class="n">per_cpu_ref</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="o">!</span><span class="n">idx</span><span class="p">],</span>
			       <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">srcu_ctl</span><span class="p">.</span><span class="n">per_cpu_ref</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">cnt</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="n">srcu_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">srcu_torture_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cleanup</span>	<span class="o">=</span> <span class="n">srcu_torture_cleanup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readlock</span>	<span class="o">=</span> <span class="n">srcu_torture_read_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_delay</span>	<span class="o">=</span> <span class="n">srcu_read_delay</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readunlock</span>	<span class="o">=</span> <span class="n">srcu_torture_read_unlock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">completed</span>	<span class="o">=</span> <span class="n">srcu_torture_completed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">deferred_free</span>	<span class="o">=</span> <span class="n">srcu_torture_deferred_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync</span>		<span class="o">=</span> <span class="n">srcu_torture_synchronize</span><span class="p">,</span>
	<span class="p">.</span><span class="n">call</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cb_barrier</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stats</span>		<span class="o">=</span> <span class="n">srcu_torture_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;srcu&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="n">srcu_sync_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">srcu_torture_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cleanup</span>	<span class="o">=</span> <span class="n">srcu_torture_cleanup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readlock</span>	<span class="o">=</span> <span class="n">srcu_torture_read_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_delay</span>	<span class="o">=</span> <span class="n">srcu_read_delay</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readunlock</span>	<span class="o">=</span> <span class="n">srcu_torture_read_unlock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">completed</span>	<span class="o">=</span> <span class="n">srcu_torture_completed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">deferred_free</span>	<span class="o">=</span> <span class="n">rcu_sync_torture_deferred_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync</span>		<span class="o">=</span> <span class="n">srcu_torture_synchronize</span><span class="p">,</span>
	<span class="p">.</span><span class="n">call</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cb_barrier</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stats</span>		<span class="o">=</span> <span class="n">srcu_torture_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;srcu_sync&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">srcu_torture_read_lock_raw</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">srcu_read_lock_raw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">srcu_torture_read_unlock_raw</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">srcu_read_unlock_raw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="n">srcu_raw_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">srcu_torture_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cleanup</span>	<span class="o">=</span> <span class="n">srcu_torture_cleanup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readlock</span>	<span class="o">=</span> <span class="n">srcu_torture_read_lock_raw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_delay</span>	<span class="o">=</span> <span class="n">srcu_read_delay</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readunlock</span>	<span class="o">=</span> <span class="n">srcu_torture_read_unlock_raw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">completed</span>	<span class="o">=</span> <span class="n">srcu_torture_completed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">deferred_free</span>	<span class="o">=</span> <span class="n">srcu_torture_deferred_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync</span>		<span class="o">=</span> <span class="n">srcu_torture_synchronize</span><span class="p">,</span>
	<span class="p">.</span><span class="n">call</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cb_barrier</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stats</span>		<span class="o">=</span> <span class="n">srcu_torture_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;srcu_raw&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="n">srcu_raw_sync_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">srcu_torture_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cleanup</span>	<span class="o">=</span> <span class="n">srcu_torture_cleanup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readlock</span>	<span class="o">=</span> <span class="n">srcu_torture_read_lock_raw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_delay</span>	<span class="o">=</span> <span class="n">srcu_read_delay</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readunlock</span>	<span class="o">=</span> <span class="n">srcu_torture_read_unlock_raw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">completed</span>	<span class="o">=</span> <span class="n">srcu_torture_completed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">deferred_free</span>	<span class="o">=</span> <span class="n">rcu_sync_torture_deferred_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync</span>		<span class="o">=</span> <span class="n">srcu_torture_synchronize</span><span class="p">,</span>
	<span class="p">.</span><span class="n">call</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cb_barrier</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stats</span>		<span class="o">=</span> <span class="n">srcu_torture_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;srcu_raw_sync&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">srcu_torture_synchronize_expedited</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">synchronize_srcu_expedited</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="n">srcu_expedited_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">srcu_torture_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cleanup</span>	<span class="o">=</span> <span class="n">srcu_torture_cleanup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readlock</span>	<span class="o">=</span> <span class="n">srcu_torture_read_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_delay</span>	<span class="o">=</span> <span class="n">srcu_read_delay</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readunlock</span>	<span class="o">=</span> <span class="n">srcu_torture_read_unlock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">completed</span>	<span class="o">=</span> <span class="n">srcu_torture_completed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">deferred_free</span>	<span class="o">=</span> <span class="n">rcu_sync_torture_deferred_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync</span>		<span class="o">=</span> <span class="n">srcu_torture_synchronize_expedited</span><span class="p">,</span>
	<span class="p">.</span><span class="n">call</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cb_barrier</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stats</span>		<span class="o">=</span> <span class="n">srcu_torture_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;srcu_expedited&quot;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Definitions for sched torture testing.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sched_torture_read_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_torture_read_unlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_sched_torture_deferred_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_torture</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">call_rcu_sched</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rtort_rcu</span><span class="p">,</span> <span class="n">rcu_torture_cb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="n">sched_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">rcu_sync_torture_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cleanup</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readlock</span>	<span class="o">=</span> <span class="n">sched_torture_read_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_delay</span>	<span class="o">=</span> <span class="n">rcu_read_delay</span><span class="p">,</span>  <span class="cm">/* just reuse rcu&#39;s version. */</span>
	<span class="p">.</span><span class="n">readunlock</span>	<span class="o">=</span> <span class="n">sched_torture_read_unlock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">completed</span>	<span class="o">=</span> <span class="n">rcu_no_completed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">deferred_free</span>	<span class="o">=</span> <span class="n">rcu_sched_torture_deferred_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync</span>		<span class="o">=</span> <span class="n">synchronize_sched</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cb_barrier</span>	<span class="o">=</span> <span class="n">rcu_barrier_sched</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fqs</span>		<span class="o">=</span> <span class="n">rcu_sched_force_quiescent_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stats</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_capable</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;sched&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="n">sched_sync_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">rcu_sync_torture_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cleanup</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readlock</span>	<span class="o">=</span> <span class="n">sched_torture_read_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_delay</span>	<span class="o">=</span> <span class="n">rcu_read_delay</span><span class="p">,</span>  <span class="cm">/* just reuse rcu&#39;s version. */</span>
	<span class="p">.</span><span class="n">readunlock</span>	<span class="o">=</span> <span class="n">sched_torture_read_unlock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">completed</span>	<span class="o">=</span> <span class="n">rcu_no_completed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">deferred_free</span>	<span class="o">=</span> <span class="n">rcu_sync_torture_deferred_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync</span>		<span class="o">=</span> <span class="n">synchronize_sched</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cb_barrier</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fqs</span>		<span class="o">=</span> <span class="n">rcu_sched_force_quiescent_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stats</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;sched_sync&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="n">sched_expedited_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span> <span class="n">rcu_sync_torture_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cleanup</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readlock</span>	<span class="o">=</span> <span class="n">sched_torture_read_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_delay</span>	<span class="o">=</span> <span class="n">rcu_read_delay</span><span class="p">,</span>  <span class="cm">/* just reuse rcu&#39;s version. */</span>
	<span class="p">.</span><span class="n">readunlock</span>	<span class="o">=</span> <span class="n">sched_torture_read_unlock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">completed</span>	<span class="o">=</span> <span class="n">rcu_no_completed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">deferred_free</span>	<span class="o">=</span> <span class="n">rcu_sync_torture_deferred_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync</span>		<span class="o">=</span> <span class="n">synchronize_sched_expedited</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cb_barrier</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fqs</span>		<span class="o">=</span> <span class="n">rcu_sched_force_quiescent_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stats</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_capable</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;sched_expedited&quot;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * RCU torture priority-boost testing.  Runs one real-time thread per</span>
<span class="cm"> * CPU for moderate bursts, repeatedly registering RCU callbacks and</span>
<span class="cm"> * spinning waiting for them to be invoked.  If a given callback takes</span>
<span class="cm"> * too long to be invoked, we assume that priority inversion has occurred.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">rcu_boost_inflight</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">inflight</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_torture_boost_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_boost_inflight</span> <span class="o">*</span><span class="n">rbip</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rcu_boost_inflight</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>

	<span class="n">smp_mb</span><span class="p">();</span> <span class="cm">/* Ensure RCU-core accesses precede clearing -&gt;inflight */</span>
	<span class="n">rbip</span><span class="o">-&gt;</span><span class="n">inflight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_torture_boost</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">call_rcu_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">endtime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">oldstarttime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_boost_inflight</span> <span class="n">rbi</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">inflight</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">sched_param</span> <span class="n">sp</span><span class="p">;</span>

	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_boost started&quot;</span><span class="p">);</span>

	<span class="cm">/* Set real-time priority. */</span>
	<span class="n">sp</span><span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sched_setscheduler</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">SCHED_FIFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_boost RT prio failed!&quot;</span><span class="p">);</span>
		<span class="n">n_rcu_torture_boost_rterror</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">init_rcu_head_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rbi</span><span class="p">.</span><span class="n">rcu</span><span class="p">);</span>
	<span class="cm">/* Each pass through the following loop does one boost-test cycle. */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Wait for the next test interval. */</span>
		<span class="n">oldstarttime</span> <span class="o">=</span> <span class="n">boost_starttime</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ULONG_CMP_LT</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">oldstarttime</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">rcu_stutter_wait</span><span class="p">(</span><span class="s">&quot;rcu_torture_boost&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">||</span>
			    <span class="n">fullstop</span> <span class="o">!=</span> <span class="n">FULLSTOP_DONTSTOP</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">checkwait</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Do one boost-test interval. */</span>
		<span class="n">endtime</span> <span class="o">=</span> <span class="n">oldstarttime</span> <span class="o">+</span> <span class="n">test_boost_duration</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="n">call_rcu_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ULONG_CMP_LT</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">endtime</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* If we don&#39;t have a callback in flight, post one. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rbi</span><span class="p">.</span><span class="n">inflight</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">smp_mb</span><span class="p">();</span> <span class="cm">/* RCU core before -&gt;inflight = 1. */</span>
				<span class="n">rbi</span><span class="p">.</span><span class="n">inflight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rbi</span><span class="p">.</span><span class="n">rcu</span><span class="p">,</span> <span class="n">rcu_torture_boost_cb</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">call_rcu_time</span> <span class="o">&gt;</span>
					 <span class="n">test_boost_duration</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">-</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_boost boosting failed&quot;</span><span class="p">);</span>
					<span class="n">n_rcu_torture_boost_failure</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">call_rcu_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="n">rcu_stutter_wait</span><span class="p">(</span><span class="s">&quot;rcu_torture_boost&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">||</span>
			    <span class="n">fullstop</span> <span class="o">!=</span> <span class="n">FULLSTOP_DONTSTOP</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">checkwait</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set the start time of the next test interval.</span>
<span class="cm">		 * Yes, this is vulnerable to long delays, but such</span>
<span class="cm">		 * delays simply cause a false negative for the next</span>
<span class="cm">		 * interval.  Besides, we are running at RT priority,</span>
<span class="cm">		 * so delays should be relatively rare.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">oldstarttime</span> <span class="o">==</span> <span class="n">boost_starttime</span> <span class="o">&amp;&amp;</span>
		       <span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boost_mutex</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">boost_starttime</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span>
						  <span class="n">test_boost_interval</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
				<span class="n">n_rcu_torture_boosts</span><span class="o">++</span><span class="p">;</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boost_mutex</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Go do the stutter. */</span>
<span class="nl">checkwait:</span>	<span class="n">rcu_stutter_wait</span><span class="p">(</span><span class="s">&quot;rcu_torture_boost&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">fullstop</span>  <span class="o">==</span> <span class="n">FULLSTOP_DONTSTOP</span><span class="p">);</span>

	<span class="cm">/* Clean up and exit. */</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_boost task stopping&quot;</span><span class="p">);</span>
	<span class="n">rcutorture_shutdown_absorb</span><span class="p">(</span><span class="s">&quot;rcu_torture_boost&quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">||</span> <span class="n">rbi</span><span class="p">.</span><span class="n">inflight</span><span class="p">)</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">smp_mb</span><span class="p">();</span> <span class="cm">/* order accesses to -&gt;inflight before stack-frame death. */</span>
	<span class="n">destroy_rcu_head_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rbi</span><span class="p">.</span><span class="n">rcu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * RCU torture force-quiescent-state kthread.  Repeatedly induces</span>
<span class="cm"> * bursts of calls to force_quiescent_state(), increasing the probability</span>
<span class="cm"> * of occurrence of some important types of race conditions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rcu_torture_fqs</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fqs_resume_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fqs_burst_remaining</span><span class="p">;</span>

	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_fqs task started&quot;</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">fqs_resume_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">fqs_stutter</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ULONG_CMP_LT</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">fqs_resume_time</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">fqs_burst_remaining</span> <span class="o">=</span> <span class="n">fqs_duration</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">fqs_burst_remaining</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		       <span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">fqs</span><span class="p">();</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">fqs_holdoff</span><span class="p">);</span>
			<span class="n">fqs_burst_remaining</span> <span class="o">-=</span> <span class="n">fqs_holdoff</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rcu_stutter_wait</span><span class="p">(</span><span class="s">&quot;rcu_torture_fqs&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">fullstop</span> <span class="o">==</span> <span class="n">FULLSTOP_DONTSTOP</span><span class="p">);</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_fqs task stopping&quot;</span><span class="p">);</span>
	<span class="n">rcutorture_shutdown_absorb</span><span class="p">(</span><span class="s">&quot;rcu_torture_fqs&quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * RCU torture writer kthread.  Repeatedly substitutes a new structure</span>
<span class="cm"> * for that pointed to by rcu_torture_current, freeing the old structure</span>
<span class="cm"> * after a series of grace periods (the &quot;pipeline&quot;).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rcu_torture_writer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">oldbatch</span> <span class="o">=</span> <span class="n">rcu_batches_completed</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">rcu_torture</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_torture</span> <span class="o">*</span><span class="n">old_rp</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">DEFINE_RCU_RANDOM</span><span class="p">(</span><span class="n">rand</span><span class="p">);</span>

	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_writer task started&quot;</span><span class="p">);</span>
	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">rp</span> <span class="o">=</span> <span class="n">rcu_torture_alloc</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rtort_pipe_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">rcu_random</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rand</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span><span class="p">);</span>
		<span class="n">old_rp</span> <span class="o">=</span> <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">rcu_torture_current</span><span class="p">,</span>
					       <span class="n">current</span> <span class="o">==</span> <span class="n">writer_task</span><span class="p">);</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">rtort_mbtest</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">rcu_torture_current</span><span class="p">,</span> <span class="n">rp</span><span class="p">);</span>
		<span class="n">smp_wmb</span><span class="p">();</span> <span class="cm">/* Mods to old_rp must follow rcu_assign_pointer() */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_rp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">old_rp</span><span class="o">-&gt;</span><span class="n">rtort_pipe_count</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">)</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">;</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_torture_wcount</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">old_rp</span><span class="o">-&gt;</span><span class="n">rtort_pipe_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">deferred_free</span><span class="p">(</span><span class="n">old_rp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">rcutorture_record_progress</span><span class="p">(</span><span class="o">++</span><span class="n">rcu_torture_current_version</span><span class="p">);</span>
		<span class="n">oldbatch</span> <span class="o">=</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">();</span>
		<span class="n">rcu_stutter_wait</span><span class="p">(</span><span class="s">&quot;rcu_torture_writer&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">fullstop</span> <span class="o">==</span> <span class="n">FULLSTOP_DONTSTOP</span><span class="p">);</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_writer task stopping&quot;</span><span class="p">);</span>
	<span class="n">rcutorture_shutdown_absorb</span><span class="p">(</span><span class="s">&quot;rcu_torture_writer&quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * RCU torture fake writer kthread.  Repeatedly calls sync, with a random</span>
<span class="cm"> * delay between calls.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rcu_torture_fakewriter</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_RCU_RANDOM</span><span class="p">(</span><span class="n">rand</span><span class="p">);</span>

	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_fakewriter task started&quot;</span><span class="p">);</span>
	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rcu_random</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rand</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">rcu_random</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rand</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span><span class="p">);</span>
		<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">();</span>
		<span class="n">rcu_stutter_wait</span><span class="p">(</span><span class="s">&quot;rcu_torture_fakewriter&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">fullstop</span> <span class="o">==</span> <span class="n">FULLSTOP_DONTSTOP</span><span class="p">);</span>

	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_fakewriter task stopping&quot;</span><span class="p">);</span>
	<span class="n">rcutorture_shutdown_absorb</span><span class="p">(</span><span class="s">&quot;rcu_torture_fakewriter&quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rcutorture_trace_dump</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">beenhere</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">beenhere</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">beenhere</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">do_trace_rcu_torture_read</span><span class="p">(</span><span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="p">)</span><span class="o">~</span><span class="mi">0UL</span><span class="p">);</span>
	<span class="n">ftrace_dump</span><span class="p">(</span><span class="n">DUMP_ALL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * RCU torture reader from timer handler.  Dereferences rcu_torture_current,</span>
<span class="cm"> * incrementing the corresponding element of the pipeline array.  The</span>
<span class="cm"> * counter in the element should never be greater than 1, otherwise, the</span>
<span class="cm"> * RCU implementation is broken.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_torture_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">completed</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">DEFINE_RCU_RANDOM</span><span class="p">(</span><span class="n">rand</span><span class="p">);</span>
	<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">rand_lock</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rcu_torture</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pipe_count</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">readlock</span><span class="p">();</span>
	<span class="n">completed</span> <span class="o">=</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">();</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">rcu_torture_current</span><span class="p">,</span>
				  <span class="n">rcu_read_lock_bh_held</span><span class="p">()</span> <span class="o">||</span>
				  <span class="n">rcu_read_lock_sched_held</span><span class="p">()</span> <span class="o">||</span>
				  <span class="n">srcu_read_lock_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Leave because rcu_torture_writer is not yet underway */</span>
		<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">readunlock</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">do_trace_rcu_torture_read</span><span class="p">(</span><span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rtort_rcu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rtort_mbtest</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_mberror</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rand_lock</span><span class="p">);</span>
	<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">read_delay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rand</span><span class="p">);</span>
	<span class="n">n_rcu_torture_timers</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rand_lock</span><span class="p">);</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">pipe_count</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rtort_pipe_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipe_count</span> <span class="o">&gt;</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Should not happen, but... */</span>
		<span class="n">pipe_count</span> <span class="o">=</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipe_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">rcutorture_trace_dump</span><span class="p">();</span>
	<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">rcu_torture_count</span><span class="p">[</span><span class="n">pipe_count</span><span class="p">]);</span>
	<span class="n">completed</span> <span class="o">=</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">()</span> <span class="o">-</span> <span class="n">completed</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">completed</span> <span class="o">&gt;</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Should not happen, but... */</span>
		<span class="n">completed</span> <span class="o">=</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">rcu_torture_batch</span><span class="p">[</span><span class="n">completed</span><span class="p">]);</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">readunlock</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * RCU torture reader kthread.  Repeatedly dereferences rcu_torture_current,</span>
<span class="cm"> * incrementing the corresponding element of the pipeline array.  The</span>
<span class="cm"> * counter in the element should never be greater than 1, otherwise, the</span>
<span class="cm"> * RCU implementation is broken.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rcu_torture_reader</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">completed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">DEFINE_RCU_RANDOM</span><span class="p">(</span><span class="n">rand</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rcu_torture</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pipe_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_reader task started&quot;</span><span class="p">);</span>
	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqreader</span> <span class="o">&amp;&amp;</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">irq_capable</span><span class="p">)</span>
		<span class="n">setup_timer_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">rcu_torture_timer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irqreader</span> <span class="o">&amp;&amp;</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">irq_capable</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">))</span>
				<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">readlock</span><span class="p">();</span>
		<span class="n">completed</span> <span class="o">=</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">();</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">rcu_torture_current</span><span class="p">,</span>
					  <span class="n">rcu_read_lock_bh_held</span><span class="p">()</span> <span class="o">||</span>
					  <span class="n">rcu_read_lock_sched_held</span><span class="p">()</span> <span class="o">||</span>
					  <span class="n">srcu_read_lock_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srcu_ctl</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Wait for rcu_torture_writer to get underway */</span>
			<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">readunlock</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
			<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">HZ</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">do_trace_rcu_torture_read</span><span class="p">(</span><span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rtort_rcu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rtort_mbtest</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_mberror</span><span class="p">);</span>
		<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">read_delay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rand</span><span class="p">);</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="n">pipe_count</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rtort_pipe_count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pipe_count</span> <span class="o">&gt;</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Should not happen, but... */</span>
			<span class="n">pipe_count</span> <span class="o">=</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pipe_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">rcutorture_trace_dump</span><span class="p">();</span>
		<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">rcu_torture_count</span><span class="p">[</span><span class="n">pipe_count</span><span class="p">]);</span>
		<span class="n">completed</span> <span class="o">=</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">completed</span><span class="p">()</span> <span class="o">-</span> <span class="n">completed</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">completed</span> <span class="o">&gt;</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Should not happen, but... */</span>
			<span class="n">completed</span> <span class="o">=</span> <span class="n">RCU_TORTURE_PIPE_LEN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">rcu_torture_batch</span><span class="p">[</span><span class="n">completed</span><span class="p">]);</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
		<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">readunlock</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">rcu_stutter_wait</span><span class="p">(</span><span class="s">&quot;rcu_torture_reader&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">fullstop</span> <span class="o">==</span> <span class="n">FULLSTOP_DONTSTOP</span><span class="p">);</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_reader task stopping&quot;</span><span class="p">);</span>
	<span class="n">rcutorture_shutdown_absorb</span><span class="p">(</span><span class="s">&quot;rcu_torture_reader&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqreader</span> <span class="o">&amp;&amp;</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">irq_capable</span><span class="p">)</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create an RCU-torture statistics message in the specified buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rcu_torture_printk</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">pipesummary</span><span class="p">[</span><span class="n">RCU_TORTURE_PIPE_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="kt">long</span> <span class="n">batchsummary</span><span class="p">[</span><span class="n">RCU_TORTURE_PIPE_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RCU_TORTURE_PIPE_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pipesummary</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">rcu_torture_count</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">batchsummary</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">rcu_torture_batch</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">RCU_TORTURE_PIPE_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pipesummary</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cnt</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="s">&quot;%s%s &quot;</span><span class="p">,</span> <span class="n">torture_type</span><span class="p">,</span> <span class="n">TORTURE_FLAG</span><span class="p">);</span>
	<span class="n">cnt</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span>
		       <span class="s">&quot;rtc: %p ver: %lu tfle: %d rta: %d rtaf: %d rtf: %d &quot;</span>
		       <span class="s">&quot;rtmbe: %d rtbke: %ld rtbre: %ld &quot;</span>
		       <span class="s">&quot;rtbf: %ld rtb: %ld nt: %ld &quot;</span>
		       <span class="s">&quot;onoff: %ld/%ld:%ld/%ld &quot;</span>
		       <span class="s">&quot;barrier: %ld/%ld:%ld&quot;</span><span class="p">,</span>
		       <span class="n">rcu_torture_current</span><span class="p">,</span>
		       <span class="n">rcu_torture_current_version</span><span class="p">,</span>
		       <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_torture_freelist</span><span class="p">),</span>
		       <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_alloc</span><span class="p">),</span>
		       <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_alloc_fail</span><span class="p">),</span>
		       <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_free</span><span class="p">),</span>
		       <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_mberror</span><span class="p">),</span>
		       <span class="n">n_rcu_torture_boost_ktrerror</span><span class="p">,</span>
		       <span class="n">n_rcu_torture_boost_rterror</span><span class="p">,</span>
		       <span class="n">n_rcu_torture_boost_failure</span><span class="p">,</span>
		       <span class="n">n_rcu_torture_boosts</span><span class="p">,</span>
		       <span class="n">n_rcu_torture_timers</span><span class="p">,</span>
		       <span class="n">n_online_successes</span><span class="p">,</span>
		       <span class="n">n_online_attempts</span><span class="p">,</span>
		       <span class="n">n_offline_successes</span><span class="p">,</span>
		       <span class="n">n_offline_attempts</span><span class="p">,</span>
		       <span class="n">n_barrier_successes</span><span class="p">,</span>
		       <span class="n">n_barrier_attempts</span><span class="p">,</span>
		       <span class="n">n_rcu_torture_barrier_error</span><span class="p">);</span>
	<span class="n">cnt</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">%s%s &quot;</span><span class="p">,</span> <span class="n">torture_type</span><span class="p">,</span> <span class="n">TORTURE_FLAG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_mberror</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">n_rcu_torture_barrier_error</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">n_rcu_torture_boost_ktrerror</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">n_rcu_torture_boost_rterror</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">n_rcu_torture_boost_failure</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cnt</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="s">&quot;!!! &quot;</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_error</span><span class="p">);</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cnt</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="s">&quot;Reader Pipe: &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RCU_TORTURE_PIPE_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="s">&quot; %ld&quot;</span><span class="p">,</span> <span class="n">pipesummary</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">cnt</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">%s%s &quot;</span><span class="p">,</span> <span class="n">torture_type</span><span class="p">,</span> <span class="n">TORTURE_FLAG</span><span class="p">);</span>
	<span class="n">cnt</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="s">&quot;Reader Batch: &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RCU_TORTURE_PIPE_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="s">&quot; %ld&quot;</span><span class="p">,</span> <span class="n">batchsummary</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">cnt</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">%s%s &quot;</span><span class="p">,</span> <span class="n">torture_type</span><span class="p">,</span> <span class="n">TORTURE_FLAG</span><span class="p">);</span>
	<span class="n">cnt</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="s">&quot;Free-Block Circulation: &quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RCU_TORTURE_PIPE_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cnt</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="s">&quot; %d&quot;</span><span class="p">,</span>
			       <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_torture_wcount</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>
	<span class="n">cnt</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">+=</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">cnt</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Print torture statistics.  Caller must ensure that there is only</span>
<span class="cm"> * one call to this function at a given time!!!  This is normally</span>
<span class="cm"> * accomplished by relying on the module system to only have one copy</span>
<span class="cm"> * of the module loaded, and then by giving the rcu_torture_stats</span>
<span class="cm"> * kthread full control (or the init/cleanup functions when rcu_torture_stats</span>
<span class="cm"> * thread is not running).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rcu_torture_stats_print</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="n">cnt</span> <span class="o">=</span> <span class="n">rcu_torture_printk</span><span class="p">(</span><span class="n">printk_buf</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">printk_buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Periodically prints torture statistics, if periodic statistics printing</span>
<span class="cm"> * was specified via the stat_interval module parameter.</span>
<span class="cm"> *</span>
<span class="cm"> * No need to worry about fullstop here, since this one doesn&#39;t reference</span>
<span class="cm"> * volatile state or register callbacks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rcu_torture_stats</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_stats task started&quot;</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">stat_interval</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
		<span class="n">rcu_torture_stats_print</span><span class="p">();</span>
		<span class="n">rcutorture_shutdown_absorb</span><span class="p">(</span><span class="s">&quot;rcu_torture_stats&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">());</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_stats task stopping&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">rcu_idle_cpu</span><span class="p">;</span>	<span class="cm">/* Force all torture tasks off this CPU */</span>

<span class="cm">/* Shuffle tasks such that we allow @rcu_idle_cpu to become idle. A special case</span>
<span class="cm"> * is when @rcu_idle_cpu = -1, when we allow the tasks to run on all CPUs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_torture_shuffle_tasks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cpumask_setall</span><span class="p">(</span><span class="n">shuffle_tmp_mask</span><span class="p">);</span>
	<span class="n">get_online_cpus</span><span class="p">();</span>

	<span class="cm">/* No point in shuffling if there is only one online CPU (ex: UP) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_online_cpus</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_idle_cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">rcu_idle_cpu</span><span class="p">,</span> <span class="n">shuffle_tmp_mask</span><span class="p">);</span>

	<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">shuffle_tmp_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reader_tasks</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nrealreaders</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reader_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">reader_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						     <span class="n">shuffle_tmp_mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fakewriter_tasks</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nfakewriters</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fakewriter_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">fakewriter_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						     <span class="n">shuffle_tmp_mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">writer_task</span><span class="p">)</span>
		<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">writer_task</span><span class="p">,</span> <span class="n">shuffle_tmp_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stats_task</span><span class="p">)</span>
		<span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">stats_task</span><span class="p">,</span> <span class="n">shuffle_tmp_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_idle_cpu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">rcu_idle_cpu</span> <span class="o">=</span> <span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rcu_idle_cpu</span><span class="o">--</span><span class="p">;</span>

	<span class="n">put_online_cpus</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Shuffle tasks across CPUs, with the intent of allowing each CPU in the</span>
<span class="cm"> * system to become idle at a time and cut off its timer ticks. This is meant</span>
<span class="cm"> * to test the support for such tickless idle CPU in RCU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rcu_torture_shuffle</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_shuffle task started&quot;</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">shuffle_interval</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
		<span class="n">rcu_torture_shuffle_tasks</span><span class="p">();</span>
		<span class="n">rcutorture_shutdown_absorb</span><span class="p">(</span><span class="s">&quot;rcu_torture_shuffle&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">());</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_shuffle task stopping&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Cause the rcutorture test to &quot;stutter&quot;, starting and stopping all</span>
<span class="cm"> * threads periodically.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rcu_torture_stutter</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_stutter task started&quot;</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">stutter</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
		<span class="n">stutter_pause_test</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span>
			<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">stutter</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
		<span class="n">stutter_pause_test</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rcutorture_shutdown_absorb</span><span class="p">(</span><span class="s">&quot;rcu_torture_stutter&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">());</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_stutter task stopping&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">rcu_torture_print_module_parms</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="o">*</span><span class="n">cur_ops</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;%s&quot;</span> <span class="n">TORTURE_FLAG</span>
		<span class="s">&quot;--- %s: nreaders=%d nfakewriters=%d &quot;</span>
		<span class="s">&quot;stat_interval=%d verbose=%d test_no_idle_hz=%d &quot;</span>
		<span class="s">&quot;shuffle_interval=%d stutter=%d irqreader=%d &quot;</span>
		<span class="s">&quot;fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d &quot;</span>
		<span class="s">&quot;test_boost=%d/%d test_boost_interval=%d &quot;</span>
		<span class="s">&quot;test_boost_duration=%d shutdown_secs=%d &quot;</span>
		<span class="s">&quot;onoff_interval=%d onoff_holdoff=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">torture_type</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">nrealreaders</span><span class="p">,</span> <span class="n">nfakewriters</span><span class="p">,</span>
		<span class="n">stat_interval</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">test_no_idle_hz</span><span class="p">,</span> <span class="n">shuffle_interval</span><span class="p">,</span>
		<span class="n">stutter</span><span class="p">,</span> <span class="n">irqreader</span><span class="p">,</span> <span class="n">fqs_duration</span><span class="p">,</span> <span class="n">fqs_holdoff</span><span class="p">,</span> <span class="n">fqs_stutter</span><span class="p">,</span>
		<span class="n">test_boost</span><span class="p">,</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">can_boost</span><span class="p">,</span>
		<span class="n">test_boost_interval</span><span class="p">,</span> <span class="n">test_boost_duration</span><span class="p">,</span> <span class="n">shutdown_secs</span><span class="p">,</span>
		<span class="n">onoff_interval</span><span class="p">,</span> <span class="n">onoff_holdoff</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">rcutorture_shutdown_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">rcutorture_shutdown_notify</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcutorture_booster_cleanup</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boost_tasks</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boost_mutex</span><span class="p">);</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;Stopping rcu_torture_boost task&quot;</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">boost_tasks</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">boost_tasks</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boost_mutex</span><span class="p">);</span>

	<span class="cm">/* This must be outside of the mutex, otherwise deadlock! */</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="n">boost_tasks</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcutorture_booster_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boost_tasks</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* Already created, nothing more to do. */</span>

	<span class="cm">/* Don&#39;t allow time recalculation while creating a new task. */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boost_mutex</span><span class="p">);</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;Creating rcu_torture_boost task&quot;</span><span class="p">);</span>
	<span class="n">boost_tasks</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">kthread_create_on_node</span><span class="p">(</span><span class="n">rcu_torture_boost</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						  <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span>
						  <span class="s">&quot;rcu_torture_boost&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">boost_tasks</span><span class="p">[</span><span class="n">cpu</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">boost_tasks</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_boost task create failed&quot;</span><span class="p">);</span>
		<span class="n">n_rcu_torture_boost_ktrerror</span><span class="o">++</span><span class="p">;</span>
		<span class="n">boost_tasks</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boost_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kthread_bind</span><span class="p">(</span><span class="n">boost_tasks</span><span class="p">[</span><span class="n">cpu</span><span class="p">],</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">boost_tasks</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boost_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cause the rcutorture test to shutdown the system after the test has</span>
<span class="cm"> * run for the time specified by the shutdown_secs module parameter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rcu_torture_shutdown</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffies_snap</span><span class="p">;</span>

	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_shutdown task started&quot;</span><span class="p">);</span>
	<span class="n">jiffies_snap</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ULONG_CMP_LT</span><span class="p">(</span><span class="n">jiffies_snap</span><span class="p">,</span> <span class="n">shutdown_time</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">shutdown_time</span> <span class="o">-</span> <span class="n">jiffies_snap</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;%s&quot;</span> <span class="n">TORTURE_FLAG</span>
			       <span class="s">&quot;rcu_torture_shutdown task: %lu &quot;</span>
			       <span class="s">&quot;jiffies remaining</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">torture_type</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
		<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
		<span class="n">jiffies_snap</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_shutdown task stopping&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* OK, shut down the system. */</span>

	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_shutdown task shutting down system&quot;</span><span class="p">);</span>
	<span class="n">shutdown_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* Avoid self-kill deadlock. */</span>
	<span class="n">rcu_torture_cleanup</span><span class="p">();</span>	<span class="cm">/* Get the success/failure message. */</span>
	<span class="n">kernel_power_off</span><span class="p">();</span>	<span class="cm">/* Shut down the system. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>

<span class="cm">/*</span>
<span class="cm"> * Execute random CPU-hotplug operations at the interval specified</span>
<span class="cm"> * by the onoff_interval.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span>
<span class="nf">rcu_torture_onoff</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxcpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">DEFINE_RCU_RANDOM</span><span class="p">(</span><span class="n">rand</span><span class="p">);</span>

	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_onoff task started&quot;</span><span class="p">);</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">maxcpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">maxcpu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">onoff_holdoff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_onoff begin holdoff&quot;</span><span class="p">);</span>
		<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">onoff_holdoff</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_onoff end holdoff&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="n">rcu_random</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rand</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">maxcpu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_is_hotpluggable</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;%s&quot;</span> <span class="n">TORTURE_FLAG</span>
				       <span class="s">&quot;rcu_torture_onoff task: offlining %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">torture_type</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="n">n_offline_attempts</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_down</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;%s&quot;</span> <span class="n">TORTURE_FLAG</span>
					       <span class="s">&quot;rcu_torture_onoff task: &quot;</span>
					       <span class="s">&quot;offlined %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">torture_type</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
				<span class="n">n_offline_successes</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_hotpluggable</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;%s&quot;</span> <span class="n">TORTURE_FLAG</span>
				       <span class="s">&quot;rcu_torture_onoff task: onlining %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">torture_type</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="n">n_online_attempts</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_up</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;%s&quot;</span> <span class="n">TORTURE_FLAG</span>
					       <span class="s">&quot;rcu_torture_onoff task: &quot;</span>
					       <span class="s">&quot;onlined %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">torture_type</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
				<span class="n">n_online_successes</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">onoff_interval</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_onoff task stopping&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span>
<span class="nf">rcu_torture_onoff_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">onoff_interval</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">onoff_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">rcu_torture_onoff</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;rcu_torture_onoff&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">onoff_task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">onoff_task</span><span class="p">);</span>
		<span class="n">onoff_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_torture_onoff_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">onoff_task</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;Stopping rcu_torture_onoff task&quot;</span><span class="p">);</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">onoff_task</span><span class="p">);</span>
	<span class="n">onoff_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* #ifdef CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">rcu_torture_onoff_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_torture_onoff_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* #else #ifdef CONFIG_HOTPLUG_CPU */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * CPU-stall kthread.  It waits as specified by stall_cpu_holdoff, then</span>
<span class="cm"> * induces a CPU stall for the time specified by stall_cpu.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">rcu_torture_stall</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stop_at</span><span class="p">;</span>

	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_stall task started&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stall_cpu_holdoff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_stall begin holdoff&quot;</span><span class="p">);</span>
		<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">stall_cpu_holdoff</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_stall end holdoff&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">stop_at</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">()</span> <span class="o">+</span> <span class="n">stall_cpu</span><span class="p">;</span>
		<span class="cm">/* RCU CPU stall is expected behavior in following code. */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;rcu_torture_stall start.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ULONG_CMP_LT</span><span class="p">(</span><span class="n">get_seconds</span><span class="p">(),</span> <span class="n">stop_at</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>  <span class="cm">/* Induce RCU CPU stall warning. */</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;rcu_torture_stall end.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcutorture_shutdown_absorb</span><span class="p">(</span><span class="s">&quot;rcu_torture_stall&quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span>
		<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Spawn CPU-stall kthread, if stall_cpu specified. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">rcu_torture_stall_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stall_cpu</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">stall_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">rcu_torture_stall</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;rcu_torture_stall&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">stall_task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">stall_task</span><span class="p">);</span>
		<span class="n">stall_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Clean up after the CPU-stall kthread, if one was spawned. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_torture_stall_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stall_task</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;Stopping rcu_torture_stall_task.&quot;</span><span class="p">);</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">stall_task</span><span class="p">);</span>
	<span class="n">stall_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Callback function for RCU barrier testing. */</span>
<span class="kt">void</span> <span class="nf">rcu_torture_barrier_cbf</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rcu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_cbs_invoked</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* kthread function to register callbacks used to test RCU barriers. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_torture_barrier_cbs</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">myid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>

	<span class="n">init_rcu_head_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu</span><span class="p">);</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_barrier_cbs task started&quot;</span><span class="p">);</span>
	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">barrier_cbs_wq</span><span class="p">[</span><span class="n">myid</span><span class="p">],</span>
			   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_cbs_count</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_barrier_cbs</span> <span class="o">||</span>
			   <span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">||</span>
			   <span class="n">fullstop</span> <span class="o">!=</span> <span class="n">FULLSTOP_DONTSTOP</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">||</span> <span class="n">fullstop</span> <span class="o">!=</span> <span class="n">FULLSTOP_DONTSTOP</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">rcu_torture_barrier_cbf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_cbs_count</span><span class="p">))</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_wq</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">fullstop</span> <span class="o">==</span> <span class="n">FULLSTOP_DONTSTOP</span><span class="p">);</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_barrier_cbs task stopping&quot;</span><span class="p">);</span>
	<span class="n">rcutorture_shutdown_absorb</span><span class="p">(</span><span class="s">&quot;rcu_torture_barrier_cbs&quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span>
		<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">cb_barrier</span><span class="p">();</span>
	<span class="n">destroy_rcu_head_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* kthread function to drive and coordinate RCU barrier testing. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_torture_barrier</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_barrier task starting&quot;</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_cbs_invoked</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_cbs_count</span><span class="p">,</span> <span class="n">n_barrier_cbs</span><span class="p">);</span>
		<span class="cm">/* wake_up() path contains the required barriers. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_barrier_cbs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_cbs_wq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">barrier_wq</span><span class="p">,</span>
			   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_cbs_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			   <span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">||</span>
			   <span class="n">fullstop</span> <span class="o">!=</span> <span class="n">FULLSTOP_DONTSTOP</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">||</span> <span class="n">fullstop</span> <span class="o">!=</span> <span class="n">FULLSTOP_DONTSTOP</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">n_barrier_attempts</span><span class="o">++</span><span class="p">;</span>
		<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">cb_barrier</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_cbs_invoked</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_barrier_cbs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n_rcu_torture_barrier_error</span><span class="o">++</span><span class="p">;</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">n_barrier_successes</span><span class="o">++</span><span class="p">;</span>
		<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">fullstop</span> <span class="o">==</span> <span class="n">FULLSTOP_DONTSTOP</span><span class="p">);</span>
	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;rcu_torture_barrier task stopping&quot;</span><span class="p">);</span>
	<span class="n">rcutorture_shutdown_absorb</span><span class="p">(</span><span class="s">&quot;rcu_torture_barrier_cbs&quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span>
		<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize RCU barrier testing. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcu_torture_barrier_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n_barrier_cbs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">call</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">cb_barrier</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;%s&quot;</span> <span class="n">TORTURE_FLAG</span>
		       <span class="s">&quot; Call or barrier ops missing for %s,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">torture_type</span><span class="p">,</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;%s&quot;</span> <span class="n">TORTURE_FLAG</span>
		       <span class="s">&quot; RCU barrier testing omitted from run.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">torture_type</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_cbs_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_cbs_invoked</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">barrier_cbs_tasks</span> <span class="o">=</span>
		<span class="n">kzalloc</span><span class="p">(</span><span class="n">n_barrier_cbs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">barrier_cbs_tasks</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">barrier_cbs_wq</span> <span class="o">=</span>
		<span class="n">kzalloc</span><span class="p">(</span><span class="n">n_barrier_cbs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">barrier_cbs_wq</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">barrier_cbs_tasks</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">barrier_cbs_wq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_barrier_cbs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier_cbs_wq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">barrier_cbs_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">rcu_torture_barrier_cbs</span><span class="p">,</span>
						   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">i</span><span class="p">,</span>
						   <span class="s">&quot;rcu_torture_barrier_cbs&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">barrier_cbs_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">barrier_cbs_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">VERBOSE_PRINTK_ERRSTRING</span><span class="p">(</span><span class="s">&quot;Failed to create rcu_torture_barrier_cbs&quot;</span><span class="p">);</span>
			<span class="n">barrier_cbs_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">barrier_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">rcu_torture_barrier</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				   <span class="s">&quot;rcu_torture_barrier&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">barrier_task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">barrier_task</span><span class="p">);</span>
		<span class="n">VERBOSE_PRINTK_ERRSTRING</span><span class="p">(</span><span class="s">&quot;Failed to create rcu_torture_barrier&quot;</span><span class="p">);</span>
		<span class="n">barrier_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Clean up after RCU barrier testing. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_torture_barrier_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">barrier_task</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;Stopping rcu_torture_barrier task&quot;</span><span class="p">);</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">barrier_task</span><span class="p">);</span>
		<span class="n">barrier_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">barrier_cbs_tasks</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_barrier_cbs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">barrier_cbs_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;Stopping rcu_torture_barrier_cbs task&quot;</span><span class="p">);</span>
				<span class="n">kthread_stop</span><span class="p">(</span><span class="n">barrier_cbs_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">barrier_cbs_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">barrier_cbs_tasks</span><span class="p">);</span>
		<span class="n">barrier_cbs_tasks</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">barrier_cbs_wq</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">barrier_cbs_wq</span><span class="p">);</span>
		<span class="n">barrier_cbs_wq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rcutorture_cpu_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED</span>:
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">rcutorture_booster_init</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE</span>:
		<span class="n">rcutorture_booster_cleanup</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">rcutorture_cpu_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">rcutorture_cpu_notify</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rcu_torture_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fullstop_mutex</span><span class="p">);</span>
	<span class="n">rcutorture_record_test_transition</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fullstop</span> <span class="o">==</span> <span class="n">FULLSTOP_SHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="cm">/* but going down anyway, so... */</span>
		       <span class="s">&quot;Concurrent &#39;rmmod rcutorture&#39; and shutdown illegal!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fullstop_mutex</span><span class="p">);</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">cb_barrier</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">cb_barrier</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fullstop</span> <span class="o">=</span> <span class="n">FULLSTOP_RMMOD</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fullstop_mutex</span><span class="p">);</span>
	<span class="n">unregister_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcutorture_shutdown_nb</span><span class="p">);</span>
	<span class="n">rcu_torture_barrier_cleanup</span><span class="p">();</span>
	<span class="n">rcu_torture_stall_cleanup</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stutter_task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;Stopping rcu_torture_stutter task&quot;</span><span class="p">);</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">stutter_task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">stutter_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shuffler_task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;Stopping rcu_torture_shuffle task&quot;</span><span class="p">);</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">shuffler_task</span><span class="p">);</span>
		<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">shuffle_tmp_mask</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">shuffler_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">writer_task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;Stopping rcu_torture_writer task&quot;</span><span class="p">);</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">writer_task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">writer_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reader_tasks</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nrealreaders</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reader_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span>
					<span class="s">&quot;Stopping rcu_torture_reader task&quot;</span><span class="p">);</span>
				<span class="n">kthread_stop</span><span class="p">(</span><span class="n">reader_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="n">reader_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">reader_tasks</span><span class="p">);</span>
		<span class="n">reader_tasks</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_torture_current</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fakewriter_tasks</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nfakewriters</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fakewriter_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span>
					<span class="s">&quot;Stopping rcu_torture_fakewriter task&quot;</span><span class="p">);</span>
				<span class="n">kthread_stop</span><span class="p">(</span><span class="n">fakewriter_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="n">fakewriter_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">fakewriter_tasks</span><span class="p">);</span>
		<span class="n">fakewriter_tasks</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stats_task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;Stopping rcu_torture_stats task&quot;</span><span class="p">);</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">stats_task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">stats_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fqs_task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;Stopping rcu_torture_fqs task&quot;</span><span class="p">);</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">fqs_task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">fqs_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">test_boost</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">can_boost</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">test_boost</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unregister_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcutorture_cpu_nb</span><span class="p">);</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
			<span class="n">rcutorture_booster_cleanup</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shutdown_task</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;Stopping rcu_torture_shutdown task&quot;</span><span class="p">);</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">shutdown_task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">shutdown_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rcu_torture_onoff_cleanup</span><span class="p">();</span>

	<span class="cm">/* Wait for all RCU callbacks to fire.  */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">cb_barrier</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">cb_barrier</span><span class="p">();</span>

	<span class="n">rcu_torture_stats_print</span><span class="p">();</span>  <span class="cm">/* -After- the stats thread is stopped! */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">cleanup</span><span class="p">)</span>
		<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">cleanup</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_error</span><span class="p">)</span> <span class="o">||</span> <span class="n">n_rcu_torture_barrier_error</span><span class="p">)</span>
		<span class="n">rcu_torture_print_module_parms</span><span class="p">(</span><span class="n">cur_ops</span><span class="p">,</span> <span class="s">&quot;End of test: FAILURE&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n_online_successes</span> <span class="o">!=</span> <span class="n">n_online_attempts</span> <span class="o">||</span>
		 <span class="n">n_offline_successes</span> <span class="o">!=</span> <span class="n">n_offline_attempts</span><span class="p">)</span>
		<span class="n">rcu_torture_print_module_parms</span><span class="p">(</span><span class="n">cur_ops</span><span class="p">,</span>
					       <span class="s">&quot;End of test: RCU_HOTPLUG&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rcu_torture_print_module_parms</span><span class="p">(</span><span class="n">cur_ops</span><span class="p">,</span> <span class="s">&quot;End of test: SUCCESS&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">rcu_torture_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">firsterr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">rcu_torture_ops</span> <span class="o">*</span><span class="n">torture_ops</span><span class="p">[]</span> <span class="o">=</span>
		<span class="p">{</span> <span class="o">&amp;</span><span class="n">rcu_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcu_sync_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcu_expedited_ops</span><span class="p">,</span>
		  <span class="o">&amp;</span><span class="n">rcu_bh_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcu_bh_sync_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcu_bh_expedited_ops</span><span class="p">,</span>
		  <span class="o">&amp;</span><span class="n">srcu_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">srcu_sync_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">srcu_raw_ops</span><span class="p">,</span>
		  <span class="o">&amp;</span><span class="n">srcu_raw_sync_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">srcu_expedited_ops</span><span class="p">,</span>
		  <span class="o">&amp;</span><span class="n">sched_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sched_sync_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sched_expedited_ops</span><span class="p">,</span> <span class="p">};</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fullstop_mutex</span><span class="p">);</span>

	<span class="cm">/* Process args and tell the world that the torturer is on the job. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">torture_ops</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur_ops</span> <span class="o">=</span> <span class="n">torture_ops</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">torture_type</span><span class="p">,</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">torture_ops</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;rcu-torture: invalid torture type: </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">torture_type</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;rcu-torture types:&quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">torture_ops</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot; %s&quot;</span><span class="p">,</span> <span class="n">torture_ops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fullstop_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">fqs</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">fqs_duration</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;rcu-torture: -&gt;fqs NULL and non-zero &quot;</span>
				  <span class="s">&quot;fqs_duration, fqs disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">fqs_duration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">)</span>
		<span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">();</span> <span class="cm">/* no &quot;goto unwind&quot; prior to this point!!! */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nreaders</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nrealreaders</span> <span class="o">=</span> <span class="n">nreaders</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">nrealreaders</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_online_cpus</span><span class="p">();</span>
	<span class="n">rcu_torture_print_module_parms</span><span class="p">(</span><span class="n">cur_ops</span><span class="p">,</span> <span class="s">&quot;Start of test&quot;</span><span class="p">);</span>
	<span class="n">fullstop</span> <span class="o">=</span> <span class="n">FULLSTOP_DONTSTOP</span><span class="p">;</span>

	<span class="cm">/* Set up the freelist. */</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_torture_freelist</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rcu_tortures</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_tortures</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rtort_mbtest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_tortures</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rtort_free</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">rcu_torture_freelist</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the statistics so that each run gets its own numbers. */</span>

	<span class="n">rcu_torture_current</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rcu_torture_current_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_alloc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_alloc_fail</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_free</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_mberror</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_rcu_torture_error</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">n_rcu_torture_barrier_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">n_rcu_torture_boost_ktrerror</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">n_rcu_torture_boost_rterror</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">n_rcu_torture_boost_failure</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">n_rcu_torture_boosts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RCU_TORTURE_PIPE_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcu_torture_wcount</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RCU_TORTURE_PIPE_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">rcu_torture_count</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">rcu_torture_batch</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Start up the kthreads. */</span>

	<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;Creating rcu_torture_writer task&quot;</span><span class="p">);</span>
	<span class="n">writer_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">rcu_torture_writer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				  <span class="s">&quot;rcu_torture_writer&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">writer_task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">firsterr</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">writer_task</span><span class="p">);</span>
		<span class="n">VERBOSE_PRINTK_ERRSTRING</span><span class="p">(</span><span class="s">&quot;Failed to create writer&quot;</span><span class="p">);</span>
		<span class="n">writer_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fakewriter_tasks</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">nfakewriters</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fakewriter_tasks</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
				   <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fakewriter_tasks</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VERBOSE_PRINTK_ERRSTRING</span><span class="p">(</span><span class="s">&quot;out of memory&quot;</span><span class="p">);</span>
		<span class="n">firsterr</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nfakewriters</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;Creating rcu_torture_fakewriter task&quot;</span><span class="p">);</span>
		<span class="n">fakewriter_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">rcu_torture_fakewriter</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						  <span class="s">&quot;rcu_torture_fakewriter&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fakewriter_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">firsterr</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fakewriter_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">VERBOSE_PRINTK_ERRSTRING</span><span class="p">(</span><span class="s">&quot;Failed to create fakewriter&quot;</span><span class="p">);</span>
			<span class="n">fakewriter_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">reader_tasks</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">nrealreaders</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">reader_tasks</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			       <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reader_tasks</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VERBOSE_PRINTK_ERRSTRING</span><span class="p">(</span><span class="s">&quot;out of memory&quot;</span><span class="p">);</span>
		<span class="n">firsterr</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nrealreaders</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;Creating rcu_torture_reader task&quot;</span><span class="p">);</span>
		<span class="n">reader_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">rcu_torture_reader</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					      <span class="s">&quot;rcu_torture_reader&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">reader_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">firsterr</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">reader_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">VERBOSE_PRINTK_ERRSTRING</span><span class="p">(</span><span class="s">&quot;Failed to create reader&quot;</span><span class="p">);</span>
			<span class="n">reader_tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat_interval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VERBOSE_PRINTK_STRING</span><span class="p">(</span><span class="s">&quot;Creating rcu_torture_stats task&quot;</span><span class="p">);</span>
		<span class="n">stats_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">rcu_torture_stats</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					<span class="s">&quot;rcu_torture_stats&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">stats_task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">firsterr</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">stats_task</span><span class="p">);</span>
			<span class="n">VERBOSE_PRINTK_ERRSTRING</span><span class="p">(</span><span class="s">&quot;Failed to create stats&quot;</span><span class="p">);</span>
			<span class="n">stats_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_no_idle_hz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_idle_cpu</span> <span class="o">=</span> <span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shuffle_tmp_mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">firsterr</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">VERBOSE_PRINTK_ERRSTRING</span><span class="p">(</span><span class="s">&quot;Failed to alloc mask&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Create the shuffler thread */</span>
		<span class="n">shuffler_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">rcu_torture_shuffle</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					  <span class="s">&quot;rcu_torture_shuffle&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">shuffler_task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">shuffle_tmp_mask</span><span class="p">);</span>
			<span class="n">firsterr</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">shuffler_task</span><span class="p">);</span>
			<span class="n">VERBOSE_PRINTK_ERRSTRING</span><span class="p">(</span><span class="s">&quot;Failed to create shuffler&quot;</span><span class="p">);</span>
			<span class="n">shuffler_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stutter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">stutter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stutter</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Create the stutter thread */</span>
		<span class="n">stutter_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">rcu_torture_stutter</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					  <span class="s">&quot;rcu_torture_stutter&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">stutter_task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">firsterr</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">stutter_task</span><span class="p">);</span>
			<span class="n">VERBOSE_PRINTK_ERRSTRING</span><span class="p">(</span><span class="s">&quot;Failed to create stutter&quot;</span><span class="p">);</span>
			<span class="n">stutter_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fqs_duration</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">fqs_duration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fqs_duration</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Create the stutter thread */</span>
		<span class="n">fqs_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">rcu_torture_fqs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				       <span class="s">&quot;rcu_torture_fqs&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fqs_task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">firsterr</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fqs_task</span><span class="p">);</span>
			<span class="n">VERBOSE_PRINTK_ERRSTRING</span><span class="p">(</span><span class="s">&quot;Failed to create fqs&quot;</span><span class="p">);</span>
			<span class="n">fqs_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_boost_interval</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">test_boost_interval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_boost_duration</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">test_boost_duration</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">test_boost</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">cur_ops</span><span class="o">-&gt;</span><span class="n">can_boost</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">test_boost</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">boost_starttime</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">test_boost_interval</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="n">register_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcutorture_cpu_nb</span><span class="p">);</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_offline</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>  <span class="cm">/* Heuristic: CPU can go offline. */</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">rcutorture_booster_init</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">firsterr</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shutdown_secs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shutdown_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">shutdown_secs</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="n">shutdown_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">rcu_torture_shutdown</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					    <span class="s">&quot;rcu_torture_shutdown&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">shutdown_task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">firsterr</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">shutdown_task</span><span class="p">);</span>
			<span class="n">VERBOSE_PRINTK_ERRSTRING</span><span class="p">(</span><span class="s">&quot;Failed to create shutdown&quot;</span><span class="p">);</span>
			<span class="n">shutdown_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">rcu_torture_onoff_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">firsterr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">register_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcutorture_shutdown_nb</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">rcu_torture_stall_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">firsterr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">rcu_torture_barrier_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">firsterr</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcutorture_record_test_transition</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fullstop_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">unwind:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fullstop_mutex</span><span class="p">);</span>
	<span class="n">rcu_torture_cleanup</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">firsterr</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">rcu_torture_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">rcu_torture_cleanup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
