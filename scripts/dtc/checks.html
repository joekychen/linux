<!DOCTYPE html>
<html><head><title>joekychen/linux » scripts › dtc › checks.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>checks.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * (C) Copyright David Gibson &lt;dwg@au1.ibm.com&gt;, IBM Corporation.  2007.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation; either version 2 of the</span>
<span class="cm"> * License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> *  General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307</span>
<span class="cm"> *                                                                   USA</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;dtc.h&quot;</span>

<span class="cp">#ifdef TRACE_CHECKS</span>
<span class="cp">#define TRACE(c, ...) \</span>
<span class="cp">	do { \</span>
<span class="cp">		fprintf(stderr, &quot;=== %s: &quot;, (c)-&gt;name); \</span>
<span class="cp">		fprintf(stderr, __VA_ARGS__); \</span>
<span class="cp">		fprintf(stderr, &quot;\n&quot;); \</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define TRACE(c, fmt, ...)	do { } while (0)</span>
<span class="cp">#endif</span>

<span class="k">enum</span> <span class="n">checklevel</span> <span class="p">{</span>
	<span class="n">IGNORE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">WARN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">ERROR</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">checkstatus</span> <span class="p">{</span>
	<span class="n">UNCHECKED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">PREREQ</span><span class="p">,</span>
	<span class="n">PASSED</span><span class="p">,</span>
	<span class="n">FAILED</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">check</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">tree_check_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">node_check_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">prop_check_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">check</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">tree_check_fn</span> <span class="n">tree_fn</span><span class="p">;</span>
	<span class="n">node_check_fn</span> <span class="n">node_fn</span><span class="p">;</span>
	<span class="n">prop_check_fn</span> <span class="n">prop_fn</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">checklevel</span> <span class="n">level</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">checkstatus</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">inprogress</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_prereqs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">check</span> <span class="o">**</span><span class="n">prereq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define CHECK(nm, tfn, nfn, pfn, d, lvl, ...) \</span>
<span class="cp">	static struct check *nm##_prereqs[] = { __VA_ARGS__ }; \</span>
<span class="cp">	static struct check nm = { \</span>
<span class="cp">		.name = #nm, \</span>
<span class="cp">		.tree_fn = (tfn), \</span>
<span class="cp">		.node_fn = (nfn), \</span>
<span class="cp">		.prop_fn = (pfn), \</span>
<span class="cp">		.data = (d), \</span>
<span class="cp">		.level = (lvl), \</span>
<span class="cp">		.status = UNCHECKED, \</span>
<span class="cp">		.num_prereqs = ARRAY_SIZE(nm##_prereqs), \</span>
<span class="cp">		.prereq = nm##_prereqs, \</span>
<span class="cp">	};</span>

<span class="cp">#define TREE_CHECK(nm, d, lvl, ...) \</span>
<span class="cp">	CHECK(nm, check_##nm, NULL, NULL, d, lvl, __VA_ARGS__)</span>
<span class="cp">#define NODE_CHECK(nm, d, lvl, ...) \</span>
<span class="cp">	CHECK(nm, NULL, check_##nm, NULL, d, lvl, __VA_ARGS__)</span>
<span class="cp">#define PROP_CHECK(nm, d, lvl, ...) \</span>
<span class="cp">	CHECK(nm, NULL, NULL, check_##nm, d, lvl, __VA_ARGS__)</span>
<span class="cp">#define BATCH_CHECK(nm, lvl, ...) \</span>
<span class="cp">	CHECK(nm, NULL, NULL, NULL, NULL, lvl, __VA_ARGS__)</span>

<span class="cp">#ifdef __GNUC__</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">check_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">format</span> <span class="p">(</span><span class="n">printf</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)));</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">check_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
	<span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">WARN</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&lt;=</span> <span class="n">quiet</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* Suppress message */</span>

	<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s (%s): &quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;ERROR&quot;</span> <span class="o">:</span> <span class="s">&quot;Warning&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">vfprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
	<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define FAIL(c, ...) \</span>
<span class="cp">	do { \</span>
<span class="cp">		TRACE((c), &quot;\t\tFAILED at %s:%d&quot;, __FILE__, __LINE__); \</span>
<span class="cp">		(c)-&gt;status = FAILED; \</span>
<span class="cp">		check_msg((c), __VA_ARGS__); \</span>
<span class="cp">	} while (0)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_nodes_props</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>

	<span class="n">TRACE</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">node_fn</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">node_fn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">prop_fn</span><span class="p">)</span>
		<span class="n">for_each_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">prop</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">TRACE</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\t</span><span class="s">&#39;%s&#39;&quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">,</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">prop_fn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">prop</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="n">for_each_child</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
		<span class="n">check_nodes_props</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">run_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inprogress</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">UNCHECKED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">inprogress</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">num_prereqs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">prq</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">prereq</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">error</span> <span class="o">|=</span> <span class="n">run_check</span><span class="p">(</span><span class="n">prq</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prq</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PASSED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">PREREQ</span><span class="p">;</span>
			<span class="n">check_msg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;Failed prerequisite &#39;%s&#39;&quot;</span><span class="p">,</span>
				  <span class="n">c</span><span class="o">-&gt;</span><span class="n">prereq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">UNCHECKED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">node_fn</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">prop_fn</span><span class="p">)</span>
		<span class="n">check_nodes_props</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tree_fn</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">tree_fn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">UNCHECKED</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">PASSED</span><span class="p">;</span>

	<span class="n">TRACE</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">Completed, status %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">inprogress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">PASSED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Utility check functions</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_is_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">propname</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">propname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* Not present, assumed ok */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data_is_one_string</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">))</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> property in %s is not a string&quot;</span><span class="p">,</span>
		     <span class="n">propname</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define CHECK_IS_STRING(nm, propname, lvl) \</span>
<span class="cp">	CHECK(nm, NULL, check_is_string, NULL, (propname), (lvl))</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_is_cell</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">propname</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">propname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* Not present, assumed ok */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cell_t</span><span class="p">))</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> property in %s is not a single cell&quot;</span><span class="p">,</span>
		     <span class="n">propname</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define CHECK_IS_CELL(nm, propname, lvl) \</span>
<span class="cp">	CHECK(nm, NULL, check_is_cell, NULL, (propname), (lvl))</span>

<span class="cm">/*</span>
<span class="cm"> * Structural check functions</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_duplicate_node_names</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="o">*</span><span class="n">child2</span><span class="p">;</span>

	<span class="n">for_each_child</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">child2</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">next_sibling</span><span class="p">;</span>
		     <span class="n">child2</span><span class="p">;</span>
		     <span class="n">child2</span> <span class="o">=</span> <span class="n">child2</span><span class="o">-&gt;</span><span class="n">next_sibling</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">streq</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">child2</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
				<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;Duplicate node name %s&quot;</span><span class="p">,</span>
				     <span class="n">child</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">NODE_CHECK</span><span class="p">(</span><span class="n">duplicate_node_names</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_duplicate_property_names</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">,</span> <span class="o">*</span><span class="n">prop2</span><span class="p">;</span>

	<span class="n">for_each_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">prop</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">prop2</span> <span class="o">=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">prop2</span><span class="p">;</span> <span class="n">prop2</span> <span class="o">=</span> <span class="n">prop2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">streq</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">prop2</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
				<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;Duplicate property name %s in %s&quot;</span><span class="p">,</span>
				     <span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">NODE_CHECK</span><span class="p">(</span><span class="n">duplicate_property_names</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">);</span>

<span class="cp">#define LOWERCASE	&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
<span class="cp">#define UPPERCASE	&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>
<span class="cp">#define DIGITS		&quot;0123456789&quot;</span>
<span class="cp">#define PROPNODECHARS	LOWERCASE UPPERCASE DIGITS &quot;,._+*#?-&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_node_name_chars</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">strspn</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;Bad character &#39;%c&#39; in node %s&quot;</span><span class="p">,</span>
		     <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">NODE_CHECK</span><span class="p">(</span><span class="n">node_name_chars</span><span class="p">,</span> <span class="n">PROPNODECHARS</span> <span class="s">&quot;@&quot;</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_node_name_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="n">get_unitname</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="sc">&#39;@&#39;</span><span class="p">))</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;Node %s has multiple &#39;@&#39; characters in name&quot;</span><span class="p">,</span>
		     <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">NODE_CHECK</span><span class="p">(</span><span class="n">node_name_format</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_name_chars</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_property_name_chars</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">strspn</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;Bad character &#39;%c&#39; in property name </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">, node %s&quot;</span><span class="p">,</span>
		     <span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">PROP_CHECK</span><span class="p">(</span><span class="n">property_name_chars</span><span class="p">,</span> <span class="n">PROPNODECHARS</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">);</span>

<span class="cp">#define DESCLABEL_FMT	&quot;%s%s%s%s%s&quot;</span>
<span class="cp">#define DESCLABEL_ARGS(node,prop,mark)		\</span>
<span class="cp">	((mark) ? &quot;value of &quot; : &quot;&quot;),		\</span>
<span class="cp">	((prop) ? &quot;&#39;&quot; : &quot;&quot;), \</span>
<span class="cp">	((prop) ? (prop)-&gt;name : &quot;&quot;), \</span>
<span class="cp">	((prop) ? &quot;&#39; in &quot; : &quot;&quot;), (node)-&gt;fullpath</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_duplicate_label</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">,</span> <span class="k">struct</span> <span class="n">marker</span> <span class="o">*</span><span class="n">mark</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">othernode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">otherprop</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">marker</span> <span class="o">*</span><span class="n">othermark</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">othernode</span> <span class="o">=</span> <span class="n">get_node_by_label</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">label</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">othernode</span><span class="p">)</span>
		<span class="n">otherprop</span> <span class="o">=</span> <span class="n">get_property_by_label</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">othernode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">othernode</span><span class="p">)</span>
		<span class="n">othermark</span> <span class="o">=</span> <span class="n">get_marker_label</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">othernode</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">otherprop</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">othernode</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">othernode</span> <span class="o">!=</span> <span class="n">node</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">otherprop</span> <span class="o">!=</span> <span class="n">prop</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">othermark</span> <span class="o">!=</span> <span class="n">mark</span><span class="p">))</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;Duplicate label &#39;%s&#39; on &quot;</span> <span class="n">DESCLABEL_FMT</span>
		     <span class="s">&quot; and &quot;</span> <span class="n">DESCLABEL_FMT</span><span class="p">,</span>
		     <span class="n">label</span><span class="p">,</span> <span class="n">DESCLABEL_ARGS</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">mark</span><span class="p">),</span>
		     <span class="n">DESCLABEL_ARGS</span><span class="p">(</span><span class="n">othernode</span><span class="p">,</span> <span class="n">otherprop</span><span class="p">,</span> <span class="n">othermark</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_duplicate_label_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">label</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>

	<span class="n">for_each_label</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">labels</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
		<span class="n">check_duplicate_label</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_duplicate_label_prop</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">marker</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">markers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">label</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>

	<span class="n">for_each_label</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">labels</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
		<span class="n">check_duplicate_label</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">for_each_marker_of_type</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">LABEL</span><span class="p">)</span>
		<span class="n">check_duplicate_label</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">CHECK</span><span class="p">(</span><span class="n">duplicate_label</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">check_duplicate_label_node</span><span class="p">,</span>
      <span class="n">check_duplicate_label_prop</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_explicit_phandles</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">marker</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">other</span><span class="p">;</span>
	<span class="n">cell_t</span> <span class="n">phandle</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">streq</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;phandle&quot;</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">streq</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;linux,phandle&quot;</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cell_t</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;%s has bad length (%d) %s property&quot;</span><span class="p">,</span>
		     <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">,</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">m</span> <span class="o">=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">markers</span><span class="p">;</span>
	<span class="n">for_each_marker_of_type</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">REF_PHANDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">assert</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="n">get_node_by_ref</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">))</span>
			<span class="cm">/* &quot;Set this node&#39;s phandle equal to some</span>
<span class="cm">			 * other node&#39;s phandle&quot;.  That&#39;s nonsensical</span>
<span class="cm">			 * by construction. */</span> <span class="p">{</span>
			<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;%s in %s is a reference to another node&quot;</span><span class="p">,</span>
			     <span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* But setting this node&#39;s phandle equal to its own</span>
<span class="cm">		 * phandle is allowed - that means allocate a unique</span>
<span class="cm">		 * phandle for this node, even if it&#39;s not otherwise</span>
<span class="cm">		 * referenced.  The value will be filled in later, so</span>
<span class="cm">		 * no further checking for now. */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">phandle</span> <span class="o">=</span> <span class="n">propval_cell</span><span class="p">(</span><span class="n">prop</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phandle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">phandle</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;%s has bad value (0x%x) in %s property&quot;</span><span class="p">,</span>
		     <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">,</span> <span class="n">phandle</span><span class="p">,</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">phandle</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">phandle</span> <span class="o">!=</span> <span class="n">phandle</span><span class="p">))</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;%s has %s property which replaces existing phandle information&quot;</span><span class="p">,</span>
		     <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">,</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">other</span> <span class="o">=</span> <span class="n">get_node_by_phandle</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">phandle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">other</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">other</span> <span class="o">!=</span> <span class="n">node</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;%s has duplicated phandle 0x%x (seen before at %s)&quot;</span><span class="p">,</span>
		     <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">,</span> <span class="n">phandle</span><span class="p">,</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">node</span><span class="o">-&gt;</span><span class="n">phandle</span> <span class="o">=</span> <span class="n">phandle</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">PROP_CHECK</span><span class="p">(</span><span class="n">explicit_phandles</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_name_properties</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">**</span><span class="n">pp</span><span class="p">,</span> <span class="o">*</span><span class="n">prop</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">proplist</span><span class="p">;</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span> <span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">((</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">streq</span><span class="p">((</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">prop</span> <span class="o">=</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* No name property, that&#39;s fine */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">len</span> <span class="o">!=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">basenamelen</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">basenamelen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">name</span><span class="se">\&quot;</span><span class="s"> property in %s is incorrect (</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> instead&quot;</span>
		     <span class="s">&quot; of base node name)&quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">,</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* The name property is correct, and therefore redundant.</span>
<span class="cm">		 * Delete it */</span>
		<span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">free</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">data_free</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">prop</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">CHECK_IS_STRING</span><span class="p">(</span><span class="n">name_is_string</span><span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">);</span>
<span class="n">NODE_CHECK</span><span class="p">(</span><span class="n">name_properties</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name_is_string</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Reference fixup functions</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_phandle_references</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">marker</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">markers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">refnode</span><span class="p">;</span>
	<span class="n">cell_t</span> <span class="n">phandle</span><span class="p">;</span>

	<span class="n">for_each_marker_of_type</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">REF_PHANDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">assert</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cell_t</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>

		<span class="n">refnode</span> <span class="o">=</span> <span class="n">get_node_by_ref</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">refnode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;Reference to non-existent node or label </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">m</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">phandle</span> <span class="o">=</span> <span class="n">get_node_phandle</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">refnode</span><span class="p">);</span>
		<span class="o">*</span><span class="p">((</span><span class="n">cell_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">))</span> <span class="o">=</span> <span class="n">cpu_to_fdt32</span><span class="p">(</span><span class="n">phandle</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">CHECK</span><span class="p">(</span><span class="n">phandle_references</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">fixup_phandle_references</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="n">duplicate_node_names</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">explicit_phandles</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_path_references</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">marker</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">markers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">refnode</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>

	<span class="n">for_each_marker_of_type</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">REF_PATH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">assert</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>

		<span class="n">refnode</span> <span class="o">=</span> <span class="n">get_node_by_ref</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">refnode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;Reference to non-existent node or label </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">m</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">path</span> <span class="o">=</span> <span class="n">refnode</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">;</span>
		<span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">data_insert_at_marker</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
						  <span class="n">strlen</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">CHECK</span><span class="p">(</span><span class="n">path_references</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">fixup_path_references</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="n">duplicate_node_names</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Semantic checks</span>
<span class="cm"> */</span>
<span class="n">CHECK_IS_CELL</span><span class="p">(</span><span class="n">address_cells_is_cell</span><span class="p">,</span> <span class="s">&quot;#address-cells&quot;</span><span class="p">,</span> <span class="n">WARN</span><span class="p">);</span>
<span class="n">CHECK_IS_CELL</span><span class="p">(</span><span class="n">size_cells_is_cell</span><span class="p">,</span> <span class="s">&quot;#size-cells&quot;</span><span class="p">,</span> <span class="n">WARN</span><span class="p">);</span>
<span class="n">CHECK_IS_CELL</span><span class="p">(</span><span class="n">interrupt_cells_is_cell</span><span class="p">,</span> <span class="s">&quot;#interrupt-cells&quot;</span><span class="p">,</span> <span class="n">WARN</span><span class="p">);</span>

<span class="n">CHECK_IS_STRING</span><span class="p">(</span><span class="n">device_type_is_string</span><span class="p">,</span> <span class="s">&quot;device_type&quot;</span><span class="p">,</span> <span class="n">WARN</span><span class="p">);</span>
<span class="n">CHECK_IS_STRING</span><span class="p">(</span><span class="n">model_is_string</span><span class="p">,</span> <span class="s">&quot;model&quot;</span><span class="p">,</span> <span class="n">WARN</span><span class="p">);</span>
<span class="n">CHECK_IS_STRING</span><span class="p">(</span><span class="n">status_is_string</span><span class="p">,</span> <span class="s">&quot;status&quot;</span><span class="p">,</span> <span class="n">WARN</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_addr_size_cells</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>

	<span class="n">node</span><span class="o">-&gt;</span><span class="n">addr_cells</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">size_cells</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;#address-cells&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span><span class="p">)</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">addr_cells</span> <span class="o">=</span> <span class="n">propval_cell</span><span class="p">(</span><span class="n">prop</span><span class="p">);</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;#size-cells&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span><span class="p">)</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">size_cells</span> <span class="o">=</span> <span class="n">propval_cell</span><span class="p">(</span><span class="n">prop</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">CHECK</span><span class="p">(</span><span class="n">addr_size_cells</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">fixup_addr_size_cells</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">WARN</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="n">address_cells_is_cell</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size_cells_is_cell</span><span class="p">);</span>

<span class="cp">#define node_addr_cells(n) \</span>
<span class="cp">	(((n)-&gt;addr_cells == -1) ? 2 : (n)-&gt;addr_cells)</span>
<span class="cp">#define node_size_cells(n) \</span>
<span class="cp">	(((n)-&gt;size_cells == -1) ? 1 : (n)-&gt;size_cells)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_reg_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addr_cells</span><span class="p">,</span> <span class="n">size_cells</span><span class="p">,</span> <span class="n">entrylen</span><span class="p">;</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* No &quot;reg&quot;, that&#39;s fine */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;Root node has a </span><span class="se">\&quot;</span><span class="s">reg</span><span class="se">\&quot;</span><span class="s"> property&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">reg</span><span class="se">\&quot;</span><span class="s"> property in %s is empty&quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">);</span>

	<span class="n">addr_cells</span> <span class="o">=</span> <span class="n">node_addr_cells</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">size_cells</span> <span class="o">=</span> <span class="n">node_size_cells</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">entrylen</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr_cells</span> <span class="o">+</span> <span class="n">size_cells</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cell_t</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">len</span> <span class="o">%</span> <span class="n">entrylen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">reg</span><span class="se">\&quot;</span><span class="s"> property in %s has invalid length (%d bytes) &quot;</span>
		     <span class="s">&quot;(#address-cells == %d, #size-cells == %d)&quot;</span><span class="p">,</span>
		     <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">,</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">addr_cells</span><span class="p">,</span> <span class="n">size_cells</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">NODE_CHECK</span><span class="p">(</span><span class="n">reg_format</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">WARN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_size_cells</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_ranges_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c_addr_cells</span><span class="p">,</span> <span class="n">p_addr_cells</span><span class="p">,</span> <span class="n">c_size_cells</span><span class="p">,</span> <span class="n">p_size_cells</span><span class="p">,</span> <span class="n">entrylen</span><span class="p">;</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ranges&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;Root node has a </span><span class="se">\&quot;</span><span class="s">ranges</span><span class="se">\&quot;</span><span class="s"> property&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p_addr_cells</span> <span class="o">=</span> <span class="n">node_addr_cells</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">p_size_cells</span> <span class="o">=</span> <span class="n">node_size_cells</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">c_addr_cells</span> <span class="o">=</span> <span class="n">node_addr_cells</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="n">c_size_cells</span> <span class="o">=</span> <span class="n">node_size_cells</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="n">entrylen</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_addr_cells</span> <span class="o">+</span> <span class="n">c_addr_cells</span> <span class="o">+</span> <span class="n">c_size_cells</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cell_t</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p_addr_cells</span> <span class="o">!=</span> <span class="n">c_addr_cells</span><span class="p">)</span>
			<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;%s has empty </span><span class="se">\&quot;</span><span class="s">ranges</span><span class="se">\&quot;</span><span class="s"> property but its &quot;</span>
			     <span class="s">&quot;#address-cells (%d) differs from %s (%d)&quot;</span><span class="p">,</span>
			     <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">,</span> <span class="n">c_addr_cells</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">,</span>
			     <span class="n">p_addr_cells</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p_size_cells</span> <span class="o">!=</span> <span class="n">c_size_cells</span><span class="p">)</span>
			<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;%s has empty </span><span class="se">\&quot;</span><span class="s">ranges</span><span class="se">\&quot;</span><span class="s"> property but its &quot;</span>
			     <span class="s">&quot;#size-cells (%d) differs from %s (%d)&quot;</span><span class="p">,</span>
			     <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">,</span> <span class="n">c_size_cells</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">,</span>
			     <span class="n">p_size_cells</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">len</span> <span class="o">%</span> <span class="n">entrylen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">ranges</span><span class="se">\&quot;</span><span class="s"> property in %s has invalid length (%d bytes) &quot;</span>
		     <span class="s">&quot;(parent #address-cells == %d, child #address-cells == %d, &quot;</span>
		     <span class="s">&quot;#size-cells == %d)&quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">,</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
		     <span class="n">p_addr_cells</span><span class="p">,</span> <span class="n">c_addr_cells</span><span class="p">,</span> <span class="n">c_size_cells</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">NODE_CHECK</span><span class="p">(</span><span class="n">ranges_format</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">WARN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_size_cells</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Style checks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_avoid_default_addr_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span> <span class="o">*</span><span class="n">ranges</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* Ignore root node */</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">);</span>
	<span class="n">ranges</span> <span class="o">=</span> <span class="n">get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ranges&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ranges</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">addr_cells</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;Relying on default #address-cells value for %s&quot;</span><span class="p">,</span>
		     <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">size_cells</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;Relying on default #size-cells value for %s&quot;</span><span class="p">,</span>
		     <span class="n">node</span><span class="o">-&gt;</span><span class="n">fullpath</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">NODE_CHECK</span><span class="p">(</span><span class="n">avoid_default_addr_size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">WARN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_size_cells</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_obsolete_chosen_interrupt_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
						       <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">chosen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>

	<span class="n">chosen</span> <span class="o">=</span> <span class="n">get_node_by_path</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="s">&quot;/chosen&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chosen</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">prop</span> <span class="o">=</span> <span class="n">get_property</span><span class="p">(</span><span class="n">chosen</span><span class="p">,</span> <span class="s">&quot;interrupt-controller&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prop</span><span class="p">)</span>
		<span class="n">FAIL</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;/chosen has obsolete </span><span class="se">\&quot;</span><span class="s">interrupt-controller</span><span class="se">\&quot;</span><span class="s"> &quot;</span>
		     <span class="s">&quot;property&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">TREE_CHECK</span><span class="p">(</span><span class="n">obsolete_chosen_interrupt_controller</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">WARN</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">check_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">duplicate_node_names</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">duplicate_property_names</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">node_name_chars</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_name_format</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">property_name_chars</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">name_is_string</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name_properties</span><span class="p">,</span>

	<span class="o">&amp;</span><span class="n">duplicate_label</span><span class="p">,</span>

	<span class="o">&amp;</span><span class="n">explicit_phandles</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">phandle_references</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path_references</span><span class="p">,</span>

	<span class="o">&amp;</span><span class="n">address_cells_is_cell</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size_cells_is_cell</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">interrupt_cells_is_cell</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">device_type_is_string</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">model_is_string</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status_is_string</span><span class="p">,</span>

	<span class="o">&amp;</span><span class="n">addr_size_cells</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_format</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ranges_format</span><span class="p">,</span>

	<span class="o">&amp;</span><span class="n">avoid_default_addr_size</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">obsolete_chosen_interrupt_controller</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">process_checks</span><span class="p">(</span><span class="kt">int</span> <span class="n">force</span><span class="p">,</span> <span class="k">struct</span> <span class="n">boot_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">dt</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">dt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">check_table</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">check</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">check_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">!=</span> <span class="n">IGNORE</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">error</span> <span class="o">||</span> <span class="n">run_check</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">force</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;ERROR: Input tree has errors, aborting &quot;</span>
				<span class="s">&quot;(use -f to force output)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">quiet</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Warning: Input tree has errors, &quot;</span>
				<span class="s">&quot;output forced</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
