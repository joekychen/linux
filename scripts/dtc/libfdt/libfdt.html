<!DOCTYPE html>
<html><head><title>joekychen/linux » scripts › dtc › libfdt › libfdt.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>libfdt.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LIBFDT_H</span>
<span class="cp">#define _LIBFDT_H</span>
<span class="cm">/*</span>
<span class="cm"> * libfdt - Flat Device Tree manipulation</span>
<span class="cm"> * Copyright (C) 2006 David Gibson, IBM Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * libfdt is dual licensed: you can use it either under the terms of</span>
<span class="cm"> * the GPL, or the BSD license, at your option.</span>
<span class="cm"> *</span>
<span class="cm"> *  a) This library is free software; you can redistribute it and/or</span>
<span class="cm"> *     modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *     published by the Free Software Foundation; either version 2 of the</span>
<span class="cm"> *     License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *     This library is distributed in the hope that it will be useful,</span>
<span class="cm"> *     but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *     GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *     You should have received a copy of the GNU General Public</span>
<span class="cm"> *     License along with this library; if not, write to the Free</span>
<span class="cm"> *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,</span>
<span class="cm"> *     MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively,</span>
<span class="cm"> *</span>
<span class="cm"> *  b) Redistribution and use in source and binary forms, with or</span>
<span class="cm"> *     without modification, are permitted provided that the following</span>
<span class="cm"> *     conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *     1. Redistributions of source code must retain the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer.</span>
<span class="cm"> *     2. Redistributions in binary form must reproduce the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer in the documentation and/or other materials</span>
<span class="cm"> *        provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND</span>
<span class="cm"> *     CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES,</span>
<span class="cm"> *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<span class="cm"> *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="cm"> *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR</span>
<span class="cm"> *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
<span class="cm"> *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="cm"> *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span class="cm"> *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="cm"> *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR</span>
<span class="cm"> *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,</span>
<span class="cm"> *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;libfdt_env.h&gt;</span>
<span class="cp">#include &lt;fdt.h&gt;</span>

<span class="cp">#define FDT_FIRST_SUPPORTED_VERSION	0x10</span>
<span class="cp">#define FDT_LAST_SUPPORTED_VERSION	0x11</span>

<span class="cm">/* Error codes: informative error codes */</span>
<span class="cp">#define FDT_ERR_NOTFOUND	1</span>
	<span class="cm">/* FDT_ERR_NOTFOUND: The requested node or property does not exist */</span>
<span class="cp">#define FDT_ERR_EXISTS		2</span>
	<span class="cm">/* FDT_ERR_EXISTS: Attempted to create a node or property which</span>
<span class="cm">	 * already exists */</span>
<span class="cp">#define FDT_ERR_NOSPACE		3</span>
	<span class="cm">/* FDT_ERR_NOSPACE: Operation needed to expand the device</span>
<span class="cm">	 * tree, but its buffer did not have sufficient space to</span>
<span class="cm">	 * contain the expanded tree. Use fdt_open_into() to move the</span>
<span class="cm">	 * device tree to a buffer with more space. */</span>

<span class="cm">/* Error codes: codes for bad parameters */</span>
<span class="cp">#define FDT_ERR_BADOFFSET	4</span>
	<span class="cm">/* FDT_ERR_BADOFFSET: Function was passed a structure block</span>
<span class="cm">	 * offset which is out-of-bounds, or which points to an</span>
<span class="cm">	 * unsuitable part of the structure for the operation. */</span>
<span class="cp">#define FDT_ERR_BADPATH		5</span>
	<span class="cm">/* FDT_ERR_BADPATH: Function was passed a badly formatted path</span>
<span class="cm">	 * (e.g. missing a leading / for a function which requires an</span>
<span class="cm">	 * absolute path) */</span>
<span class="cp">#define FDT_ERR_BADPHANDLE	6</span>
	<span class="cm">/* FDT_ERR_BADPHANDLE: Function was passed an invalid phandle</span>
<span class="cm">	 * value.  phandle values of 0 and -1 are not permitted. */</span>
<span class="cp">#define FDT_ERR_BADSTATE	7</span>
	<span class="cm">/* FDT_ERR_BADSTATE: Function was passed an incomplete device</span>
<span class="cm">	 * tree created by the sequential-write functions, which is</span>
<span class="cm">	 * not sufficiently complete for the requested operation. */</span>

<span class="cm">/* Error codes: codes for bad device tree blobs */</span>
<span class="cp">#define FDT_ERR_TRUNCATED	8</span>
	<span class="cm">/* FDT_ERR_TRUNCATED: Structure block of the given device tree</span>
<span class="cm">	 * ends without an FDT_END tag. */</span>
<span class="cp">#define FDT_ERR_BADMAGIC	9</span>
	<span class="cm">/* FDT_ERR_BADMAGIC: Given &quot;device tree&quot; appears not to be a</span>
<span class="cm">	 * device tree at all - it is missing the flattened device</span>
<span class="cm">	 * tree magic number. */</span>
<span class="cp">#define FDT_ERR_BADVERSION	10</span>
	<span class="cm">/* FDT_ERR_BADVERSION: Given device tree has a version which</span>
<span class="cm">	 * can&#39;t be handled by the requested operation.  For</span>
<span class="cm">	 * read-write functions, this may mean that fdt_open_into() is</span>
<span class="cm">	 * required to convert the tree to the expected version. */</span>
<span class="cp">#define FDT_ERR_BADSTRUCTURE	11</span>
	<span class="cm">/* FDT_ERR_BADSTRUCTURE: Given device tree has a corrupt</span>
<span class="cm">	 * structure block or other serious error (e.g. misnested</span>
<span class="cm">	 * nodes, or subnodes preceding properties). */</span>
<span class="cp">#define FDT_ERR_BADLAYOUT	12</span>
	<span class="cm">/* FDT_ERR_BADLAYOUT: For read-write functions, the given</span>
<span class="cm">	 * device tree has it&#39;s sub-blocks in an order that the</span>
<span class="cm">	 * function can&#39;t handle (memory reserve map, then structure,</span>
<span class="cm">	 * then strings).  Use fdt_open_into() to reorganize the tree</span>
<span class="cm">	 * into a form suitable for the read-write operations. */</span>

<span class="cm">/* &quot;Can&#39;t happen&quot; error indicating a bug in libfdt */</span>
<span class="cp">#define FDT_ERR_INTERNAL	13</span>
	<span class="cm">/* FDT_ERR_INTERNAL: libfdt has failed an internal assertion.</span>
<span class="cm">	 * Should never be returned, if it is, it indicates a bug in</span>
<span class="cm">	 * libfdt itself. */</span>

<span class="cp">#define FDT_ERR_MAX		13</span>

<span class="cm">/**********************************************************************/</span>
<span class="cm">/* Low-level functions (you probably don&#39;t need these)                */</span>
<span class="cm">/**********************************************************************/</span>

<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt_offset_ptr</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">checklen</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">fdt_offset_ptr_w</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">checklen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">fdt_offset_ptr</span><span class="p">(</span><span class="n">fdt</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">checklen</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="n">fdt_next_tag</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nextoffset</span><span class="p">);</span>

<span class="cm">/**********************************************************************/</span>
<span class="cm">/* Traversal functions                                                */</span>
<span class="cm">/**********************************************************************/</span>

<span class="kt">int</span> <span class="n">fdt_next_node</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">depth</span><span class="p">);</span>

<span class="cm">/**********************************************************************/</span>
<span class="cm">/* General functions                                                  */</span>
<span class="cm">/**********************************************************************/</span>

<span class="cp">#define fdt_get_header(fdt, field) \</span>
<span class="cp">	(fdt32_to_cpu(((const struct fdt_header *)(fdt))-&gt;field))</span>
<span class="cp">#define fdt_magic(fdt) 			(fdt_get_header(fdt, magic))</span>
<span class="cp">#define fdt_totalsize(fdt)		(fdt_get_header(fdt, totalsize))</span>
<span class="cp">#define fdt_off_dt_struct(fdt)		(fdt_get_header(fdt, off_dt_struct))</span>
<span class="cp">#define fdt_off_dt_strings(fdt)		(fdt_get_header(fdt, off_dt_strings))</span>
<span class="cp">#define fdt_off_mem_rsvmap(fdt)		(fdt_get_header(fdt, off_mem_rsvmap))</span>
<span class="cp">#define fdt_version(fdt)		(fdt_get_header(fdt, version))</span>
<span class="cp">#define fdt_last_comp_version(fdt) 	(fdt_get_header(fdt, last_comp_version))</span>
<span class="cp">#define fdt_boot_cpuid_phys(fdt) 	(fdt_get_header(fdt, boot_cpuid_phys))</span>
<span class="cp">#define fdt_size_dt_strings(fdt) 	(fdt_get_header(fdt, size_dt_strings))</span>
<span class="cp">#define fdt_size_dt_struct(fdt)		(fdt_get_header(fdt, size_dt_struct))</span>

<span class="cp">#define __fdt_set_hdr(name) \</span>
<span class="cp">	static inline void fdt_set_##name(void *fdt, uint32_t val) \</span>
<span class="cp">	{ \</span>
<span class="cp">		struct fdt_header *fdth = fdt; \</span>
<span class="cp">		fdth-&gt;name = cpu_to_fdt32(val); \</span>
<span class="cp">	}</span>
<span class="n">__fdt_set_hdr</span><span class="p">(</span><span class="n">magic</span><span class="p">);</span>
<span class="n">__fdt_set_hdr</span><span class="p">(</span><span class="n">totalsize</span><span class="p">);</span>
<span class="n">__fdt_set_hdr</span><span class="p">(</span><span class="n">off_dt_struct</span><span class="p">);</span>
<span class="n">__fdt_set_hdr</span><span class="p">(</span><span class="n">off_dt_strings</span><span class="p">);</span>
<span class="n">__fdt_set_hdr</span><span class="p">(</span><span class="n">off_mem_rsvmap</span><span class="p">);</span>
<span class="n">__fdt_set_hdr</span><span class="p">(</span><span class="n">version</span><span class="p">);</span>
<span class="n">__fdt_set_hdr</span><span class="p">(</span><span class="n">last_comp_version</span><span class="p">);</span>
<span class="n">__fdt_set_hdr</span><span class="p">(</span><span class="n">boot_cpuid_phys</span><span class="p">);</span>
<span class="n">__fdt_set_hdr</span><span class="p">(</span><span class="n">size_dt_strings</span><span class="p">);</span>
<span class="n">__fdt_set_hdr</span><span class="p">(</span><span class="n">size_dt_struct</span><span class="p">);</span>
<span class="cp">#undef __fdt_set_hdr</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_check_header - sanity check a device tree or possible device tree</span>
<span class="cm"> * @fdt: pointer to data which might be a flattened device tree</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_check_header() checks that the given buffer contains what</span>
<span class="cm"> * appears to be a flattened device tree with sane information in its</span>
<span class="cm"> * header.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *     0, if the buffer appears to contain a valid device tree</span>
<span class="cm"> *     -FDT_ERR_BADMAGIC,</span>
<span class="cm"> *     -FDT_ERR_BADVERSION,</span>
<span class="cm"> *     -FDT_ERR_BADSTATE, standard meanings, as above</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_check_header</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_move - move a device tree around in memory</span>
<span class="cm"> * @fdt: pointer to the device tree to move</span>
<span class="cm"> * @buf: pointer to memory where the device is to be moved</span>
<span class="cm"> * @bufsize: size of the memory space at buf</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_move() relocates, if possible, the device tree blob located at</span>
<span class="cm"> * fdt to the buffer at buf of size bufsize.  The buffer may overlap</span>
<span class="cm"> * with the existing device tree blob at fdt.  Therefore,</span>
<span class="cm"> *     fdt_move(fdt, fdt, fdt_totalsize(fdt))</span>
<span class="cm"> * should always succeed.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *     0, on success</span>
<span class="cm"> *     -FDT_ERR_NOSPACE, bufsize is insufficient to contain the device tree</span>
<span class="cm"> *     -FDT_ERR_BADMAGIC,</span>
<span class="cm"> *     -FDT_ERR_BADVERSION,</span>
<span class="cm"> *     -FDT_ERR_BADSTATE, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_move</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">);</span>

<span class="cm">/**********************************************************************/</span>
<span class="cm">/* Read-only functions                                                */</span>
<span class="cm">/**********************************************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_string - retrieve a string from the strings block of a device tree</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @stroffset: offset of the string within the strings block (native endian)</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_string() retrieves a pointer to a single string from the</span>
<span class="cm"> * strings block of the device tree blob at fdt.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *     a pointer to the string, on success</span>
<span class="cm"> *     NULL, if stroffset is out of bounds</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fdt_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stroffset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_num_mem_rsv - retrieve the number of memory reserve map entries</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of entries in the device tree blob&#39;s memory</span>
<span class="cm"> * reservation map.  This does not include the terminating 0,0 entry</span>
<span class="cm"> * or any other (0,0) entries reserved for expansion.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *     the number of entries</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_num_mem_rsv</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_get_mem_rsv - retrieve one memory reserve map entry</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @address, @size: pointers to 64-bit variables</span>
<span class="cm"> *</span>
<span class="cm"> * On success, *address and *size will contain the address and size of</span>
<span class="cm"> * the n-th reserve map entry from the device tree blob, in</span>
<span class="cm"> * native-endian format.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *     0, on success</span>
<span class="cm"> *     -FDT_ERR_BADMAGIC,</span>
<span class="cm"> *     -FDT_ERR_BADVERSION,</span>
<span class="cm"> *     -FDT_ERR_BADSTATE, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_get_mem_rsv</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_subnode_offset_namelen - find a subnode based on substring</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @parentoffset: structure block offset of a node</span>
<span class="cm"> * @name: name of the subnode to locate</span>
<span class="cm"> * @namelen: number of characters of name to consider</span>
<span class="cm"> *</span>
<span class="cm"> * Identical to fdt_subnode_offset(), but only examine the first</span>
<span class="cm"> * namelen characters of name for matching the subnode name.  This is</span>
<span class="cm"> * useful for finding subnodes based on a portion of a larger string,</span>
<span class="cm"> * such as a full path.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_subnode_offset_namelen</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parentoffset</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * fdt_subnode_offset - find a subnode of a given node</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @parentoffset: structure block offset of a node</span>
<span class="cm"> * @name: name of the subnode to locate</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_subnode_offset() finds a subnode of the node at structure block</span>
<span class="cm"> * offset parentoffset with the given name.  name may include a unit</span>
<span class="cm"> * address, in which case fdt_subnode_offset() will find the subnode</span>
<span class="cm"> * with that unit address, or the unit address may be omitted, in</span>
<span class="cm"> * which case fdt_subnode_offset() will find an arbitrary subnode</span>
<span class="cm"> * whose name excluding unit address matches the given name.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	structure block offset of the requested subnode (&gt;=0), on success</span>
<span class="cm"> *	-FDT_ERR_NOTFOUND, if the requested subnode does not exist</span>
<span class="cm"> *	-FDT_ERR_BADOFFSET, if parentoffset did not point to an FDT_BEGIN_NODE tag</span>
<span class="cm"> *      -FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE,</span>
<span class="cm"> *	-FDT_ERR_TRUNCATED, standard meanings.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_subnode_offset</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parentoffset</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_path_offset - find a tree node by its full path</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @path: full path of the node to locate</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_path_offset() finds a node of a given path in the device tree.</span>
<span class="cm"> * Each path component may omit the unit address portion, but the</span>
<span class="cm"> * results of this are undefined if any such path component is</span>
<span class="cm"> * ambiguous (that is if there are multiple nodes at the relevant</span>
<span class="cm"> * level matching the given component, differentiated only by unit</span>
<span class="cm"> * address).</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	structure block offset of the node with the requested path (&gt;=0), on success</span>
<span class="cm"> *	-FDT_ERR_BADPATH, given path does not begin with &#39;/&#39; or is invalid</span>
<span class="cm"> *	-FDT_ERR_NOTFOUND, if the requested node does not exist</span>
<span class="cm"> *      -FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE,</span>
<span class="cm"> *	-FDT_ERR_TRUNCATED, standard meanings.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_path_offset</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_get_name - retrieve the name of a given node</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: structure block offset of the starting node</span>
<span class="cm"> * @lenp: pointer to an integer variable (will be overwritten) or NULL</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_get_name() retrieves the name (including unit address) of the</span>
<span class="cm"> * device tree node at structure block offset nodeoffset.  If lenp is</span>
<span class="cm"> * non-NULL, the length of this name is also returned, in the integer</span>
<span class="cm"> * pointed to by lenp.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	pointer to the node&#39;s name, on success</span>
<span class="cm"> *		If lenp is non-NULL, *lenp contains the length of that name (&gt;=0)</span>
<span class="cm"> *	NULL, on error</span>
<span class="cm"> *		if lenp is non-NULL *lenp contains an error code (&lt;0):</span>
<span class="cm"> *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag</span>
<span class="cm"> *		-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *		-FDT_ERR_BADVERSION,</span>
<span class="cm"> *		-FDT_ERR_BADSTATE, standard meanings</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fdt_get_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lenp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_get_property - find a given property in a given node</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: offset of the node whose property to find</span>
<span class="cm"> * @name: name of the property to find</span>
<span class="cm"> * @lenp: pointer to an integer variable (will be overwritten) or NULL</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_get_property() retrieves a pointer to the fdt_property</span>
<span class="cm"> * structure within the device tree blob corresponding to the property</span>
<span class="cm"> * named &#39;name&#39; of the node at offset nodeoffset.  If lenp is</span>
<span class="cm"> * non-NULL, the length of the property value is also returned, in the</span>
<span class="cm"> * integer pointed to by lenp.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	pointer to the structure representing the property</span>
<span class="cm"> *		if lenp is non-NULL, *lenp contains the length of the property</span>
<span class="cm"> *		value (&gt;=0)</span>
<span class="cm"> *	NULL, on error</span>
<span class="cm"> *		if lenp is non-NULL, *lenp contains an error code (&lt;0):</span>
<span class="cm"> *		-FDT_ERR_NOTFOUND, node does not have named property</span>
<span class="cm"> *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag</span>
<span class="cm"> *		-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *		-FDT_ERR_BADVERSION,</span>
<span class="cm"> *		-FDT_ERR_BADSTATE,</span>
<span class="cm"> *		-FDT_ERR_BADSTRUCTURE,</span>
<span class="cm"> *		-FDT_ERR_TRUNCATED, standard meanings</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">fdt_property</span> <span class="o">*</span><span class="n">fdt_get_property</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lenp</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fdt_property</span> <span class="o">*</span><span class="nf">fdt_get_property_w</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">,</span>
						      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
						      <span class="kt">int</span> <span class="o">*</span><span class="n">lenp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fdt_property</span> <span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span>
		<span class="n">fdt_get_property</span><span class="p">(</span><span class="n">fdt</span><span class="p">,</span> <span class="n">nodeoffset</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">lenp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_getprop - retrieve the value of a given property</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: offset of the node whose property to find</span>
<span class="cm"> * @name: name of the property to find</span>
<span class="cm"> * @lenp: pointer to an integer variable (will be overwritten) or NULL</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_getprop() retrieves a pointer to the value of the property</span>
<span class="cm"> * named &#39;name&#39; of the node at offset nodeoffset (this will be a</span>
<span class="cm"> * pointer to within the device blob itself, not a copy of the value).</span>
<span class="cm"> * If lenp is non-NULL, the length of the property value is also</span>
<span class="cm"> * returned, in the integer pointed to by lenp.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	pointer to the property&#39;s value</span>
<span class="cm"> *		if lenp is non-NULL, *lenp contains the length of the property</span>
<span class="cm"> *		value (&gt;=0)</span>
<span class="cm"> *	NULL, on error</span>
<span class="cm"> *		if lenp is non-NULL, *lenp contains an error code (&lt;0):</span>
<span class="cm"> *		-FDT_ERR_NOTFOUND, node does not have named property</span>
<span class="cm"> *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag</span>
<span class="cm"> *		-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *		-FDT_ERR_BADVERSION,</span>
<span class="cm"> *		-FDT_ERR_BADSTATE,</span>
<span class="cm"> *		-FDT_ERR_BADSTRUCTURE,</span>
<span class="cm"> *		-FDT_ERR_TRUNCATED, standard meanings</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt_getprop</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lenp</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">fdt_getprop_w</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lenp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">fdt_getprop</span><span class="p">(</span><span class="n">fdt</span><span class="p">,</span> <span class="n">nodeoffset</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">lenp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_get_phandle - retrieve the phandle of a given node</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: structure block offset of the node</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_get_phandle() retrieves the phandle of the device tree node at</span>
<span class="cm"> * structure block offset nodeoffset.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	the phandle of the node at nodeoffset, on success (!= 0, != -1)</span>
<span class="cm"> *	0, if the node has no phandle, or another error occurs</span>
<span class="cm"> */</span>
<span class="kt">uint32_t</span> <span class="n">fdt_get_phandle</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_get_path - determine the full path of a node</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: offset of the node whose path to find</span>
<span class="cm"> * @buf: character buffer to contain the returned path (will be overwritten)</span>
<span class="cm"> * @buflen: size of the character buffer at buf</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_get_path() computes the full path of the node at offset</span>
<span class="cm"> * nodeoffset, and records that path in the buffer at buf.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This function is expensive, as it must scan the device tree</span>
<span class="cm"> * structure from the start to nodeoffset.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	0, on success</span>
<span class="cm"> *		buf contains the absolute path of the node at</span>
<span class="cm"> *		nodeoffset, as a NUL-terminated string.</span>
<span class="cm"> * 	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_NOSPACE, the path of the given node is longer than (bufsize-1)</span>
<span class="cm"> *		characters and will not fit in the given buffer.</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_get_path</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_supernode_atdepth_offset - find a specific ancestor of a node</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: offset of the node whose parent to find</span>
<span class="cm"> * @supernodedepth: depth of the ancestor to find</span>
<span class="cm"> * @nodedepth: pointer to an integer variable (will be overwritten) or NULL</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_supernode_atdepth_offset() finds an ancestor of the given node</span>
<span class="cm"> * at a specific depth from the root (where the root itself has depth</span>
<span class="cm"> * 0, its immediate subnodes depth 1 and so forth).  So</span>
<span class="cm"> *	fdt_supernode_atdepth_offset(fdt, nodeoffset, 0, NULL);</span>
<span class="cm"> * will always return 0, the offset of the root node.  If the node at</span>
<span class="cm"> * nodeoffset has depth D, then:</span>
<span class="cm"> *	fdt_supernode_atdepth_offset(fdt, nodeoffset, D, NULL);</span>
<span class="cm"> * will return nodeoffset itself.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This function is expensive, as it must scan the device tree</span>
<span class="cm"> * structure from the start to nodeoffset.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>

<span class="cm"> *	structure block offset of the node at node offset&#39;s ancestor</span>
<span class="cm"> *		of depth supernodedepth (&gt;=0), on success</span>
<span class="cm"> * 	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag</span>
<span class="cm">*	-FDT_ERR_NOTFOUND, supernodedepth was greater than the depth of nodeoffset</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_supernode_atdepth_offset</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">supernodedepth</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nodedepth</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_node_depth - find the depth of a given node</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: offset of the node whose parent to find</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_node_depth() finds the depth of a given node.  The root node</span>
<span class="cm"> * has depth 0, its immediate subnodes depth 1 and so forth.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This function is expensive, as it must scan the device tree</span>
<span class="cm"> * structure from the start to nodeoffset.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	depth of the node at nodeoffset (&gt;=0), on success</span>
<span class="cm"> * 	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_node_depth</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_parent_offset - find the parent of a given node</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: offset of the node whose parent to find</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_parent_offset() locates the parent node of a given node (that</span>
<span class="cm"> * is, it finds the offset of the node which contains the node at</span>
<span class="cm"> * nodeoffset as a subnode).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This function is expensive, as it must scan the device tree</span>
<span class="cm"> * structure from the start to nodeoffset, *twice*.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	structure block offset of the parent of the node at nodeoffset</span>
<span class="cm"> *		(&gt;=0), on success</span>
<span class="cm"> * 	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_parent_offset</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_node_offset_by_prop_value - find nodes with a given property value</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @startoffset: only find nodes after this offset</span>
<span class="cm"> * @propname: property name to check</span>
<span class="cm"> * @propval: property value to search for</span>
<span class="cm"> * @proplen: length of the value in propval</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_node_offset_by_prop_value() returns the offset of the first</span>
<span class="cm"> * node after startoffset, which has a property named propname whose</span>
<span class="cm"> * value is of length proplen and has value equal to propval; or if</span>
<span class="cm"> * startoffset is -1, the very first such node in the tree.</span>
<span class="cm"> *</span>
<span class="cm"> * To iterate through all nodes matching the criterion, the following</span>
<span class="cm"> * idiom can be used:</span>
<span class="cm"> *	offset = fdt_node_offset_by_prop_value(fdt, -1, propname,</span>
<span class="cm"> *					       propval, proplen);</span>
<span class="cm"> *	while (offset != -FDT_ERR_NOTFOUND) {</span>
<span class="cm"> *		// other code here</span>
<span class="cm"> *		offset = fdt_node_offset_by_prop_value(fdt, offset, propname,</span>
<span class="cm"> *						       propval, proplen);</span>
<span class="cm"> *	}</span>
<span class="cm"> *</span>
<span class="cm"> * Note the -1 in the first call to the function, if 0 is used here</span>
<span class="cm"> * instead, the function will never locate the root node, even if it</span>
<span class="cm"> * matches the criterion.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	structure block offset of the located node (&gt;= 0, &gt;startoffset),</span>
<span class="cm"> *		 on success</span>
<span class="cm"> *	-FDT_ERR_NOTFOUND, no node matching the criterion exists in the</span>
<span class="cm"> *		tree after startoffset</span>
<span class="cm"> * 	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_node_offset_by_prop_value</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">startoffset</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">propval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">proplen</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_node_offset_by_phandle - find the node with a given phandle</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @phandle: phandle value</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_node_offset_by_phandle() returns the offset of the node</span>
<span class="cm"> * which has the given phandle value.  If there is more than one node</span>
<span class="cm"> * in the tree with the given phandle (an invalid tree), results are</span>
<span class="cm"> * undefined.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	structure block offset of the located node (&gt;= 0), on success</span>
<span class="cm"> *	-FDT_ERR_NOTFOUND, no node with that phandle exists</span>
<span class="cm"> *	-FDT_ERR_BADPHANDLE, given phandle value was invalid (0 or -1)</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_node_offset_by_phandle</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">phandle</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_node_check_compatible: check a node&#39;s compatible property</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: offset of a tree node</span>
<span class="cm"> * @compatible: string to match against</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_node_check_compatible() returns 0 if the given node contains a</span>
<span class="cm"> * &#39;compatible&#39; property with the given string as one of its elements,</span>
<span class="cm"> * it returns non-zero otherwise, or on error.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	0, if the node has a &#39;compatible&#39; property listing the given string</span>
<span class="cm"> *	1, if the node has a &#39;compatible&#39; property, but it does not list</span>
<span class="cm"> *		the given string</span>
<span class="cm"> *	-FDT_ERR_NOTFOUND, if the given node has no &#39;compatible&#39; property</span>
<span class="cm"> * 	-FDT_ERR_BADOFFSET, if nodeoffset does not refer to a BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_node_check_compatible</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">compatible</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_node_offset_by_compatible - find nodes with a given &#39;compatible&#39; value</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @startoffset: only find nodes after this offset</span>
<span class="cm"> * @compatible: &#39;compatible&#39; string to match against</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_node_offset_by_compatible() returns the offset of the first</span>
<span class="cm"> * node after startoffset, which has a &#39;compatible&#39; property which</span>
<span class="cm"> * lists the given compatible string; or if startoffset is -1, the</span>
<span class="cm"> * very first such node in the tree.</span>
<span class="cm"> *</span>
<span class="cm"> * To iterate through all nodes matching the criterion, the following</span>
<span class="cm"> * idiom can be used:</span>
<span class="cm"> *	offset = fdt_node_offset_by_compatible(fdt, -1, compatible);</span>
<span class="cm"> *	while (offset != -FDT_ERR_NOTFOUND) {</span>
<span class="cm"> *		// other code here</span>
<span class="cm"> *		offset = fdt_node_offset_by_compatible(fdt, offset, compatible);</span>
<span class="cm"> *	}</span>
<span class="cm"> *</span>
<span class="cm"> * Note the -1 in the first call to the function, if 0 is used here</span>
<span class="cm"> * instead, the function will never locate the root node, even if it</span>
<span class="cm"> * matches the criterion.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	structure block offset of the located node (&gt;= 0, &gt;startoffset),</span>
<span class="cm"> *		 on success</span>
<span class="cm"> *	-FDT_ERR_NOTFOUND, no node matching the criterion exists in the</span>
<span class="cm"> *		tree after startoffset</span>
<span class="cm"> * 	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_node_offset_by_compatible</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">startoffset</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">compatible</span><span class="p">);</span>

<span class="cm">/**********************************************************************/</span>
<span class="cm">/* Write-in-place functions                                           */</span>
<span class="cm">/**********************************************************************/</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_setprop_inplace - change a property&#39;s value, but not its size</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: offset of the node whose property to change</span>
<span class="cm"> * @name: name of the property to change</span>
<span class="cm"> * @val: pointer to data to replace the property value with</span>
<span class="cm"> * @len: length of the property value</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_setprop_inplace() replaces the value of a given property with</span>
<span class="cm"> * the data in val, of length len.  This function cannot change the</span>
<span class="cm"> * size of a property, and so will only work if len is equal to the</span>
<span class="cm"> * current length of the property.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will alter only the bytes in the blob which contain</span>
<span class="cm"> * the given property value, and will not alter or move any other part</span>
<span class="cm"> * of the tree.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	0, on success</span>
<span class="cm"> *	-FDT_ERR_NOSPACE, if len is not equal to the property&#39;s current length</span>
<span class="cm"> *	-FDT_ERR_NOTFOUND, node does not have the named property</span>
<span class="cm"> *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE,</span>
<span class="cm"> *	-FDT_ERR_TRUNCATED, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_setprop_inplace</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_setprop_inplace_cell - change the value of a single-cell property</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: offset of the node whose property to change</span>
<span class="cm"> * @name: name of the property to change</span>
<span class="cm"> * @val: cell (32-bit integer) value to replace the property with</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_setprop_inplace_cell() replaces the value of a given property</span>
<span class="cm"> * with the 32-bit integer cell value in val, converting val to</span>
<span class="cm"> * big-endian if necessary.  This function cannot change the size of a</span>
<span class="cm"> * property, and so will only work if the property already exists and</span>
<span class="cm"> * has length 4.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will alter only the bytes in the blob which contain</span>
<span class="cm"> * the given property value, and will not alter or move any other part</span>
<span class="cm"> * of the tree.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	0, on success</span>
<span class="cm"> *	-FDT_ERR_NOSPACE, if the property&#39;s length is not equal to 4</span>
<span class="cm">  *	-FDT_ERR_NOTFOUND, node does not have the named property</span>
<span class="cm"> *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE,</span>
<span class="cm"> *	-FDT_ERR_TRUNCATED, standard meanings</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fdt_setprop_inplace_cell</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">,</span>
					   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">cpu_to_fdt32</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fdt_setprop_inplace</span><span class="p">(</span><span class="n">fdt</span><span class="p">,</span> <span class="n">nodeoffset</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_nop_property - replace a property with nop tags</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: offset of the node whose property to nop</span>
<span class="cm"> * @name: name of the property to nop</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_nop_property() will replace a given property&#39;s representation</span>
<span class="cm"> * in the blob with FDT_NOP tags, effectively removing it from the</span>
<span class="cm"> * tree.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will alter only the bytes in the blob which contain</span>
<span class="cm"> * the property, and will not alter or move any other part of the</span>
<span class="cm"> * tree.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	0, on success</span>
<span class="cm"> *	-FDT_ERR_NOTFOUND, node does not have the named property</span>
<span class="cm"> *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE,</span>
<span class="cm"> *	-FDT_ERR_TRUNCATED, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_nop_property</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_nop_node - replace a node (subtree) with nop tags</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: offset of the node to nop</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_nop_node() will replace a given node&#39;s representation in the</span>
<span class="cm"> * blob, including all its subnodes, if any, with FDT_NOP tags,</span>
<span class="cm"> * effectively removing it from the tree.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will alter only the bytes in the blob which contain</span>
<span class="cm"> * the node and its properties and subnodes, and will not alter or</span>
<span class="cm"> * move any other part of the tree.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	0, on success</span>
<span class="cm"> *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE,</span>
<span class="cm"> *	-FDT_ERR_TRUNCATED, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_nop_node</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">);</span>

<span class="cm">/**********************************************************************/</span>
<span class="cm">/* Sequential write functions                                         */</span>
<span class="cm">/**********************************************************************/</span>

<span class="kt">int</span> <span class="n">fdt_create</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fdt_add_reservemap_entry</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fdt_finish_reservemap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fdt_begin_node</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fdt_property</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fdt_property_cell</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">cpu_to_fdt32</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fdt_property</span><span class="p">(</span><span class="n">fdt</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#define fdt_property_string(fdt, name, str) \</span>
<span class="cp">	fdt_property(fdt, name, str, strlen(str)+1)</span>
<span class="kt">int</span> <span class="n">fdt_end_node</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fdt_finish</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">);</span>

<span class="cm">/**********************************************************************/</span>
<span class="cm">/* Read-write functions                                               */</span>
<span class="cm">/**********************************************************************/</span>

<span class="kt">int</span> <span class="n">fdt_open_into</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fdt_pack</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_add_mem_rsv - add one memory reserve map entry</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @address, @size: 64-bit values (native endian)</span>
<span class="cm"> *</span>
<span class="cm"> * Adds a reserve map entry to the given blob reserving a region at</span>
<span class="cm"> * address address of length size.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will insert data into the reserve map and will</span>
<span class="cm"> * therefore change the indexes of some entries in the table.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	0, on success</span>
<span class="cm"> *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to</span>
<span class="cm"> *		contain the new reservation entry</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE,</span>
<span class="cm"> *	-FDT_ERR_BADLAYOUT,</span>
<span class="cm"> *	-FDT_ERR_TRUNCATED, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_add_mem_rsv</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">address</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_del_mem_rsv - remove a memory reserve map entry</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @n: entry to remove</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_del_mem_rsv() removes the n-th memory reserve map entry from</span>
<span class="cm"> * the blob.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will delete data from the reservation table and will</span>
<span class="cm"> * therefore change the indexes of some entries in the table.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	0, on success</span>
<span class="cm"> *	-FDT_ERR_NOTFOUND, there is no entry of the given index (i.e. there</span>
<span class="cm"> *		are less than n+1 reserve map entries)</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE,</span>
<span class="cm"> *	-FDT_ERR_BADLAYOUT,</span>
<span class="cm"> *	-FDT_ERR_TRUNCATED, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_del_mem_rsv</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_set_name - change the name of a given node</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: structure block offset of a node</span>
<span class="cm"> * @name: name to give the node</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_set_name() replaces the name (including unit address, if any)</span>
<span class="cm"> * of the given node with the given string.  NOTE: this function can&#39;t</span>
<span class="cm"> * efficiently check if the new name is unique amongst the given</span>
<span class="cm"> * node&#39;s siblings; results are undefined if this function is invoked</span>
<span class="cm"> * with a name equal to one of the given node&#39;s siblings.</span>
<span class="cm"> *</span>
<span class="cm"> * This function may insert or delete data from the blob, and will</span>
<span class="cm"> * therefore change the offsets of some existing nodes.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	0, on success</span>
<span class="cm"> *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob</span>
<span class="cm"> *		to contain the new name</span>
<span class="cm"> *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_set_name</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_setprop - create or change a property</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: offset of the node whose property to change</span>
<span class="cm"> * @name: name of the property to change</span>
<span class="cm"> * @val: pointer to data to set the property value to</span>
<span class="cm"> * @len: length of the property value</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_setprop() sets the value of the named property in the given</span>
<span class="cm"> * node to the given value and length, creating the property if it</span>
<span class="cm"> * does not already exist.</span>
<span class="cm"> *</span>
<span class="cm"> * This function may insert or delete data from the blob, and will</span>
<span class="cm"> * therefore change the offsets of some existing nodes.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	0, on success</span>
<span class="cm"> *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to</span>
<span class="cm"> *		contain the new property value</span>
<span class="cm"> *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_BADLAYOUT,</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE,</span>
<span class="cm"> *	-FDT_ERR_BADLAYOUT,</span>
<span class="cm"> *	-FDT_ERR_TRUNCATED, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_setprop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_setprop_cell - set a property to a single cell value</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: offset of the node whose property to change</span>
<span class="cm"> * @name: name of the property to change</span>
<span class="cm"> * @val: 32-bit integer value for the property (native endian)</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_setprop_cell() sets the value of the named property in the</span>
<span class="cm"> * given node to the given cell value (converting to big-endian if</span>
<span class="cm"> * necessary), or creates a new property with that value if it does</span>
<span class="cm"> * not already exist.</span>
<span class="cm"> *</span>
<span class="cm"> * This function may insert or delete data from the blob, and will</span>
<span class="cm"> * therefore change the offsets of some existing nodes.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	0, on success</span>
<span class="cm"> *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to</span>
<span class="cm"> *		contain the new property value</span>
<span class="cm"> *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_BADLAYOUT,</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE,</span>
<span class="cm"> *	-FDT_ERR_BADLAYOUT,</span>
<span class="cm"> *	-FDT_ERR_TRUNCATED, standard meanings</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fdt_setprop_cell</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				   <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">cpu_to_fdt32</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fdt_setprop</span><span class="p">(</span><span class="n">fdt</span><span class="p">,</span> <span class="n">nodeoffset</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_setprop_string - set a property to a string value</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: offset of the node whose property to change</span>
<span class="cm"> * @name: name of the property to change</span>
<span class="cm"> * @str: string value for the property</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_setprop_string() sets the value of the named property in the</span>
<span class="cm"> * given node to the given string value (using the length of the</span>
<span class="cm"> * string to determine the new length of the property), or creates a</span>
<span class="cm"> * new property with that value if it does not already exist.</span>
<span class="cm"> *</span>
<span class="cm"> * This function may insert or delete data from the blob, and will</span>
<span class="cm"> * therefore change the offsets of some existing nodes.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	0, on success</span>
<span class="cm"> *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to</span>
<span class="cm"> *		contain the new property value</span>
<span class="cm"> *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_BADLAYOUT,</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE,</span>
<span class="cm"> *	-FDT_ERR_BADLAYOUT,</span>
<span class="cm"> *	-FDT_ERR_TRUNCATED, standard meanings</span>
<span class="cm"> */</span>
<span class="cp">#define fdt_setprop_string(fdt, nodeoffset, name, str) \</span>
<span class="cp">	fdt_setprop((fdt), (nodeoffset), (name), (str), strlen(str)+1)</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_delprop - delete a property</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: offset of the node whose property to nop</span>
<span class="cm"> * @name: name of the property to nop</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_del_property() will delete the given property.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will delete data from the blob, and will therefore</span>
<span class="cm"> * change the offsets of some existing nodes.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	0, on success</span>
<span class="cm"> *	-FDT_ERR_NOTFOUND, node does not have the named property</span>
<span class="cm"> *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_BADLAYOUT,</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE,</span>
<span class="cm"> *	-FDT_ERR_TRUNCATED, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_delprop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_add_subnode_namelen - creates a new node based on substring</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @parentoffset: structure block offset of a node</span>
<span class="cm"> * @name: name of the subnode to locate</span>
<span class="cm"> * @namelen: number of characters of name to consider</span>
<span class="cm"> *</span>
<span class="cm"> * Identical to fdt_add_subnode(), but use only the first namelen</span>
<span class="cm"> * characters of name as the name of the new node.  This is useful for</span>
<span class="cm"> * creating subnodes based on a portion of a larger string, such as a</span>
<span class="cm"> * full path.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_add_subnode_namelen</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parentoffset</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_add_subnode - creates a new node</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @parentoffset: structure block offset of a node</span>
<span class="cm"> * @name: name of the subnode to locate</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_add_subnode() creates a new node as a subnode of the node at</span>
<span class="cm"> * structure block offset parentoffset, with the given name (which</span>
<span class="cm"> * should include the unit address, if any).</span>
<span class="cm"> *</span>
<span class="cm"> * This function will insert data into the blob, and will therefore</span>
<span class="cm"> * change the offsets of some existing nodes.</span>

<span class="cm"> * returns:</span>
<span class="cm"> *	structure block offset of the created nodeequested subnode (&gt;=0), on success</span>
<span class="cm"> *	-FDT_ERR_NOTFOUND, if the requested subnode does not exist</span>
<span class="cm"> *	-FDT_ERR_BADOFFSET, if parentoffset did not point to an FDT_BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_EXISTS, if the node at parentoffset already has a subnode of</span>
<span class="cm"> *		the given name</span>
<span class="cm"> *	-FDT_ERR_NOSPACE, if there is insufficient free space in the</span>
<span class="cm"> *		blob to contain the new node</span>
<span class="cm"> *	-FDT_ERR_NOSPACE</span>
<span class="cm"> *	-FDT_ERR_BADLAYOUT</span>
<span class="cm"> *      -FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE,</span>
<span class="cm"> *	-FDT_ERR_TRUNCATED, standard meanings.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_add_subnode</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parentoffset</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fdt_del_node - delete a node (subtree)</span>
<span class="cm"> * @fdt: pointer to the device tree blob</span>
<span class="cm"> * @nodeoffset: offset of the node to nop</span>
<span class="cm"> *</span>
<span class="cm"> * fdt_del_node() will remove the given node, including all its</span>
<span class="cm"> * subnodes if any, from the blob.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will delete data from the blob, and will therefore</span>
<span class="cm"> * change the offsets of some existing nodes.</span>
<span class="cm"> *</span>
<span class="cm"> * returns:</span>
<span class="cm"> *	0, on success</span>
<span class="cm"> *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag</span>
<span class="cm"> *	-FDT_ERR_BADLAYOUT,</span>
<span class="cm"> *	-FDT_ERR_BADMAGIC,</span>
<span class="cm"> *	-FDT_ERR_BADVERSION,</span>
<span class="cm"> *	-FDT_ERR_BADSTATE,</span>
<span class="cm"> *	-FDT_ERR_BADSTRUCTURE,</span>
<span class="cm"> *	-FDT_ERR_TRUNCATED, standard meanings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fdt_del_node</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fdt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeoffset</span><span class="p">);</span>

<span class="cm">/**********************************************************************/</span>
<span class="cm">/* Debugging / informational functions                                */</span>
<span class="cm">/**********************************************************************/</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fdt_strerror</span><span class="p">(</span><span class="kt">int</span> <span class="n">errval</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _LIBFDT_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
