<!DOCTYPE html>
<html><head><title>joekychen/linux » scripts › mod › modpost.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>modpost.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Postprocess module symbol versions</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2003       Kai Germaschewski</span>
<span class="cm"> * Copyright 2002-2004  Rusty Russell, IBM Corporation</span>
<span class="cm"> * Copyright 2006-2008  Sam Ravnborg</span>
<span class="cm"> * Based in part on module-init-tools/depmod.c,file2alias</span>
<span class="cm"> *</span>
<span class="cm"> * This software may be used and distributed according to the terms</span>
<span class="cm"> * of the GNU General Public License, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> * Usage: modpost vmlinux module1.o module2.o ...</span>
<span class="cm"> */</span>

<span class="cp">#define _GNU_SOURCE</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;ctype.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &quot;modpost.h&quot;</span>
<span class="cp">#include &quot;../../include/generated/autoconf.h&quot;</span>
<span class="cp">#include &quot;../../include/linux/license.h&quot;</span>

<span class="cm">/* Some toolchains use a `_&#39; prefix for all user symbols. */</span>
<span class="cp">#ifdef CONFIG_SYMBOL_PREFIX</span>
<span class="cp">#define MODULE_SYMBOL_PREFIX CONFIG_SYMBOL_PREFIX</span>
<span class="cp">#else</span>
<span class="cp">#define MODULE_SYMBOL_PREFIX &quot;&quot;</span>
<span class="cp">#endif</span>


<span class="cm">/* Are we using CONFIG_MODVERSIONS? */</span>
<span class="kt">int</span> <span class="n">modversions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cm">/* Warn about undefined symbols? (do so if we have vmlinux) */</span>
<span class="kt">int</span> <span class="n">have_vmlinux</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cm">/* Is CONFIG_MODULE_SRCVERSION_ALL set? */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">all_versions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cm">/* If we are modposting external module set to 1 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">external_module</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cm">/* Warn about section mismatch in vmlinux if set to 1 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">vmlinux_section_warnings</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cm">/* Only warn about unresolved symbols */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">warn_unresolved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cm">/* How a symbol is exported */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sec_mismatch_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sec_mismatch_verbose</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">export</span> <span class="p">{</span>
	<span class="n">export_plain</span><span class="p">,</span>      <span class="n">export_unused</span><span class="p">,</span>     <span class="n">export_gpl</span><span class="p">,</span>
	<span class="n">export_unused_gpl</span><span class="p">,</span> <span class="n">export_gpl_future</span><span class="p">,</span> <span class="n">export_unknown</span>
<span class="p">};</span>

<span class="cp">#define PRINTF __attribute__ ((format (printf, 1, 2)))</span>

<span class="n">PRINTF</span> <span class="kt">void</span> <span class="nf">fatal</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">arglist</span><span class="p">;</span>

	<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;FATAL: &quot;</span><span class="p">);</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">arglist</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">vfprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">arglist</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">arglist</span><span class="p">);</span>

	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">PRINTF</span> <span class="kt">void</span> <span class="nf">warn</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">arglist</span><span class="p">;</span>

	<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;WARNING: &quot;</span><span class="p">);</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">arglist</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">vfprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">arglist</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">arglist</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">PRINTF</span> <span class="kt">void</span> <span class="nf">merror</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">arglist</span><span class="p">;</span>

	<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;ERROR: &quot;</span><span class="p">);</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">arglist</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">vfprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">arglist</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">arglist</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_vmlinux</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">myname</span><span class="p">;</span>

	<span class="n">myname</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">myname</span><span class="p">)</span>
		<span class="n">myname</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">myname</span> <span class="o">=</span> <span class="n">modname</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">myname</span><span class="p">,</span> <span class="s">&quot;vmlinux&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">myname</span><span class="p">,</span> <span class="s">&quot;vmlinux.o&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">do_nofail</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">expr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span>
		<span class="n">fatal</span><span class="p">(</span><span class="s">&quot;modpost: Memory allocation failure: %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* A list of all modules we processed */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">modules</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="nf">find_module</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">mod</span> <span class="o">=</span> <span class="n">modules</span><span class="p">;</span> <span class="n">mod</span><span class="p">;</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">modname</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mod</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="nf">new_module</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="n">mod</span> <span class="o">=</span> <span class="n">NOFAIL</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="p">)));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mod</span><span class="p">));</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">NOFAIL</span><span class="p">(</span><span class="n">strdup</span><span class="p">(</span><span class="n">modname</span><span class="p">));</span>

	<span class="cm">/* strip trailing .o */</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;.o&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">is_dot_o</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* add to list */</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_compatible</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">mod</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">modules</span><span class="p">;</span>
	<span class="n">modules</span> <span class="o">=</span> <span class="n">mod</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mod</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* A hash of all exported symbols,</span>
<span class="cm"> * struct symbol is also used for lists of unresolved symbols */</span>

<span class="cp">#define SYMBOL_HASH_SIZE 1024</span>

<span class="k">struct</span> <span class="n">symbol</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">crc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crc_valid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">weak</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vmlinux</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>    <span class="cm">/* 1 if symbol is defined in vmlinux */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kernel</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>     <span class="cm">/* 1 if symbol is from kernel</span>
<span class="cm">				    *  (only for external modules) **/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">preloaded</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>  <span class="cm">/* 1 if symbol from Module.symvers */</span>
	<span class="k">enum</span> <span class="n">export</span>  <span class="n">export</span><span class="p">;</span>       <span class="cm">/* Type of export */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">symbolhash</span><span class="p">[</span><span class="n">SYMBOL_HASH_SIZE</span><span class="p">];</span>

<span class="cm">/* This is based on the hash agorithm from gdbm, via tdb */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tdb_hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">value</span><span class="p">;</span>	<span class="cm">/* Used to compute the hash value.  */</span>
	<span class="kt">unsigned</span>   <span class="n">i</span><span class="p">;</span>	<span class="cm">/* Used to cycle through random values. */</span>

	<span class="cm">/* Set the initial value from the key size. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="mh">0x238F13AF</span> <span class="o">*</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">+</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">name</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">5</span> <span class="o">%</span> <span class="mi">24</span><span class="p">)));</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">1103515243</span> <span class="o">*</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">12345</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Allocate a new symbols for use in the hash of exported symbols or</span>
<span class="cm"> * the list of unresolved symbols per module</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="nf">alloc_symbol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">weak</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">NOFAIL</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">));</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">weak</span> <span class="o">=</span> <span class="n">weak</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* For the hash of exported symbols */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="nf">new_symbol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">export</span> <span class="n">export</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">tdb_hash</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">%</span> <span class="n">SYMBOL_HASH_SIZE</span><span class="p">;</span>
	<span class="n">new</span> <span class="o">=</span> <span class="n">symbolhash</span><span class="p">[</span><span class="n">hash</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">symbolhash</span><span class="p">[</span><span class="n">hash</span><span class="p">]);</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">module</span> <span class="o">=</span> <span class="n">module</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">export</span> <span class="o">=</span> <span class="n">export</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="nf">find_symbol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="cm">/* For our purposes, .foo matches foo.  PPC64 needs this. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span>
		<span class="n">name</span><span class="o">++</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">symbolhash</span><span class="p">[</span><span class="n">tdb_hash</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">%</span> <span class="n">SYMBOL_HASH_SIZE</span><span class="p">];</span> <span class="n">s</span><span class="p">;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">export</span> <span class="n">export</span><span class="p">;</span>
<span class="p">}</span> <span class="n">export_list</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">&quot;EXPORT_SYMBOL&quot;</span><span class="p">,</span>            <span class="p">.</span><span class="n">export</span> <span class="o">=</span> <span class="n">export_plain</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">&quot;EXPORT_UNUSED_SYMBOL&quot;</span><span class="p">,</span>     <span class="p">.</span><span class="n">export</span> <span class="o">=</span> <span class="n">export_unused</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">&quot;EXPORT_SYMBOL_GPL&quot;</span><span class="p">,</span>        <span class="p">.</span><span class="n">export</span> <span class="o">=</span> <span class="n">export_gpl</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">&quot;EXPORT_UNUSED_SYMBOL_GPL&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">export</span> <span class="o">=</span> <span class="n">export_unused_gpl</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">&quot;EXPORT_SYMBOL_GPL_FUTURE&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">export</span> <span class="o">=</span> <span class="n">export_gpl_future</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">&quot;(unknown)&quot;</span><span class="p">,</span>                <span class="p">.</span><span class="n">export</span> <span class="o">=</span> <span class="n">export_unknown</span> <span class="p">},</span>
<span class="p">};</span>


<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">export_str</span><span class="p">(</span><span class="k">enum</span> <span class="n">export</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">export_list</span><span class="p">[</span><span class="n">ex</span><span class="p">].</span><span class="n">str</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">export</span> <span class="nf">export_no</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">export_unknown</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">export_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">export</span> <span class="o">!=</span> <span class="n">export_unknown</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">export_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">str</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">export_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">export</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">export_unknown</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sec_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secindex</span><span class="p">);</span>

<span class="cp">#define strstarts(str, prefix) (strncmp(str, prefix, strlen(prefix)) == 0)</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">export</span> <span class="nf">export_from_secname</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">secname</span> <span class="o">=</span> <span class="n">sec_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sec</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strstarts</span><span class="p">(</span><span class="n">secname</span><span class="p">,</span> <span class="s">&quot;___ksymtab+&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">export_plain</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstarts</span><span class="p">(</span><span class="n">secname</span><span class="p">,</span> <span class="s">&quot;___ksymtab_unused+&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">export_unused</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstarts</span><span class="p">(</span><span class="n">secname</span><span class="p">,</span> <span class="s">&quot;___ksymtab_gpl+&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">export_gpl</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstarts</span><span class="p">(</span><span class="n">secname</span><span class="p">,</span> <span class="s">&quot;___ksymtab_unused_gpl+&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">export_unused_gpl</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstarts</span><span class="p">(</span><span class="n">secname</span><span class="p">,</span> <span class="s">&quot;___ksymtab_gpl_future+&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">export_gpl_future</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">export_unknown</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">export</span> <span class="nf">export_from_sec</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sec</span> <span class="o">==</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">export_sec</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">export_plain</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sec</span> <span class="o">==</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">export_unused_sec</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">export_unused</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sec</span> <span class="o">==</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">export_gpl_sec</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">export_gpl</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sec</span> <span class="o">==</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">export_unused_gpl_sec</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">export_unused_gpl</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sec</span> <span class="o">==</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">export_gpl_future_sec</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">export_gpl_future</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">export_unknown</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Add an exported symbol - it may have already been added without a</span>
<span class="cm"> * CRC, in this case just update the CRC</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="nf">sym_add_exported</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
				       <span class="k">enum</span> <span class="n">export</span> <span class="n">export</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">find_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">new_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">export</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">preloaded</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">warn</span><span class="p">(</span><span class="s">&quot;%s: &#39;%s&#39; exported twice. Previous export &quot;</span>
			     <span class="s">&quot;was in %s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
			     <span class="n">s</span><span class="o">-&gt;</span><span class="n">module</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">is_vmlinux</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">module</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">?</span><span class="s">&quot;&quot;</span><span class="o">:</span><span class="s">&quot;.ko&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* In case Modules.symvers was out of date */</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">module</span> <span class="o">=</span> <span class="n">mod</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">preloaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">vmlinux</span>   <span class="o">=</span> <span class="n">is_vmlinux</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">kernel</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">export</span>    <span class="o">=</span> <span class="n">export</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym_update_crc</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">crc</span><span class="p">,</span> <span class="k">enum</span> <span class="n">export</span> <span class="n">export</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">find_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">new_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">export</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">crc</span> <span class="o">=</span> <span class="n">crc</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">crc_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">grab_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">MAP_FAILED</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fstat</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

	<span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">st_size</span><span class="p">;</span>
	<span class="n">map</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">failed:</span>
	<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">map</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">  * Return a copy of the next line in a mmap&#39;ed file.</span>
<span class="cm">  * spaces in the beginning of the line is trimmed away.</span>
<span class="cm">  * Return a pointer to a static buffer.</span>
<span class="cm">  **/</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">get_next_line</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">skip</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">signed</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">signed</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">file</span> <span class="o">+</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">line</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="p">;</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skip</span> <span class="o">&amp;&amp;</span> <span class="n">isspace</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">len</span><span class="o">++</span><span class="p">;</span>
			<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">4095</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span> <span class="cm">/* Too long, stop */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* End of string */</span>
			<span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">line</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* End of buffer */</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">release_file</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">munmap</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_elf</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">Elf_Ehdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">;</span>
	<span class="n">Elf_Sym</span>  <span class="o">*</span><span class="n">sym</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">secstrings</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">symtab_idx</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">,</span> <span class="n">symtab_shndx_idx</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="n">grab_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* file too small, assume this is an empty .o file */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Is this a valid ELF file? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_MAG0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFMAG0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_MAG1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFMAG1</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_MAG2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFMAG2</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_MAG3</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFMAG3</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Not an ELF file - silently ignore it */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Fix endianness in ELF header */</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_type</span>      <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_type</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_machine</span>   <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_machine</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_version</span>   <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_version</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_entry</span>     <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_entry</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_phoff</span>     <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_phoff</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shoff</span>     <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shoff</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_flags</span>     <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_flags</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ehsize</span>    <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ehsize</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_phentsize</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_phentsize</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_phnum</span>     <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shentsize</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shentsize</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span>     <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shstrndx</span>  <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shstrndx</span><span class="p">);</span>
	<span class="n">sechdrs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shoff</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">;</span>

	<span class="cm">/* Check if file offset is correct */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shoff</span> <span class="o">&gt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fatal</span><span class="p">(</span><span class="s">&quot;section header offset=%lu in file &#39;%s&#39; is bigger than &quot;</span>
		      <span class="s">&quot;filesize=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shoff</span><span class="p">,</span>
		      <span class="n">filename</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span> <span class="o">==</span> <span class="n">SHN_UNDEF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * There are more than 64k sections,</span>
<span class="cm">		 * read count from .sh_size.</span>
<span class="cm">		 */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_sections</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sh_size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_sections</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shstrndx</span> <span class="o">==</span> <span class="n">SHN_XINDEX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">secindex_strings</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sh_link</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">secindex_strings</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_shstrndx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fix endianness in section headers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">num_sections</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_name</span>      <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_name</span><span class="p">);</span>
		<span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span>      <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span><span class="p">);</span>
		<span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_flags</span>     <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_flags</span><span class="p">);</span>
		<span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_addr</span>      <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">);</span>
		<span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_offset</span>    <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">);</span>
		<span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_size</span>      <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_size</span><span class="p">);</span>
		<span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_link</span>      <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_link</span><span class="p">);</span>
		<span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_info</span>      <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_info</span><span class="p">);</span>
		<span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_addralign</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_addralign</span><span class="p">);</span>
		<span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_entsize</span>   <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_entsize</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Find symbol table. */</span>
	<span class="n">secstrings</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">secindex_strings</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">num_sections</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">secname</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nobits</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_NOBITS</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nobits</span> <span class="o">&amp;&amp;</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_offset</span> <span class="o">&gt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fatal</span><span class="p">(</span><span class="s">&quot;%s is truncated. sechdrs[i].sh_offset=%lu &gt; &quot;</span>
			      <span class="s">&quot;sizeof(*hrd)=%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span>
			      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">,</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">));</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">secname</span> <span class="o">=</span> <span class="n">secstrings</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_name</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">secname</span><span class="p">,</span> <span class="s">&quot;.modinfo&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nobits</span><span class="p">)</span>
				<span class="n">fatal</span><span class="p">(</span><span class="s">&quot;%s has NOBITS .modinfo</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">modinfo</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">modinfo_len</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_size</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">secname</span><span class="p">,</span> <span class="s">&quot;__ksymtab&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">export_sec</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">secname</span><span class="p">,</span> <span class="s">&quot;__ksymtab_unused&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">export_unused_sec</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">secname</span><span class="p">,</span> <span class="s">&quot;__ksymtab_gpl&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">export_gpl_sec</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">secname</span><span class="p">,</span> <span class="s">&quot;__ksymtab_unused_gpl&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">export_unused_gpl_sec</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">secname</span><span class="p">,</span> <span class="s">&quot;__ksymtab_gpl_future&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">export_gpl_future_sec</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_SYMTAB</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sh_link_idx</span><span class="p">;</span>
			<span class="n">symtab_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">symtab_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span>
			    <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">symtab_stop</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span>
			    <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_offset</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_size</span><span class="p">;</span>
			<span class="n">sh_link_idx</span> <span class="o">=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_link</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">strtab</span>       <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span>
			    <span class="n">sechdrs</span><span class="p">[</span><span class="n">sh_link_idx</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* 32bit section no. table? (&quot;more than 64k sections&quot;) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_SYMTAB_SHNDX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">symtab_shndx_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">symtab_shndx_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span>
			    <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">symtab_shndx_stop</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span> <span class="o">+</span>
			    <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_offset</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_size</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">symtab_start</span><span class="p">)</span>
		<span class="n">fatal</span><span class="p">(</span><span class="s">&quot;%s has no symtab?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>

	<span class="cm">/* Fix endianness in symbols */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">sym</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">symtab_start</span><span class="p">;</span> <span class="n">sym</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">symtab_stop</span><span class="p">;</span> <span class="n">sym</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span><span class="p">);</span>
		<span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span>  <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">);</span>
		<span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">);</span>
		<span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_size</span>  <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">symtab_shndx_idx</span> <span class="o">!=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Elf32_Word</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">symtab_idx</span> <span class="o">!=</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">symtab_shndx_idx</span><span class="p">].</span><span class="n">sh_link</span><span class="p">)</span>
			<span class="n">fatal</span><span class="p">(</span><span class="s">&quot;%s: SYMTAB_SHNDX has bad sh_link: %u!=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">filename</span><span class="p">,</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">symtab_shndx_idx</span><span class="p">].</span><span class="n">sh_link</span><span class="p">,</span>
			      <span class="n">symtab_idx</span><span class="p">);</span>
		<span class="cm">/* Fix endianness */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">symtab_shndx_start</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">symtab_shndx_stop</span><span class="p">;</span>
		     <span class="n">p</span><span class="o">++</span><span class="p">)</span>
			<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">parse_elf_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">release_file</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ignore_undef_symbol</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* ignore __this_module, it will be resolved shortly */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="n">MODULE_SYMBOL_PREFIX</span> <span class="s">&quot;__this_module&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* ignore global offset table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="s">&quot;_GLOBAL_OFFSET_TABLE_&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_machine</span> <span class="o">==</span> <span class="n">EM_PPC</span><span class="p">)</span>
		<span class="cm">/* Special register function linked on all modules during final link of .ko */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="s">&quot;_restgpr_&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;_restgpr_&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">strncmp</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="s">&quot;_savegpr_&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;_savegpr_&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">strncmp</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="s">&quot;_rest32gpr_&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;_rest32gpr_&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">strncmp</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="s">&quot;_save32gpr_&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;_save32gpr_&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_machine</span> <span class="o">==</span> <span class="n">EM_PPC64</span><span class="p">)</span>
		<span class="cm">/* Special register function linked on all modules during final link of .ko */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="s">&quot;_restgpr0_&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;_restgpr0_&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">strncmp</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="s">&quot;_savegpr0_&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;_savegpr0_&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Do not ignore this symbol */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define CRC_PFX     MODULE_SYMBOL_PREFIX &quot;__crc_&quot;</span>
<span class="cp">#define KSYMTAB_PFX MODULE_SYMBOL_PREFIX &quot;__ksymtab_&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_modversions</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			       <span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">crc</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">export</span> <span class="n">export</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">is_vmlinux</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">||</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">is_dot_o</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">strncmp</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="s">&quot;__ksymtab&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">export</span> <span class="o">=</span> <span class="n">export_from_secname</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">get_secindex</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">sym</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">export</span> <span class="o">=</span> <span class="n">export_from_sec</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">get_secindex</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">sym</span><span class="p">));</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SHN_COMMON</span>:
		<span class="n">warn</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> [%s] is COMMON symbol</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">symname</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SHN_ABS</span>:
		<span class="cm">/* CRC&#39;d symbol */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="n">CRC_PFX</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">CRC_PFX</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">crc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">;</span>
			<span class="n">sym_update_crc</span><span class="p">(</span><span class="n">symname</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">CRC_PFX</span><span class="p">),</span> <span class="n">mod</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span>
					<span class="n">export</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SHN_UNDEF</span>:
		<span class="cm">/* undefined symbol */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ELF_ST_BIND</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_info</span><span class="p">)</span> <span class="o">!=</span> <span class="n">STB_GLOBAL</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ELF_ST_BIND</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_info</span><span class="p">)</span> <span class="o">!=</span> <span class="n">STB_WEAK</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ignore_undef_symbol</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">symname</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cm">/* cope with newer glibc (2.3.4 or higher) STT_ definition in elf.h */</span>
<span class="cp">#if defined(STT_REGISTER) || defined(STT_SPARC_REGISTER)</span>
<span class="cm">/* add compatibility with older glibc */</span>
<span class="cp">#ifndef STT_SPARC_REGISTER</span>
<span class="cp">#define STT_SPARC_REGISTER STT_REGISTER</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_machine</span> <span class="o">==</span> <span class="n">EM_SPARC</span> <span class="o">||</span>
		    <span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_machine</span> <span class="o">==</span> <span class="n">EM_SPARCV9</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Ignore register directives. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ELF_ST_TYPE</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_info</span><span class="p">)</span> <span class="o">==</span> <span class="n">STT_SPARC_REGISTER</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">symname</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">munged</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">symname</span><span class="p">);</span>
				<span class="n">munged</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;_&#39;</span><span class="p">;</span>
				<span class="n">munged</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">munged</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="n">symname</span> <span class="o">=</span> <span class="n">munged</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#endif</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="n">MODULE_SYMBOL_PREFIX</span><span class="p">,</span>
			   <span class="n">strlen</span><span class="p">(</span><span class="n">MODULE_SYMBOL_PREFIX</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">unres</span> <span class="o">=</span>
			  <span class="n">alloc_symbol</span><span class="p">(</span><span class="n">symname</span> <span class="o">+</span>
			               <span class="n">strlen</span><span class="p">(</span><span class="n">MODULE_SYMBOL_PREFIX</span><span class="p">),</span>
			               <span class="n">ELF_ST_BIND</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_info</span><span class="p">)</span> <span class="o">==</span> <span class="n">STB_WEAK</span><span class="p">,</span>
			               <span class="n">mod</span><span class="o">-&gt;</span><span class="n">unres</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* All exported symbols */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="n">KSYMTAB_PFX</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">KSYMTAB_PFX</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sym_add_exported</span><span class="p">(</span><span class="n">symname</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">KSYMTAB_PFX</span><span class="p">),</span> <span class="n">mod</span><span class="p">,</span>
					<span class="n">export</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="n">MODULE_SYMBOL_PREFIX</span> <span class="s">&quot;init_module&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">has_init</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="n">MODULE_SYMBOL_PREFIX</span> <span class="s">&quot;cleanup_module&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">has_cleanup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Parse tag=value strings from .modinfo section</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">next_string</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">secsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Skip non-zero chars */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">string</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">secsize</span><span class="p">)</span><span class="o">--</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Skip any zero padding. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">string</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">secsize</span><span class="p">)</span><span class="o">--</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_next_modinfo</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">modinfo</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">modinfo_len</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tag</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">taglen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">tag</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">modinfo_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">info</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">modinfo</span><span class="p">;</span>
		<span class="n">modinfo</span> <span class="o">=</span> <span class="n">next_string</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">modinfo</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">next_string</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">taglen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">[</span><span class="n">taglen</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;=&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">p</span> <span class="o">+</span> <span class="n">taglen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_modinfo</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">modinfo</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">modinfo_len</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tag</span><span class="p">)</span>

<span class="p">{</span>
	<span class="k">return</span> <span class="n">get_next_modinfo</span><span class="p">(</span><span class="n">modinfo</span><span class="p">,</span> <span class="n">modinfo_len</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Test if string s ends in string sub</span>
<span class="cm"> * return 0 if match</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">strrcmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sub</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">slen</span><span class="p">,</span> <span class="n">sublen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span> <span class="o">||</span> <span class="o">!</span><span class="n">sub</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">slen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">sublen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sub</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">slen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">sublen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sublen</span> <span class="o">&gt;</span> <span class="n">slen</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">slen</span> <span class="o">-</span> <span class="n">sublen</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">sublen</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">sym_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="s">&quot;(unknown)&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">sec_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secindex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span> <span class="o">=</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">+</span>
		<span class="n">elf</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">secindex_strings</span><span class="p">].</span><span class="n">sh_offset</span> <span class="o">+</span>
		<span class="n">sechdrs</span><span class="p">[</span><span class="n">secindex</span><span class="p">].</span><span class="n">sh_name</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">sech_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">+</span>
		<span class="n">elf</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">secindex_strings</span><span class="p">].</span><span class="n">sh_offset</span> <span class="o">+</span>
		<span class="n">sechdr</span><span class="o">-&gt;</span><span class="n">sh_name</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* if sym is empty or point to a string</span>
<span class="cm"> * like &quot;.[0-9]+&quot; then return 1.</span>
<span class="cm"> * This is the optional prefix added by ld to some sections</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">number_prefix</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">sym</span><span class="o">++</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">sym</span> <span class="o">!=</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">sym</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="sc">&#39;0&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">sym</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The pattern is an array of simple patterns.</span>
<span class="cm"> * &quot;foo&quot; will match an exact string equal to &quot;foo&quot;</span>
<span class="cm"> * &quot;*foo&quot; will match a string that ends with &quot;foo&quot;</span>
<span class="cm"> * &quot;foo*&quot; will match a string that begins with &quot;foo&quot;</span>
<span class="cm"> * &quot;foo$&quot; will match a string equal to &quot;foo&quot; or &quot;foo.1&quot;</span>
<span class="cm"> *   where the &#39;1&#39; can be any number including several digits.</span>
<span class="cm"> *   The $ syntax is for sections where ld append a dot number</span>
<span class="cm"> *   to make section name unique.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">match</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sym</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">pat</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">pat</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">pat</span><span class="o">++</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">endp</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* &quot;*foo&quot; */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">strrcmp</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* &quot;foo*&quot; */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">endp</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* &quot;foo$&quot; */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">endp</span> <span class="o">==</span> <span class="sc">&#39;$&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">number_prefix</span><span class="p">(</span><span class="n">sym</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
					<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* no wildcards */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* no match */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* sections that we do not want to do full section mismatch check on */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">section_white_list</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="s">&quot;.comment*&quot;</span><span class="p">,</span>
	<span class="s">&quot;.debug*&quot;</span><span class="p">,</span>
	<span class="s">&quot;.zdebug*&quot;</span><span class="p">,</span>		<span class="cm">/* Compressed debug sections. */</span>
	<span class="s">&quot;.GCC-command-line&quot;</span><span class="p">,</span>	<span class="cm">/* mn10300 */</span>
	<span class="s">&quot;.mdebug*&quot;</span><span class="p">,</span>        <span class="cm">/* alpha, score, mips etc. */</span>
	<span class="s">&quot;.pdr&quot;</span><span class="p">,</span>            <span class="cm">/* alpha, score, mips etc. */</span>
	<span class="s">&quot;.stab*&quot;</span><span class="p">,</span>
	<span class="s">&quot;.note*&quot;</span><span class="p">,</span>
	<span class="s">&quot;.got*&quot;</span><span class="p">,</span>
	<span class="s">&quot;.toc*&quot;</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This is used to find sections missing the SHF_ALLOC flag.</span>
<span class="cm"> * The cause of this is often a section specified in assembler</span>
<span class="cm"> * without &quot;ax&quot; / &quot;aw&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_section</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span>
                          <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sec</span> <span class="o">=</span> <span class="n">sech_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sechdr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sechdr</span><span class="o">-&gt;</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_PROGBITS</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">sechdr</span><span class="o">-&gt;</span><span class="n">sh_flags</span> <span class="o">&amp;</span> <span class="n">SHF_ALLOC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">match</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">section_white_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">warn</span><span class="p">(</span><span class="s">&quot;%s (%s): unexpected non-allocatable section.</span><span class="se">\n</span><span class="s">&quot;</span>
		     <span class="s">&quot;Did you forget to use </span><span class="se">\&quot;</span><span class="s">ax</span><span class="se">\&quot;</span><span class="s">/</span><span class="se">\&quot;</span><span class="s">aw</span><span class="se">\&quot;</span><span class="s"> in a .S file?</span><span class="se">\n</span><span class="s">&quot;</span>
		     <span class="s">&quot;Note that for example &lt;linux/init.h&gt; contains</span><span class="se">\n</span><span class="s">&quot;</span>
		     <span class="s">&quot;section definitions for use in .S files.</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">modname</span><span class="p">,</span> <span class="n">sec</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>



<span class="cp">#define ALL_INIT_DATA_SECTIONS \</span>
<span class="cp">	&quot;.init.setup$&quot;, &quot;.init.rodata$&quot;, \</span>
<span class="cp">	&quot;.devinit.rodata$&quot;, &quot;.cpuinit.rodata$&quot;, &quot;.meminit.rodata$&quot;, \</span>
<span class="cp">	&quot;.init.data$&quot;, &quot;.devinit.data$&quot;, &quot;.cpuinit.data$&quot;, &quot;.meminit.data$&quot;</span>
<span class="cp">#define ALL_EXIT_DATA_SECTIONS \</span>
<span class="cp">	&quot;.exit.data$&quot;, &quot;.devexit.data$&quot;, &quot;.cpuexit.data$&quot;, &quot;.memexit.data$&quot;</span>

<span class="cp">#define ALL_INIT_TEXT_SECTIONS \</span>
<span class="cp">	&quot;.init.text$&quot;, &quot;.devinit.text$&quot;, &quot;.cpuinit.text$&quot;, &quot;.meminit.text$&quot;</span>
<span class="cp">#define ALL_EXIT_TEXT_SECTIONS \</span>
<span class="cp">	&quot;.exit.text$&quot;, &quot;.devexit.text$&quot;, &quot;.cpuexit.text$&quot;, &quot;.memexit.text$&quot;</span>

<span class="cp">#define ALL_XXXINIT_SECTIONS DEV_INIT_SECTIONS, CPU_INIT_SECTIONS, \</span>
<span class="cp">	MEM_INIT_SECTIONS</span>
<span class="cp">#define ALL_XXXEXIT_SECTIONS DEV_EXIT_SECTIONS, CPU_EXIT_SECTIONS, \</span>
<span class="cp">	MEM_EXIT_SECTIONS</span>

<span class="cp">#define ALL_INIT_SECTIONS INIT_SECTIONS, ALL_XXXINIT_SECTIONS</span>
<span class="cp">#define ALL_EXIT_SECTIONS EXIT_SECTIONS, ALL_XXXEXIT_SECTIONS</span>

<span class="cp">#define DATA_SECTIONS &quot;.data$&quot;, &quot;.data.rel$&quot;</span>
<span class="cp">#define TEXT_SECTIONS &quot;.text$&quot;</span>

<span class="cp">#define INIT_SECTIONS      &quot;.init.*&quot;</span>
<span class="cp">#define DEV_INIT_SECTIONS  &quot;.devinit.*&quot;</span>
<span class="cp">#define CPU_INIT_SECTIONS  &quot;.cpuinit.*&quot;</span>
<span class="cp">#define MEM_INIT_SECTIONS  &quot;.meminit.*&quot;</span>

<span class="cp">#define EXIT_SECTIONS      &quot;.exit.*&quot;</span>
<span class="cp">#define DEV_EXIT_SECTIONS  &quot;.devexit.*&quot;</span>
<span class="cp">#define CPU_EXIT_SECTIONS  &quot;.cpuexit.*&quot;</span>
<span class="cp">#define MEM_EXIT_SECTIONS  &quot;.memexit.*&quot;</span>

<span class="cm">/* init data sections */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">init_data_sections</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ALL_INIT_DATA_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>

<span class="cm">/* all init sections */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">init_sections</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ALL_INIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>

<span class="cm">/* All init and exit sections (code + data) */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">init_exit_sections</span><span class="p">[]</span> <span class="o">=</span>
	<span class="p">{</span><span class="n">ALL_INIT_SECTIONS</span><span class="p">,</span> <span class="n">ALL_EXIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>

<span class="cm">/* data section */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data_sections</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DATA_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>


<span class="cm">/* symbols in .data that may refer to init/exit sections */</span>
<span class="cp">#define DEFAULT_SYMBOL_WHITE_LIST					\</span>
<span class="cp">	&quot;*driver&quot;,							\</span>
<span class="cp">	&quot;*_template&quot;, </span><span class="cm">/* scsi uses *_template a lot */</span><span class="cp">			\</span>
<span class="cp">	&quot;*_timer&quot;,    </span><span class="cm">/* arm uses ops structures named _timer a lot */</span><span class="cp">	\</span>
<span class="cp">	&quot;*_sht&quot;,      </span><span class="cm">/* scsi also used *_sht to some extent */</span><span class="cp">		\</span>
<span class="cp">	&quot;*_ops&quot;,							\</span>
<span class="cp">	&quot;*_probe&quot;,							\</span>
<span class="cp">	&quot;*_probe_one&quot;,							\</span>
<span class="cp">	&quot;*_console&quot;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">head_sections</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;.head.text*&quot;</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">linker_symbols</span><span class="p">[]</span> <span class="o">=</span>
	<span class="p">{</span> <span class="s">&quot;__init_begin&quot;</span><span class="p">,</span> <span class="s">&quot;_sinittext&quot;</span><span class="p">,</span> <span class="s">&quot;_einittext&quot;</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>

<span class="k">enum</span> <span class="n">mismatch</span> <span class="p">{</span>
	<span class="n">TEXT_TO_ANY_INIT</span><span class="p">,</span>
	<span class="n">DATA_TO_ANY_INIT</span><span class="p">,</span>
	<span class="n">TEXT_TO_ANY_EXIT</span><span class="p">,</span>
	<span class="n">DATA_TO_ANY_EXIT</span><span class="p">,</span>
	<span class="n">XXXINIT_TO_SOME_INIT</span><span class="p">,</span>
	<span class="n">XXXEXIT_TO_SOME_EXIT</span><span class="p">,</span>
	<span class="n">ANY_INIT_TO_ANY_EXIT</span><span class="p">,</span>
	<span class="n">ANY_EXIT_TO_ANY_INIT</span><span class="p">,</span>
	<span class="n">EXPORT_TO_INIT_EXIT</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sectioncheck</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fromsec</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tosec</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="k">enum</span> <span class="n">mismatch</span> <span class="n">mismatch</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symbol_white_list</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">sectioncheck</span> <span class="n">sectioncheck</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/* Do not reference init/exit code/data from</span>
<span class="cm"> * normal code and data</span>
<span class="cm"> */</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">fromsec</span> <span class="o">=</span> <span class="p">{</span> <span class="n">TEXT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">tosec</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">ALL_INIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="n">TEXT_TO_ANY_INIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symbol_white_list</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DEFAULT_SYMBOL_WHITE_LIST</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">},</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">fromsec</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DATA_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">tosec</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">ALL_XXXINIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="n">DATA_TO_ANY_INIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symbol_white_list</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DEFAULT_SYMBOL_WHITE_LIST</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">},</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">fromsec</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DATA_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">tosec</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">INIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="n">DATA_TO_ANY_INIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symbol_white_list</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;*_template&quot;</span><span class="p">,</span> <span class="s">&quot;*_timer&quot;</span><span class="p">,</span> <span class="s">&quot;*_sht&quot;</span><span class="p">,</span> <span class="s">&quot;*_ops&quot;</span><span class="p">,</span>
		<span class="s">&quot;*_probe&quot;</span><span class="p">,</span> <span class="s">&quot;*_probe_one&quot;</span><span class="p">,</span> <span class="s">&quot;*_console&quot;</span><span class="p">,</span> <span class="nb">NULL</span>
	<span class="p">},</span>
<span class="p">},</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">fromsec</span> <span class="o">=</span> <span class="p">{</span> <span class="n">TEXT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">tosec</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">ALL_EXIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="n">TEXT_TO_ANY_EXIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symbol_white_list</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DEFAULT_SYMBOL_WHITE_LIST</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">},</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">fromsec</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DATA_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">tosec</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">ALL_EXIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="n">DATA_TO_ANY_EXIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symbol_white_list</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DEFAULT_SYMBOL_WHITE_LIST</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">},</span>
<span class="cm">/* Do not reference init code/data from devinit/cpuinit/meminit code/data */</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">fromsec</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ALL_XXXINIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">tosec</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">INIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="n">XXXINIT_TO_SOME_INIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symbol_white_list</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DEFAULT_SYMBOL_WHITE_LIST</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">},</span>
<span class="cm">/* Do not reference cpuinit code/data from meminit code/data */</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">fromsec</span> <span class="o">=</span> <span class="p">{</span> <span class="n">MEM_INIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">tosec</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">CPU_INIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="n">XXXINIT_TO_SOME_INIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symbol_white_list</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DEFAULT_SYMBOL_WHITE_LIST</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">},</span>
<span class="cm">/* Do not reference meminit code/data from cpuinit code/data */</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">fromsec</span> <span class="o">=</span> <span class="p">{</span> <span class="n">CPU_INIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">tosec</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">MEM_INIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="n">XXXINIT_TO_SOME_INIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symbol_white_list</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DEFAULT_SYMBOL_WHITE_LIST</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">},</span>
<span class="cm">/* Do not reference exit code/data from devexit/cpuexit/memexit code/data */</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">fromsec</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ALL_XXXEXIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">tosec</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">EXIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="n">XXXEXIT_TO_SOME_EXIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symbol_white_list</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DEFAULT_SYMBOL_WHITE_LIST</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">},</span>
<span class="cm">/* Do not reference cpuexit code/data from memexit code/data */</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">fromsec</span> <span class="o">=</span> <span class="p">{</span> <span class="n">MEM_EXIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">tosec</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">CPU_EXIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="n">XXXEXIT_TO_SOME_EXIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symbol_white_list</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DEFAULT_SYMBOL_WHITE_LIST</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">},</span>
<span class="cm">/* Do not reference memexit code/data from cpuexit code/data */</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">fromsec</span> <span class="o">=</span> <span class="p">{</span> <span class="n">CPU_EXIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">tosec</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">MEM_EXIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="n">XXXEXIT_TO_SOME_EXIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symbol_white_list</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DEFAULT_SYMBOL_WHITE_LIST</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">},</span>
<span class="cm">/* Do not use exit code/data from init code */</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">fromsec</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ALL_INIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">tosec</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">ALL_EXIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="n">ANY_INIT_TO_ANY_EXIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symbol_white_list</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DEFAULT_SYMBOL_WHITE_LIST</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">},</span>
<span class="cm">/* Do not use init code/data from exit code */</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">fromsec</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ALL_EXIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">tosec</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">ALL_INIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="n">ANY_EXIT_TO_ANY_INIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symbol_white_list</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DEFAULT_SYMBOL_WHITE_LIST</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">},</span>
<span class="cm">/* Do not export init/exit functions or data */</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">fromsec</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;__ksymtab*&quot;</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">tosec</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">INIT_SECTIONS</span><span class="p">,</span> <span class="n">EXIT_SECTIONS</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="n">EXPORT_TO_INIT_EXIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symbol_white_list</span> <span class="o">=</span> <span class="p">{</span> <span class="n">DEFAULT_SYMBOL_WHITE_LIST</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">},</span>
<span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sectioncheck</span> <span class="o">*</span><span class="nf">section_mismatch</span><span class="p">(</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fromsec</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tosec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">elems</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sectioncheck</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sectioncheck</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sectioncheck</span> <span class="o">*</span><span class="n">check</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sectioncheck</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">elems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">fromsec</span><span class="p">,</span> <span class="n">check</span><span class="o">-&gt;</span><span class="n">fromsec</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">match</span><span class="p">(</span><span class="n">tosec</span><span class="p">,</span> <span class="n">check</span><span class="o">-&gt;</span><span class="n">tosec</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">check</span><span class="p">;</span>
		<span class="n">check</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Whitelist to allow certain references to pass with no warning.</span>
<span class="cm"> *</span>
<span class="cm"> * Pattern 1:</span>
<span class="cm"> *   If a module parameter is declared __initdata and permissions=0</span>
<span class="cm"> *   then this is legal despite the warning generated.</span>
<span class="cm"> *   We cannot see value of permissions here, so just ignore</span>
<span class="cm"> *   this pattern.</span>
<span class="cm"> *   The pattern is identified by:</span>
<span class="cm"> *   tosec   = .init.data</span>
<span class="cm"> *   fromsec = .data*</span>
<span class="cm"> *   atsym   =__param*</span>
<span class="cm"> *</span>
<span class="cm"> * Pattern 1a:</span>
<span class="cm"> *   module_param_call() ops can refer to __init set function if permissions=0</span>
<span class="cm"> *   The pattern is identified by:</span>
<span class="cm"> *   tosec   = .init.text</span>
<span class="cm"> *   fromsec = .data*</span>
<span class="cm"> *   atsym   = __param_ops_*</span>
<span class="cm"> *</span>
<span class="cm"> * Pattern 2:</span>
<span class="cm"> *   Many drivers utilise a *driver container with references to</span>
<span class="cm"> *   add, remove, probe functions etc.</span>
<span class="cm"> *   These functions may often be marked __devinit and we do not want to</span>
<span class="cm"> *   warn here.</span>
<span class="cm"> *   the pattern is identified by:</span>
<span class="cm"> *   tosec   = init or exit section</span>
<span class="cm"> *   fromsec = data section</span>
<span class="cm"> *   atsym = *driver, *_template, *_sht, *_ops, *_probe,</span>
<span class="cm"> *           *probe_one, *_console, *_timer</span>
<span class="cm"> *</span>
<span class="cm"> * Pattern 3:</span>
<span class="cm"> *   Whitelist all references from .head.text to any init section</span>
<span class="cm"> *</span>
<span class="cm"> * Pattern 4:</span>
<span class="cm"> *   Some symbols belong to init section but still it is ok to reference</span>
<span class="cm"> *   these from non-init sections as these symbols don&#39;t have any memory</span>
<span class="cm"> *   allocated for them and symbol address and value are same. So even</span>
<span class="cm"> *   if init section is freed, its ok to reference those symbols.</span>
<span class="cm"> *   For ex. symbols marking the init section boundaries.</span>
<span class="cm"> *   This pattern is identified by</span>
<span class="cm"> *   refsymname = __init_begin, _sinittext, _einittext</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">secref_whitelist</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sectioncheck</span> <span class="o">*</span><span class="n">mismatch</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fromsec</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fromsym</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tosec</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tosym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Check for pattern 1 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">tosec</span><span class="p">,</span> <span class="n">init_data_sections</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">match</span><span class="p">(</span><span class="n">fromsec</span><span class="p">,</span> <span class="n">data_sections</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">fromsym</span><span class="p">,</span> <span class="s">&quot;__param&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;__param&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Check for pattern 1a */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">tosec</span><span class="p">,</span> <span class="s">&quot;.init.text&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">match</span><span class="p">(</span><span class="n">fromsec</span><span class="p">,</span> <span class="n">data_sections</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">fromsym</span><span class="p">,</span> <span class="s">&quot;__param_ops_&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;__param_ops_&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Check for pattern 2 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">tosec</span><span class="p">,</span> <span class="n">init_exit_sections</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">match</span><span class="p">(</span><span class="n">fromsec</span><span class="p">,</span> <span class="n">data_sections</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">match</span><span class="p">(</span><span class="n">fromsym</span><span class="p">,</span> <span class="n">mismatch</span><span class="o">-&gt;</span><span class="n">symbol_white_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Check for pattern 3 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">fromsec</span><span class="p">,</span> <span class="n">head_sections</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">match</span><span class="p">(</span><span class="n">tosec</span><span class="p">,</span> <span class="n">init_sections</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Check for pattern 4 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">tosym</span><span class="p">,</span> <span class="n">linker_symbols</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Find symbol based on relocation record info.</span>
<span class="cm"> * In some cases the symbol supplied is a valid symbol so</span>
<span class="cm"> * return refsym. If st_name != 0 we assume this is a valid symbol.</span>
<span class="cm"> * In other cases the symbol needs to be looked up in the symbol table</span>
<span class="cm"> * based on section and address.</span>
<span class="cm"> *  **/</span>
<span class="k">static</span> <span class="n">Elf_Sym</span> <span class="o">*</span><span class="nf">find_elf_symbol</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="n">Elf64_Sword</span> <span class="n">addr</span><span class="p">,</span>
				<span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">relsym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>
	<span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">near</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">Elf64_Sword</span> <span class="n">distance</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
	<span class="n">Elf64_Sword</span> <span class="n">d</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">relsym_secindex</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">relsym</span><span class="o">-&gt;</span><span class="n">st_name</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">relsym</span><span class="p">;</span>

	<span class="n">relsym_secindex</span> <span class="o">=</span> <span class="n">get_secindex</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">relsym</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">sym</span> <span class="o">=</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">symtab_start</span><span class="p">;</span> <span class="n">sym</span> <span class="o">&lt;</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">symtab_stop</span><span class="p">;</span> <span class="n">sym</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_secindex</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span> <span class="o">!=</span> <span class="n">relsym_secindex</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ELF_ST_TYPE</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_info</span><span class="p">)</span> <span class="o">==</span> <span class="n">STT_SECTION</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">sym</span><span class="p">;</span>
		<span class="cm">/* Find a symbol nearby - addr are maybe negative */</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span> <span class="o">-</span> <span class="n">addr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">d</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">-</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">distance</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
			<span class="n">near</span> <span class="o">=</span> <span class="n">sym</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* We need a close match */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">near</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_arm_mapping_symbol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;$&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">strchr</span><span class="p">(</span><span class="s">&quot;atd&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	       <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">||</span> <span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If there&#39;s no name there, ignore it; likewise, ignore it if it&#39;s</span>
<span class="cm"> * one of the magic symbols emitted used by current ARM tools.</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise if find_symbols_between() returns those symbols, they&#39;ll</span>
<span class="cm"> * fail the whitelist tests and cause lots of false alarms ... fixable</span>
<span class="cm"> * only by merging __exit and __init sections into __text, bloating</span>
<span class="cm"> * the kernel (which is especially evil on embedded platforms).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_valid_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span> <span class="o">||</span> <span class="o">!</span><span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">is_arm_mapping_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find symbols before or equal addr and after addr - in the section sec.</span>
<span class="cm"> * If we find two symbols with equal offset prefer one with a valid name.</span>
<span class="cm"> * The ELF format may have a better way to detect what type of symbol</span>
<span class="cm"> * it is, but this works for now.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">Elf_Sym</span> <span class="o">*</span><span class="nf">find_elf_symbol2</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="n">Elf_Addr</span> <span class="n">addr</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>
	<span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">near</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">Elf_Addr</span> <span class="n">distance</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">sym</span> <span class="o">=</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">symtab_start</span><span class="p">;</span> <span class="n">sym</span> <span class="o">&lt;</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">symtab_stop</span><span class="p">;</span> <span class="n">sym</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symsec</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_shndx_special</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">symsec</span> <span class="o">=</span> <span class="n">sec_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">get_secindex</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sym</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">symsec</span><span class="p">,</span> <span class="n">sec</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sym</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span> <span class="o">&lt;=</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">-</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">distance</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">-</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">;</span>
				<span class="n">near</span> <span class="o">=</span> <span class="n">sym</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">-</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">)</span> <span class="o">==</span> <span class="n">distance</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">near</span> <span class="o">=</span> <span class="n">sym</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">near</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert a section name to the function/data attribute</span>
<span class="cm"> * .init.text =&gt; __init</span>
<span class="cm"> * .cpuinit.data =&gt; __cpudata</span>
<span class="cm"> * .memexitconst =&gt; __memconst</span>
<span class="cm"> * etc.</span>
<span class="cm"> *</span>
<span class="cm"> * The memory of returned value has been allocated on a heap. The user of this</span>
<span class="cm"> * method should free it after usage.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">sec2annotation</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">init_exit_sections</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;_&#39;</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;_&#39;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span>
			<span class="n">s</span><span class="o">++</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">s</span> <span class="o">!=</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span>
			<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="o">++</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span>
			<span class="n">s</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;rodata&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">strcat</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;const &quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;data&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">strcat</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;data &quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">strcat</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">strdup</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_function</span><span class="p">(</span><span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ELF_ST_TYPE</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_info</span><span class="p">)</span> <span class="o">==</span> <span class="n">STT_FUNC</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_section_list</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">list</span><span class="p">[</span><span class="mi">20</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
		<span class="n">s</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
			<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;, &quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Print a warning about a section mismatch.</span>
<span class="cm"> * Try to find symbols near it so user can find it.</span>
<span class="cm"> * Check whitelist before warning - it may be a false positive.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">report_sec_mismatch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">sectioncheck</span> <span class="o">*</span><span class="n">mismatch</span><span class="p">,</span>
                                <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fromsec</span><span class="p">,</span>
                                <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">fromaddr</span><span class="p">,</span>
                                <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fromsym</span><span class="p">,</span>
                                <span class="kt">int</span> <span class="n">from_is_func</span><span class="p">,</span>
                                <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tosec</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tosym</span><span class="p">,</span>
                                <span class="kt">int</span> <span class="n">to_is_func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="o">*</span><span class="n">from_p</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="o">*</span><span class="n">to_p</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">prl_from</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">prl_to</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">from_is_func</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>: <span class="n">from</span> <span class="o">=</span> <span class="s">&quot;variable&quot;</span><span class="p">;</span> <span class="n">from_p</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>   <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="n">from</span> <span class="o">=</span> <span class="s">&quot;function&quot;</span><span class="p">;</span> <span class="n">from_p</span> <span class="o">=</span> <span class="s">&quot;()&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span> <span class="n">from</span> <span class="o">=</span> <span class="s">&quot;(unknown reference)&quot;</span><span class="p">;</span> <span class="n">from_p</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">to_is_func</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>: <span class="n">to</span> <span class="o">=</span> <span class="s">&quot;variable&quot;</span><span class="p">;</span> <span class="n">to_p</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>   <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="n">to</span> <span class="o">=</span> <span class="s">&quot;function&quot;</span><span class="p">;</span> <span class="n">to_p</span> <span class="o">=</span> <span class="s">&quot;()&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span> <span class="n">to</span> <span class="o">=</span> <span class="s">&quot;(unknown reference)&quot;</span><span class="p">;</span> <span class="n">to_p</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sec_mismatch_count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sec_mismatch_verbose</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">warn</span><span class="p">(</span><span class="s">&quot;%s(%s+0x%llx): Section mismatch in reference from the %s %s%s &quot;</span>
	     <span class="s">&quot;to the %s %s:%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">modname</span><span class="p">,</span> <span class="n">fromsec</span><span class="p">,</span> <span class="n">fromaddr</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">fromsym</span><span class="p">,</span> <span class="n">from_p</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">tosec</span><span class="p">,</span>
	     <span class="n">tosym</span><span class="p">,</span> <span class="n">to_p</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mismatch</span><span class="o">-&gt;</span><span class="n">mismatch</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TEXT_TO_ANY_INIT</span>:
		<span class="n">prl_from</span> <span class="o">=</span> <span class="n">sec2annotation</span><span class="p">(</span><span class="n">fromsec</span><span class="p">);</span>
		<span class="n">prl_to</span> <span class="o">=</span> <span class="n">sec2annotation</span><span class="p">(</span><span class="n">tosec</span><span class="p">);</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
		<span class="s">&quot;The function %s%s() references</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;the %s %s%s%s.</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;This is often because %s lacks a %s</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;annotation or the annotation of %s is wrong.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">prl_from</span><span class="p">,</span> <span class="n">fromsym</span><span class="p">,</span>
		<span class="n">to</span><span class="p">,</span> <span class="n">prl_to</span><span class="p">,</span> <span class="n">tosym</span><span class="p">,</span> <span class="n">to_p</span><span class="p">,</span>
		<span class="n">fromsym</span><span class="p">,</span> <span class="n">prl_to</span><span class="p">,</span> <span class="n">tosym</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">prl_from</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">prl_to</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DATA_TO_ANY_INIT</span>: <span class="p">{</span>
		<span class="n">prl_to</span> <span class="o">=</span> <span class="n">sec2annotation</span><span class="p">(</span><span class="n">tosec</span><span class="p">);</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
		<span class="s">&quot;The variable %s references</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;the %s %s%s%s</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;If the reference is valid then annotate the</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;variable with __init* or __refdata (see linux/init.h) &quot;</span>
		<span class="s">&quot;or name the variable:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">fromsym</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">prl_to</span><span class="p">,</span> <span class="n">tosym</span><span class="p">,</span> <span class="n">to_p</span><span class="p">);</span>
		<span class="n">print_section_list</span><span class="p">(</span><span class="n">mismatch</span><span class="o">-&gt;</span><span class="n">symbol_white_list</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">prl_to</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">TEXT_TO_ANY_EXIT</span>:
		<span class="n">prl_to</span> <span class="o">=</span> <span class="n">sec2annotation</span><span class="p">(</span><span class="n">tosec</span><span class="p">);</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
		<span class="s">&quot;The function %s() references a %s in an exit section.</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;Often the %s %s%s has valid usage outside the exit section</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;and the fix is to remove the %sannotation of %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">fromsym</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">tosym</span><span class="p">,</span> <span class="n">to_p</span><span class="p">,</span> <span class="n">prl_to</span><span class="p">,</span> <span class="n">tosym</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">prl_to</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DATA_TO_ANY_EXIT</span>: <span class="p">{</span>
		<span class="n">prl_to</span> <span class="o">=</span> <span class="n">sec2annotation</span><span class="p">(</span><span class="n">tosec</span><span class="p">);</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
		<span class="s">&quot;The variable %s references</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;the %s %s%s%s</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;If the reference is valid then annotate the</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;variable with __exit* (see linux/init.h) or &quot;</span>
		<span class="s">&quot;name the variable:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">fromsym</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">prl_to</span><span class="p">,</span> <span class="n">tosym</span><span class="p">,</span> <span class="n">to_p</span><span class="p">);</span>
		<span class="n">print_section_list</span><span class="p">(</span><span class="n">mismatch</span><span class="o">-&gt;</span><span class="n">symbol_white_list</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">prl_to</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">XXXINIT_TO_SOME_INIT</span>:
	<span class="k">case</span> <span class="n">XXXEXIT_TO_SOME_EXIT</span>:
		<span class="n">prl_from</span> <span class="o">=</span> <span class="n">sec2annotation</span><span class="p">(</span><span class="n">fromsec</span><span class="p">);</span>
		<span class="n">prl_to</span> <span class="o">=</span> <span class="n">sec2annotation</span><span class="p">(</span><span class="n">tosec</span><span class="p">);</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
		<span class="s">&quot;The %s %s%s%s references</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;a %s %s%s%s.</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;If %s is only used by %s then</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;annotate %s with a matching annotation.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">from</span><span class="p">,</span> <span class="n">prl_from</span><span class="p">,</span> <span class="n">fromsym</span><span class="p">,</span> <span class="n">from_p</span><span class="p">,</span>
		<span class="n">to</span><span class="p">,</span> <span class="n">prl_to</span><span class="p">,</span> <span class="n">tosym</span><span class="p">,</span> <span class="n">to_p</span><span class="p">,</span>
		<span class="n">tosym</span><span class="p">,</span> <span class="n">fromsym</span><span class="p">,</span> <span class="n">tosym</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">prl_from</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">prl_to</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ANY_INIT_TO_ANY_EXIT</span>:
		<span class="n">prl_from</span> <span class="o">=</span> <span class="n">sec2annotation</span><span class="p">(</span><span class="n">fromsec</span><span class="p">);</span>
		<span class="n">prl_to</span> <span class="o">=</span> <span class="n">sec2annotation</span><span class="p">(</span><span class="n">tosec</span><span class="p">);</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
		<span class="s">&quot;The %s %s%s%s references</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;a %s %s%s%s.</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;This is often seen when error handling &quot;</span>
		<span class="s">&quot;in the init function</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;uses functionality in the exit path.</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;The fix is often to remove the %sannotation of</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;%s%s so it may be used outside an exit section.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">from</span><span class="p">,</span> <span class="n">prl_from</span><span class="p">,</span> <span class="n">fromsym</span><span class="p">,</span> <span class="n">from_p</span><span class="p">,</span>
		<span class="n">to</span><span class="p">,</span> <span class="n">prl_to</span><span class="p">,</span> <span class="n">tosym</span><span class="p">,</span> <span class="n">to_p</span><span class="p">,</span>
		<span class="n">prl_to</span><span class="p">,</span> <span class="n">tosym</span><span class="p">,</span> <span class="n">to_p</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">prl_from</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">prl_to</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ANY_EXIT_TO_ANY_INIT</span>:
		<span class="n">prl_from</span> <span class="o">=</span> <span class="n">sec2annotation</span><span class="p">(</span><span class="n">fromsec</span><span class="p">);</span>
		<span class="n">prl_to</span> <span class="o">=</span> <span class="n">sec2annotation</span><span class="p">(</span><span class="n">tosec</span><span class="p">);</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
		<span class="s">&quot;The %s %s%s%s references</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;a %s %s%s%s.</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;This is often seen when error handling &quot;</span>
		<span class="s">&quot;in the exit function</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;uses functionality in the init path.</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;The fix is often to remove the %sannotation of</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;%s%s so it may be used outside an init section.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">from</span><span class="p">,</span> <span class="n">prl_from</span><span class="p">,</span> <span class="n">fromsym</span><span class="p">,</span> <span class="n">from_p</span><span class="p">,</span>
		<span class="n">to</span><span class="p">,</span> <span class="n">prl_to</span><span class="p">,</span> <span class="n">tosym</span><span class="p">,</span> <span class="n">to_p</span><span class="p">,</span>
		<span class="n">prl_to</span><span class="p">,</span> <span class="n">tosym</span><span class="p">,</span> <span class="n">to_p</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">prl_from</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">prl_to</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EXPORT_TO_INIT_EXIT</span>:
		<span class="n">prl_to</span> <span class="o">=</span> <span class="n">sec2annotation</span><span class="p">(</span><span class="n">tosec</span><span class="p">);</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
		<span class="s">&quot;The symbol %s is exported and annotated %s</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;Fix this by removing the %sannotation of %s &quot;</span>
		<span class="s">&quot;or drop the export.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">tosym</span><span class="p">,</span> <span class="n">prl_to</span><span class="p">,</span> <span class="n">prl_to</span><span class="p">,</span> <span class="n">tosym</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">prl_to</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_section_mismatch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span>
                                   <span class="n">Elf_Rela</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fromsec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tosec</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sectioncheck</span> <span class="o">*</span><span class="n">mismatch</span><span class="p">;</span>

	<span class="n">tosec</span> <span class="o">=</span> <span class="n">sec_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">get_secindex</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sym</span><span class="p">));</span>
	<span class="n">mismatch</span> <span class="o">=</span> <span class="n">section_mismatch</span><span class="p">(</span><span class="n">fromsec</span><span class="p">,</span> <span class="n">tosec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mismatch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">to</span><span class="p">;</span>
		<span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">from</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tosym</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fromsym</span><span class="p">;</span>

		<span class="n">from</span> <span class="o">=</span> <span class="n">find_elf_symbol2</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">r_offset</span><span class="p">,</span> <span class="n">fromsec</span><span class="p">);</span>
		<span class="n">fromsym</span> <span class="o">=</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
		<span class="n">to</span> <span class="o">=</span> <span class="n">find_elf_symbol</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">r_addend</span><span class="p">,</span> <span class="n">sym</span><span class="p">);</span>
		<span class="n">tosym</span> <span class="o">=</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>

		<span class="cm">/* check whitelist - we may ignore it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">secref_whitelist</span><span class="p">(</span><span class="n">mismatch</span><span class="p">,</span>
					<span class="n">fromsec</span><span class="p">,</span> <span class="n">fromsym</span><span class="p">,</span> <span class="n">tosec</span><span class="p">,</span> <span class="n">tosym</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">report_sec_mismatch</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">mismatch</span><span class="p">,</span>
			   <span class="n">fromsec</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">r_offset</span><span class="p">,</span> <span class="n">fromsym</span><span class="p">,</span>
			   <span class="n">is_function</span><span class="p">(</span><span class="n">from</span><span class="p">),</span> <span class="n">tosec</span><span class="p">,</span> <span class="n">tosym</span><span class="p">,</span>
			   <span class="n">is_function</span><span class="p">(</span><span class="n">to</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="nf">reloc_location</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span>
				    <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdr</span><span class="p">,</span> <span class="n">Elf_Rela</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span> <span class="o">=</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">section</span> <span class="o">=</span> <span class="n">sechdr</span><span class="o">-&gt;</span><span class="n">sh_info</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">section</span><span class="p">].</span><span class="n">sh_offset</span> <span class="o">+</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">r_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">addend_386_rel</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdr</span><span class="p">,</span> <span class="n">Elf_Rela</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r_typ</span> <span class="o">=</span> <span class="n">ELF_R_TYPE</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">location</span> <span class="o">=</span> <span class="n">reloc_location</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sechdr</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">r_typ</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">R_386_32</span>:
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">r_addend</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="o">*</span><span class="n">location</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">R_386_PC32</span>:
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">r_addend</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="o">*</span><span class="n">location</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
		<span class="cm">/* For CONFIG_RELOCATABLE=y */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">==</span> <span class="n">ET_EXEC</span><span class="p">)</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">r_addend</span> <span class="o">+=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">r_offset</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef R_ARM_CALL</span>
<span class="cp">#define R_ARM_CALL	28</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef R_ARM_JUMP24</span>
<span class="cp">#define R_ARM_JUMP24	29</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">addend_arm_rel</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdr</span><span class="p">,</span> <span class="n">Elf_Rela</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r_typ</span> <span class="o">=</span> <span class="n">ELF_R_TYPE</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">r_typ</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">R_ARM_ABS32</span>:
		<span class="cm">/* From ARM ABI: (S + A) | T */</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">r_addend</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span>
		              <span class="p">(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">symtab_start</span> <span class="o">+</span> <span class="n">ELF_R_SYM</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">R_ARM_PC24</span>:
	<span class="k">case</span> <span class="n">R_ARM_CALL</span>:
	<span class="k">case</span> <span class="n">R_ARM_JUMP24</span>:
		<span class="cm">/* From ARM ABI: ((S + A) | T) - P */</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">r_addend</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="kt">long</span><span class="p">)(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">+</span>
		              <span class="n">sechdr</span><span class="o">-&gt;</span><span class="n">sh_offset</span> <span class="o">+</span>
		              <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_offset</span> <span class="o">-</span> <span class="n">sechdr</span><span class="o">-&gt;</span><span class="n">sh_addr</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">addend_mips_rel</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdr</span><span class="p">,</span> <span class="n">Elf_Rela</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r_typ</span> <span class="o">=</span> <span class="n">ELF_R_TYPE</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">location</span> <span class="o">=</span> <span class="n">reloc_location</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sechdr</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inst</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r_typ</span> <span class="o">==</span> <span class="n">R_MIPS_HI16</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* skip this */</span>
	<span class="n">inst</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="o">*</span><span class="n">location</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">r_typ</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">R_MIPS_LO16</span>:
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">r_addend</span> <span class="o">=</span> <span class="n">inst</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">R_MIPS_26</span>:
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">r_addend</span> <span class="o">=</span> <span class="p">(</span><span class="n">inst</span> <span class="o">&amp;</span> <span class="mh">0x03ffffff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">R_MIPS_32</span>:
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">r_addend</span> <span class="o">=</span> <span class="n">inst</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">section_rela</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span>
                         <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf_Sym</span>  <span class="o">*</span><span class="n">sym</span><span class="p">;</span>
	<span class="n">Elf_Rela</span> <span class="o">*</span><span class="n">rela</span><span class="p">;</span>
	<span class="n">Elf_Rela</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r_sym</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fromsec</span><span class="p">;</span>

	<span class="n">Elf_Rela</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">sechdr</span><span class="o">-&gt;</span><span class="n">sh_offset</span><span class="p">;</span>
	<span class="n">Elf_Rela</span> <span class="o">*</span><span class="n">stop</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">start</span> <span class="o">+</span> <span class="n">sechdr</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">;</span>

	<span class="n">fromsec</span> <span class="o">=</span> <span class="n">sech_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sechdr</span><span class="p">);</span>
	<span class="n">fromsec</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;.rela&quot;</span><span class="p">);</span>
	<span class="cm">/* if from section (name) is know good then skip it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">fromsec</span><span class="p">,</span> <span class="n">section_white_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">rela</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">rela</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">;</span> <span class="n">rela</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span><span class="p">.</span><span class="n">r_offset</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">rela</span><span class="o">-&gt;</span><span class="n">r_offset</span><span class="p">);</span>
<span class="cp">#if KERNEL_ELFCLASS == ELFCLASS64</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_machine</span> <span class="o">==</span> <span class="n">EM_MIPS</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r_typ</span><span class="p">;</span>
			<span class="n">r_sym</span> <span class="o">=</span> <span class="n">ELF64_MIPS_R_SYM</span><span class="p">(</span><span class="n">rela</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">);</span>
			<span class="n">r_sym</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">r_sym</span><span class="p">);</span>
			<span class="n">r_typ</span> <span class="o">=</span> <span class="n">ELF64_MIPS_R_TYPE</span><span class="p">(</span><span class="n">rela</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">);</span>
			<span class="n">r</span><span class="p">.</span><span class="n">r_info</span> <span class="o">=</span> <span class="n">ELF64_R_INFO</span><span class="p">(</span><span class="n">r_sym</span><span class="p">,</span> <span class="n">r_typ</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">r</span><span class="p">.</span><span class="n">r_info</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">rela</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">);</span>
			<span class="n">r_sym</span> <span class="o">=</span> <span class="n">ELF_R_SYM</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">r_info</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#else</span>
		<span class="n">r</span><span class="p">.</span><span class="n">r_info</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">rela</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">);</span>
		<span class="n">r_sym</span> <span class="o">=</span> <span class="n">ELF_R_SYM</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">r_info</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">r</span><span class="p">.</span><span class="n">r_addend</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">rela</span><span class="o">-&gt;</span><span class="n">r_addend</span><span class="p">);</span>
		<span class="n">sym</span> <span class="o">=</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">symtab_start</span> <span class="o">+</span> <span class="n">r_sym</span><span class="p">;</span>
		<span class="cm">/* Skip special sections */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_shndx_special</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">check_section_mismatch</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">fromsec</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">section_rel</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span>
                        <span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>
	<span class="n">Elf_Rel</span> <span class="o">*</span><span class="n">rel</span><span class="p">;</span>
	<span class="n">Elf_Rela</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r_sym</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fromsec</span><span class="p">;</span>

	<span class="n">Elf_Rel</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">sechdr</span><span class="o">-&gt;</span><span class="n">sh_offset</span><span class="p">;</span>
	<span class="n">Elf_Rel</span> <span class="o">*</span><span class="n">stop</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">start</span> <span class="o">+</span> <span class="n">sechdr</span><span class="o">-&gt;</span><span class="n">sh_size</span><span class="p">;</span>

	<span class="n">fromsec</span> <span class="o">=</span> <span class="n">sech_name</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sechdr</span><span class="p">);</span>
	<span class="n">fromsec</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;.rel&quot;</span><span class="p">);</span>
	<span class="cm">/* if from section (name) is know good then skip it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">fromsec</span><span class="p">,</span> <span class="n">section_white_list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">rel</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">rel</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">;</span> <span class="n">rel</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span><span class="p">.</span><span class="n">r_offset</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">rel</span><span class="o">-&gt;</span><span class="n">r_offset</span><span class="p">);</span>
<span class="cp">#if KERNEL_ELFCLASS == ELFCLASS64</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_machine</span> <span class="o">==</span> <span class="n">EM_MIPS</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r_typ</span><span class="p">;</span>
			<span class="n">r_sym</span> <span class="o">=</span> <span class="n">ELF64_MIPS_R_SYM</span><span class="p">(</span><span class="n">rel</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">);</span>
			<span class="n">r_sym</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">r_sym</span><span class="p">);</span>
			<span class="n">r_typ</span> <span class="o">=</span> <span class="n">ELF64_MIPS_R_TYPE</span><span class="p">(</span><span class="n">rel</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">);</span>
			<span class="n">r</span><span class="p">.</span><span class="n">r_info</span> <span class="o">=</span> <span class="n">ELF64_R_INFO</span><span class="p">(</span><span class="n">r_sym</span><span class="p">,</span> <span class="n">r_typ</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">r</span><span class="p">.</span><span class="n">r_info</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">rel</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">);</span>
			<span class="n">r_sym</span> <span class="o">=</span> <span class="n">ELF_R_SYM</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">r_info</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#else</span>
		<span class="n">r</span><span class="p">.</span><span class="n">r_info</span> <span class="o">=</span> <span class="n">TO_NATIVE</span><span class="p">(</span><span class="n">rel</span><span class="o">-&gt;</span><span class="n">r_info</span><span class="p">);</span>
		<span class="n">r_sym</span> <span class="o">=</span> <span class="n">ELF_R_SYM</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">r_info</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">r</span><span class="p">.</span><span class="n">r_addend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_machine</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">EM_386</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">addend_386_rel</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sechdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">EM_ARM</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">addend_arm_rel</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sechdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">EM_MIPS</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">addend_mips_rel</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">sechdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sym</span> <span class="o">=</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">symtab_start</span> <span class="o">+</span> <span class="n">r_sym</span><span class="p">;</span>
		<span class="cm">/* Skip special sections */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_shndx_special</span><span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_shndx</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">check_section_mismatch</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">fromsec</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * A module includes a number of sections that are discarded</span>
<span class="cm"> * either when loaded or when used as built-in.</span>
<span class="cm"> * For loaded modules all functions marked __init and all data</span>
<span class="cm"> * marked __initdata will be discarded when the module has been initialized.</span>
<span class="cm"> * Likewise for modules used built-in the sections marked __exit</span>
<span class="cm"> * are discarded because __exit marked function are supposed to be called</span>
<span class="cm"> * only when a module is unloaded which never happens for built-in modules.</span>
<span class="cm"> * The check_sec_ref() function traverses all relocation records</span>
<span class="cm"> * to find all references to a section that reference a section that will</span>
<span class="cm"> * be discarded and warns about it.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_sec_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">,</span>
                          <span class="k">struct</span> <span class="n">elf_info</span> <span class="o">*</span><span class="n">elf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">Elf_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span> <span class="o">=</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">;</span>

	<span class="cm">/* Walk through all sections */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">num_sections</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">check_section</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="cm">/* We want to process only relocation sections and not .init */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_RELA</span><span class="p">)</span>
			<span class="n">section_rela</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sh_type</span> <span class="o">==</span> <span class="n">SHT_REL</span><span class="p">)</span>
			<span class="n">section_rel</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">elf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_symbols</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">version</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">license</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf_info</span> <span class="n">info</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span>
	<span class="n">Elf_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parse_elf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">modname</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mod</span> <span class="o">=</span> <span class="n">new_module</span><span class="p">(</span><span class="n">modname</span><span class="p">);</span>

	<span class="cm">/* When there&#39;s no vmlinux, don&#39;t print warnings about</span>
<span class="cm">	 * unresolved symbols (since there&#39;ll be too many ;) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_vmlinux</span><span class="p">(</span><span class="n">modname</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">have_vmlinux</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mod</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">license</span> <span class="o">=</span> <span class="n">get_modinfo</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">modinfo</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">modinfo_len</span><span class="p">,</span> <span class="s">&quot;license&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">modinfo</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">license</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_vmlinux</span><span class="p">(</span><span class="n">modname</span><span class="p">))</span>
		<span class="n">warn</span><span class="p">(</span><span class="s">&quot;modpost: missing MODULE_LICENSE() in %s</span><span class="se">\n</span><span class="s">&quot;</span>
		     <span class="s">&quot;see include/linux/module.h for &quot;</span>
		     <span class="s">&quot;more information</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">modname</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">license</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">license_is_gpl_compatible</span><span class="p">(</span><span class="n">license</span><span class="p">))</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_compatible</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_compatible</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">license</span> <span class="o">=</span> <span class="n">get_next_modinfo</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">modinfo</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">modinfo_len</span><span class="p">,</span>
					   <span class="s">&quot;license&quot;</span><span class="p">,</span> <span class="n">license</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">sym</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">symtab_start</span><span class="p">;</span> <span class="n">sym</span> <span class="o">&lt;</span> <span class="n">info</span><span class="p">.</span><span class="n">symtab_stop</span><span class="p">;</span> <span class="n">sym</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">symname</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">;</span>

		<span class="n">handle_modversions</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">symname</span><span class="p">);</span>
		<span class="n">handle_moddevtable</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">symname</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_vmlinux</span><span class="p">(</span><span class="n">modname</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">is_vmlinux</span><span class="p">(</span><span class="n">modname</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">vmlinux_section_warnings</span><span class="p">))</span>
		<span class="n">check_sec_ref</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">modname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

	<span class="n">version</span> <span class="o">=</span> <span class="n">get_modinfo</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">modinfo</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">modinfo_len</span><span class="p">,</span> <span class="s">&quot;version&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">version</span><span class="p">)</span>
		<span class="n">maybe_frob_rcs_version</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">modinfo</span><span class="p">,</span>
				       <span class="n">version</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">.</span><span class="n">hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">version</span> <span class="o">||</span> <span class="p">(</span><span class="n">all_versions</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_vmlinux</span><span class="p">(</span><span class="n">modname</span><span class="p">)))</span>
		<span class="n">get_src_version</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">srcversion</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">srcversion</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">parse_elf_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/* Our trick to get versioning for module struct etc. - it&#39;s</span>
<span class="cm">	 * never passed as an argument to an exported function, so</span>
<span class="cm">	 * the automatic versioning doesn&#39;t pick it up, but it&#39;s really</span>
<span class="cm">	 * important anyhow */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">modversions</span><span class="p">)</span>
		<span class="n">mod</span><span class="o">-&gt;</span><span class="n">unres</span> <span class="o">=</span> <span class="n">alloc_symbol</span><span class="p">(</span><span class="s">&quot;module_layout&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">unres</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define SZ 500</span>

<span class="cm">/* We first write the generated file into memory using the</span>
<span class="cm"> * following helper, then compare to the file on disk and</span>
<span class="cm"> * only update the later if anything changed */</span>

<span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">format</span><span class="p">(</span><span class="n">printf</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span> <span class="n">buf_printf</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
						      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="n">SZ</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">vsnprintf</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">SZ</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
	<span class="n">buf_write</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">buf_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">+</span> <span class="n">SZ</span><span class="p">;</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_for_gpl_usage</span><span class="p">(</span><span class="k">enum</span> <span class="n">export</span> <span class="n">exp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">is_vmlinux</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">?</span><span class="s">&quot;&quot;</span><span class="o">:</span><span class="s">&quot;.ko&quot;</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">export_gpl</span>:
		<span class="n">fatal</span><span class="p">(</span><span class="s">&quot;modpost: GPL-incompatible module %s%s &quot;</span>
		      <span class="s">&quot;uses GPL-only symbol &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">export_unused_gpl</span>:
		<span class="n">fatal</span><span class="p">(</span><span class="s">&quot;modpost: GPL-incompatible module %s%s &quot;</span>
		      <span class="s">&quot;uses GPL-only symbol marked UNUSED &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">export_gpl_future</span>:
		<span class="n">warn</span><span class="p">(</span><span class="s">&quot;modpost: GPL-incompatible module %s%s &quot;</span>
		      <span class="s">&quot;uses future GPL-only symbol &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">export_plain</span>:
	<span class="k">case</span> <span class="n">export_unused</span>:
	<span class="k">case</span> <span class="n">export_unknown</span>:
		<span class="cm">/* ignore */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_for_unused</span><span class="p">(</span><span class="k">enum</span> <span class="n">export</span> <span class="n">exp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">is_vmlinux</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">?</span><span class="s">&quot;&quot;</span><span class="o">:</span><span class="s">&quot;.ko&quot;</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">export_unused</span>:
	<span class="k">case</span> <span class="n">export_unused_gpl</span>:
		<span class="n">warn</span><span class="p">(</span><span class="s">&quot;modpost: module %s%s &quot;</span>
		      <span class="s">&quot;uses symbol &#39;%s&#39; marked UNUSED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* ignore */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_exports</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">exp</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">unres</span><span class="p">;</span> <span class="n">s</span><span class="p">;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">basename</span><span class="p">;</span>
		<span class="n">exp</span> <span class="o">=</span> <span class="n">find_symbol</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exp</span> <span class="o">||</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">module</span> <span class="o">==</span> <span class="n">mod</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">basename</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">basename</span><span class="p">)</span>
			<span class="n">basename</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">basename</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">gpl_compatible</span><span class="p">)</span>
			<span class="n">check_for_gpl_usage</span><span class="p">(</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">export</span><span class="p">,</span> <span class="n">basename</span><span class="p">,</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">check_for_unused</span><span class="p">(</span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">export</span><span class="p">,</span> <span class="n">basename</span><span class="p">,</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Header for the generated file</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;#include &lt;linux/module.h&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;#include &lt;linux/vermagic.h&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;#include &lt;linux/compiler.h&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;MODULE_INFO(vermagic, VERMAGIC_STRING);</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;struct module __this_module</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;__attribute__((section(</span><span class="se">\&quot;</span><span class="s">.gnu.linkonce.this_module</span><span class="se">\&quot;</span><span class="s">))) = {</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.name = KBUILD_MODNAME,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">has_init</span><span class="p">)</span>
		<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.init = init_module,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">has_cleanup</span><span class="p">)</span>
		<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;#ifdef CONFIG_MODULE_UNLOAD</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;</span><span class="se">\t</span><span class="s">.exit = cleanup_module,</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;#endif</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.arch = MODULE_ARCH_INIT,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;};</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_intree_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_intree</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_intree</span><span class="p">)</span>
		<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">MODULE_INFO(intree, </span><span class="se">\&quot;</span><span class="s">Y</span><span class="se">\&quot;</span><span class="s">);</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_staging_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">staging_dir</span> <span class="o">=</span> <span class="s">&quot;drivers/staging&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">staging_dir</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">staging_dir</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">MODULE_INFO(staging, </span><span class="se">\&quot;</span><span class="s">Y</span><span class="se">\&quot;</span><span class="s">);</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Record CRCs for unresolved symbols</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_versions</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">exp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">unres</span><span class="p">;</span> <span class="n">s</span><span class="p">;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">exp</span> <span class="o">=</span> <span class="n">find_symbol</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exp</span> <span class="o">||</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">module</span> <span class="o">==</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">have_vmlinux</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">weak</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">warn_unresolved</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">warn</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> [%s.ko] undefined!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">merror</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> [%s.ko] undefined!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					          <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
					<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">module</span> <span class="o">=</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">crc_valid</span> <span class="o">=</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">crc_valid</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">crc</span> <span class="o">=</span> <span class="n">exp</span><span class="o">-&gt;</span><span class="n">crc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">modversions</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;static const struct modversion_info ____versions[]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;__used</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;__attribute__((section(</span><span class="se">\&quot;</span><span class="s">__versions</span><span class="se">\&quot;</span><span class="s">))) = {</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">unres</span><span class="p">;</span> <span class="n">s</span><span class="p">;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">crc_valid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">warn</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> [%s.ko] has no CRC!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">{ %#8x, </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> },</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">crc</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;};</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_depends</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">modules</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">modules</span><span class="p">;</span> <span class="n">m</span><span class="p">;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">=</span> <span class="n">is_vmlinux</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;static const char __module_depends[]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;__used</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;__attribute__((section(</span><span class="se">\&quot;</span><span class="s">.modinfo</span><span class="se">\&quot;</span><span class="s">))) =</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">depends=&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">unres</span><span class="p">;</span> <span class="n">s</span><span class="p">;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">module</span><span class="o">-&gt;</span><span class="n">seen</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">module</span><span class="o">-&gt;</span><span class="n">seen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">module</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
			<span class="n">p</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">module</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;%s%s&quot;</span><span class="p">,</span> <span class="n">first</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;,&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_srcversion</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">srcversion</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">buf_printf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;MODULE_INFO(srcversion, </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">);</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">mod</span><span class="o">-&gt;</span><span class="n">srcversion</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_if_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">write</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fstat</span><span class="p">(</span><span class="n">fileno</span><span class="p">(</span><span class="n">file</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">close_write</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">st_size</span> <span class="o">!=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">close_write</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">NOFAIL</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fread</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="o">!=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_write</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_write</span><span class="p">;</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

 <span class="nl">free_write:</span>
	<span class="n">free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
 <span class="nl">close_write:</span>
	<span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
 <span class="nl">write:</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="n">fname</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fwrite</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="o">!=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="n">fname</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* parse Module.symvers file. line format:</span>
<span class="cm"> * 0x12345678&lt;tab&gt;symbol&lt;tab&gt;module[[&lt;tab&gt;export]&lt;tab&gt;something]</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_dump</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kernel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">grab_file</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">line</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="cm">/* No symbol versions, silently ignore */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">get_next_line</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">size</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">,</span> <span class="o">*</span><span class="n">modname</span><span class="p">,</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">export</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">crc</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">symname</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="sc">&#39;\t&#39;</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="o">*</span><span class="n">symname</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">modname</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="sc">&#39;\t&#39;</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="o">*</span><span class="n">modname</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">export</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="sc">&#39;\t&#39;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="o">*</span><span class="n">export</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">export</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">end</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">export</span><span class="p">,</span> <span class="sc">&#39;\t&#39;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">crc</span> <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">symname</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">modname</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">d</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="n">mod</span> <span class="o">=</span> <span class="n">find_module</span><span class="p">(</span><span class="n">modname</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_vmlinux</span><span class="p">(</span><span class="n">modname</span><span class="p">))</span>
				<span class="n">have_vmlinux</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">mod</span> <span class="o">=</span> <span class="n">new_module</span><span class="p">(</span><span class="n">modname</span><span class="p">);</span>
			<span class="n">mod</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">sym_add_exported</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">export_no</span><span class="p">(</span><span class="n">export</span><span class="p">));</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">kernel</span>    <span class="o">=</span> <span class="n">kernel</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">preloaded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sym_update_crc</span><span class="p">(</span><span class="n">symname</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span> <span class="n">export_no</span><span class="p">(</span><span class="n">export</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">fatal</span><span class="p">(</span><span class="s">&quot;parse error in symbol dump file</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* For normal builds always dump all symbols.</span>
<span class="cm"> * For external modules only dump symbols</span>
<span class="cm"> * that are not read from kernel Module.symvers.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dump_sym</span><span class="p">(</span><span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">sym</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">external_module</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">vmlinux</span> <span class="o">||</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">kernel</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_dump</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">symbol</span> <span class="o">*</span><span class="n">symbol</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">SYMBOL_HASH_SIZE</span> <span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">symbol</span> <span class="o">=</span> <span class="n">symbolhash</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">symbol</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dump_sym</span><span class="p">(</span><span class="n">symbol</span><span class="p">))</span>
				<span class="n">buf_printf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;0x%08x</span><span class="se">\t</span><span class="s">%s</span><span class="se">\t</span><span class="s">%s</span><span class="se">\t</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">crc</span><span class="p">,</span> <span class="n">symbol</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					<span class="n">symbol</span><span class="o">-&gt;</span><span class="n">module</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					<span class="n">export_str</span><span class="p">(</span><span class="n">symbol</span><span class="o">-&gt;</span><span class="n">export</span><span class="p">));</span>
			<span class="n">symbol</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">write_if_changed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">fname</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ext_sym_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext_sym_list</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kernel_read</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">module_read</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">dump_write</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">opt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext_sym_list</span> <span class="o">*</span><span class="n">extsym_iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext_sym_list</span> <span class="o">*</span><span class="n">extsym_start</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">opt</span> <span class="o">=</span> <span class="n">getopt</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot;i:I:e:cmsSo:awM:K:&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">opt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;i&#39;</span>:
			<span class="n">kernel_read</span> <span class="o">=</span> <span class="n">optarg</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;I&#39;</span>:
			<span class="n">module_read</span> <span class="o">=</span> <span class="n">optarg</span><span class="p">;</span>
			<span class="n">external_module</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;c&#39;</span>:
			<span class="n">cross_build</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;e&#39;</span>:
			<span class="n">external_module</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">extsym_iter</span> <span class="o">=</span>
			   <span class="n">NOFAIL</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">extsym_iter</span><span class="p">)));</span>
			<span class="n">extsym_iter</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">extsym_start</span><span class="p">;</span>
			<span class="n">extsym_iter</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">optarg</span><span class="p">;</span>
			<span class="n">extsym_start</span> <span class="o">=</span> <span class="n">extsym_iter</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;m&#39;</span>:
			<span class="n">modversions</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;o&#39;</span>:
			<span class="n">dump_write</span> <span class="o">=</span> <span class="n">optarg</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;a&#39;</span>:
			<span class="n">all_versions</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;s&#39;</span>:
			<span class="n">vmlinux_section_warnings</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;S&#39;</span>:
			<span class="n">sec_mismatch_verbose</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;w&#39;</span>:
			<span class="n">warn_unresolved</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kernel_read</span><span class="p">)</span>
		<span class="n">read_dump</span><span class="p">(</span><span class="n">kernel_read</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">module_read</span><span class="p">)</span>
		<span class="n">read_dump</span><span class="p">(</span><span class="n">module_read</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">extsym_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">read_dump</span><span class="p">(</span><span class="n">extsym_start</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">extsym_iter</span> <span class="o">=</span> <span class="n">extsym_start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">free</span><span class="p">(</span><span class="n">extsym_start</span><span class="p">);</span>
		<span class="n">extsym_start</span> <span class="o">=</span> <span class="n">extsym_iter</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">optind</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">)</span>
		<span class="n">read_symbols</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">optind</span><span class="o">++</span><span class="p">]);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">mod</span> <span class="o">=</span> <span class="n">modules</span><span class="p">;</span> <span class="n">mod</span><span class="p">;</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">check_exports</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">mod</span> <span class="o">=</span> <span class="n">modules</span><span class="p">;</span> <span class="n">mod</span><span class="p">;</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">fname</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">buf</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">add_header</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
		<span class="n">add_intree_flag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="o">!</span><span class="n">external_module</span><span class="p">);</span>
		<span class="n">add_staging_flag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">add_versions</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
		<span class="n">add_depends</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">modules</span><span class="p">);</span>
		<span class="n">add_moddevtable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
		<span class="n">add_srcversion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>

		<span class="n">sprintf</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&quot;%s.mod.c&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">write_if_changed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">fname</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dump_write</span><span class="p">)</span>
		<span class="n">write_dump</span><span class="p">(</span><span class="n">dump_write</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sec_mismatch_count</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sec_mismatch_verbose</span><span class="p">)</span>
		<span class="n">warn</span><span class="p">(</span><span class="s">&quot;modpost: Found %d section mismatch(es).</span><span class="se">\n</span><span class="s">&quot;</span>
		     <span class="s">&quot;To see full details build your kernel with:</span><span class="se">\n</span><span class="s">&quot;</span>
		     <span class="s">&quot;&#39;make CONFIG_DEBUG_SECTION_MISMATCH=y&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">sec_mismatch_count</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
