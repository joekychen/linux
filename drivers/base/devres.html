<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › base › devres.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>devres.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * drivers/base/devres.c - device resource management</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2006  SUSE Linux Products GmbH</span>
<span class="cm"> * Copyright (c) 2006  Tejun Heo &lt;teheo@suse.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPLv2.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &quot;base.h&quot;</span>

<span class="k">struct</span> <span class="n">devres_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">entry</span><span class="p">;</span>
	<span class="n">dr_release_t</span>			<span class="n">release</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_DEBUG_DEVRES</span>
	<span class="k">const</span> <span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">size_t</span>				<span class="n">size</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">devres</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">devres_node</span>		<span class="n">node</span><span class="p">;</span>
	<span class="cm">/* -- 3 pointers */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>		<span class="n">data</span><span class="p">[];</span>	<span class="cm">/* guarantee ull alignment */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">devres_group</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">devres_node</span>		<span class="n">node</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">color</span><span class="p">;</span>
	<span class="cm">/* -- 8 pointers */</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_DEBUG_DEVRES</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">log_devres</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">log_devres</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_node_dbginfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">devres_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">devres_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">devres_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">log_devres</span><span class="p">))</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DEVRES %3s %p %s (%lu bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">op</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_DEBUG_DEVRES */</span><span class="cp"></span>
<span class="cp">#define set_node_dbginfo(node, n, s)	do {} while (0)</span>
<span class="cp">#define devres_log(dev, node, op)	do {} while (0)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_DEVRES */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Release functions for devres group.  These callbacks are used only</span>
<span class="cm"> * for identification.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">group_open_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* noop */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">group_close_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* noop */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">devres_group</span> <span class="o">*</span> <span class="nf">node_to_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">devres_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">group_open_release</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">devres_group</span><span class="p">,</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">group_close_release</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">devres_group</span><span class="p">,</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="k">struct</span> <span class="n">devres</span> <span class="o">*</span> <span class="nf">alloc_dr</span><span class="p">(</span><span class="n">dr_release_t</span> <span class="n">release</span><span class="p">,</span>
						<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">tot_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">devres</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">devres</span> <span class="o">*</span><span class="n">dr</span><span class="p">;</span>

	<span class="n">dr</span> <span class="o">=</span> <span class="n">kmalloc_track_caller</span><span class="p">(</span><span class="n">tot_size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dr</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">dr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tot_size</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">dr</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">release</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_dr</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">devres_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">devres_log</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="s">&quot;ADD&quot;</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">));</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_head</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_DEVRES</span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">__devres_alloc</span><span class="p">(</span><span class="n">dr_release_t</span> <span class="n">release</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devres</span> <span class="o">*</span><span class="n">dr</span><span class="p">;</span>

	<span class="n">dr</span> <span class="o">=</span> <span class="n">alloc_dr</span><span class="p">(</span><span class="n">release</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dr</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">set_node_dbginfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__devres_alloc</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cm">/**</span>
<span class="cm"> * devres_alloc - Allocate device resource data</span>
<span class="cm"> * @release: Release function devres will be associated with</span>
<span class="cm"> * @size: Allocation size</span>
<span class="cm"> * @gfp: Allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate devres of @size bytes.  The allocated area is zeroed, then</span>
<span class="cm"> * associated with @release.  The returned pointer can be passed to</span>
<span class="cm"> * other devres_*() functions.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to allocated devres on success, NULL on failure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">devres_alloc</span><span class="p">(</span><span class="n">dr_release_t</span> <span class="n">release</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devres</span> <span class="o">*</span><span class="n">dr</span><span class="p">;</span>

	<span class="n">dr</span> <span class="o">=</span> <span class="n">alloc_dr</span><span class="p">(</span><span class="n">release</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dr</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">devres_alloc</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * devres_free - Free device resource data</span>
<span class="cm"> * @res: Pointer to devres data to free</span>
<span class="cm"> *</span>
<span class="cm"> * Free devres created with devres_alloc().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">devres_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">devres</span> <span class="o">*</span><span class="n">dr</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="k">struct</span> <span class="n">devres</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">entry</span><span class="p">));</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">devres_free</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * devres_add - Register device resource</span>
<span class="cm"> * @dev: Device to add resource to</span>
<span class="cm"> * @res: Resource to register</span>
<span class="cm"> *</span>
<span class="cm"> * Register devres @res to @dev.  @res should have been allocated</span>
<span class="cm"> * using devres_alloc().  On driver detach, the associated release</span>
<span class="cm"> * function will be invoked and devres will be freed automatically.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">devres_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devres</span> <span class="o">*</span><span class="n">dr</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="k">struct</span> <span class="n">devres</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">add_dr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">devres_add</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">devres</span> <span class="o">*</span><span class="nf">find_dr</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dr_release_t</span> <span class="n">release</span><span class="p">,</span>
			      <span class="n">dr_match_t</span> <span class="n">match</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">match_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devres_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_head</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">devres</span> <span class="o">*</span><span class="n">dr</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">devres</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">!=</span> <span class="n">release</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">match</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">match_data</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">dr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * devres_find - Find device resource</span>
<span class="cm"> * @dev: Device to lookup resource from</span>
<span class="cm"> * @release: Look for resources associated with this release function</span>
<span class="cm"> * @match: Match function (optional)</span>
<span class="cm"> * @match_data: Data for the match function</span>
<span class="cm"> *</span>
<span class="cm"> * Find the latest devres of @dev which is associated with @release</span>
<span class="cm"> * and for which @match returns 1.  If @match is NULL, it&#39;s considered</span>
<span class="cm"> * to match all.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to found devres, NULL if not found.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">devres_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dr_release_t</span> <span class="n">release</span><span class="p">,</span>
		   <span class="n">dr_match_t</span> <span class="n">match</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">match_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devres</span> <span class="o">*</span><span class="n">dr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dr</span> <span class="o">=</span> <span class="n">find_dr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">release</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">match_data</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">devres_find</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * devres_get - Find devres, if non-existent, add one atomically</span>
<span class="cm"> * @dev: Device to lookup or add devres for</span>
<span class="cm"> * @new_res: Pointer to new initialized devres to add if not found</span>
<span class="cm"> * @match: Match function (optional)</span>
<span class="cm"> * @match_data: Data for the match function</span>
<span class="cm"> *</span>
<span class="cm"> * Find the latest devres of @dev which has the same release function</span>
<span class="cm"> * as @new_res and for which @match return 1.  If found, @new_res is</span>
<span class="cm"> * freed; otherwise, @new_res is added atomically.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to found or added devres.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">devres_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">new_res</span><span class="p">,</span>
		  <span class="n">dr_match_t</span> <span class="n">match</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">match_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devres</span> <span class="o">*</span><span class="n">new_dr</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">new_res</span><span class="p">,</span> <span class="k">struct</span> <span class="n">devres</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">devres</span> <span class="o">*</span><span class="n">dr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dr</span> <span class="o">=</span> <span class="n">find_dr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">new_dr</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">match_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">add_dr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_dr</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">dr</span> <span class="o">=</span> <span class="n">new_dr</span><span class="p">;</span>
		<span class="n">new_dr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">devres_free</span><span class="p">(</span><span class="n">new_dr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">devres_get</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * devres_remove - Find a device resource and remove it</span>
<span class="cm"> * @dev: Device to find resource from</span>
<span class="cm"> * @release: Look for resources associated with this release function</span>
<span class="cm"> * @match: Match function (optional)</span>
<span class="cm"> * @match_data: Data for the match function</span>
<span class="cm"> *</span>
<span class="cm"> * Find the latest devres of @dev associated with @release and for</span>
<span class="cm"> * which @match returns 1.  If @match is NULL, it&#39;s considered to</span>
<span class="cm"> * match all.  If found, the resource is removed atomically and</span>
<span class="cm"> * returned.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to removed devres on success, NULL if not found.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">devres_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dr_release_t</span> <span class="n">release</span><span class="p">,</span>
		     <span class="n">dr_match_t</span> <span class="n">match</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">match_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devres</span> <span class="o">*</span><span class="n">dr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dr</span> <span class="o">=</span> <span class="n">find_dr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">release</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">match_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">devres_log</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;REM&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">devres_remove</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * devres_destroy - Find a device resource and destroy it</span>
<span class="cm"> * @dev: Device to find resource from</span>
<span class="cm"> * @release: Look for resources associated with this release function</span>
<span class="cm"> * @match: Match function (optional)</span>
<span class="cm"> * @match_data: Data for the match function</span>
<span class="cm"> *</span>
<span class="cm"> * Find the latest devres of @dev associated with @release and for</span>
<span class="cm"> * which @match returns 1.  If @match is NULL, it&#39;s considered to</span>
<span class="cm"> * match all.  If found, the resource is removed atomically and freed.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the release function for the resource will not be called,</span>
<span class="cm"> * only the devres-allocated data will be freed.  The caller becomes</span>
<span class="cm"> * responsible for freeing any other data.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 if devres is found and freed, -ENOENT if not found.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">devres_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dr_release_t</span> <span class="n">release</span><span class="p">,</span>
		   <span class="n">dr_match_t</span> <span class="n">match</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">match_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">devres_remove</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">release</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">match_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">devres_free</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">devres_destroy</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * devres_release - Find a device resource and destroy it, calling release</span>
<span class="cm"> * @dev: Device to find resource from</span>
<span class="cm"> * @release: Look for resources associated with this release function</span>
<span class="cm"> * @match: Match function (optional)</span>
<span class="cm"> * @match_data: Data for the match function</span>
<span class="cm"> *</span>
<span class="cm"> * Find the latest devres of @dev associated with @release and for</span>
<span class="cm"> * which @match returns 1.  If @match is NULL, it&#39;s considered to</span>
<span class="cm"> * match all.  If found, the resource is removed atomically, the</span>
<span class="cm"> * release function called and the resource freed.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 if devres is found and freed, -ENOENT if not found.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">devres_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dr_release_t</span> <span class="n">release</span><span class="p">,</span>
		   <span class="n">dr_match_t</span> <span class="n">match</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">match_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">devres_remove</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">release</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">match_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="n">dev</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="n">devres_free</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">devres_release</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">remove_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">end</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">todo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nr_groups</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>

	<span class="cm">/* First pass - move normal devres entries to @todo and clear</span>
<span class="cm">	 * devres_group colors.</span>
<span class="cm">	 */</span>
	<span class="n">cur</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">devres_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">devres_group</span> <span class="o">*</span><span class="n">grp</span><span class="p">;</span>

		<span class="n">node</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="k">struct</span> <span class="n">devres_node</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="n">grp</span> <span class="o">=</span> <span class="n">node_to_group</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">grp</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* clear color of group markers in the first pass */</span>
			<span class="n">grp</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">nr_groups</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* regular devres entry */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">==</span> <span class="n">first</span><span class="p">)</span>
				<span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="n">todo</span><span class="p">);</span>
			<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_groups</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="cm">/* Second pass - Scan groups and color them.  A group gets</span>
<span class="cm">	 * color value of two iff the group is wholly contained in</span>
<span class="cm">	 * [cur, end).  That is, for a closed group, both opening and</span>
<span class="cm">	 * closing markers should be in the range, while just the</span>
<span class="cm">	 * opening marker is enough for an open group.</span>
<span class="cm">	 */</span>
	<span class="n">cur</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">devres_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">devres_group</span> <span class="o">*</span><span class="n">grp</span><span class="p">;</span>

		<span class="n">node</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="k">struct</span> <span class="n">devres_node</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="n">grp</span> <span class="o">=</span> <span class="n">node_to_group</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">grp</span> <span class="o">||</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">entry</span><span class="p">));</span>

		<span class="n">grp</span><span class="o">-&gt;</span><span class="n">color</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">entry</span><span class="p">))</span>
			<span class="n">grp</span><span class="o">-&gt;</span><span class="n">color</span><span class="o">++</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">grp</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* No need to update cur or end.  The removed</span>
<span class="cm">			 * nodes are always before both.</span>
<span class="cm">			 */</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">entry</span><span class="p">,</span> <span class="n">todo</span><span class="p">);</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">entry</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">release_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">end</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">todo</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">devres</span> <span class="o">*</span><span class="n">dr</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">cnt</span> <span class="o">=</span> <span class="n">remove_nodes</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">todo</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Release.  Note that both devres and devres_group are</span>
<span class="cm">	 * handled as devres in the following loop.  This is safe.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe_reverse</span><span class="p">(</span><span class="n">dr</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">todo</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">devres_log</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dr</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;REL&quot;</span><span class="p">);</span>
		<span class="n">dr</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * devres_release_all - Release all managed resources</span>
<span class="cm"> * @dev: Device to release resources for</span>
<span class="cm"> *</span>
<span class="cm"> * Release all resources associated with @dev.  This function is</span>
<span class="cm"> * called on driver detach.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">devres_release_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Looks like an uninitialized device structure */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_head</span><span class="p">.</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">release_nodes</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_head</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_head</span><span class="p">,</span>
			     <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * devres_open_group - Open a new devres group</span>
<span class="cm"> * @dev: Device to open devres group for</span>
<span class="cm"> * @id: Separator ID</span>
<span class="cm"> * @gfp: Allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * Open a new devres group for @dev with @id.  For @id, using a</span>
<span class="cm"> * pointer to an object which won&#39;t be used for another group is</span>
<span class="cm"> * recommended.  If @id is NULL, address-wise unique ID is created.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * ID of the new group, NULL on failure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">devres_open_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devres_group</span> <span class="o">*</span><span class="n">grp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">grp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">grp</span><span class="p">),</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">grp</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">release</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">group_open_release</span><span class="p">;</span>
	<span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">release</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">group_close_release</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">set_node_dbginfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;grp&lt;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">set_node_dbginfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;grp&gt;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">grp</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">grp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
		<span class="n">grp</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">add_dr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">grp</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">devres_open_group</span><span class="p">);</span>

<span class="cm">/* Find devres group with ID @id.  If @id is NULL, look for the latest. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">devres_group</span> <span class="o">*</span> <span class="nf">find_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devres_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_head</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">devres_group</span> <span class="o">*</span><span class="n">grp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">group_open_release</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">grp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">devres_group</span><span class="p">,</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">grp</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">entry</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">grp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * devres_close_group - Close a devres group</span>
<span class="cm"> * @dev: Device to close devres group for</span>
<span class="cm"> * @id: ID of target group, can be NULL</span>
<span class="cm"> *</span>
<span class="cm"> * Close the group identified by @id.  If @id is NULL, the latest open</span>
<span class="cm"> * group is selected.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">devres_close_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devres_group</span> <span class="o">*</span><span class="n">grp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">grp</span> <span class="o">=</span> <span class="n">find_group</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">grp</span><span class="p">)</span>
		<span class="n">add_dr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">devres_close_group</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * devres_remove_group - Remove a devres group</span>
<span class="cm"> * @dev: Device to remove group for</span>
<span class="cm"> * @id: ID of target group, can be NULL</span>
<span class="cm"> *</span>
<span class="cm"> * Remove the group identified by @id.  If @id is NULL, the latest</span>
<span class="cm"> * open group is selected.  Note that removing a group doesn&#39;t affect</span>
<span class="cm"> * any other resources.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">devres_remove_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devres_group</span> <span class="o">*</span><span class="n">grp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">grp</span> <span class="o">=</span> <span class="n">find_group</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">grp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">entry</span><span class="p">);</span>
		<span class="n">devres_log</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;REM&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">grp</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">devres_remove_group</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * devres_release_group - Release resources in a devres group</span>
<span class="cm"> * @dev: Device to release group for</span>
<span class="cm"> * @id: ID of target group, can be NULL</span>
<span class="cm"> *</span>
<span class="cm"> * Release all resources in the group identified by @id.  If @id is</span>
<span class="cm"> * NULL, the latest open group is selected.  The selected group and</span>
<span class="cm"> * groups properly nested inside the selected group are removed.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * The number of released non-group resources.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">devres_release_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devres_group</span> <span class="o">*</span><span class="n">grp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">grp</span> <span class="o">=</span> <span class="n">find_group</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">grp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">entry</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_head</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">entry</span><span class="p">))</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">grp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">entry</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

		<span class="n">cnt</span> <span class="o">=</span> <span class="n">release_nodes</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devres_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">devres_release_group</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Managed kzalloc/kfree</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">devm_kzalloc_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* noop */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">devm_kzalloc_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">res</span> <span class="o">==</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * devm_kzalloc - Resource-managed kzalloc</span>
<span class="cm"> * @dev: Device to allocate memory for</span>
<span class="cm"> * @size: Allocation size</span>
<span class="cm"> * @gfp: Allocation gfp flags</span>
<span class="cm"> *</span>
<span class="cm"> * Managed kzalloc.  Memory allocated with this function is</span>
<span class="cm"> * automatically freed on driver detach.  Like all other devres</span>
<span class="cm"> * resources, guaranteed alignment is unsigned long long.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to allocated memory on success, NULL on failure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">devm_kzalloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">devres</span> <span class="o">*</span><span class="n">dr</span><span class="p">;</span>

	<span class="cm">/* use raw alloc_dr for kmalloc caller tracing */</span>
	<span class="n">dr</span> <span class="o">=</span> <span class="n">alloc_dr</span><span class="p">(</span><span class="n">devm_kzalloc_release</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dr</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">set_node_dbginfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dr</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;devm_kzalloc_release&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">devres_add</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">devm_kzalloc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * devm_kfree - Resource-managed kfree</span>
<span class="cm"> * @dev: Device this memory belongs to</span>
<span class="cm"> * @p: Memory to free</span>
<span class="cm"> *</span>
<span class="cm"> * Free memory allocated with devm_kzalloc().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">devm_kfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">devres_destroy</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">devm_kzalloc_release</span><span class="p">,</span> <span class="n">devm_kzalloc_match</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">devm_kfree</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
