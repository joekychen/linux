<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › base › bus.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>bus.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * bus.c - bus driver management</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2002-3 Patrick Mochel</span>
<span class="cm"> * Copyright (c) 2002-3 Open Source Development Labs</span>
<span class="cm"> * Copyright (c) 2007 Greg Kroah-Hartman &lt;gregkh@suse.de&gt;</span>
<span class="cm"> * Copyright (c) 2007 Novell Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPLv2</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &quot;base.h&quot;</span>
<span class="cp">#include &quot;power/power.h&quot;</span>

<span class="cm">/* /sys/devices/system */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">system_kset</span><span class="p">;</span>

<span class="cp">#define to_bus_attr(_attr) container_of(_attr, struct bus_attribute, attr)</span>

<span class="cm">/*</span>
<span class="cm"> * sysfs bindings for drivers</span>
<span class="cm"> */</span>

<span class="cp">#define to_drv_attr(_attr) container_of(_attr, struct driver_attribute, attr)</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">bus_rescan_devices_helper</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="nf">bus_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kset_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">bus</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bus_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="p">)</span>
		<span class="n">kset_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">drv_attr_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_attribute</span> <span class="o">*</span><span class="n">drv_attr</span> <span class="o">=</span> <span class="n">to_drv_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">driver_private</span> <span class="o">*</span><span class="n">drv_priv</span> <span class="o">=</span> <span class="n">to_driver</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">drv_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">drv_priv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">drv_attr_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_attribute</span> <span class="o">*</span><span class="n">drv_attr</span> <span class="o">=</span> <span class="n">to_drv_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">driver_private</span> <span class="o">*</span><span class="n">drv_priv</span> <span class="o">=</span> <span class="n">to_driver</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">drv_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">drv_priv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sysfs_ops</span> <span class="n">driver_sysfs_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">drv_attr_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span>	<span class="o">=</span> <span class="n">drv_attr_store</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">driver_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_private</span> <span class="o">*</span><span class="n">drv_priv</span> <span class="o">=</span> <span class="n">to_driver</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;driver: &#39;%s&#39;: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">),</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">drv_priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">driver_ktype</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sysfs_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">driver_sysfs_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">driver_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * sysfs bindings for buses</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">bus_attr_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bus_attribute</span> <span class="o">*</span><span class="n">bus_attr</span> <span class="o">=</span> <span class="n">to_bus_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">subsys_private</span> <span class="o">*</span><span class="n">subsys_priv</span> <span class="o">=</span> <span class="n">to_subsys_private</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">bus_attr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">subsys_priv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">bus_attr_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bus_attribute</span> <span class="o">*</span><span class="n">bus_attr</span> <span class="o">=</span> <span class="n">to_bus_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">subsys_private</span> <span class="o">*</span><span class="n">subsys_priv</span> <span class="o">=</span> <span class="n">to_subsys_private</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">bus_attr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">subsys_priv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sysfs_ops</span> <span class="n">bus_sysfs_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">bus_attr_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span>	<span class="o">=</span> <span class="n">bus_attr_store</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">bus_create_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bus_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_get</span><span class="p">(</span><span class="n">bus</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">);</span>
		<span class="n">bus_put</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bus_create_file</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">bus_remove_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bus_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_get</span><span class="p">(</span><span class="n">bus</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sysfs_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">);</span>
		<span class="n">bus_put</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bus_remove_file</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">bus_ktype</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sysfs_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">bus_sysfs_ops</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bus_uevent_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">kset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobj_type</span> <span class="o">*</span><span class="n">ktype</span> <span class="o">=</span> <span class="n">get_ktype</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ktype</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">bus_ktype</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kset_uevent_ops</span> <span class="n">bus_uevent_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">bus_uevent_filter</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">bus_kset</span><span class="p">;</span>


<span class="cp">#ifdef CONFIG_HOTPLUG</span>
<span class="cm">/* Manually detach a device from its associated driver. */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">driver_unbind</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bus_get</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">bus_find_device_by_name</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">==</span> <span class="n">drv</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>	<span class="cm">/* Needed for USB */</span>
			<span class="n">device_lock</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="n">device_release_driver</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
			<span class="n">device_unlock</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">bus_put</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DRIVER_ATTR</span><span class="p">(</span><span class="n">unbind</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">driver_unbind</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Manually attach a device to a driver.</span>
<span class="cm"> * Note: the driver must want to bind to the device,</span>
<span class="cm"> * it is not possible to override the driver&#39;s id table.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">driver_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bus_get</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">bus_find_device_by_name</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">driver_match_device</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>	<span class="cm">/* Needed for USB */</span>
			<span class="n">device_lock</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="n">device_lock</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">driver_probe_device</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="n">device_unlock</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
			<span class="n">device_unlock</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* success */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* driver didn&#39;t accept device */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">bus_put</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DRIVER_ATTR</span><span class="p">(</span><span class="n">bind</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">driver_bind</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_drivers_autoprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">drivers_autoprobe</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_drivers_autoprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
		<span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">drivers_autoprobe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">drivers_autoprobe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_drivers_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">bus_find_device_by_name</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_rescan_devices_helper</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">next_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">klist_next</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_private</span> <span class="o">*</span><span class="n">dev_prv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_prv</span> <span class="o">=</span> <span class="n">to_device_private_bus</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_prv</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bus_for_each_dev - device iterator.</span>
<span class="cm"> * @bus: bus type.</span>
<span class="cm"> * @start: device to start iterating from.</span>
<span class="cm"> * @data: data for the callback.</span>
<span class="cm"> * @fn: function to be called for each device.</span>
<span class="cm"> *</span>
<span class="cm"> * Iterate over @bus&#39;s list of devices, and call @fn for each,</span>
<span class="cm"> * passing it @data. If @start is not NULL, we use that device to</span>
<span class="cm"> * begin iterating from.</span>
<span class="cm"> *</span>
<span class="cm"> * We check the return of @fn each time. If it returns anything</span>
<span class="cm"> * other than 0, we break out and return that value.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: The device that returns a non-zero value is not retained</span>
<span class="cm"> * in any way, nor is its refcount incremented. If the caller needs</span>
<span class="cm"> * to retain this data, it should do so, and increment the reference</span>
<span class="cm"> * count in the supplied callback.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bus_for_each_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist_iter</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">klist_iter_init_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">klist_devices</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">start</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">knode_bus</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">));</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">dev</span> <span class="o">=</span> <span class="n">next_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">klist_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bus_for_each_dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bus_find_device - device iterator for locating a particular device.</span>
<span class="cm"> * @bus: bus type</span>
<span class="cm"> * @start: Device to begin with</span>
<span class="cm"> * @data: Data to pass to match function</span>
<span class="cm"> * @match: Callback function to check device</span>
<span class="cm"> *</span>
<span class="cm"> * This is similar to the bus_for_each_dev() function above, but it</span>
<span class="cm"> * returns a reference to a device that is &#39;found&#39; for later use, as</span>
<span class="cm"> * determined by the @match callback.</span>
<span class="cm"> *</span>
<span class="cm"> * The callback should return 0 if the device doesn&#39;t match and non-zero</span>
<span class="cm"> * if it does.  If the callback returns non-zero, this function will</span>
<span class="cm"> * return to the caller and not iterate over any more devices.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">bus_find_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist_iter</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">klist_iter_init_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">klist_devices</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">start</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">knode_bus</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">));</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">dev</span> <span class="o">=</span> <span class="n">next_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">get_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="n">klist_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bus_find_device</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">match_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sysfs_streq</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bus_find_device_by_name - device iterator for locating a particular device of a specific name</span>
<span class="cm"> * @bus: bus type</span>
<span class="cm"> * @start: Device to begin with</span>
<span class="cm"> * @name: name of the device to match</span>
<span class="cm"> *</span>
<span class="cm"> * This is similar to the bus_find_device() function above, but it handles</span>
<span class="cm"> * searching by a name automatically, no need to write another strcmp matching</span>
<span class="cm"> * function.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">bus_find_device_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bus_find_device</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">name</span><span class="p">,</span> <span class="n">match_name</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bus_find_device_by_name</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * subsys_find_device_by_id - find a device with a specific enumeration number</span>
<span class="cm"> * @subsys: subsystem</span>
<span class="cm"> * @id: index &#39;id&#39; in struct device</span>
<span class="cm"> * @hint: device to check first</span>
<span class="cm"> *</span>
<span class="cm"> * Check the hint&#39;s next object and if it is a match return it directly,</span>
<span class="cm"> * otherwise, fall back to a full list search. Either way a reference for</span>
<span class="cm"> * the returned object is taken.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">subsys_find_device_by_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">subsys</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist_iter</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">subsys</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hint</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">klist_iter_init_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">klist_devices</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hint</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">knode_bus</span><span class="p">);</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">next_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span> <span class="o">&amp;&amp;</span> <span class="n">get_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">klist_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">klist_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">klist_iter_init_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">klist_devices</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">dev</span> <span class="o">=</span> <span class="n">next_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span> <span class="o">&amp;&amp;</span> <span class="n">get_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">klist_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">klist_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">subsys_find_device_by_id</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="nf">next_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">klist_next</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">driver_private</span> <span class="o">*</span><span class="n">drv_priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drv_priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">driver_private</span><span class="p">,</span> <span class="n">knode_bus</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">drv_priv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bus_for_each_drv - driver iterator</span>
<span class="cm"> * @bus: bus we&#39;re dealing with.</span>
<span class="cm"> * @start: driver to start iterating on.</span>
<span class="cm"> * @data: data to pass to the callback.</span>
<span class="cm"> * @fn: function to call for each driver.</span>
<span class="cm"> *</span>
<span class="cm"> * This is nearly identical to the device iterator above.</span>
<span class="cm"> * We iterate over each driver that belongs to @bus, and call</span>
<span class="cm"> * @fn for each. If @fn returns anything but 0, we break out</span>
<span class="cm"> * and return it. If @start is not NULL, we use it as the head</span>
<span class="cm"> * of the list.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: we don&#39;t return the driver that returns a non-zero</span>
<span class="cm"> * value, nor do we leave the reference count incremented for that</span>
<span class="cm"> * driver. If the caller needs to know that info, it must set it</span>
<span class="cm"> * in the callback. It must also be sure to increment the refcount</span>
<span class="cm"> * so it doesn&#39;t disappear before returning to the caller.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bus_for_each_drv</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist_iter</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">klist_iter_init_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">klist_drivers</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span>
			     <span class="n">start</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">knode_bus</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">drv</span> <span class="o">=</span> <span class="n">next_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">klist_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bus_for_each_drv</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">device_add_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_attrs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">attr_name</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">device_remove_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_attrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">attr_name</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bus_add_device - add device to bus</span>
<span class="cm"> * @dev: device being added</span>
<span class="cm"> *</span>
<span class="cm"> * - Add device&#39;s bus attributes.</span>
<span class="cm"> * - Create links to device&#39;s bus.</span>
<span class="cm"> * - Add the device to its bus&#39;s list of devices.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bus_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bus_get</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bus: &#39;%s&#39;: add device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">device_add_attrs</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">devices_kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_id</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="s">&quot;subsystem&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_subsys</span><span class="p">;</span>
		<span class="n">klist_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">knode_bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">klist_devices</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_subsys:</span>
	<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">devices_kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="nl">out_id:</span>
	<span class="n">device_remove_attrs</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="nl">out_put:</span>
	<span class="n">bus_put</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bus_probe_device - probe drivers for a new device</span>
<span class="cm"> * @dev: device to probe</span>
<span class="cm"> *</span>
<span class="cm"> * - Automatically probe for a driver if the bus allows it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bus_probe_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">subsys_interface</span> <span class="o">*</span><span class="n">sif</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">drivers_autoprobe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">device_attach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sif</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">interfaces</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sif</span><span class="o">-&gt;</span><span class="n">add_dev</span><span class="p">)</span>
			<span class="n">sif</span><span class="o">-&gt;</span><span class="n">add_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sif</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bus_remove_device - remove device from bus</span>
<span class="cm"> * @dev: device to be removed</span>
<span class="cm"> *</span>
<span class="cm"> * - Remove device from all interfaces.</span>
<span class="cm"> * - Remove symlink from bus&#39; directory.</span>
<span class="cm"> * - Delete device from bus&#39;s list.</span>
<span class="cm"> * - Detach from its driver.</span>
<span class="cm"> * - Drop reference taken in bus_add_device().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bus_remove_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">subsys_interface</span> <span class="o">*</span><span class="n">sif</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sif</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">interfaces</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sif</span><span class="o">-&gt;</span><span class="n">remove_dev</span><span class="p">)</span>
			<span class="n">sif</span><span class="o">-&gt;</span><span class="n">remove_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sif</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="s">&quot;subsystem&quot;</span><span class="p">);</span>
	<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">devices_kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
			  <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="n">device_remove_attrs</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">klist_node_attached</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">knode_bus</span><span class="p">))</span>
		<span class="n">klist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">knode_bus</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bus: &#39;%s&#39;: remove device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="n">device_release_driver</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">bus_put</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">driver_add_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">drv_attrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">attr_name</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">drv_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">driver_create_file</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">drv_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">driver_remove_file</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">drv_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">driver_remove_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">drv_attrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">attr_name</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">drv_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">driver_remove_file</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">drv_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HOTPLUG</span>
<span class="cm">/*</span>
<span class="cm"> * Thanks to drivers making their tables __devinit, we can&#39;t allow manual</span>
<span class="cm"> * bind and unbind from userspace unless CONFIG_HOTPLUG is enabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">add_bind_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">driver_create_file</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver_attr_unbind</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">driver_create_file</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver_attr_bind</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">driver_remove_file</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver_attr_unbind</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_bind_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">driver_remove_file</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver_attr_bind</span><span class="p">);</span>
	<span class="n">driver_remove_file</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver_attr_unbind</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">BUS_ATTR</span><span class="p">(</span><span class="n">drivers_probe</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">store_drivers_probe</span><span class="p">);</span>
<span class="k">static</span> <span class="n">BUS_ATTR</span><span class="p">(</span><span class="n">drivers_autoprobe</span><span class="p">,</span> <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		<span class="n">show_drivers_autoprobe</span><span class="p">,</span> <span class="n">store_drivers_autoprobe</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_probe_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">bus_create_file</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_attr_drivers_probe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">bus_create_file</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_attr_drivers_autoprobe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">bus_remove_file</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_attr_drivers_probe</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_probe_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bus_remove_file</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_attr_drivers_autoprobe</span><span class="p">);</span>
	<span class="n">bus_remove_file</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_attr_drivers_probe</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add_bind_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">remove_bind_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add_probe_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">remove_probe_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">driver_uevent_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">kobject_action</span> <span class="n">action</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kobject_action_type</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DRIVER_ATTR</span><span class="p">(</span><span class="n">uevent</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">driver_uevent_store</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bus_add_driver - Add a driver to the bus.</span>
<span class="cm"> * @drv: driver.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bus_add_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">driver_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bus</span> <span class="o">=</span> <span class="n">bus_get</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bus: &#39;%s&#39;: add driver %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">priv</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_put_bus</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">klist_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">klist_devices</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="n">drv</span><span class="p">;</span>
	<span class="n">drv</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">kset</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">drivers_kset</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">kobject_init_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver_ktype</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				     <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unregister</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">drivers_autoprobe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">driver_attach</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unregister</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">klist_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">knode_bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">klist_drivers</span><span class="p">);</span>
	<span class="n">module_add_driver</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">,</span> <span class="n">drv</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">driver_create_file</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver_attr_uevent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: uevent attr (%s) failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">driver_add_attrs</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">drv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* How the hell do we get out of this pickle? Give up */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: driver_add_attrs(%s) failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">suppress_bind_attrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">add_bind_files</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Ditto */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: add_bind_files(%s) failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unregister:</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
	<span class="n">drv</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out_put_bus:</span>
	<span class="n">bus_put</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bus_remove_driver - delete driver from bus&#39;s knowledge.</span>
<span class="cm"> * @drv: driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Detach the driver from the devices it controls, and remove</span>
<span class="cm"> * it from its bus&#39;s list of drivers. Finally, we drop the reference</span>
<span class="cm"> * to the bus we took in bus_add_driver().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bus_remove_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">suppress_bind_attrs</span><span class="p">)</span>
		<span class="n">remove_bind_files</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>
	<span class="n">driver_remove_attrs</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">drv</span><span class="p">);</span>
	<span class="n">driver_remove_file</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver_attr_uevent</span><span class="p">);</span>
	<span class="n">klist_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">knode_bus</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bus: &#39;%s&#39;: remove driver %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">driver_detach</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>
	<span class="n">module_remove_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
	<span class="n">bus_put</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Helper for bus_rescan_devices&#39;s iter */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">bus_rescan_devices_helper</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						  <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>	<span class="cm">/* Needed for USB */</span>
			<span class="n">device_lock</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">device_attach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
			<span class="n">device_unlock</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bus_rescan_devices - rescan devices on the bus for possible drivers</span>
<span class="cm"> * @bus: the bus to scan.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will look for devices on the bus with no driver</span>
<span class="cm"> * attached and rescan it against existing drivers to see if it matches</span>
<span class="cm"> * any by calling device_attach() for the unbound devices.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bus_rescan_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bus_for_each_dev</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">bus_rescan_devices_helper</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bus_rescan_devices</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * device_reprobe - remove driver for a device and probe for a new driver</span>
<span class="cm"> * @dev: the device to reprobe</span>
<span class="cm"> *</span>
<span class="cm"> * This function detaches the attached driver (if any) for the given</span>
<span class="cm"> * device and restarts the driver probing process.  It is intended</span>
<span class="cm"> * to use if probing criteria changed during a devices lifetime and</span>
<span class="cm"> * driver attachment should change accordingly.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">device_reprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>        <span class="cm">/* Needed for USB */</span>
			<span class="n">device_lock</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="n">device_release_driver</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
			<span class="n">device_unlock</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bus_rescan_devices_helper</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">device_reprobe</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * find_bus - locate bus by name.</span>
<span class="cm"> * @name: name of bus.</span>
<span class="cm"> *</span>
<span class="cm"> * Call kset_find_obj() to iterate over list of buses to</span>
<span class="cm"> * find a bus by name. Return bus if found.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that kset_find_obj increments bus&#39; reference count.</span>
<span class="cm"> */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">struct bus_type *find_bus(char *name)</span>
<span class="c">{</span>
<span class="c">	struct kobject *k = kset_find_obj(bus_kset, name);</span>
<span class="c">	return k ? to_bus(k) : NULL;</span>
<span class="c">}</span>
<span class="cp">#endif  /*  0  */</span>


<span class="cm">/**</span>
<span class="cm"> * bus_add_attrs - Add default attributes for this bus.</span>
<span class="cm"> * @bus: Bus that has just been registered.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bus_add_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_attrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">attr_name</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">bus_create_file</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">bus_remove_file</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bus_remove_attrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_attrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">attr_name</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">bus_remove_file</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">klist_devices_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_private</span> <span class="o">*</span><span class="n">dev_prv</span> <span class="o">=</span> <span class="n">to_device_private_bus</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_prv</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

	<span class="n">get_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">klist_devices_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_private</span> <span class="o">*</span><span class="n">dev_prv</span> <span class="o">=</span> <span class="n">to_device_private_bus</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_prv</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">bus_uevent_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">kobject_action</span> <span class="n">action</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kobject_action_type</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">action</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">BUS_ATTR</span><span class="p">(</span><span class="n">uevent</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">bus_uevent_store</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __bus_register - register a driver-core subsystem</span>
<span class="cm"> * @bus: bus to register</span>
<span class="cm"> * @key: lockdep class key</span>
<span class="cm"> *</span>
<span class="cm"> * Once we have that, we register the bus with the kobject</span>
<span class="cm"> * infrastructure, then register the children subsystems it has:</span>
<span class="cm"> * the devices and drivers that belong to the subsystem.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__bus_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">subsys_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">subsys_private</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="n">bus</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="n">BLOCKING_INIT_NOTIFIER_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">bus_notifier</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">kobject_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">.</span><span class="n">kobj</span><span class="p">.</span><span class="n">kset</span> <span class="o">=</span> <span class="n">bus_kset</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">.</span><span class="n">kobj</span><span class="p">.</span><span class="n">ktype</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bus_ktype</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">drivers_autoprobe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">kset_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">bus_create_file</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_attr_uevent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bus_uevent_fail</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">devices_kset</span> <span class="o">=</span> <span class="n">kset_create_and_add</span><span class="p">(</span><span class="s">&quot;devices&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">.</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">devices_kset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bus_devices_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">drivers_kset</span> <span class="o">=</span> <span class="n">kset_create_and_add</span><span class="p">(</span><span class="s">&quot;drivers&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">.</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">drivers_kset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bus_drivers_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">interfaces</span><span class="p">);</span>
	<span class="n">__mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">,</span> <span class="s">&quot;subsys mutex&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="n">klist_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">klist_devices</span><span class="p">,</span> <span class="n">klist_devices_get</span><span class="p">,</span> <span class="n">klist_devices_put</span><span class="p">);</span>
	<span class="n">klist_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">klist_drivers</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">add_probe_files</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bus_probe_files_fail</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">bus_add_attrs</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bus_attrs_fail</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bus: &#39;%s&#39;: registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bus_attrs_fail:</span>
	<span class="n">remove_probe_files</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
<span class="nl">bus_probe_files_fail:</span>
	<span class="n">kset_unregister</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">drivers_kset</span><span class="p">);</span>
<span class="nl">bus_drivers_fail:</span>
	<span class="n">kset_unregister</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">devices_kset</span><span class="p">);</span>
<span class="nl">bus_devices_fail:</span>
	<span class="n">bus_remove_file</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_attr_uevent</span><span class="p">);</span>
<span class="nl">bus_uevent_fail:</span>
	<span class="n">kset_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__bus_register</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bus_unregister - remove a bus from the system</span>
<span class="cm"> * @bus: bus.</span>
<span class="cm"> *</span>
<span class="cm"> * Unregister the child subsystems and the bus itself.</span>
<span class="cm"> * Finally, we call bus_put() to release the refcount</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bus_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bus: &#39;%s&#39;: unregistering</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="p">)</span>
		<span class="n">device_unregister</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="p">);</span>
	<span class="n">bus_remove_attrs</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="n">remove_probe_files</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>
	<span class="n">kset_unregister</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">drivers_kset</span><span class="p">);</span>
	<span class="n">kset_unregister</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">devices_kset</span><span class="p">);</span>
	<span class="n">bus_remove_file</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_attr_uevent</span><span class="p">);</span>
	<span class="n">kset_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bus_unregister</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">bus_register_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blocking_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bus_notifier</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bus_register_notifier</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">bus_unregister_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blocking_notifier_chain_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bus_notifier</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bus_unregister_notifier</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="nf">bus_get_kset</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bus_get_kset</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="nf">bus_get_device_klist</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">klist_devices</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bus_get_device_klist</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Yes, this forcibly breaks the klist abstraction temporarily.  It</span>
<span class="cm"> * just wants to sort the klist, not change reference counts and</span>
<span class="cm"> * take/drop locks rapidly in the process.  It does all this while</span>
<span class="cm"> * holding the lock for the list, so objects can&#39;t otherwise be</span>
<span class="cm"> * added/removed while we&#39;re swizzling.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">device_insertion_sort_klist</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
					<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
							<span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">b</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_private</span> <span class="o">*</span><span class="n">dev_prv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">klist_node</span><span class="p">,</span> <span class="n">n_node</span><span class="p">);</span>
		<span class="n">dev_prv</span> <span class="o">=</span> <span class="n">to_device_private_bus</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">dev_prv</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">compare</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">knode_bus</span><span class="p">.</span><span class="n">n_node</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">knode_bus</span><span class="p">.</span><span class="n">n_node</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">knode_bus</span><span class="p">.</span><span class="n">n_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bus_sort_breadthfirst</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">b</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">sorted_devices</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_private</span> <span class="o">*</span><span class="n">dev_prv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="n">device_klist</span><span class="p">;</span>

	<span class="n">device_klist</span> <span class="o">=</span> <span class="n">bus_get_device_klist</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_klist</span><span class="o">-&gt;</span><span class="n">k_lock</span><span class="p">);</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_klist</span><span class="o">-&gt;</span><span class="n">k_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">klist_node</span><span class="p">,</span> <span class="n">n_node</span><span class="p">);</span>
		<span class="n">dev_prv</span> <span class="o">=</span> <span class="n">to_device_private_bus</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_prv</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
		<span class="n">device_insertion_sort_klist</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sorted_devices</span><span class="p">,</span> <span class="n">compare</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sorted_devices</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_klist</span><span class="o">-&gt;</span><span class="n">k_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_klist</span><span class="o">-&gt;</span><span class="n">k_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bus_sort_breadthfirst</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * subsys_dev_iter_init - initialize subsys device iterator</span>
<span class="cm"> * @iter: subsys iterator to initialize</span>
<span class="cm"> * @subsys: the subsys we wanna iterate over</span>
<span class="cm"> * @start: the device to start iterating from, if any</span>
<span class="cm"> * @type: device_type of the devices to iterate over, NULL for all</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize subsys iterator @iter such that it iterates over devices</span>
<span class="cm"> * of @subsys.  If @start is set, the list iteration will start there,</span>
<span class="cm"> * otherwise if it is NULL, the iteration starts at the beginning of</span>
<span class="cm"> * the list.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">subsys_dev_iter_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">subsys_dev_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">subsys</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">start_knode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="p">)</span>
		<span class="n">start_knode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">knode_bus</span><span class="p">;</span>
	<span class="n">klist_iter_init_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">klist_devices</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">ki</span><span class="p">,</span> <span class="n">start_knode</span><span class="p">);</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">subsys_dev_iter_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * subsys_dev_iter_next - iterate to the next device</span>
<span class="cm"> * @iter: subsys iterator to proceed</span>
<span class="cm"> *</span>
<span class="cm"> * Proceed @iter to the next device and return it.  Returns NULL if</span>
<span class="cm"> * iteration is complete.</span>
<span class="cm"> *</span>
<span class="cm"> * The returned device is referenced and won&#39;t be released till</span>
<span class="cm"> * iterator is proceed to the next device or exited.  The caller is</span>
<span class="cm"> * free to do whatever it wants to do with the device including</span>
<span class="cm"> * calling back into subsys code.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">subsys_dev_iter_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">subsys_dev_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">knode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">knode</span> <span class="o">=</span> <span class="n">klist_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">ki</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">knode</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">knode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_private</span><span class="p">,</span> <span class="n">knode_bus</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">||</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">subsys_dev_iter_next</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * subsys_dev_iter_exit - finish iteration</span>
<span class="cm"> * @iter: subsys iterator to finish</span>
<span class="cm"> *</span>
<span class="cm"> * Finish an iteration.  Always call this function after iteration is</span>
<span class="cm"> * complete whether the iteration ran till the end or not.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">subsys_dev_iter_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">subsys_dev_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">klist_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">ki</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">subsys_dev_iter_exit</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">subsys_interface_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">subsys_interface</span> <span class="o">*</span><span class="n">sif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">subsys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">subsys_dev_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sif</span> <span class="o">||</span> <span class="o">!</span><span class="n">sif</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">subsys</span> <span class="o">=</span> <span class="n">bus_get</span><span class="p">(</span><span class="n">sif</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">subsys</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sif</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">interfaces</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sif</span><span class="o">-&gt;</span><span class="n">add_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">subsys_dev_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="n">subsys</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">dev</span> <span class="o">=</span> <span class="n">subsys_dev_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">)))</span>
			<span class="n">sif</span><span class="o">-&gt;</span><span class="n">add_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sif</span><span class="p">);</span>
		<span class="n">subsys_dev_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">subsys_interface_register</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">subsys_interface_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">subsys_interface</span> <span class="o">*</span><span class="n">sif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">subsys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">subsys_dev_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sif</span> <span class="o">||</span> <span class="o">!</span><span class="n">sif</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">subsys</span> <span class="o">=</span> <span class="n">sif</span><span class="o">-&gt;</span><span class="n">subsys</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sif</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sif</span><span class="o">-&gt;</span><span class="n">remove_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">subsys_dev_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="n">subsys</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">dev</span> <span class="o">=</span> <span class="n">subsys_dev_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">)))</span>
			<span class="n">sif</span><span class="o">-&gt;</span><span class="n">remove_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sif</span><span class="p">);</span>
		<span class="n">subsys_dev_iter_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subsys</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">bus_put</span><span class="p">(</span><span class="n">subsys</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">subsys_interface_unregister</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">system_root_device_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * subsys_system_register - register a subsystem at /sys/devices/system/</span>
<span class="cm"> * @subsys: system subsystem</span>
<span class="cm"> * @groups: default attributes for the root device</span>
<span class="cm"> *</span>
<span class="cm"> * All &#39;system&#39; subsystems have a /sys/devices/system/&lt;name&gt; root device</span>
<span class="cm"> * with the name of the subsystem. The root device can carry subsystem-</span>
<span class="cm"> * wide attributes. All registered devices are below this single root</span>
<span class="cm"> * device and are named after the subsystem with a simple enumeration</span>
<span class="cm"> * number appended. The registered devices are not explicitely named;</span>
<span class="cm"> * only &#39;id&#39; in the device needs to be set.</span>
<span class="cm"> *</span>
<span class="cm"> * Do not use this interface for anything new, it exists for compatibility</span>
<span class="cm"> * with bad ideas only. New subsystems should use plain subsystems; and</span>
<span class="cm"> * add the subsystem-wide attributes should be added to the subsystem</span>
<span class="cm"> * directory itself and not some create fake root-device placed in</span>
<span class="cm"> * /sys/devices/system/&lt;name&gt;.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">subsys_system_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">subsys</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">**</span><span class="n">groups</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">bus_register</span><span class="p">(</span><span class="n">subsys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dev_set_name</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">subsys</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_name</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">system_kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">groups</span> <span class="o">=</span> <span class="n">groups</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">=</span> <span class="n">system_root_device_release</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_dev_reg</span><span class="p">;</span>

	<span class="n">subsys</span><span class="o">-&gt;</span><span class="n">dev_root</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_dev_reg:</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">err_name:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">err_dev:</span>
	<span class="n">bus_unregister</span><span class="p">(</span><span class="n">subsys</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">subsys_system_register</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">buses_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bus_kset</span> <span class="o">=</span> <span class="n">kset_create_and_add</span><span class="p">(</span><span class="s">&quot;bus&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_uevent_ops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus_kset</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">system_kset</span> <span class="o">=</span> <span class="n">kset_create_and_add</span><span class="p">(</span><span class="s">&quot;system&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devices_kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">system_kset</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
