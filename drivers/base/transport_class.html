<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › base › transport_class.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>transport_class.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * transport_class.c - implementation of generic transport classes</span>
<span class="cm"> *                     using attribute_containers</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2005 - James Bottomley &lt;James.Bottomley@steeleye.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is licensed under GPLv2</span>
<span class="cm"> *</span>
<span class="cm"> * The basic idea here is to allow any &quot;device controller&quot; (which</span>
<span class="cm"> * would most often be a Host Bus Adapter to use the services of one</span>
<span class="cm"> * or more tranport classes for performing transport specific</span>
<span class="cm"> * services.  Transport specific services are things that the generic</span>
<span class="cm"> * command layer doesn&#39;t want to know about (speed settings, line</span>
<span class="cm"> * condidtioning, etc), but which the user might be interested in.</span>
<span class="cm"> * Thus, the HBA&#39;s use the routines exported by the transport classes</span>
<span class="cm"> * to perform these functions.  The transport classes export certain</span>
<span class="cm"> * values to the user via sysfs using attribute containers.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: because not every HBA will care about every transport</span>
<span class="cm"> * attribute, there&#39;s a many to one relationship that goes like this:</span>
<span class="cm"> *</span>
<span class="cm"> * transport class&lt;-----attribute container&lt;----class device</span>
<span class="cm"> *</span>
<span class="cm"> * Usually the attribute container is per-HBA, but the design doesn&#39;t</span>
<span class="cm"> * mandate that.  Although most of the services will be specific to</span>
<span class="cm"> * the actual external storage connection used by the HBA, the generic</span>
<span class="cm"> * transport class is framed entirely in terms of generic devices to</span>
<span class="cm"> * allow it to be used by any physical HBA in the system.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/attribute_container.h&gt;</span>
<span class="cp">#include &lt;linux/transport_class.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * transport_class_register - register an initial transport class</span>
<span class="cm"> *</span>
<span class="cm"> * @tclass:	a pointer to the transport class structure to be initialised</span>
<span class="cm"> *</span>
<span class="cm"> * The transport class contains an embedded class which is used to</span>
<span class="cm"> * identify it.  The caller should initialise this structure with</span>
<span class="cm"> * zeros and then generic class must have been initialised with the</span>
<span class="cm"> * actual transport class unique name.  There&#39;s a macro</span>
<span class="cm"> * DECLARE_TRANSPORT_CLASS() to do this (declared classes still must</span>
<span class="cm"> * be registered).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success or error on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">transport_class_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">transport_class</span> <span class="o">*</span><span class="n">tclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tclass</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">transport_class_register</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * transport_class_unregister - unregister a previously registered class</span>
<span class="cm"> *</span>
<span class="cm"> * @tclass: The transport class to unregister</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called prior to deallocating the memory for the transport</span>
<span class="cm"> * class.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">transport_class_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">transport_class</span> <span class="o">*</span><span class="n">tclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tclass</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">transport_class_unregister</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">anon_transport_dummy_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">transport_container</span> <span class="o">*</span><span class="n">tc</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* do nothing */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * anon_transport_class_register - register an anonymous class</span>
<span class="cm"> *</span>
<span class="cm"> * @atc: The anon transport class to register</span>
<span class="cm"> *</span>
<span class="cm"> * The anonymous transport class contains both a transport class and a</span>
<span class="cm"> * container.  The idea of an anonymous class is that it never</span>
<span class="cm"> * actually has any device attributes associated with it (and thus</span>
<span class="cm"> * saves on container storage).  So it can only be used for triggering</span>
<span class="cm"> * events.  Use prezero and then use DECLARE_ANON_TRANSPORT_CLASS() to</span>
<span class="cm"> * initialise the anon transport class storage.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">anon_transport_class_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_transport_class</span> <span class="o">*</span><span class="n">atc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">atc</span><span class="o">-&gt;</span><span class="n">container</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atc</span><span class="o">-&gt;</span><span class="n">tclass</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>
	<span class="n">attribute_container_set_no_classdevs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atc</span><span class="o">-&gt;</span><span class="n">container</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">attribute_container_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atc</span><span class="o">-&gt;</span><span class="n">container</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">atc</span><span class="o">-&gt;</span><span class="n">tclass</span><span class="p">.</span><span class="n">setup</span> <span class="o">=</span> <span class="n">anon_transport_dummy_function</span><span class="p">;</span>
	<span class="n">atc</span><span class="o">-&gt;</span><span class="n">tclass</span><span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">anon_transport_dummy_function</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">anon_transport_class_register</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * anon_transport_class_unregister - unregister an anon class</span>
<span class="cm"> *</span>
<span class="cm"> * @atc: Pointer to the anon transport class to unregister</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called prior to deallocating the memory for the anon</span>
<span class="cm"> * transport class.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">anon_transport_class_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_transport_class</span> <span class="o">*</span><span class="n">atc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">attribute_container_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atc</span><span class="o">-&gt;</span><span class="n">container</span><span class="p">)))</span>
		<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">anon_transport_class_unregister</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_setup_classdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">attribute_container</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">classdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">transport_class</span> <span class="o">*</span><span class="n">tclass</span> <span class="o">=</span> <span class="n">class_to_transport_class</span><span class="p">(</span><span class="n">cont</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">transport_container</span> <span class="o">*</span><span class="n">tcont</span> <span class="o">=</span> <span class="n">attribute_container_to_transport_container</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tclass</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">)</span>
		<span class="n">tclass</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="n">tcont</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">classdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * transport_setup_device - declare a new dev for transport class association but don&#39;t make it visible yet.</span>
<span class="cm"> * @dev: the generic device representing the entity being added</span>
<span class="cm"> *</span>
<span class="cm"> * Usually, dev represents some component in the HBA system (either</span>
<span class="cm"> * the HBA itself or a device remote across the HBA bus).  This</span>
<span class="cm"> * routine is simply a trigger point to see if any set of transport</span>
<span class="cm"> * classes wishes to associate with the added device.  This allocates</span>
<span class="cm"> * storage for the class device and initialises it, but does not yet</span>
<span class="cm"> * add it to the system or add attributes to it (you do this with</span>
<span class="cm"> * transport_add_device).  If you have no need for a separate setup</span>
<span class="cm"> * and add operations, use transport_register_device (see</span>
<span class="cm"> * transport_class.h).</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">transport_setup_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">attribute_container_add_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">transport_setup_classdev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">transport_setup_device</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_add_class_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">attribute_container</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">classdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">attribute_container_add_class_device</span><span class="p">(</span><span class="n">classdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">transport_container</span> <span class="o">*</span><span class="n">tcont</span> <span class="o">=</span> 
		<span class="n">attribute_container_to_transport_container</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">tcont</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">classdev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">tcont</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * transport_add_device - declare a new dev for transport class association</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: the generic device representing the entity being added</span>
<span class="cm"> *</span>
<span class="cm"> * Usually, dev represents some component in the HBA system (either</span>
<span class="cm"> * the HBA itself or a device remote across the HBA bus).  This</span>
<span class="cm"> * routine is simply a trigger point used to add the device to the</span>
<span class="cm"> * system and register attributes for it.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">transport_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">attribute_container_device_trigger</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">transport_add_class_device</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">transport_add_device</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">attribute_container</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">transport_class</span> <span class="o">*</span><span class="n">tclass</span> <span class="o">=</span> <span class="n">class_to_transport_class</span><span class="p">(</span><span class="n">cont</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">transport_container</span> <span class="o">*</span><span class="n">tcont</span> <span class="o">=</span> <span class="n">attribute_container_to_transport_container</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tclass</span><span class="o">-&gt;</span><span class="n">configure</span><span class="p">)</span>
		<span class="n">tclass</span><span class="o">-&gt;</span><span class="n">configure</span><span class="p">(</span><span class="n">tcont</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">cdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * transport_configure_device - configure an already set up device</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: generic device representing device to be configured</span>
<span class="cm"> *</span>
<span class="cm"> * The idea of configure is simply to provide a point within the setup</span>
<span class="cm"> * process to allow the transport class to extract information from a</span>
<span class="cm"> * device after it has been setup.  This is used in SCSI because we</span>
<span class="cm"> * have to have a setup device to begin using the HBA, but after we</span>
<span class="cm"> * send the initial inquiry, we use configure to extract the device</span>
<span class="cm"> * parameters.  The device need not have been added to be configured.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">transport_configure_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">attribute_container_device_trigger</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">transport_configure</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">transport_configure_device</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">transport_remove_classdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">attribute_container</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">classdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">transport_container</span> <span class="o">*</span><span class="n">tcont</span> <span class="o">=</span> 
		<span class="n">attribute_container_to_transport_container</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">transport_class</span> <span class="o">*</span><span class="n">tclass</span> <span class="o">=</span> <span class="n">class_to_transport_class</span><span class="p">(</span><span class="n">cont</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tclass</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">)</span>
		<span class="n">tclass</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">tcont</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">classdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tclass</span><span class="o">-&gt;</span><span class="n">remove</span> <span class="o">!=</span> <span class="n">anon_transport_dummy_function</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcont</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">)</span>
			<span class="n">sysfs_remove_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">classdev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">tcont</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">);</span>
		<span class="n">attribute_container_class_device_del</span><span class="p">(</span><span class="n">classdev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * transport_remove_device - remove the visibility of a device</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: generic device to remove</span>
<span class="cm"> *</span>
<span class="cm"> * This call removes the visibility of the device (to the user from</span>
<span class="cm"> * sysfs), but does not destroy it.  To eliminate a device entirely</span>
<span class="cm"> * you must also call transport_destroy_device.  If you don&#39;t need to</span>
<span class="cm"> * do remove and destroy as separate operations, use</span>
<span class="cm"> * transport_unregister_device() (see transport_class.h) which will</span>
<span class="cm"> * perform both calls for you.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">transport_remove_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">attribute_container_device_trigger</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">transport_remove_classdev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">transport_remove_device</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">transport_destroy_classdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">attribute_container</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">classdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">transport_class</span> <span class="o">*</span><span class="n">tclass</span> <span class="o">=</span> <span class="n">class_to_transport_class</span><span class="p">(</span><span class="n">cont</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tclass</span><span class="o">-&gt;</span><span class="n">remove</span> <span class="o">!=</span> <span class="n">anon_transport_dummy_function</span><span class="p">)</span>
		<span class="n">put_device</span><span class="p">(</span><span class="n">classdev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * transport_destroy_device - destroy a removed device</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: device to eliminate from the transport class.</span>
<span class="cm"> *</span>
<span class="cm"> * This call triggers the elimination of storage associated with the</span>
<span class="cm"> * transport classdev.  Note: all it really does is relinquish a</span>
<span class="cm"> * reference to the classdev.  The memory will not be freed until the</span>
<span class="cm"> * last reference goes to zero.  Note also that the classdev retains a</span>
<span class="cm"> * reference count on dev, so dev too will remain for as long as the</span>
<span class="cm"> * transport class device remains around.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">transport_destroy_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">attribute_container_remove_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">transport_destroy_classdev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">transport_destroy_device</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
