<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › base › power › opp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>opp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Generic OPP Interface</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009-2010 Texas Instruments Incorporated.</span>
<span class="cm"> *	Nishanth Menon</span>
<span class="cm"> *	Romit Dasgupta</span>
<span class="cm"> *	Kevin Hilman</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/cpufreq.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/rculist.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/opp.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Internal data structure organization with the OPP layer library is as</span>
<span class="cm"> * follows:</span>
<span class="cm"> * dev_opp_list (root)</span>
<span class="cm"> *	|- device 1 (represents voltage domain 1)</span>
<span class="cm"> *	|	|- opp 1 (availability, freq, voltage)</span>
<span class="cm"> *	|	|- opp 2 ..</span>
<span class="cm"> *	...	...</span>
<span class="cm"> *	|	`- opp n ..</span>
<span class="cm"> *	|- device 2 (represents the next voltage domain)</span>
<span class="cm"> *	...</span>
<span class="cm"> *	`- device m (represents mth voltage domain)</span>
<span class="cm"> * device 1, 2.. are represented by dev_opp structure while each opp</span>
<span class="cm"> * is represented by the opp structure.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct opp - Generic OPP description structure</span>
<span class="cm"> * @node:	opp list node. The nodes are maintained throughout the lifetime</span>
<span class="cm"> *		of boot. It is expected only an optimal set of OPPs are</span>
<span class="cm"> *		added to the library by the SoC framework.</span>
<span class="cm"> *		RCU usage: opp list is traversed with RCU locks. node</span>
<span class="cm"> *		modification is possible realtime, hence the modifications</span>
<span class="cm"> *		are protected by the dev_opp_list_lock for integrity.</span>
<span class="cm"> *		IMPORTANT: the opp nodes should be maintained in increasing</span>
<span class="cm"> *		order.</span>
<span class="cm"> * @available:	true/false - marks if this OPP as available or not</span>
<span class="cm"> * @rate:	Frequency in hertz</span>
<span class="cm"> * @u_volt:	Nominal voltage in microvolts corresponding to this OPP</span>
<span class="cm"> * @dev_opp:	points back to the device_opp struct this opp belongs to</span>
<span class="cm"> *</span>
<span class="cm"> * This structure stores the OPP information for a given device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">opp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">available</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">u_volt</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device_opp</span> <span class="o">*</span><span class="n">dev_opp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct device_opp - Device opp structure</span>
<span class="cm"> * @node:	list node - contains the devices with OPPs that</span>
<span class="cm"> *		have been registered. Nodes once added are not modified in this</span>
<span class="cm"> *		list.</span>
<span class="cm"> *		RCU usage: nodes are not modified in the list of device_opp,</span>
<span class="cm"> *		however addition is possible and is secured by dev_opp_list_lock</span>
<span class="cm"> * @dev:	device pointer</span>
<span class="cm"> * @head:	notifier head to notify the OPP availability changes.</span>
<span class="cm"> * @opp_list:	list of opps</span>
<span class="cm"> *</span>
<span class="cm"> * This is an internal data structure maintaining the link to opps attached to</span>
<span class="cm"> * a device. This structure is not meant to be shared to users as it is</span>
<span class="cm"> * meant for book keeping and private to OPP library</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_opp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">srcu_notifier_head</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">opp_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The root of the list of all devices. All device_opp structures branch off</span>
<span class="cm"> * from here, with each device_opp containing the list of opp it supports in</span>
<span class="cm"> * various states of availability.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">dev_opp_list</span><span class="p">);</span>
<span class="cm">/* Lock to allow exclusive modification to the device and opp lists */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">dev_opp_list_lock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * find_device_opp() - find device_opp struct using device pointer</span>
<span class="cm"> * @dev:	device pointer used to lookup device OPPs</span>
<span class="cm"> *</span>
<span class="cm"> * Search list of device OPPs for one containing matching device. Does a RCU</span>
<span class="cm"> * reader operation to grab the pointer needed.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns pointer to &#39;struct device_opp&#39; if found, otherwise -ENODEV or</span>
<span class="cm"> * -EINVAL based on type of error.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: This function must be called under rcu_read_lock(). device_opp</span>
<span class="cm"> * is a RCU protected pointer. This means that device_opp is valid as long</span>
<span class="cm"> * as we are under RCU lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_opp</span> <span class="o">*</span><span class="nf">find_device_opp</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_opp</span> <span class="o">*</span><span class="n">tmp_dev_opp</span><span class="p">,</span> <span class="o">*</span><span class="n">dev_opp</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Invalid parameters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">tmp_dev_opp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_opp_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_dev_opp</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_opp</span> <span class="o">=</span> <span class="n">tmp_dev_opp</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dev_opp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * opp_get_voltage() - Gets the voltage corresponding to an available opp</span>
<span class="cm"> * @opp:	opp for which voltage has to be returned for</span>
<span class="cm"> *</span>
<span class="cm"> * Return voltage in micro volt corresponding to the opp, else</span>
<span class="cm"> * return 0</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: This function must be called under rcu_read_lock(). opp is a rcu</span>
<span class="cm"> * protected pointer. This means that opp which could have been fetched by</span>
<span class="cm"> * opp_find_freq_{exact,ceil,floor} functions is valid as long as we are</span>
<span class="cm"> * under RCU lock. The pointer returned by the opp_find_freq family must be</span>
<span class="cm"> * used in the same section as the usage of this function with the pointer</span>
<span class="cm"> * prior to unlocking with rcu_read_unlock() to maintain the integrity of the</span>
<span class="cm"> * pointer.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">opp_get_voltage</span><span class="p">(</span><span class="k">struct</span> <span class="n">opp</span> <span class="o">*</span><span class="n">opp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">opp</span> <span class="o">*</span><span class="n">tmp_opp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tmp_opp</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">opp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">tmp_opp</span><span class="p">))</span> <span class="o">||</span> <span class="o">!</span><span class="n">tmp_opp</span><span class="o">-&gt;</span><span class="n">available</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Invalid parameters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">tmp_opp</span><span class="o">-&gt;</span><span class="n">u_volt</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * opp_get_freq() - Gets the frequency corresponding to an available opp</span>
<span class="cm"> * @opp:	opp for which frequency has to be returned for</span>
<span class="cm"> *</span>
<span class="cm"> * Return frequency in hertz corresponding to the opp, else</span>
<span class="cm"> * return 0</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: This function must be called under rcu_read_lock(). opp is a rcu</span>
<span class="cm"> * protected pointer. This means that opp which could have been fetched by</span>
<span class="cm"> * opp_find_freq_{exact,ceil,floor} functions is valid as long as we are</span>
<span class="cm"> * under RCU lock. The pointer returned by the opp_find_freq family must be</span>
<span class="cm"> * used in the same section as the usage of this function with the pointer</span>
<span class="cm"> * prior to unlocking with rcu_read_unlock() to maintain the integrity of the</span>
<span class="cm"> * pointer.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">opp_get_freq</span><span class="p">(</span><span class="k">struct</span> <span class="n">opp</span> <span class="o">*</span><span class="n">opp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">opp</span> <span class="o">*</span><span class="n">tmp_opp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tmp_opp</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">opp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">tmp_opp</span><span class="p">))</span> <span class="o">||</span> <span class="o">!</span><span class="n">tmp_opp</span><span class="o">-&gt;</span><span class="n">available</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Invalid parameters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">f</span> <span class="o">=</span> <span class="n">tmp_opp</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * opp_get_opp_count() - Get number of opps available in the opp list</span>
<span class="cm"> * @dev:	device for which we do this operation</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of available opps if there are any,</span>
<span class="cm"> * else returns 0 if none or the corresponding error value.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: This function must be called under rcu_read_lock(). This function</span>
<span class="cm"> * internally references two RCU protected structures: device_opp and opp which</span>
<span class="cm"> * are safe as long as we are under a common RCU locked section.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">opp_get_opp_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_opp</span> <span class="o">*</span><span class="n">dev_opp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">opp</span> <span class="o">*</span><span class="n">temp_opp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_opp</span> <span class="o">=</span> <span class="n">find_device_opp</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev_opp</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dev_opp</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: device OPP not found (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">temp_opp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_opp</span><span class="o">-&gt;</span><span class="n">opp_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp_opp</span><span class="o">-&gt;</span><span class="n">available</span><span class="p">)</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * opp_find_freq_exact() - search for an exact frequency</span>
<span class="cm"> * @dev:		device for which we do this operation</span>
<span class="cm"> * @freq:		frequency to search for</span>
<span class="cm"> * @available:		true/false - match for available opp</span>
<span class="cm"> *</span>
<span class="cm"> * Searches for exact match in the opp list and returns pointer to the matching</span>
<span class="cm"> * opp if found, else returns ERR_PTR in case of error and should be handled</span>
<span class="cm"> * using IS_ERR.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: available is a modifier for the search. if available=true, then the</span>
<span class="cm"> * match is for exact matching frequency and is available in the stored OPP</span>
<span class="cm"> * table. if false, the match is for exact frequency which is not available.</span>
<span class="cm"> *</span>
<span class="cm"> * This provides a mechanism to enable an opp which is not available currently</span>
<span class="cm"> * or the opposite as well.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: This function must be called under rcu_read_lock(). opp is a rcu</span>
<span class="cm"> * protected pointer. The reason for the same is that the opp pointer which is</span>
<span class="cm"> * returned will remain valid for use with opp_get_{voltage, freq} only while</span>
<span class="cm"> * under the locked area. The pointer returned must be used prior to unlocking</span>
<span class="cm"> * with rcu_read_unlock() to maintain the integrity of the pointer.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">opp</span> <span class="o">*</span><span class="nf">opp_find_freq_exact</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freq</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">available</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_opp</span> <span class="o">*</span><span class="n">dev_opp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">opp</span> <span class="o">*</span><span class="n">temp_opp</span><span class="p">,</span> <span class="o">*</span><span class="n">opp</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="n">dev_opp</span> <span class="o">=</span> <span class="n">find_device_opp</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev_opp</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dev_opp</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: device OPP not found (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">temp_opp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_opp</span><span class="o">-&gt;</span><span class="n">opp_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp_opp</span><span class="o">-&gt;</span><span class="n">available</span> <span class="o">==</span> <span class="n">available</span> <span class="o">&amp;&amp;</span>
				<span class="n">temp_opp</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">==</span> <span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">opp</span> <span class="o">=</span> <span class="n">temp_opp</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">opp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * opp_find_freq_ceil() - Search for an rounded ceil freq</span>
<span class="cm"> * @dev:	device for which we do this operation</span>
<span class="cm"> * @freq:	Start frequency</span>
<span class="cm"> *</span>
<span class="cm"> * Search for the matching ceil *available* OPP from a starting freq</span>
<span class="cm"> * for a device.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns matching *opp and refreshes *freq accordingly, else returns</span>
<span class="cm"> * ERR_PTR in case of error and should be handled using IS_ERR.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: This function must be called under rcu_read_lock(). opp is a rcu</span>
<span class="cm"> * protected pointer. The reason for the same is that the opp pointer which is</span>
<span class="cm"> * returned will remain valid for use with opp_get_{voltage, freq} only while</span>
<span class="cm"> * under the locked area. The pointer returned must be used prior to unlocking</span>
<span class="cm"> * with rcu_read_unlock() to maintain the integrity of the pointer.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">opp</span> <span class="o">*</span><span class="nf">opp_find_freq_ceil</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_opp</span> <span class="o">*</span><span class="n">dev_opp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">opp</span> <span class="o">*</span><span class="n">temp_opp</span><span class="p">,</span> <span class="o">*</span><span class="n">opp</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Invalid argument freq=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_opp</span> <span class="o">=</span> <span class="n">find_device_opp</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev_opp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">opp</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">temp_opp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_opp</span><span class="o">-&gt;</span><span class="n">opp_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp_opp</span><span class="o">-&gt;</span><span class="n">available</span> <span class="o">&amp;&amp;</span> <span class="n">temp_opp</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">&gt;=</span> <span class="o">*</span><span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">opp</span> <span class="o">=</span> <span class="n">temp_opp</span><span class="p">;</span>
			<span class="o">*</span><span class="n">freq</span> <span class="o">=</span> <span class="n">opp</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">opp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * opp_find_freq_floor() - Search for a rounded floor freq</span>
<span class="cm"> * @dev:	device for which we do this operation</span>
<span class="cm"> * @freq:	Start frequency</span>
<span class="cm"> *</span>
<span class="cm"> * Search for the matching floor *available* OPP from a starting freq</span>
<span class="cm"> * for a device.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns matching *opp and refreshes *freq accordingly, else returns</span>
<span class="cm"> * ERR_PTR in case of error and should be handled using IS_ERR.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: This function must be called under rcu_read_lock(). opp is a rcu</span>
<span class="cm"> * protected pointer. The reason for the same is that the opp pointer which is</span>
<span class="cm"> * returned will remain valid for use with opp_get_{voltage, freq} only while</span>
<span class="cm"> * under the locked area. The pointer returned must be used prior to unlocking</span>
<span class="cm"> * with rcu_read_unlock() to maintain the integrity of the pointer.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">opp</span> <span class="o">*</span><span class="nf">opp_find_freq_floor</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_opp</span> <span class="o">*</span><span class="n">dev_opp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">opp</span> <span class="o">*</span><span class="n">temp_opp</span><span class="p">,</span> <span class="o">*</span><span class="n">opp</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Invalid argument freq=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_opp</span> <span class="o">=</span> <span class="n">find_device_opp</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev_opp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">opp</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">temp_opp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_opp</span><span class="o">-&gt;</span><span class="n">opp_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp_opp</span><span class="o">-&gt;</span><span class="n">available</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* go to the next node, before choosing prev */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">temp_opp</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">freq</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">opp</span> <span class="o">=</span> <span class="n">temp_opp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">opp</span><span class="p">))</span>
		<span class="o">*</span><span class="n">freq</span> <span class="o">=</span> <span class="n">opp</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">opp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * opp_add()  - Add an OPP table from a table definitions</span>
<span class="cm"> * @dev:	device for which we do this operation</span>
<span class="cm"> * @freq:	Frequency in Hz for this OPP</span>
<span class="cm"> * @u_volt:	Voltage in uVolts for this OPP</span>
<span class="cm"> *</span>
<span class="cm"> * This function adds an opp definition to the opp list and returns status.</span>
<span class="cm"> * The opp is made available by default and it can be controlled using</span>
<span class="cm"> * opp_enable/disable functions.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: The internal device_opp and opp structures are RCU protected.</span>
<span class="cm"> * Hence this function internally uses RCU updater strategy with mutex locks</span>
<span class="cm"> * to keep the integrity of the internal data structures. Callers should ensure</span>
<span class="cm"> * that this function is *NOT* called under RCU protection or in contexts where</span>
<span class="cm"> * mutex cannot be locked.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">opp_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">u_volt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_opp</span> <span class="o">*</span><span class="n">dev_opp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">opp</span> <span class="o">*</span><span class="n">opp</span><span class="p">,</span> <span class="o">*</span><span class="n">new_opp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="cm">/* allocate new OPP node */</span>
	<span class="n">new_opp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">opp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_opp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Unable to create new OPP node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Hold our list modification lock here */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_opp_list_lock</span><span class="p">);</span>

	<span class="cm">/* Check for existing list for &#39;dev&#39; */</span>
	<span class="n">dev_opp</span> <span class="o">=</span> <span class="n">find_device_opp</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev_opp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Allocate a new device OPP table. In the infrequent case</span>
<span class="cm">		 * where a new device is needed to be added, we pay this</span>
<span class="cm">		 * penalty.</span>
<span class="cm">		 */</span>
		<span class="n">dev_opp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_opp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_opp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_opp_list_lock</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">new_opp</span><span class="p">);</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s: Unable to create device OPP structure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev_opp</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="n">srcu_init_notifier_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_opp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_opp</span><span class="o">-&gt;</span><span class="n">opp_list</span><span class="p">);</span>

		<span class="cm">/* Secure the device list modification */</span>
		<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_opp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_opp_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* populate the opp table */</span>
	<span class="n">new_opp</span><span class="o">-&gt;</span><span class="n">dev_opp</span> <span class="o">=</span> <span class="n">dev_opp</span><span class="p">;</span>
	<span class="n">new_opp</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">=</span> <span class="n">freq</span><span class="p">;</span>
	<span class="n">new_opp</span><span class="o">-&gt;</span><span class="n">u_volt</span> <span class="o">=</span> <span class="n">u_volt</span><span class="p">;</span>
	<span class="n">new_opp</span><span class="o">-&gt;</span><span class="n">available</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Insert new OPP in order of increasing frequency */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_opp</span><span class="o">-&gt;</span><span class="n">opp_list</span><span class="p">;</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">opp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_opp</span><span class="o">-&gt;</span><span class="n">opp_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_opp</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">&lt;</span> <span class="n">opp</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">opp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_opp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_opp_list_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Notify the changes in the availability of the operable</span>
<span class="cm">	 * frequency/voltage list.</span>
<span class="cm">	 */</span>
	<span class="n">srcu_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_opp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">OPP_EVENT_ADD</span><span class="p">,</span> <span class="n">new_opp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * opp_set_availability() - helper to set the availability of an opp</span>
<span class="cm"> * @dev:		device for which we do this operation</span>
<span class="cm"> * @freq:		OPP frequency to modify availability</span>
<span class="cm"> * @availability_req:	availability status requested for this opp</span>
<span class="cm"> *</span>
<span class="cm"> * Set the availability of an OPP with an RCU operation, opp_{enable,disable}</span>
<span class="cm"> * share a common logic which is isolated here.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -EINVAL for bad pointers, -ENOMEM if no memory available for the</span>
<span class="cm"> * copy operation, returns 0 if no modifcation was done OR modification was</span>
<span class="cm"> * successful.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: The internal device_opp and opp structures are RCU protected.</span>
<span class="cm"> * Hence this function internally uses RCU updater strategy with mutex locks to</span>
<span class="cm"> * keep the integrity of the internal data structures. Callers should ensure</span>
<span class="cm"> * that this function is *NOT* called under RCU protection or in contexts where</span>
<span class="cm"> * mutex locking or synchronize_rcu() blocking calls cannot be used.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">opp_set_availability</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freq</span><span class="p">,</span>
		<span class="n">bool</span> <span class="n">availability_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_opp</span> <span class="o">*</span><span class="n">tmp_dev_opp</span><span class="p">,</span> <span class="o">*</span><span class="n">dev_opp</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">opp</span> <span class="o">*</span><span class="n">new_opp</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_opp</span><span class="p">,</span> <span class="o">*</span><span class="n">opp</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* keep the node allocated */</span>
	<span class="n">new_opp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">opp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_opp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Unable to create OPP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_opp_list_lock</span><span class="p">);</span>

	<span class="cm">/* Find the device_opp */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">tmp_dev_opp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_opp_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="n">tmp_dev_opp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_opp</span> <span class="o">=</span> <span class="n">tmp_dev_opp</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev_opp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dev_opp</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Device OPP not found (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do we have the frequency? */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">tmp_opp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_opp</span><span class="o">-&gt;</span><span class="n">opp_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_opp</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">==</span> <span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">opp</span> <span class="o">=</span> <span class="n">tmp_opp</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">opp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">opp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is update really needed? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opp</span><span class="o">-&gt;</span><span class="n">available</span> <span class="o">==</span> <span class="n">availability_req</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="cm">/* copy the old data over */</span>
	<span class="o">*</span><span class="n">new_opp</span> <span class="o">=</span> <span class="o">*</span><span class="n">opp</span><span class="p">;</span>

	<span class="cm">/* plug in new node */</span>
	<span class="n">new_opp</span><span class="o">-&gt;</span><span class="n">available</span> <span class="o">=</span> <span class="n">availability_req</span><span class="p">;</span>

	<span class="n">list_replace_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_opp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_opp_list_lock</span><span class="p">);</span>
	<span class="n">synchronize_rcu</span><span class="p">();</span>

	<span class="cm">/* Notify the change of the OPP availability */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">availability_req</span><span class="p">)</span>
		<span class="n">srcu_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_opp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">OPP_EVENT_ENABLE</span><span class="p">,</span>
					 <span class="n">new_opp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">srcu_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_opp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">OPP_EVENT_DISABLE</span><span class="p">,</span>
					 <span class="n">new_opp</span><span class="p">);</span>

	<span class="cm">/* clean up old opp */</span>
	<span class="n">new_opp</span> <span class="o">=</span> <span class="n">opp</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_opp_list_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">new_opp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * opp_enable() - Enable a specific OPP</span>
<span class="cm"> * @dev:	device for which we do this operation</span>
<span class="cm"> * @freq:	OPP frequency to enable</span>
<span class="cm"> *</span>
<span class="cm"> * Enables a provided opp. If the operation is valid, this returns 0, else the</span>
<span class="cm"> * corresponding error value. It is meant to be used for users an OPP available</span>
<span class="cm"> * after being temporarily made unavailable with opp_disable.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: The internal device_opp and opp structures are RCU protected.</span>
<span class="cm"> * Hence this function indirectly uses RCU and mutex locks to keep the</span>
<span class="cm"> * integrity of the internal data structures. Callers should ensure that</span>
<span class="cm"> * this function is *NOT* called under RCU protection or in contexts where</span>
<span class="cm"> * mutex locking or synchronize_rcu() blocking calls cannot be used.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">opp_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">opp_set_availability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * opp_disable() - Disable a specific OPP</span>
<span class="cm"> * @dev:	device for which we do this operation</span>
<span class="cm"> * @freq:	OPP frequency to disable</span>
<span class="cm"> *</span>
<span class="cm"> * Disables a provided opp. If the operation is valid, this returns</span>
<span class="cm"> * 0, else the corresponding error value. It is meant to be a temporary</span>
<span class="cm"> * control by users to make this OPP not available until the circumstances are</span>
<span class="cm"> * right to make it available again (with a call to opp_enable).</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: The internal device_opp and opp structures are RCU protected.</span>
<span class="cm"> * Hence this function indirectly uses RCU and mutex locks to keep the</span>
<span class="cm"> * integrity of the internal data structures. Callers should ensure that</span>
<span class="cm"> * this function is *NOT* called under RCU protection or in contexts where</span>
<span class="cm"> * mutex locking or synchronize_rcu() blocking calls cannot be used.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">opp_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">opp_set_availability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CPU_FREQ</span>
<span class="cm">/**</span>
<span class="cm"> * opp_init_cpufreq_table() - create a cpufreq table for a device</span>
<span class="cm"> * @dev:	device for which we do this operation</span>
<span class="cm"> * @table:	Cpufreq table returned back to caller</span>
<span class="cm"> *</span>
<span class="cm"> * Generate a cpufreq table for a provided device- this assumes that the</span>
<span class="cm"> * opp list is already initialized and ready for usage.</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates required memory for the cpufreq table. It is</span>
<span class="cm"> * expected that the caller does the required maintenance such as freeing</span>
<span class="cm"> * the table as required.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -EINVAL for bad pointers, -ENODEV if the device is not found, -ENOMEM</span>
<span class="cm"> * if no memory available for the operation (table is not populated), returns 0</span>
<span class="cm"> * if successful and table is populated.</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING: It is  important for the callers to ensure refreshing their copy of</span>
<span class="cm"> * the table if any of the mentioned functions have been invoked in the interim.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: The internal device_opp and opp structures are RCU protected.</span>
<span class="cm"> * To simplify the logic, we pretend we are updater and hold relevant mutex here</span>
<span class="cm"> * Callers should ensure that this function is *NOT* called under RCU protection</span>
<span class="cm"> * or in contexts where mutex locking cannot be used.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">opp_init_cpufreq_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">cpufreq_frequency_table</span> <span class="o">**</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_opp</span> <span class="o">*</span><span class="n">dev_opp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">opp</span> <span class="o">*</span><span class="n">opp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpufreq_frequency_table</span> <span class="o">*</span><span class="n">freq_table</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Pretend as if I am an updater */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_opp_list_lock</span><span class="p">);</span>

	<span class="n">dev_opp</span> <span class="o">=</span> <span class="n">find_device_opp</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev_opp</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dev_opp</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_opp_list_lock</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Device OPP not found (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">freq_table</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpufreq_frequency_table</span><span class="p">)</span> <span class="o">*</span>
			     <span class="p">(</span><span class="n">opp_get_opp_count</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">freq_table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_opp_list_lock</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Unable to allocate frequency table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">opp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_opp</span><span class="o">-&gt;</span><span class="n">opp_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">opp</span><span class="o">-&gt;</span><span class="n">available</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">freq_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">freq_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">frequency</span> <span class="o">=</span> <span class="n">opp</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_opp_list_lock</span><span class="p">);</span>

	<span class="n">freq_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">freq_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">frequency</span> <span class="o">=</span> <span class="n">CPUFREQ_TABLE_END</span><span class="p">;</span>

	<span class="o">*</span><span class="n">table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">freq_table</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * opp_free_cpufreq_table() - free the cpufreq table</span>
<span class="cm"> * @dev:	device for which we do this operation</span>
<span class="cm"> * @table:	table to free</span>
<span class="cm"> *</span>
<span class="cm"> * Free up the table allocated by opp_init_cpufreq_table</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">opp_free_cpufreq_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">cpufreq_frequency_table</span> <span class="o">**</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">table</span><span class="p">);</span>
	<span class="o">*</span><span class="n">table</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif		</span><span class="cm">/* CONFIG_CPU_FREQ */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * opp_get_notifier() - find notifier_head of the device with opp</span>
<span class="cm"> * @dev:	device pointer used to lookup device OPPs.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">srcu_notifier_head</span> <span class="o">*</span><span class="nf">opp_get_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_opp</span> <span class="o">*</span><span class="n">dev_opp</span> <span class="o">=</span> <span class="n">find_device_opp</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev_opp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">dev_opp</span><span class="p">);</span> <span class="cm">/* matching type */</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">dev_opp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
