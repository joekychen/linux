<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › base › dma-buf.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dma-buf.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Framework for buffer objects that can be shared across devices/subsystems.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(C) 2011 Linaro Limited. All rights reserved.</span>
<span class="cm"> * Author: Sumit Semwal &lt;sumit.semwal@ti.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Many thanks to linaro-mm-sig list, and specially</span>
<span class="cm"> * Arnd Bergmann &lt;arnd@arndb.de&gt;, Rob Clark &lt;rob@ti.com&gt; and</span>
<span class="cm"> * Daniel Vetter &lt;daniel@ffwll.ch&gt; for their support in creation and</span>
<span class="cm"> * refining of this idea.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/dma-buf.h&gt;</span>
<span class="cp">#include &lt;linux/anon_inodes.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">is_dma_buf_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dma_buf_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_dma_buf_file</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dmabuf</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dma_buf_mmap_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_dma_buf_file</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dmabuf</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="cm">/* check for overflowing the buffer&#39;s size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">+</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&gt;</span>
	    <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">dma_buf_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">dma_buf_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>		<span class="o">=</span> <span class="n">dma_buf_mmap_internal</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * is_dma_buf_file - Check if struct file* is associated with dma_buf</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_dma_buf_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dma_buf_fops</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dma_buf_export - Creates a new dma_buf, and associates an anon file</span>
<span class="cm"> * with this buffer, so it can be exported.</span>
<span class="cm"> * Also connect the allocator specific data and ops to the buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * @priv:	[in]	Attach private data of allocator to this buffer</span>
<span class="cm"> * @ops:	[in]	Attach allocator-defined dma buf ops to the new buffer.</span>
<span class="cm"> * @size:	[in]	Size of the buffer</span>
<span class="cm"> * @flags:	[in]	mode flags for the file.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns, on success, a newly created dma_buf object, which wraps the</span>
<span class="cm"> * supplied private data and operations for dma_buf_ops. On either missing</span>
<span class="cm"> * ops, or error in allocating struct dma_buf, will return negative error.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="nf">dma_buf_export</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dma_buf_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">priv</span> <span class="o">||</span> <span class="o">!</span><span class="n">ops</span>
			  <span class="o">||</span> <span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">map_dma_buf</span>
			  <span class="o">||</span> <span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">unmap_dma_buf</span>
			  <span class="o">||</span> <span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">release</span>
			  <span class="o">||</span> <span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">kmap_atomic</span>
			  <span class="o">||</span> <span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">kmap</span>
			  <span class="o">||</span> <span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dmabuf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dmabuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>
	<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">anon_inode_getfile</span><span class="p">(</span><span class="s">&quot;dmabuf&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_buf_fops</span><span class="p">,</span> <span class="n">dmabuf</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">attachments</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dmabuf</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_export</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * dma_buf_fd - returns a file descriptor for the given dma_buf</span>
<span class="cm"> * @dmabuf:	[in]	pointer to dma_buf for which fd is required.</span>
<span class="cm"> * @flags:      [in]    flags to give to fd</span>
<span class="cm"> *</span>
<span class="cm"> * On success, returns an associated &#39;fd&#39;. Else, returns error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dma_buf_fd</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">fd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span> <span class="o">||</span> <span class="o">!</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">get_unused_fd_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">fd</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">fd_install</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_fd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * dma_buf_get - returns the dma_buf structure related to an fd</span>
<span class="cm"> * @fd:	[in]	fd associated with the dma_buf to be returned</span>
<span class="cm"> *</span>
<span class="cm"> * On success, returns the dma_buf structure associated with an fd; uses</span>
<span class="cm"> * file&#39;s refcounting done by fget to increase refcount. returns ERR_PTR</span>
<span class="cm"> * otherwise.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="nf">dma_buf_get</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EBADF</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_dma_buf_file</span><span class="p">(</span><span class="n">file</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_get</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * dma_buf_put - decreases refcount of the buffer</span>
<span class="cm"> * @dmabuf:	[in]	buffer to reduce refcount of</span>
<span class="cm"> *</span>
<span class="cm"> * Uses file&#39;s refcounting done implicitly by fput()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dma_buf_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span> <span class="o">||</span> <span class="o">!</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">fput</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_put</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * dma_buf_attach - Add the device to dma_buf&#39;s attachments list; optionally,</span>
<span class="cm"> * calls attach() of dma_buf_ops to allow device-specific attach functionality</span>
<span class="cm"> * @dmabuf:	[in]	buffer to attach device to.</span>
<span class="cm"> * @dev:	[in]	device to be attached.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns struct dma_buf_attachment * for this attachment; may return negative</span>
<span class="cm"> * error codes.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dma_buf_attachment</span> <span class="o">*</span><span class="nf">dma_buf_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_buf_attachment</span> <span class="o">*</span><span class="n">attach</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">attach</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf_attachment</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attach</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">attach</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">attach</span><span class="o">-&gt;</span><span class="n">dmabuf</span> <span class="o">=</span> <span class="n">dmabuf</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">attach</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_attach</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attach</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">attachments</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">attach</span><span class="p">;</span>

<span class="nl">err_attach:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">attach</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_attach</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * dma_buf_detach - Remove the given attachment from dmabuf&#39;s attachments list;</span>
<span class="cm"> * optionally calls detach() of dma_buf_ops for device-specific detach</span>
<span class="cm"> * @dmabuf:	[in]	buffer to detach from.</span>
<span class="cm"> * @attach:	[in]	attachment to be detached; is free&#39;d after this call.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dma_buf_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_buf_attachment</span> <span class="o">*</span><span class="n">attach</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span> <span class="o">||</span> <span class="o">!</span><span class="n">attach</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attach</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">detach</span><span class="p">)</span>
		<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">detach</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">attach</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">attach</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_detach</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * dma_buf_map_attachment - Returns the scatterlist table of the attachment;</span>
<span class="cm"> * mapped into _device_ address space. Is a wrapper for map_dma_buf() of the</span>
<span class="cm"> * dma_buf_ops.</span>
<span class="cm"> * @attach:	[in]	attachment whose scatterlist is to be returned</span>
<span class="cm"> * @direction:	[in]	direction of DMA transfer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns sg_table containing the scatterlist to be returned; may return NULL</span>
<span class="cm"> * or ERR_PTR.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sg_table</span> <span class="o">*</span><span class="nf">dma_buf_map_attachment</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf_attachment</span> <span class="o">*</span><span class="n">attach</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sg_table</span> <span class="o">*</span><span class="n">sg_table</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">attach</span> <span class="o">||</span> <span class="o">!</span><span class="n">attach</span><span class="o">-&gt;</span><span class="n">dmabuf</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">sg_table</span> <span class="o">=</span> <span class="n">attach</span><span class="o">-&gt;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">map_dma_buf</span><span class="p">(</span><span class="n">attach</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sg_table</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_map_attachment</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * dma_buf_unmap_attachment - unmaps and decreases usecount of the buffer;might</span>
<span class="cm"> * deallocate the scatterlist associated. Is a wrapper for unmap_dma_buf() of</span>
<span class="cm"> * dma_buf_ops.</span>
<span class="cm"> * @attach:	[in]	attachment to unmap buffer from</span>
<span class="cm"> * @sg_table:	[in]	scatterlist info of the buffer to unmap</span>
<span class="cm"> * @direction:  [in]    direction of DMA transfer</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dma_buf_unmap_attachment</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf_attachment</span> <span class="o">*</span><span class="n">attach</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sg_table</span> <span class="o">*</span><span class="n">sg_table</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">attach</span> <span class="o">||</span> <span class="o">!</span><span class="n">attach</span><span class="o">-&gt;</span><span class="n">dmabuf</span> <span class="o">||</span> <span class="o">!</span><span class="n">sg_table</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">attach</span><span class="o">-&gt;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">unmap_dma_buf</span><span class="p">(</span><span class="n">attach</span><span class="p">,</span> <span class="n">sg_table</span><span class="p">,</span>
						<span class="n">direction</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_unmap_attachment</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * dma_buf_begin_cpu_access - Must be called before accessing a dma_buf from the</span>
<span class="cm"> * cpu in the kernel context. Calls begin_cpu_access to allow exporter-specific</span>
<span class="cm"> * preparations. Coherency is only guaranteed in the specified range for the</span>
<span class="cm"> * specified access direction.</span>
<span class="cm"> * @dmabuf:	[in]	buffer to prepare cpu access for.</span>
<span class="cm"> * @start:	[in]	start of range for cpu access.</span>
<span class="cm"> * @len:	[in]	length of range for cpu access.</span>
<span class="cm"> * @direction:	[in]	length of range for cpu access.</span>
<span class="cm"> *</span>
<span class="cm"> * Can return negative error values, returns 0 on success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dma_buf_begin_cpu_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">begin_cpu_access</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">begin_cpu_access</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_begin_cpu_access</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * dma_buf_end_cpu_access - Must be called after accessing a dma_buf from the</span>
<span class="cm"> * cpu in the kernel context. Calls end_cpu_access to allow exporter-specific</span>
<span class="cm"> * actions. Coherency is only guaranteed in the specified range for the</span>
<span class="cm"> * specified access direction.</span>
<span class="cm"> * @dmabuf:	[in]	buffer to complete cpu access for.</span>
<span class="cm"> * @start:	[in]	start of range for cpu access.</span>
<span class="cm"> * @len:	[in]	length of range for cpu access.</span>
<span class="cm"> * @direction:	[in]	length of range for cpu access.</span>
<span class="cm"> *</span>
<span class="cm"> * This call must always succeed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dma_buf_end_cpu_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">end_cpu_access</span><span class="p">)</span>
		<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">end_cpu_access</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_end_cpu_access</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * dma_buf_kmap_atomic - Map a page of the buffer object into kernel address</span>
<span class="cm"> * space. The same restrictions as for kmap_atomic and friends apply.</span>
<span class="cm"> * @dmabuf:	[in]	buffer to map page from.</span>
<span class="cm"> * @page_num:	[in]	page in PAGE_SIZE units to map.</span>
<span class="cm"> *</span>
<span class="cm"> * This call must always succeed, any necessary preparations that might fail</span>
<span class="cm"> * need to be done in begin_cpu_access.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">dma_buf_kmap_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">kmap_atomic</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">page_num</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_kmap_atomic</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * dma_buf_kunmap_atomic - Unmap a page obtained by dma_buf_kmap_atomic.</span>
<span class="cm"> * @dmabuf:	[in]	buffer to unmap page from.</span>
<span class="cm"> * @page_num:	[in]	page in PAGE_SIZE units to unmap.</span>
<span class="cm"> * @vaddr:	[in]	kernel space pointer obtained from dma_buf_kmap_atomic.</span>
<span class="cm"> *</span>
<span class="cm"> * This call must always succeed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dma_buf_kunmap_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_num</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">kunmap_atomic</span><span class="p">)</span>
		<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">page_num</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_kunmap_atomic</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * dma_buf_kmap - Map a page of the buffer object into kernel address space. The</span>
<span class="cm"> * same restrictions as for kmap and friends apply.</span>
<span class="cm"> * @dmabuf:	[in]	buffer to map page from.</span>
<span class="cm"> * @page_num:	[in]	page in PAGE_SIZE units to map.</span>
<span class="cm"> *</span>
<span class="cm"> * This call must always succeed, any necessary preparations that might fail</span>
<span class="cm"> * need to be done in begin_cpu_access.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">dma_buf_kmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">kmap</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">page_num</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_kmap</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * dma_buf_kunmap - Unmap a page obtained by dma_buf_kmap.</span>
<span class="cm"> * @dmabuf:	[in]	buffer to unmap page from.</span>
<span class="cm"> * @page_num:	[in]	page in PAGE_SIZE units to unmap.</span>
<span class="cm"> * @vaddr:	[in]	kernel space pointer obtained from dma_buf_kmap.</span>
<span class="cm"> *</span>
<span class="cm"> * This call must always succeed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dma_buf_kunmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_num</span><span class="p">,</span>
		    <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">kunmap</span><span class="p">)</span>
		<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">kunmap</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">page_num</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_kunmap</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * dma_buf_mmap - Setup up a userspace mmap with the given vma</span>
<span class="cm"> * @dmabuf:	[in]	buffer that should back the vma</span>
<span class="cm"> * @vma:	[in]	vma for the mmap</span>
<span class="cm"> * @pgoff:	[in]	offset in pages where this mmap should start within the</span>
<span class="cm"> * 			dma-buf buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function adjusts the passed in vma so that it points at the file of the</span>
<span class="cm"> * dma_buf operation. It alsog adjusts the starting pgoff and does bounds</span>
<span class="cm"> * checking on the size of the vma. Then it calls the exporters mmap function to</span>
<span class="cm"> * set up the mapping.</span>
<span class="cm"> *</span>
<span class="cm"> * Can return negative error values, returns 0 on success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dma_buf_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span> <span class="o">||</span> <span class="o">!</span><span class="n">vma</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* check for offset overflow */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgoff</span> <span class="o">+</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">pgoff</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>

	<span class="cm">/* check for overflowing the buffer&#39;s size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgoff</span> <span class="o">+</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&gt;</span>
	    <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* readjust the vma */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">=</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">;</span>
	<span class="n">get_file</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">=</span> <span class="n">pgoff</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_mmap</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * dma_buf_vmap - Create virtual mapping for the buffer object into kernel</span>
<span class="cm"> * address space. Same restrictions as for vmap and friends apply.</span>
<span class="cm"> * @dmabuf:	[in]	buffer to vmap</span>
<span class="cm"> *</span>
<span class="cm"> * This call may fail due to lack of virtual mapping address space.</span>
<span class="cm"> * These calls are optional in drivers. The intended use for them</span>
<span class="cm"> * is for mapping objects linear in kernel space for high use objects.</span>
<span class="cm"> * Please attempt to use kmap/kunmap before thinking about these interfaces.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">dma_buf_vmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">vmap</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">vmap</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_vmap</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * dma_buf_vunmap - Unmap a vmap obtained by dma_buf_vmap.</span>
<span class="cm"> * @dmabuf:	[in]	buffer to vunmap</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dma_buf_vunmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">vunmap</span><span class="p">)</span>
		<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">vunmap</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dma_buf_vunmap</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
