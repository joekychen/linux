<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › hwmon › pmbus › pmbus.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pmbus.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * pmbus.h - Common defines and structures for PMBus devices</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2010, 2011 Ericsson AB.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef PMBUS_H</span>
<span class="cp">#define PMBUS_H</span>

<span class="cm">/*</span>
<span class="cm"> * Registers</span>
<span class="cm"> */</span>
<span class="cp">#define PMBUS_PAGE			0x00</span>
<span class="cp">#define PMBUS_OPERATION			0x01</span>
<span class="cp">#define PMBUS_ON_OFF_CONFIG		0x02</span>
<span class="cp">#define PMBUS_CLEAR_FAULTS		0x03</span>
<span class="cp">#define PMBUS_PHASE			0x04</span>

<span class="cp">#define PMBUS_CAPABILITY		0x19</span>
<span class="cp">#define PMBUS_QUERY			0x1A</span>

<span class="cp">#define PMBUS_VOUT_MODE			0x20</span>
<span class="cp">#define PMBUS_VOUT_COMMAND		0x21</span>
<span class="cp">#define PMBUS_VOUT_TRIM			0x22</span>
<span class="cp">#define PMBUS_VOUT_CAL_OFFSET		0x23</span>
<span class="cp">#define PMBUS_VOUT_MAX			0x24</span>
<span class="cp">#define PMBUS_VOUT_MARGIN_HIGH		0x25</span>
<span class="cp">#define PMBUS_VOUT_MARGIN_LOW		0x26</span>
<span class="cp">#define PMBUS_VOUT_TRANSITION_RATE	0x27</span>
<span class="cp">#define PMBUS_VOUT_DROOP		0x28</span>
<span class="cp">#define PMBUS_VOUT_SCALE_LOOP		0x29</span>
<span class="cp">#define PMBUS_VOUT_SCALE_MONITOR	0x2A</span>

<span class="cp">#define PMBUS_COEFFICIENTS		0x30</span>
<span class="cp">#define PMBUS_POUT_MAX			0x31</span>

<span class="cp">#define PMBUS_FAN_CONFIG_12		0x3A</span>
<span class="cp">#define PMBUS_FAN_COMMAND_1		0x3B</span>
<span class="cp">#define PMBUS_FAN_COMMAND_2		0x3C</span>
<span class="cp">#define PMBUS_FAN_CONFIG_34		0x3D</span>
<span class="cp">#define PMBUS_FAN_COMMAND_3		0x3E</span>
<span class="cp">#define PMBUS_FAN_COMMAND_4		0x3F</span>

<span class="cp">#define PMBUS_VOUT_OV_FAULT_LIMIT	0x40</span>
<span class="cp">#define PMBUS_VOUT_OV_FAULT_RESPONSE	0x41</span>
<span class="cp">#define PMBUS_VOUT_OV_WARN_LIMIT	0x42</span>
<span class="cp">#define PMBUS_VOUT_UV_WARN_LIMIT	0x43</span>
<span class="cp">#define PMBUS_VOUT_UV_FAULT_LIMIT	0x44</span>
<span class="cp">#define PMBUS_VOUT_UV_FAULT_RESPONSE	0x45</span>
<span class="cp">#define PMBUS_IOUT_OC_FAULT_LIMIT	0x46</span>
<span class="cp">#define PMBUS_IOUT_OC_FAULT_RESPONSE	0x47</span>
<span class="cp">#define PMBUS_IOUT_OC_LV_FAULT_LIMIT	0x48</span>
<span class="cp">#define PMBUS_IOUT_OC_LV_FAULT_RESPONSE	0x49</span>
<span class="cp">#define PMBUS_IOUT_OC_WARN_LIMIT	0x4A</span>
<span class="cp">#define PMBUS_IOUT_UC_FAULT_LIMIT	0x4B</span>
<span class="cp">#define PMBUS_IOUT_UC_FAULT_RESPONSE	0x4C</span>

<span class="cp">#define PMBUS_OT_FAULT_LIMIT		0x4F</span>
<span class="cp">#define PMBUS_OT_FAULT_RESPONSE		0x50</span>
<span class="cp">#define PMBUS_OT_WARN_LIMIT		0x51</span>
<span class="cp">#define PMBUS_UT_WARN_LIMIT		0x52</span>
<span class="cp">#define PMBUS_UT_FAULT_LIMIT		0x53</span>
<span class="cp">#define PMBUS_UT_FAULT_RESPONSE		0x54</span>
<span class="cp">#define PMBUS_VIN_OV_FAULT_LIMIT	0x55</span>
<span class="cp">#define PMBUS_VIN_OV_FAULT_RESPONSE	0x56</span>
<span class="cp">#define PMBUS_VIN_OV_WARN_LIMIT		0x57</span>
<span class="cp">#define PMBUS_VIN_UV_WARN_LIMIT		0x58</span>
<span class="cp">#define PMBUS_VIN_UV_FAULT_LIMIT	0x59</span>

<span class="cp">#define PMBUS_IIN_OC_FAULT_LIMIT	0x5B</span>
<span class="cp">#define PMBUS_IIN_OC_WARN_LIMIT		0x5D</span>

<span class="cp">#define PMBUS_POUT_OP_FAULT_LIMIT	0x68</span>
<span class="cp">#define PMBUS_POUT_OP_WARN_LIMIT	0x6A</span>
<span class="cp">#define PMBUS_PIN_OP_WARN_LIMIT		0x6B</span>

<span class="cp">#define PMBUS_STATUS_BYTE		0x78</span>
<span class="cp">#define PMBUS_STATUS_WORD		0x79</span>
<span class="cp">#define PMBUS_STATUS_VOUT		0x7A</span>
<span class="cp">#define PMBUS_STATUS_IOUT		0x7B</span>
<span class="cp">#define PMBUS_STATUS_INPUT		0x7C</span>
<span class="cp">#define PMBUS_STATUS_TEMPERATURE	0x7D</span>
<span class="cp">#define PMBUS_STATUS_CML		0x7E</span>
<span class="cp">#define PMBUS_STATUS_OTHER		0x7F</span>
<span class="cp">#define PMBUS_STATUS_MFR_SPECIFIC	0x80</span>
<span class="cp">#define PMBUS_STATUS_FAN_12		0x81</span>
<span class="cp">#define PMBUS_STATUS_FAN_34		0x82</span>

<span class="cp">#define PMBUS_READ_VIN			0x88</span>
<span class="cp">#define PMBUS_READ_IIN			0x89</span>
<span class="cp">#define PMBUS_READ_VCAP			0x8A</span>
<span class="cp">#define PMBUS_READ_VOUT			0x8B</span>
<span class="cp">#define PMBUS_READ_IOUT			0x8C</span>
<span class="cp">#define PMBUS_READ_TEMPERATURE_1	0x8D</span>
<span class="cp">#define PMBUS_READ_TEMPERATURE_2	0x8E</span>
<span class="cp">#define PMBUS_READ_TEMPERATURE_3	0x8F</span>
<span class="cp">#define PMBUS_READ_FAN_SPEED_1		0x90</span>
<span class="cp">#define PMBUS_READ_FAN_SPEED_2		0x91</span>
<span class="cp">#define PMBUS_READ_FAN_SPEED_3		0x92</span>
<span class="cp">#define PMBUS_READ_FAN_SPEED_4		0x93</span>
<span class="cp">#define PMBUS_READ_DUTY_CYCLE		0x94</span>
<span class="cp">#define PMBUS_READ_FREQUENCY		0x95</span>
<span class="cp">#define PMBUS_READ_POUT			0x96</span>
<span class="cp">#define PMBUS_READ_PIN			0x97</span>

<span class="cp">#define PMBUS_REVISION			0x98</span>
<span class="cp">#define PMBUS_MFR_ID			0x99</span>
<span class="cp">#define PMBUS_MFR_MODEL			0x9A</span>
<span class="cp">#define PMBUS_MFR_REVISION		0x9B</span>
<span class="cp">#define PMBUS_MFR_LOCATION		0x9C</span>
<span class="cp">#define PMBUS_MFR_DATE			0x9D</span>
<span class="cp">#define PMBUS_MFR_SERIAL		0x9E</span>

<span class="cm">/*</span>
<span class="cm"> * Virtual registers.</span>
<span class="cm"> * Useful to support attributes which are not supported by standard PMBus</span>
<span class="cm"> * registers but exist as manufacturer specific registers on individual chips.</span>
<span class="cm"> * Must be mapped to real registers in device specific code.</span>
<span class="cm"> *</span>
<span class="cm"> * Semantics:</span>
<span class="cm"> * Virtual registers are all word size.</span>
<span class="cm"> * READ registers are read-only; writes are either ignored or return an error.</span>
<span class="cm"> * RESET registers are read/write. Reading reset registers returns zero</span>
<span class="cm"> * (used for detection), writing any value causes the associated history to be</span>
<span class="cm"> * reset.</span>
<span class="cm"> * Virtual registers have to be handled in device specific driver code. Chip</span>
<span class="cm"> * driver code returns non-negative register values if a virtual register is</span>
<span class="cm"> * supported, or a negative error code if not. The chip driver may return</span>
<span class="cm"> * -ENODATA or any other error code in this case, though an error code other</span>
<span class="cm"> * than -ENODATA is handled more efficiently and thus preferred. Either case,</span>
<span class="cm"> * the calling PMBus core code will abort if the chip driver returns an error</span>
<span class="cm"> * code when reading or writing virtual registers.</span>
<span class="cm"> */</span>
<span class="cp">#define PMBUS_VIRT_BASE			0x100</span>
<span class="cp">#define PMBUS_VIRT_READ_TEMP_AVG	(PMBUS_VIRT_BASE + 0)</span>
<span class="cp">#define PMBUS_VIRT_READ_TEMP_MIN	(PMBUS_VIRT_BASE + 1)</span>
<span class="cp">#define PMBUS_VIRT_READ_TEMP_MAX	(PMBUS_VIRT_BASE + 2)</span>
<span class="cp">#define PMBUS_VIRT_RESET_TEMP_HISTORY	(PMBUS_VIRT_BASE + 3)</span>
<span class="cp">#define PMBUS_VIRT_READ_VIN_AVG		(PMBUS_VIRT_BASE + 4)</span>
<span class="cp">#define PMBUS_VIRT_READ_VIN_MIN		(PMBUS_VIRT_BASE + 5)</span>
<span class="cp">#define PMBUS_VIRT_READ_VIN_MAX		(PMBUS_VIRT_BASE + 6)</span>
<span class="cp">#define PMBUS_VIRT_RESET_VIN_HISTORY	(PMBUS_VIRT_BASE + 7)</span>
<span class="cp">#define PMBUS_VIRT_READ_IIN_AVG		(PMBUS_VIRT_BASE + 8)</span>
<span class="cp">#define PMBUS_VIRT_READ_IIN_MIN		(PMBUS_VIRT_BASE + 9)</span>
<span class="cp">#define PMBUS_VIRT_READ_IIN_MAX		(PMBUS_VIRT_BASE + 10)</span>
<span class="cp">#define PMBUS_VIRT_RESET_IIN_HISTORY	(PMBUS_VIRT_BASE + 11)</span>
<span class="cp">#define PMBUS_VIRT_READ_PIN_AVG		(PMBUS_VIRT_BASE + 12)</span>
<span class="cp">#define PMBUS_VIRT_READ_PIN_MAX		(PMBUS_VIRT_BASE + 13)</span>
<span class="cp">#define PMBUS_VIRT_RESET_PIN_HISTORY	(PMBUS_VIRT_BASE + 14)</span>
<span class="cp">#define PMBUS_VIRT_READ_POUT_AVG	(PMBUS_VIRT_BASE + 15)</span>
<span class="cp">#define PMBUS_VIRT_READ_POUT_MAX	(PMBUS_VIRT_BASE + 16)</span>
<span class="cp">#define PMBUS_VIRT_RESET_POUT_HISTORY	(PMBUS_VIRT_BASE + 17)</span>
<span class="cp">#define PMBUS_VIRT_READ_VOUT_AVG	(PMBUS_VIRT_BASE + 18)</span>
<span class="cp">#define PMBUS_VIRT_READ_VOUT_MIN	(PMBUS_VIRT_BASE + 19)</span>
<span class="cp">#define PMBUS_VIRT_READ_VOUT_MAX	(PMBUS_VIRT_BASE + 20)</span>
<span class="cp">#define PMBUS_VIRT_RESET_VOUT_HISTORY	(PMBUS_VIRT_BASE + 21)</span>
<span class="cp">#define PMBUS_VIRT_READ_IOUT_AVG	(PMBUS_VIRT_BASE + 22)</span>
<span class="cp">#define PMBUS_VIRT_READ_IOUT_MIN	(PMBUS_VIRT_BASE + 23)</span>
<span class="cp">#define PMBUS_VIRT_READ_IOUT_MAX	(PMBUS_VIRT_BASE + 24)</span>
<span class="cp">#define PMBUS_VIRT_RESET_IOUT_HISTORY	(PMBUS_VIRT_BASE + 25)</span>
<span class="cp">#define PMBUS_VIRT_READ_TEMP2_AVG	(PMBUS_VIRT_BASE + 26)</span>
<span class="cp">#define PMBUS_VIRT_READ_TEMP2_MIN	(PMBUS_VIRT_BASE + 27)</span>
<span class="cp">#define PMBUS_VIRT_READ_TEMP2_MAX	(PMBUS_VIRT_BASE + 28)</span>
<span class="cp">#define PMBUS_VIRT_RESET_TEMP2_HISTORY	(PMBUS_VIRT_BASE + 29)</span>

<span class="cm">/*</span>
<span class="cm"> * CAPABILITY</span>
<span class="cm"> */</span>
<span class="cp">#define PB_CAPABILITY_SMBALERT		(1&lt;&lt;4)</span>
<span class="cp">#define PB_CAPABILITY_ERROR_CHECK	(1&lt;&lt;7)</span>

<span class="cm">/*</span>
<span class="cm"> * VOUT_MODE</span>
<span class="cm"> */</span>
<span class="cp">#define PB_VOUT_MODE_MODE_MASK		0xe0</span>
<span class="cp">#define PB_VOUT_MODE_PARAM_MASK		0x1f</span>

<span class="cp">#define PB_VOUT_MODE_LINEAR		0x00</span>
<span class="cp">#define PB_VOUT_MODE_VID		0x20</span>
<span class="cp">#define PB_VOUT_MODE_DIRECT		0x40</span>

<span class="cm">/*</span>
<span class="cm"> * Fan configuration</span>
<span class="cm"> */</span>
<span class="cp">#define PB_FAN_2_PULSE_MASK		((1 &lt;&lt; 0) | (1 &lt;&lt; 1))</span>
<span class="cp">#define PB_FAN_2_RPM			(1 &lt;&lt; 2)</span>
<span class="cp">#define PB_FAN_2_INSTALLED		(1 &lt;&lt; 3)</span>
<span class="cp">#define PB_FAN_1_PULSE_MASK		((1 &lt;&lt; 4) | (1 &lt;&lt; 5))</span>
<span class="cp">#define PB_FAN_1_RPM			(1 &lt;&lt; 6)</span>
<span class="cp">#define PB_FAN_1_INSTALLED		(1 &lt;&lt; 7)</span>

<span class="cm">/*</span>
<span class="cm"> * STATUS_BYTE, STATUS_WORD (lower)</span>
<span class="cm"> */</span>
<span class="cp">#define PB_STATUS_NONE_ABOVE		(1&lt;&lt;0)</span>
<span class="cp">#define PB_STATUS_CML			(1&lt;&lt;1)</span>
<span class="cp">#define PB_STATUS_TEMPERATURE		(1&lt;&lt;2)</span>
<span class="cp">#define PB_STATUS_VIN_UV		(1&lt;&lt;3)</span>
<span class="cp">#define PB_STATUS_IOUT_OC		(1&lt;&lt;4)</span>
<span class="cp">#define PB_STATUS_VOUT_OV		(1&lt;&lt;5)</span>
<span class="cp">#define PB_STATUS_OFF			(1&lt;&lt;6)</span>
<span class="cp">#define PB_STATUS_BUSY			(1&lt;&lt;7)</span>

<span class="cm">/*</span>
<span class="cm"> * STATUS_WORD (upper)</span>
<span class="cm"> */</span>
<span class="cp">#define PB_STATUS_UNKNOWN		(1&lt;&lt;8)</span>
<span class="cp">#define PB_STATUS_OTHER			(1&lt;&lt;9)</span>
<span class="cp">#define PB_STATUS_FANS			(1&lt;&lt;10)</span>
<span class="cp">#define PB_STATUS_POWER_GOOD_N		(1&lt;&lt;11)</span>
<span class="cp">#define PB_STATUS_WORD_MFR		(1&lt;&lt;12)</span>
<span class="cp">#define PB_STATUS_INPUT			(1&lt;&lt;13)</span>
<span class="cp">#define PB_STATUS_IOUT_POUT		(1&lt;&lt;14)</span>
<span class="cp">#define PB_STATUS_VOUT			(1&lt;&lt;15)</span>

<span class="cm">/*</span>
<span class="cm"> * STATUS_IOUT</span>
<span class="cm"> */</span>
<span class="cp">#define PB_POUT_OP_WARNING		(1&lt;&lt;0)</span>
<span class="cp">#define PB_POUT_OP_FAULT		(1&lt;&lt;1)</span>
<span class="cp">#define PB_POWER_LIMITING		(1&lt;&lt;2)</span>
<span class="cp">#define PB_CURRENT_SHARE_FAULT		(1&lt;&lt;3)</span>
<span class="cp">#define PB_IOUT_UC_FAULT		(1&lt;&lt;4)</span>
<span class="cp">#define PB_IOUT_OC_WARNING		(1&lt;&lt;5)</span>
<span class="cp">#define PB_IOUT_OC_LV_FAULT		(1&lt;&lt;6)</span>
<span class="cp">#define PB_IOUT_OC_FAULT		(1&lt;&lt;7)</span>

<span class="cm">/*</span>
<span class="cm"> * STATUS_VOUT, STATUS_INPUT</span>
<span class="cm"> */</span>
<span class="cp">#define PB_VOLTAGE_UV_FAULT		(1&lt;&lt;4)</span>
<span class="cp">#define PB_VOLTAGE_UV_WARNING		(1&lt;&lt;5)</span>
<span class="cp">#define PB_VOLTAGE_OV_WARNING		(1&lt;&lt;6)</span>
<span class="cp">#define PB_VOLTAGE_OV_FAULT		(1&lt;&lt;7)</span>

<span class="cm">/*</span>
<span class="cm"> * STATUS_INPUT</span>
<span class="cm"> */</span>
<span class="cp">#define PB_PIN_OP_WARNING		(1&lt;&lt;0)</span>
<span class="cp">#define PB_IIN_OC_WARNING		(1&lt;&lt;1)</span>
<span class="cp">#define PB_IIN_OC_FAULT			(1&lt;&lt;2)</span>

<span class="cm">/*</span>
<span class="cm"> * STATUS_TEMPERATURE</span>
<span class="cm"> */</span>
<span class="cp">#define PB_TEMP_UT_FAULT		(1&lt;&lt;4)</span>
<span class="cp">#define PB_TEMP_UT_WARNING		(1&lt;&lt;5)</span>
<span class="cp">#define PB_TEMP_OT_WARNING		(1&lt;&lt;6)</span>
<span class="cp">#define PB_TEMP_OT_FAULT		(1&lt;&lt;7)</span>

<span class="cm">/*</span>
<span class="cm"> * STATUS_FAN</span>
<span class="cm"> */</span>
<span class="cp">#define PB_FAN_AIRFLOW_WARNING		(1&lt;&lt;0)</span>
<span class="cp">#define PB_FAN_AIRFLOW_FAULT		(1&lt;&lt;1)</span>
<span class="cp">#define PB_FAN_FAN2_SPEED_OVERRIDE	(1&lt;&lt;2)</span>
<span class="cp">#define PB_FAN_FAN1_SPEED_OVERRIDE	(1&lt;&lt;3)</span>
<span class="cp">#define PB_FAN_FAN2_WARNING		(1&lt;&lt;4)</span>
<span class="cp">#define PB_FAN_FAN1_WARNING		(1&lt;&lt;5)</span>
<span class="cp">#define PB_FAN_FAN2_FAULT		(1&lt;&lt;6)</span>
<span class="cp">#define PB_FAN_FAN1_FAULT		(1&lt;&lt;7)</span>

<span class="cm">/*</span>
<span class="cm"> * CML_FAULT_STATUS</span>
<span class="cm"> */</span>
<span class="cp">#define PB_CML_FAULT_OTHER_MEM_LOGIC	(1&lt;&lt;0)</span>
<span class="cp">#define PB_CML_FAULT_OTHER_COMM		(1&lt;&lt;1)</span>
<span class="cp">#define PB_CML_FAULT_PROCESSOR		(1&lt;&lt;3)</span>
<span class="cp">#define PB_CML_FAULT_MEMORY		(1&lt;&lt;4)</span>
<span class="cp">#define PB_CML_FAULT_PACKET_ERROR	(1&lt;&lt;5)</span>
<span class="cp">#define PB_CML_FAULT_INVALID_DATA	(1&lt;&lt;6)</span>
<span class="cp">#define PB_CML_FAULT_INVALID_COMMAND	(1&lt;&lt;7)</span>

<span class="k">enum</span> <span class="n">pmbus_sensor_classes</span> <span class="p">{</span>
	<span class="n">PSC_VOLTAGE_IN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">PSC_VOLTAGE_OUT</span><span class="p">,</span>
	<span class="n">PSC_CURRENT_IN</span><span class="p">,</span>
	<span class="n">PSC_CURRENT_OUT</span><span class="p">,</span>
	<span class="n">PSC_POWER</span><span class="p">,</span>
	<span class="n">PSC_TEMPERATURE</span><span class="p">,</span>
	<span class="n">PSC_FAN</span><span class="p">,</span>
	<span class="n">PSC_NUM_CLASSES</span>		<span class="cm">/* Number of power sensor classes */</span>
<span class="p">};</span>

<span class="cp">#define PMBUS_PAGES	32	</span><span class="cm">/* Per PMBus specification */</span><span class="cp"></span>

<span class="cm">/* Functionality bit mask */</span>
<span class="cp">#define PMBUS_HAVE_VIN		(1 &lt;&lt; 0)</span>
<span class="cp">#define PMBUS_HAVE_VCAP		(1 &lt;&lt; 1)</span>
<span class="cp">#define PMBUS_HAVE_VOUT		(1 &lt;&lt; 2)</span>
<span class="cp">#define PMBUS_HAVE_IIN		(1 &lt;&lt; 3)</span>
<span class="cp">#define PMBUS_HAVE_IOUT		(1 &lt;&lt; 4)</span>
<span class="cp">#define PMBUS_HAVE_PIN		(1 &lt;&lt; 5)</span>
<span class="cp">#define PMBUS_HAVE_POUT		(1 &lt;&lt; 6)</span>
<span class="cp">#define PMBUS_HAVE_FAN12	(1 &lt;&lt; 7)</span>
<span class="cp">#define PMBUS_HAVE_FAN34	(1 &lt;&lt; 8)</span>
<span class="cp">#define PMBUS_HAVE_TEMP		(1 &lt;&lt; 9)</span>
<span class="cp">#define PMBUS_HAVE_TEMP2	(1 &lt;&lt; 10)</span>
<span class="cp">#define PMBUS_HAVE_TEMP3	(1 &lt;&lt; 11)</span>
<span class="cp">#define PMBUS_HAVE_STATUS_VOUT	(1 &lt;&lt; 12)</span>
<span class="cp">#define PMBUS_HAVE_STATUS_IOUT	(1 &lt;&lt; 13)</span>
<span class="cp">#define PMBUS_HAVE_STATUS_INPUT	(1 &lt;&lt; 14)</span>
<span class="cp">#define PMBUS_HAVE_STATUS_TEMP	(1 &lt;&lt; 15)</span>
<span class="cp">#define PMBUS_HAVE_STATUS_FAN12	(1 &lt;&lt; 16)</span>
<span class="cp">#define PMBUS_HAVE_STATUS_FAN34	(1 &lt;&lt; 17)</span>

<span class="k">enum</span> <span class="n">pmbus_data_format</span> <span class="p">{</span> <span class="n">linear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">direct</span><span class="p">,</span> <span class="n">vid</span> <span class="p">};</span>

<span class="k">struct</span> <span class="n">pmbus_driver_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">pages</span><span class="p">;</span>		<span class="cm">/* Total number of pages */</span>
	<span class="k">enum</span> <span class="n">pmbus_data_format</span> <span class="n">format</span><span class="p">[</span><span class="n">PSC_NUM_CLASSES</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * Support one set of coefficients for each sensor type</span>
<span class="cm">	 * Used for chips providing data in direct mode.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">m</span><span class="p">[</span><span class="n">PSC_NUM_CLASSES</span><span class="p">];</span>	<span class="cm">/* mantissa for direct data format */</span>
	<span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="n">PSC_NUM_CLASSES</span><span class="p">];</span>	<span class="cm">/* offset */</span>
	<span class="kt">int</span> <span class="n">R</span><span class="p">[</span><span class="n">PSC_NUM_CLASSES</span><span class="p">];</span>	<span class="cm">/* exponent */</span>

	<span class="n">u32</span> <span class="n">func</span><span class="p">[</span><span class="n">PMBUS_PAGES</span><span class="p">];</span>	<span class="cm">/* Functionality, per page */</span>
	<span class="cm">/*</span>
<span class="cm">	 * The following functions map manufacturing specific register values</span>
<span class="cm">	 * to PMBus standard register values. Specify only if mapping is</span>
<span class="cm">	 * necessary.</span>
<span class="cm">	 * Functions return the register value (read) or zero (write) if</span>
<span class="cm">	 * successful. A return value of -ENODATA indicates that there is no</span>
<span class="cm">	 * manufacturer specific register, but that a standard PMBus register</span>
<span class="cm">	 * may exist. Any other negative return value indicates that the</span>
<span class="cm">	 * register does not exist, and that no attempt should be made to read</span>
<span class="cm">	 * the standard register.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_byte_data</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_word_data</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_word_data</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
			       <span class="n">u16</span> <span class="n">word</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_byte</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The identify function determines supported PMBus functionality.</span>
<span class="cm">	 * This function is only necessary if a chip driver supports multiple</span>
<span class="cm">	 * chips, and the chip functionality is not pre-determined.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">identify</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">pmbus_driver_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* Function declarations */</span>

<span class="kt">int</span> <span class="n">pmbus_set_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="n">u8</span> <span class="n">page</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pmbus_read_word_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="n">u8</span> <span class="n">page</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pmbus_write_word_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="n">u8</span> <span class="n">page</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">word</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pmbus_read_byte_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pmbus_write_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pmbus_clear_faults</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">pmbus_check_byte_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">pmbus_check_word_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pmbus_do_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">pmbus_driver_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pmbus_do_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">);</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">pmbus_driver_info</span> <span class="o">*</span><span class="n">pmbus_get_driver_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span>
						      <span class="o">*</span><span class="n">client</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* PMBUS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
