<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › message › i2o › exec-osm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>exec-osm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	Executive OSM</span>
<span class="cm"> *</span>
<span class="cm"> * 	Copyright (C) 1999-2002	Red Hat Software</span>
<span class="cm"> *</span>
<span class="cm"> *	Written by Alan Cox, Building Number Three Ltd</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> *	under the terms of the GNU General Public License as published by the</span>
<span class="cm"> *	Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> *	option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *	A lot of the I2O message side code from this is taken from the Red</span>
<span class="cm"> *	Creek RCPCI45 adapter driver by Red Creek Communications</span>
<span class="cm"> *</span>
<span class="cm"> *	Fixes/additions:</span>
<span class="cm"> *		Philipp Rumpf</span>
<span class="cm"> *		Juha Sievänen &lt;Juha.Sievanen@cs.Helsinki.FI&gt;</span>
<span class="cm"> *		Auvo Häkkinen &lt;Auvo.Hakkinen@cs.Helsinki.FI&gt;</span>
<span class="cm"> *		Deepak Saxena &lt;deepak@plexity.net&gt;</span>
<span class="cm"> *		Boji T Kannanthanam &lt;boji.t.kannanthanam@intel.com&gt;</span>
<span class="cm"> *		Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;:</span>
<span class="cm"> *			Ported to Linux 2.5.</span>
<span class="cm"> *		Markus Lidel &lt;Markus.Lidel@shadowconnect.com&gt;:</span>
<span class="cm"> *			Minor fixes for 2.6.</span>
<span class="cm"> *		Markus Lidel &lt;Markus.Lidel@shadowconnect.com&gt;:</span>
<span class="cm"> *			Support for sysfs included.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/i2o.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;	</span><span class="cm">/* wait_event_interruptible_timeout() needs this */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/param.h&gt;		</span><span class="cm">/* HZ */</span><span class="cp"></span>
<span class="cp">#include &quot;core.h&quot;</span>

<span class="cp">#define OSM_NAME &quot;exec-osm&quot;</span>

<span class="k">struct</span> <span class="n">i2o_driver</span> <span class="n">i2o_exec_driver</span><span class="p">;</span>

<span class="cm">/* global wait list for POST WAIT */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">i2o_exec_wait_list</span><span class="p">);</span>

<span class="cm">/* Wait struct needed for POST WAIT */</span>
<span class="k">struct</span> <span class="n">i2o_exec_wait</span> <span class="p">{</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>	<span class="cm">/* Pointer to Wait queue */</span>
	<span class="k">struct</span> <span class="n">i2o_dma</span> <span class="n">dma</span><span class="p">;</span>	<span class="cm">/* DMA buffers to free on failure */</span>
	<span class="n">u32</span> <span class="n">tcntxt</span><span class="p">;</span>		<span class="cm">/* transaction context from reply */</span>
	<span class="kt">int</span> <span class="n">complete</span><span class="p">;</span>		<span class="cm">/* 1 if reply received otherwise 0 */</span>
	<span class="n">u32</span> <span class="n">m</span><span class="p">;</span>			<span class="cm">/* message id */</span>
	<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>	<span class="cm">/* pointer to the reply message */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>	<span class="cm">/* node in global wait list */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>	<span class="cm">/* lock before modifying */</span>
<span class="p">};</span>

<span class="cm">/* Work struct needed to handle LCT NOTIFY replies */</span>
<span class="k">struct</span> <span class="n">i2o_exec_lct_notify_work</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>	<span class="cm">/* work struct */</span>
	<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>	<span class="cm">/* controller on which the LCT NOTIFY</span>
<span class="cm">					   was received */</span>
<span class="p">};</span>

<span class="cm">/* Exec OSM class handling definition */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">i2o_class_id</span> <span class="n">i2o_exec_class_id</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">I2O_CLASS_EXECUTIVE</span><span class="p">},</span>
	<span class="p">{</span><span class="n">I2O_CLASS_END</span><span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_exec_wait_alloc - Allocate a i2o_exec_wait struct an initialize it</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate the i2o_exec_wait struct and initialize the wait.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns i2o_exec_wait pointer on success or negative error code on</span>
<span class="cm"> *	failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">i2o_exec_wait</span> <span class="o">*</span><span class="nf">i2o_exec_wait_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_exec_wait</span> <span class="o">*</span><span class="n">wait</span><span class="p">;</span>

	<span class="n">wait</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">wait</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">wait</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_exec_wait_free - Free an i2o_exec_wait struct</span>
<span class="cm"> *	@wait: I2O wait data which should be cleaned up</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i2o_exec_wait_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_exec_wait</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * 	i2o_msg_post_wait_mem - Post and wait a message with DMA buffers</span>
<span class="cm"> *	@c: controller</span>
<span class="cm"> *	@msg: message to post</span>
<span class="cm"> *	@timeout: time in seconds to wait</span>
<span class="cm"> *	@dma: i2o_dma struct of the DMA buffer to free on failure</span>
<span class="cm"> *</span>
<span class="cm"> * 	This API allows an OSM to post a message and then be told whether or</span>
<span class="cm"> *	not the system received a successful reply. If the message times out</span>
<span class="cm"> *	then the value &#39;-ETIMEDOUT&#39; is returned. This is a special case. In</span>
<span class="cm"> *	this situation the message may (should) complete at an indefinite time</span>
<span class="cm"> *	in the future. When it completes it will use the memory buffer</span>
<span class="cm"> *	attached to the request. If -ETIMEDOUT is returned then the memory</span>
<span class="cm"> *	buffer must not be freed. Instead the event completion will free them</span>
<span class="cm"> *	for you. In all other cases the buffer are your problem.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success, negative error code on timeout or positive error</span>
<span class="cm"> *	code from reply.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2o_msg_post_wait_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2o_dma</span> <span class="o">*</span><span class="n">dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAIT_QUEUE_HEAD_ONSTACK</span><span class="p">(</span><span class="n">wq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2o_exec_wait</span> <span class="o">*</span><span class="n">wait</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">u32</span> <span class="n">tcntxt</span> <span class="o">=</span> <span class="mh">0x80000000</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">wait</span> <span class="o">=</span> <span class="n">i2o_exec_wait_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i2o_msg_nop</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcntxt</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">)</span>
		<span class="n">tcntxt</span> <span class="o">=</span> <span class="mh">0x80000000</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="p">)</span>
		<span class="n">wait</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="o">*</span><span class="n">dma</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill in the message initiator context and transaction context.</span>
<span class="cm">	 * We will only use transaction contexts &gt;= 0x80000000 for POST WAIT,</span>
<span class="cm">	 * so we could find a POST WAIT reply easier in the reply handler.</span>
<span class="cm">	 */</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">icntxt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i2o_exec_driver</span><span class="p">.</span><span class="n">context</span><span class="p">);</span>
	<span class="n">wait</span><span class="o">-&gt;</span><span class="n">tcntxt</span> <span class="o">=</span> <span class="n">tcntxt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tcntxt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">tcntxt</span><span class="p">);</span>

	<span class="n">wait</span><span class="o">-&gt;</span><span class="n">wq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wq</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * we add elements to the head, because if a entry in the list will</span>
<span class="cm">	 * never be removed, we have to iterate over it every time</span>
<span class="cm">	 */</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2o_exec_wait_list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Post the message to the controller. At some point later it will</span>
<span class="cm">	 * return. If we time out before it returns then complete will be zero.</span>
<span class="cm">	 */</span>
	<span class="n">i2o_msg_post</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">wait</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">wait</span><span class="o">-&gt;</span><span class="n">wq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We cannot remove it now. This is important. When it does</span>
<span class="cm">		 * terminate (which it must do if the controller has not</span>
<span class="cm">		 * died...) then it will otherwise scribble on stuff.</span>
<span class="cm">		 *</span>
<span class="cm">		 * FIXME: try abort message</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="p">)</span>
			<span class="n">dma</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i2o_flush_reply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">wait</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
		<span class="n">i2o_exec_wait_free</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_msg_post_wait_complete - Reply to a i2o_msg_post request from IOP</span>
<span class="cm"> *	@c: I2O controller which answers</span>
<span class="cm"> *	@m: message id</span>
<span class="cm"> *	@msg: pointer to the I2O reply message</span>
<span class="cm"> *	@context: transaction context of request</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is called in interrupt context only. If the reply reached</span>
<span class="cm"> *	before the timeout, the i2o_exec_wait struct is filled with the message</span>
<span class="cm"> *	and the task will be waked up. The task is now responsible for returning</span>
<span class="cm"> *	the message m back to the controller! If the message reaches us after</span>
<span class="cm"> *	the timeout clean up the i2o_exec_wait struct (including allocated</span>
<span class="cm"> *	DMA buffer).</span>
<span class="cm"> *</span>
<span class="cm"> *	Return 0 on success and if the message m should not be given back to the</span>
<span class="cm"> *	I2O controller, or &gt;0 on success and if the message should be given back</span>
<span class="cm"> *	afterwords. Returns negative error code on failure. In this case the</span>
<span class="cm"> *	message must also be given back to the controller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_msg_post_wait_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u32</span> <span class="n">m</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_exec_wait</span> <span class="o">*</span><span class="n">wait</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to search through the i2o_exec_wait_list to see if the given</span>
<span class="cm">	 * message is still outstanding. If not, it means that the IOP took</span>
<span class="cm">	 * longer to respond to the message than we had allowed and timer has</span>
<span class="cm">	 * already expired. Not much we can do about that except log it for</span>
<span class="cm">	 * debug purposes, increase timeout, and recompile.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2o_exec_wait_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">tcntxt</span> <span class="o">==</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

			<span class="n">wait</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
			<span class="n">wait</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
			<span class="n">wait</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">)</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

				<span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: timedout reply received!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="n">i2o_dma_free</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
				<span class="n">i2o_exec_wait_free</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;%s: Bogus reply in POST WAIT (tr-context: %08x)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		 <span class="n">context</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_exec_show_vendor_id - Displays Vendor ID of controller</span>
<span class="cm"> *	@d: device of which the Vendor ID should be displayed</span>
<span class="cm"> *	@attr: device_attribute to display</span>
<span class="cm"> *	@buf: buffer into which the Vendor ID should be printed</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns number of bytes printed into buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">i2o_exec_show_vendor_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">to_i2o_device</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2o_parm_field_get</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;0x%04x&quot;</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">id</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_exec_show_product_id - Displays Product ID of controller</span>
<span class="cm"> *	@d: device of which the Product ID should be displayed</span>
<span class="cm"> *	@attr: device_attribute to display</span>
<span class="cm"> *	@buf: buffer into which the Product ID should be printed</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns number of bytes printed into buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">i2o_exec_show_product_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">to_i2o_device</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2o_parm_field_get</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;0x%04x&quot;</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">id</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Exec-OSM device attributes */</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">vendor_id</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">i2o_exec_show_vendor_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">product_id</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">i2o_exec_show_product_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_exec_probe - Called if a new I2O device (executive class) appears</span>
<span class="cm"> *	@dev: I2O device which should be probed</span>
<span class="cm"> *</span>
<span class="cm"> *	Registers event notification for every event from Executive device. The</span>
<span class="cm"> *	return is always 0, because we want all devices of class Executive.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_exec_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">i2o_dev</span> <span class="o">=</span> <span class="n">to_i2o_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_event_register</span><span class="p">(</span><span class="n">i2o_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2o_exec_driver</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_vendor_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="k">goto</span> <span class="n">err_evtreg</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_product_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="k">goto</span> <span class="n">err_vid</span><span class="p">;</span>

	<span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">iop</span><span class="o">-&gt;</span><span class="n">exec</span> <span class="o">=</span> <span class="n">i2o_dev</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_vid:</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_vendor_id</span><span class="p">);</span>
<span class="nl">err_evtreg:</span>
	<span class="n">i2o_event_register</span><span class="p">(</span><span class="n">to_i2o_device</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">i2o_exec_driver</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_exec_remove - Called on I2O device removal</span>
<span class="cm"> *	@dev: I2O device which was removed</span>
<span class="cm"> *</span>
<span class="cm"> *	Unregisters event notification from Executive I2O device.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_exec_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_product_id</span><span class="p">);</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_vendor_id</span><span class="p">);</span>

	<span class="n">i2o_event_register</span><span class="p">(</span><span class="n">to_i2o_device</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">i2o_exec_driver</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_I2O_LCT_NOTIFY_ON_CHANGES</span>
<span class="cm">/**</span>
<span class="cm"> *	i2o_exec_lct_notify - Send a asynchronus LCT NOTIFY request</span>
<span class="cm"> *	@c: I2O controller to which the request should be send</span>
<span class="cm"> *	@change_ind: change indicator</span>
<span class="cm"> *</span>
<span class="cm"> *	This function sends a LCT NOTIFY request to the I2O controller with</span>
<span class="cm"> *	the change indicator change_ind. If the change_ind == 0 the controller</span>
<span class="cm"> *	replies immediately after the request. If change_ind &gt; 0 the reply is</span>
<span class="cm"> *	send after change indicator of the LCT is &gt; change_ind.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_exec_lct_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u32</span> <span class="n">change_ind</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i2o_status_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">status_block</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lct_lock</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i2o_dma_realloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dlct</span><span class="p">,</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">expected_lct_size</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lct_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">i2o_msg_get_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">I2O_TIMEOUT_MESSAGE_GET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lct_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EIGHT_WORD_MSG_SIZE</span> <span class="o">|</span> <span class="n">SGL_OFFSET_6</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2O_CMD_LCT_NOTIFY</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> <span class="n">HOST_TID</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span>
				     <span class="n">ADAPTER_TID</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">icntxt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i2o_exec_driver</span><span class="p">.</span><span class="n">context</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tcntxt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">change_ind</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xd0000000</span> <span class="o">|</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dlct</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dlct</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>

	<span class="n">i2o_msg_post</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lct_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_exec_lct_modified - Called on LCT NOTIFY reply</span>
<span class="cm"> *	@_work: work struct for a specific controller</span>
<span class="cm"> *</span>
<span class="cm"> *	This function handles asynchronus LCT NOTIFY replies. It parses the</span>
<span class="cm"> *	new LCT and if the buffer for the LCT was to small sends a LCT NOTIFY</span>
<span class="cm"> *	again, otherwise send LCT NOTIFY to get informed on next LCT change.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i2o_exec_lct_modified</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">_work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_exec_lct_notify_work</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">_work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2o_exec_lct_notify_work</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">change_ind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i2o_device_parse_lct</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="n">change_ind</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lct</span><span class="o">-&gt;</span><span class="n">change_ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_I2O_LCT_NOTIFY_ON_CHANGES</span>
	<span class="n">i2o_exec_lct_notify</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">change_ind</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_exec_reply -  I2O Executive reply handler</span>
<span class="cm"> *	@c: I2O controller from which the reply comes</span>
<span class="cm"> *	@m: message id</span>
<span class="cm"> *	@msg: pointer to the I2O reply message</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is always called from interrupt context. If a POST WAIT</span>
<span class="cm"> *	reply was received, pass it to the complete function. If a LCT NOTIFY</span>
<span class="cm"> *	reply was received, a new event is created to handle the update.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success and if the reply should not be flushed or &gt; 0</span>
<span class="cm"> *	on success and if the reply should be flushed. Returns negative error</span>
<span class="cm"> *	code on failure and if the reply should be flushed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_exec_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u32</span> <span class="n">m</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">context</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">MSG_FAIL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">i2o_message</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pmsg</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">pm</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If Fail bit is set we must take the transaction context of</span>
<span class="cm">		 * the preserved message to find the right request again.</span>
<span class="cm">		 */</span>

		<span class="n">pm</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="n">pmsg</span> <span class="o">=</span> <span class="n">i2o_msg_in_to_virt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">pm</span><span class="p">);</span>
		<span class="n">context</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pmsg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tcntxt</span><span class="p">);</span>

		<span class="n">i2o_report_status</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;i2o_core&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

		<span class="cm">/* Release the preserved msg */</span>
		<span class="n">i2o_msg_nop_mfa</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">pm</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">context</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tcntxt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">context</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">i2o_msg_post_wait_complete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">==</span> <span class="n">I2O_CMD_LCT_NOTIFY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">i2o_exec_lct_notify_work</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: LCT notify received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="n">work</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">work</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">work</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">work</span><span class="o">-&gt;</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">i2o_exec_lct_modified</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">i2o_exec_driver</span><span class="p">.</span><span class="n">event_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this happens, we want to dump the message to the syslog so</span>
<span class="cm">	 * it can be sent back to the card manufacturer by the end user</span>
<span class="cm">	 * to aid in debugging.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Unsolicited message reply sent to core!&quot;</span>
	       <span class="s">&quot;Message dumped to syslog</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">i2o_dump_message</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_exec_event - Event handling function</span>
<span class="cm"> *	@work: Work item in occurring event</span>
<span class="cm"> *</span>
<span class="cm"> *	Handles events send by the Executive device. At the moment does not do</span>
<span class="cm"> *	anything useful.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i2o_exec_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_event</span> <span class="o">*</span><span class="n">evt</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2o_event</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">evt</span><span class="o">-&gt;</span><span class="n">i2o_dev</span><span class="p">))</span>
		<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;Event received from device: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">evt</span><span class="o">-&gt;</span><span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">lct_data</span><span class="p">.</span><span class="n">tid</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">evt</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_exec_lct_get - Get the IOP&#39;s Logical Configuration Table</span>
<span class="cm"> *	@c: I2O controller from which the LCT should be fetched</span>
<span class="cm"> *</span>
<span class="cm"> *	Send a LCT NOTIFY request to the controller, and wait</span>
<span class="cm"> *	I2O_TIMEOUT_LCT_GET seconds until arrival of response. If the LCT is</span>
<span class="cm"> *	to large, retry it.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2o_exec_lct_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">I2O_LCT_GET_TRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="n">i2o_msg_get_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">I2O_TIMEOUT_MESSAGE_GET</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EIGHT_WORD_MSG_SIZE</span> <span class="o">|</span> <span class="n">SGL_OFFSET_6</span><span class="p">);</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2O_CMD_LCT_NOTIFY</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> <span class="n">HOST_TID</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span>
				<span class="n">ADAPTER_TID</span><span class="p">);</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">);</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xd0000000</span> <span class="o">|</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dlct</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dlct</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_msg_post_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">I2O_TIMEOUT_LCT_GET</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_device_parse_lct</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Exec OSM driver struct */</span>
<span class="k">struct</span> <span class="n">i2o_driver</span> <span class="n">i2o_exec_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">OSM_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reply</span> <span class="o">=</span> <span class="n">i2o_exec_reply</span><span class="p">,</span>
	<span class="p">.</span><span class="n">event</span> <span class="o">=</span> <span class="n">i2o_exec_event</span><span class="p">,</span>
	<span class="p">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">i2o_exec_class_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		   <span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">i2o_exec_probe</span><span class="p">,</span>
		   <span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">i2o_exec_remove</span><span class="p">,</span>
		   <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_exec_init - Registers the Exec OSM</span>
<span class="cm"> *</span>
<span class="cm"> *	Registers the Exec OSM in the I2O core.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">i2o_exec_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">i2o_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2o_exec_driver</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_exec_exit - Removes the Exec OSM</span>
<span class="cm"> *</span>
<span class="cm"> *	Unregisters the Exec OSM from the I2O core.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2o_exec_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i2o_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2o_exec_driver</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2o_msg_post_wait_mem</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2o_exec_lct_get</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
