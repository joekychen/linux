<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › message › i2o › i2o_scsi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>i2o_scsi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2, or (at your option) any</span>
<span class="cm"> * later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * For the avoidance of doubt the &quot;preferred form&quot; of this code is one which</span>
<span class="cm"> * is in an open non patent encumbered format. Where cryptographic key signing</span>
<span class="cm"> * forms part of the process of creating an executable the information</span>
<span class="cm"> * including keys needed to generate an equivalently functional executable</span>
<span class="cm"> * are deemed to be part of the source code.</span>
<span class="cm"> *</span>
<span class="cm"> *  Complications for I2O scsi</span>
<span class="cm"> *</span>
<span class="cm"> *	o	Each (bus,lun) is a logical device in I2O. We keep a map</span>
<span class="cm"> *		table. We spoof failed selection for unmapped units</span>
<span class="cm"> *	o	Request sense buffers can come back for free.</span>
<span class="cm"> *	o	Scatter gather is a bit dynamic. We have to investigate at</span>
<span class="cm"> *		setup time.</span>
<span class="cm"> *	o	Some of our resources are dynamically shared. The i2o core</span>
<span class="cm"> *		needs a message reservation protocol to avoid swap v net</span>
<span class="cm"> *		deadlocking. We need to back off queue requests.</span>
<span class="cm"> *</span>
<span class="cm"> *	In general the firmware wants to help. Where its help isn&#39;t performance</span>
<span class="cm"> *	useful we just ignore the aid. Its not worth the code in truth.</span>
<span class="cm"> *</span>
<span class="cm"> * Fixes/additions:</span>
<span class="cm"> *	Steve Ralston:</span>
<span class="cm"> *		Scatter gather now works</span>
<span class="cm"> *	Markus Lidel &lt;Markus.Lidel@shadowconnect.com&gt;:</span>
<span class="cm"> *		Minor fixes for 2.6.</span>
<span class="cm"> *</span>
<span class="cm"> * To Do:</span>
<span class="cm"> *	64bit cleanups</span>
<span class="cm"> *	Fix the resource management problems.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/i2o.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>

<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/sg.h&gt;</span>

<span class="cp">#define OSM_NAME	&quot;scsi-osm&quot;</span>
<span class="cp">#define OSM_VERSION	&quot;1.316&quot;</span>
<span class="cp">#define OSM_DESCRIPTION	&quot;I2O SCSI Peripheral OSM&quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">i2o_driver</span> <span class="n">i2o_scsi_driver</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i2o_scsi_max_id</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i2o_scsi_max_lun</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">i2o_scsi_host</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">scsi_host</span><span class="p">;</span>	<span class="cm">/* pointer to the SCSI host */</span>
	<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">iop</span><span class="p">;</span>	<span class="cm">/* pointer to the I2O controller */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">;</span>	<span class="cm">/* lun&#39;s used for block devices */</span>
	<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* channel-&gt;i2o_dev mapping table */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">i2o_scsi_host_template</span><span class="p">;</span>

<span class="cp">#define I2O_SCSI_CAN_QUEUE	4</span>

<span class="cm">/* SCSI OSM class handling definition */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">i2o_class_id</span> <span class="n">i2o_scsi_class_id</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">I2O_CLASS_SCSI_PERIPHERAL</span><span class="p">},</span>
	<span class="p">{</span><span class="n">I2O_CLASS_END</span><span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">i2o_scsi_host</span> <span class="o">*</span><span class="nf">i2o_scsi_host_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_scsi_host</span> <span class="o">*</span><span class="n">i2o_shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">i2o_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">scsi_host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">body_size</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_I2O_EXT_ADAPTEC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">adaptec</span><span class="p">)</span>
		<span class="n">body_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">i2o_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">lct_data</span><span class="p">.</span><span class="n">class_id</span> <span class="o">==</span> <span class="n">I2O_CLASS_BUS_ADAPTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2o_parm_field_get</span><span class="p">(</span><span class="n">i2o_dev</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">))</span>	<span class="cm">/* SCSI bus */</span>
			<span class="n">max_channel</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_channel</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;no channels found on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">max_channel</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="p">)</span>
	    <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_scsi_host</span><span class="p">);</span>

	<span class="n">scsi_host</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2o_scsi_host_template</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_host</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;Could not allocate SCSI host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">max_channel</span> <span class="o">=</span> <span class="n">max_channel</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">=</span> <span class="n">i2o_scsi_max_id</span><span class="p">;</span>
	<span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="n">i2o_scsi_max_lun</span><span class="p">;</span>
	<span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">this_id</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">unit</span><span class="p">;</span>
	<span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="n">i2o_sg_tablesize</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">body_size</span><span class="p">);</span>

	<span class="n">i2o_shost</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">i2o_scsi_host</span> <span class="o">*</span><span class="p">)</span><span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">i2o_shost</span><span class="o">-&gt;</span><span class="n">scsi_host</span> <span class="o">=</span> <span class="n">scsi_host</span><span class="p">;</span>
	<span class="n">i2o_shost</span><span class="o">-&gt;</span><span class="n">iop</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">i2o_shost</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">i2o_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">lct_data</span><span class="p">.</span><span class="n">class_id</span> <span class="o">==</span> <span class="n">I2O_CLASS_BUS_ADAPTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2o_parm_field_get</span><span class="p">(</span><span class="n">i2o_dev</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">))</span>	<span class="cm">/* only SCSI bus */</span>
			<span class="n">i2o_shost</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i2o_dev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">max_channel</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">i2o_shost</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_scsi_get_host - Get an I2O SCSI host</span>
<span class="cm"> *	@c: I2O controller to for which to get the SCSI host</span>
<span class="cm"> *</span>
<span class="cm"> *	If the I2O controller already exists as SCSI host, the SCSI host</span>
<span class="cm"> *	is returned, otherwise the I2O controller is added to the SCSI</span>
<span class="cm"> *	core.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns pointer to the I2O SCSI host on success or NULL on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">i2o_scsi_host</span> <span class="o">*</span><span class="nf">i2o_scsi_get_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">[</span><span class="n">i2o_scsi_driver</span><span class="p">.</span><span class="n">context</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_scsi_remove - Remove I2O device from SCSI core</span>
<span class="cm"> *	@dev: device which should be removed</span>
<span class="cm"> *</span>
<span class="cm"> *	Removes the I2O device from the SCSI core again.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_scsi_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">i2o_dev</span> <span class="o">=</span> <span class="n">to_i2o_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">iop</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_scsi_host</span> <span class="o">*</span><span class="n">i2o_shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsi_dev</span><span class="p">;</span>

	<span class="n">osm_info</span><span class="p">(</span><span class="s">&quot;device removed (TID: %03x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">lct_data</span><span class="p">.</span><span class="n">tid</span><span class="p">);</span>

	<span class="n">i2o_shost</span> <span class="o">=</span> <span class="n">i2o_scsi_get_host</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">shost_for_each_device</span><span class="p">(</span><span class="n">scsi_dev</span><span class="p">,</span> <span class="n">i2o_shost</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">)</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">hostdata</span> <span class="o">==</span> <span class="n">i2o_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="s">&quot;scsi&quot;</span><span class="p">);</span>
		<span class="n">scsi_remove_device</span><span class="p">(</span><span class="n">scsi_dev</span><span class="p">);</span>
		<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">scsi_dev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_scsi_probe - verify if dev is a I2O SCSI device and install it</span>
<span class="cm"> *	@dev: device to verify if it is a I2O SCSI device</span>
<span class="cm"> *</span>
<span class="cm"> *	Retrieve channel, id and lun for I2O device. If everything goes well</span>
<span class="cm"> *	register the I2O device as SCSI device on the I2O SCSI controller.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_scsi_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">i2o_dev</span> <span class="o">=</span> <span class="n">to_i2o_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">iop</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_scsi_host</span> <span class="o">*</span><span class="n">i2o_shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">scsi_host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsi_dev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">lun</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">channel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">i2o_shost</span> <span class="o">=</span> <span class="n">i2o_scsi_get_host</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2o_shost</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">scsi_host</span> <span class="o">=</span> <span class="n">i2o_shost</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">lct_data</span><span class="p">.</span><span class="n">class_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">I2O_CLASS_RANDOM_BLOCK_STORAGE</span>:
	<span class="k">case</span> <span class="n">I2O_CLASS_EXECUTIVE</span>:
<span class="cp">#ifdef CONFIG_I2O_EXT_ADAPTEC</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">adaptec</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">i2o_shost</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2o_parm_field_get</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">))</span>	<span class="cm">/* SCSI bus */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2o_parm_field_get</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mh">0x0200</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">lct_data</span><span class="p">.</span><span class="n">class_id</span> <span class="o">==</span>
					    <span class="n">I2O_CLASS_RANDOM_BLOCK_STORAGE</span><span class="p">)</span>
						<span class="n">lun</span> <span class="o">=</span>
						    <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">i2o_shost</span><span class="o">-&gt;</span>
								<span class="n">lun</span><span class="o">++</span><span class="p">);</span>
					<span class="k">else</span>
						<span class="n">lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">I2O_CLASS_SCSI_PERIPHERAL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">i2o_parm_field_get</span><span class="p">(</span><span class="n">i2o_dev</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i2o_parm_field_get</span><span class="p">(</span><span class="n">i2o_dev</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lun</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">parent</span> <span class="o">=</span> <span class="n">i2o_iop_find_device</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">lct_data</span><span class="p">.</span><span class="n">parent_tid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;can not find parent of device %03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">lct_data</span><span class="p">.</span><span class="n">tid</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">i2o_shost</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">max_channel</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i2o_shost</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">parent</span><span class="p">)</span>
				<span class="n">channel</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;can not find channel of device %03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">lct_data</span><span class="p">.</span><span class="n">tid</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">max_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;SCSI device id (%d) &gt;= max_id of I2O host (%d)&quot;</span><span class="p">,</span>
			 <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">id</span><span class="p">),</span> <span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">max_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">lun</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">max_lun</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;SCSI device lun (%lu) &gt;= max_lun of I2O host (%d)&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">lun</span><span class="p">),</span>
			 <span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">max_lun</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scsi_dev</span> <span class="o">=</span>
	    <span class="n">__scsi_add_device</span><span class="p">(</span><span class="n">i2o_shost</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">id</span><span class="p">),</span>
			      <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">lun</span><span class="p">),</span> <span class="n">i2o_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">scsi_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;can not add SCSI device %03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">lct_data</span><span class="p">.</span><span class="n">tid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">scsi_dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">scsi_dev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="s">&quot;scsi&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">osm_info</span><span class="p">(</span><span class="s">&quot;device added (TID: %03x) channel: %d, id: %d, lun: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">lct_data</span><span class="p">.</span><span class="n">tid</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">id</span><span class="p">),</span>
		 <span class="p">(</span><span class="kt">long</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">lun</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">scsi_remove_device</span><span class="p">(</span><span class="n">scsi_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">i2o_scsi_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">SChost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_scsi_host</span> <span class="o">*</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">hostdata</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">i2o_scsi_host</span> <span class="o">*</span><span class="p">)</span><span class="n">SChost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">hostdata</span><span class="o">-&gt;</span><span class="n">iop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_scsi_reply - SCSI OSM message reply handler</span>
<span class="cm"> *	@c: controller issuing the reply</span>
<span class="cm"> *	@m: message id for flushing</span>
<span class="cm"> *	@msg: the message from the controller</span>
<span class="cm"> *</span>
<span class="cm"> *	Process reply messages (interrupts in normal scsi controller think).</span>
<span class="cm"> *	We can get a variety of messages to process. The normal path is</span>
<span class="cm"> *	scsi command completions. We must also deal with IOP failures,</span>
<span class="cm"> *	the reply to a bus reset and the reply to a LUN query.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success and if the reply should not be flushed or &gt; 0</span>
<span class="cm"> *	on success and if the reply should be flushed. Returns negative error</span>
<span class="cm"> *	code on failure and if the reply should be flushed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_scsi_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u32</span> <span class="n">m</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">i2o_cntxt_list_get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tcntxt</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;NULL reply received!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *      Low byte is device status, next is adapter status,</span>
<span class="cm">	 *      (then one byte reserved), then request status.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;Completed %0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">error</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * if DeviceStatus is not SCSI_SUCCESS copy over the sense data and let</span>
<span class="cm">	 * the SCSI layer handle the error</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
		       <span class="n">min</span><span class="p">(</span><span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span> <span class="mi">40</span><span class="p">));</span>

	<span class="cm">/* only output error code if AdapterStatus is not HBA_SUCCESS */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;SCSI error %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_scsi_notify_device_add - Retrieve notifications of added devices</span>
<span class="cm"> *	@i2o_dev: the I2O device which was added</span>
<span class="cm"> *</span>
<span class="cm"> *	If a I2O device is added we catch the notification, because I2O classes</span>
<span class="cm"> *	other than SCSI peripheral will not be received through</span>
<span class="cm"> *	i2o_scsi_probe().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i2o_scsi_notify_device_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">i2o_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">lct_data</span><span class="p">.</span><span class="n">class_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">I2O_CLASS_EXECUTIVE</span>:
	<span class="k">case</span> <span class="n">I2O_CLASS_RANDOM_BLOCK_STORAGE</span>:
		<span class="n">i2o_scsi_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_scsi_notify_device_remove - Retrieve notifications of removed devices</span>
<span class="cm"> *	@i2o_dev: the I2O device which was removed</span>
<span class="cm"> *</span>
<span class="cm"> *	If a I2O device is removed, we catch the notification to remove the</span>
<span class="cm"> *	corresponding SCSI device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i2o_scsi_notify_device_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">i2o_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">lct_data</span><span class="p">.</span><span class="n">class_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">I2O_CLASS_EXECUTIVE</span>:
	<span class="k">case</span> <span class="n">I2O_CLASS_RANDOM_BLOCK_STORAGE</span>:
		<span class="n">i2o_scsi_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_scsi_notify_controller_add - Retrieve notifications of added controllers</span>
<span class="cm"> *	@c: the controller which was added</span>
<span class="cm"> *</span>
<span class="cm"> *	If a I2O controller is added, we catch the notification to add a</span>
<span class="cm"> *	corresponding Scsi_Host.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i2o_scsi_notify_controller_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_scsi_host</span> <span class="o">*</span><span class="n">i2o_shost</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">i2o_shost</span> <span class="o">=</span> <span class="n">i2o_scsi_host_alloc</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">i2o_shost</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;Could not initialize SCSI host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">scsi_add_host</span><span class="p">(</span><span class="n">i2o_shost</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;Could not add SCSI host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">i2o_shost</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">[</span><span class="n">i2o_scsi_driver</span><span class="p">.</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="n">i2o_shost</span><span class="p">;</span>

	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;new I2O SCSI host added</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_scsi_notify_controller_remove - Retrieve notifications of removed controllers</span>
<span class="cm"> *	@c: the controller which was removed</span>
<span class="cm"> *</span>
<span class="cm"> *	If a I2O controller is removed, we catch the notification to remove the</span>
<span class="cm"> *	corresponding Scsi_Host.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i2o_scsi_notify_controller_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_scsi_host</span> <span class="o">*</span><span class="n">i2o_shost</span><span class="p">;</span>
	<span class="n">i2o_shost</span> <span class="o">=</span> <span class="n">i2o_scsi_get_host</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2o_shost</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">[</span><span class="n">i2o_scsi_driver</span><span class="p">.</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">i2o_shost</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">i2o_shost</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">);</span>
	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;I2O SCSI host removed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* SCSI OSM driver struct */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">i2o_driver</span> <span class="n">i2o_scsi_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">OSM_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reply</span> <span class="o">=</span> <span class="n">i2o_scsi_reply</span><span class="p">,</span>
	<span class="p">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">i2o_scsi_class_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">notify_device_add</span> <span class="o">=</span> <span class="n">i2o_scsi_notify_device_add</span><span class="p">,</span>
	<span class="p">.</span><span class="n">notify_device_remove</span> <span class="o">=</span> <span class="n">i2o_scsi_notify_device_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">notify_controller_add</span> <span class="o">=</span> <span class="n">i2o_scsi_notify_controller_add</span><span class="p">,</span>
	<span class="p">.</span><span class="n">notify_controller_remove</span> <span class="o">=</span> <span class="n">i2o_scsi_notify_controller_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		   <span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">i2o_scsi_probe</span><span class="p">,</span>
		   <span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">i2o_scsi_remove</span><span class="p">,</span>
		   <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_scsi_queuecommand - queue a SCSI command</span>
<span class="cm"> *	@SCpnt: scsi command pointer</span>
<span class="cm"> *	@done: callback for completion</span>
<span class="cm"> *</span>
<span class="cm"> *	Issue a scsi command asynchronously. Return 0 on success or 1 if</span>
<span class="cm"> *	we hit an error (normally message queue congestion). The only</span>
<span class="cm"> *	minor complication here is that I2O deals with the device addressing</span>
<span class="cm"> *	so we have to map the bus/dev/lun back to an I2O handle as well</span>
<span class="cm"> *	as faking absent devices ourself.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locks: takes the controller lock on error path only</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_scsi_queuecommand_lck</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">SCpnt</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">i2o_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * ENABLE_DISCONNECT</span>
<span class="cm">	 * SIMPLE_TAG</span>
<span class="cm">	 * RETURN_SENSE_DATA_IN_REPLY_MESSAGE_FRAME</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">scsi_flags</span> <span class="o">=</span> <span class="mh">0x20a00000</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sgl_offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">mptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">I2O_CMD_SCSI_EXEC</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *      Do the incoming paperwork</span>
<span class="cm">	 */</span>
	<span class="n">i2o_dev</span> <span class="o">=</span> <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">i2o_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;no I2O device in request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">done</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">iop</span><span class="p">;</span>
	<span class="n">tid</span> <span class="o">=</span> <span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">lct_data</span><span class="p">.</span><span class="n">tid</span><span class="p">;</span>

	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;qcmd: Tid = %03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;Real scsi messages.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *      Put together a scsi execscb message</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_DMA_NONE</span>:
		<span class="cm">/* DATA NO XFER */</span>
		<span class="n">sgl_offset</span> <span class="o">=</span> <span class="n">SGL_OFFSET_0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PCI_DMA_TODEVICE</span>:
		<span class="cm">/* DATA OUT (iop--&gt;dev) */</span>
		<span class="n">scsi_flags</span> <span class="o">|=</span> <span class="mh">0x80000000</span><span class="p">;</span>
		<span class="n">sgl_offset</span> <span class="o">=</span> <span class="n">SGL_OFFSET_10</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PCI_DMA_FROMDEVICE</span>:
		<span class="cm">/* DATA IN  (iop&lt;--dev) */</span>
		<span class="n">scsi_flags</span> <span class="o">|=</span> <span class="mh">0x40000000</span><span class="p">;</span>
		<span class="n">sgl_offset</span> <span class="o">=</span> <span class="n">SGL_OFFSET_10</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* Unknown - kill the command */</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">done</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *      Obtain an I2O message. If there are none free then</span>
<span class="cm">	 *      throw it back to the scsi layer</span>
<span class="cm">	 */</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">i2o_msg_get</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="cp">#if 0</span><span class="c"> /* this code can&#39;t work */</span>
<span class="cp">#ifdef CONFIG_I2O_EXT_ADAPTEC</span>
<span class="c">	if (c-&gt;adaptec) {</span>
<span class="c">		u32 adpt_flags = 0;</span>

<span class="c">		if (SCpnt-&gt;sc_request &amp;&amp; SCpnt-&gt;sc_request-&gt;upper_private_data) {</span>
<span class="c">			i2o_sg_io_hdr_t __user *usr_ptr =</span>
<span class="c">			    ((Sg_request *) (SCpnt-&gt;sc_request-&gt;</span>
<span class="c">					     upper_private_data))-&gt;header.</span>
<span class="c">			    usr_ptr;</span>

<span class="c">			if (usr_ptr)</span>
<span class="c">				get_user(adpt_flags, &amp;usr_ptr-&gt;flags);</span>
<span class="c">		}</span>

<span class="c">		switch (i2o_dev-&gt;lct_data.class_id) {</span>
<span class="c">		case I2O_CLASS_EXECUTIVE:</span>
<span class="c">		case I2O_CLASS_RANDOM_BLOCK_STORAGE:</span>
<span class="c">			/* interpret flag has to be set for executive */</span>
<span class="c">			adpt_flags ^= I2O_DPT_SG_FLAG_INTERPRET;</span>
<span class="c">			break;</span>

<span class="c">		default:</span>
<span class="c">			break;</span>
<span class="c">		}</span>

<span class="c">		/*</span>
<span class="c">		 * for Adaptec controllers we use the PRIVATE command, because</span>
<span class="c">		 * the normal SCSI EXEC doesn&#39;t support all SCSI commands on</span>
<span class="c">		 * all controllers (for example READ CAPACITY).</span>
<span class="c">		 */</span>
<span class="c">		if (sgl_offset == SGL_OFFSET_10)</span>
<span class="c">			sgl_offset = SGL_OFFSET_12;</span>
<span class="c">		cmd = I2O_CMD_PRIVATE &lt;&lt; 24;</span>
<span class="c">		*mptr++ = cpu_to_le32(I2O_VENDOR_DPT &lt;&lt; 16 | I2O_CMD_SCSI_EXEC);</span>
<span class="c">		*mptr++ = cpu_to_le32(adpt_flags | tid);</span>
<span class="c">	}</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cmd</span> <span class="o">|</span> <span class="n">HOST_TID</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span> <span class="n">tid</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">icntxt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i2o_scsi_driver</span><span class="p">.</span><span class="n">context</span><span class="p">);</span>

	<span class="cm">/* We want the SCSI control block back */</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tcntxt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i2o_cntxt_list_add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">SCpnt</span><span class="p">));</span>

	<span class="cm">/* LSI_920_PCI_QUIRK</span>
<span class="cm">	 *</span>
<span class="cm">	 *      Intermittant observations of msg frame word data corruption</span>
<span class="cm">	 *      observed on msg[4] after:</span>
<span class="cm">	 *        WRITE, READ-MODIFY-WRITE</span>
<span class="cm">	 *      operations.  19990606 -sralston</span>
<span class="cm">	 *</span>
<span class="cm">	 *      (Hence we build this word via tag. Its good practice anyway</span>
<span class="cm">	 *       we don&#39;t want fetches over PCI needlessly)</span>
<span class="cm">	 */</span>

	<span class="cm">/* Attach tags to the devices */</span>
	<span class="cm">/* FIXME: implement</span>
<span class="cm">	   if(SCpnt-&gt;device-&gt;tagged_supported) {</span>
<span class="cm">	   if(SCpnt-&gt;tag == HEAD_OF_QUEUE_TAG)</span>
<span class="cm">	   scsi_flags |= 0x01000000;</span>
<span class="cm">	   else if(SCpnt-&gt;tag == ORDERED_QUEUE_TAG)</span>
<span class="cm">	   scsi_flags |= 0x01800000;</span>
<span class="cm">	   }</span>
<span class="cm">	 */</span>

	<span class="o">*</span><span class="n">mptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">scsi_flags</span> <span class="o">|</span> <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="cm">/* Write SCSI command into the message - always 16 byte block */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">mptr</span><span class="p">,</span> <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">mptr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sgl_offset</span> <span class="o">!=</span> <span class="n">SGL_OFFSET_0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* write size of data addressed by SGL */</span>
		<span class="o">*</span><span class="n">mptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">));</span>

		<span class="cm">/* Now fill in the SGList and command */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2o_dma_map_sg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">),</span>
					    <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">),</span>
					    <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mptr</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Stick the headers on */</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2O_MESSAGE_SIZE</span><span class="p">(</span><span class="n">mptr</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="n">sgl_offset</span><span class="p">);</span>

	<span class="cm">/* Queue the message */</span>
	<span class="n">i2o_msg_post</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;Issued %0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SCpnt</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

      <span class="nl">nomem:</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">i2o_msg_nop</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

      <span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">i2o_scsi_queuecommand</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_scsi_abort - abort a running command</span>
<span class="cm"> *	@SCpnt: command to abort</span>
<span class="cm"> *</span>
<span class="cm"> *	Ask the I2O controller to abort a command. This is an asynchrnous</span>
<span class="cm"> *	process and our callback handler will see the command complete with an</span>
<span class="cm"> *	aborted message if it succeeds.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 if the command is successfully aborted or negative error code</span>
<span class="cm"> *	on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">i2o_scsi_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">SCpnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">i2o_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>

	<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;Aborting command block.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">i2o_dev</span> <span class="o">=</span> <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">iop</span><span class="p">;</span>
	<span class="n">tid</span> <span class="o">=</span> <span class="n">i2o_dev</span><span class="o">-&gt;</span><span class="n">lct_data</span><span class="p">.</span><span class="n">tid</span><span class="p">;</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">i2o_msg_get_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">I2O_TIMEOUT_MESSAGE_GET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">FIVE_WORD_MSG_SIZE</span> <span class="o">|</span> <span class="n">SGL_OFFSET_0</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2O_CMD_SCSI_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> <span class="n">HOST_TID</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span> <span class="n">tid</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i2o_cntxt_list_get_ptr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">SCpnt</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2o_msg_post_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">I2O_TIMEOUT_SCSI_SCB_ABORT</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_scsi_bios_param	-	Invent disk geometry</span>
<span class="cm"> *	@sdev: scsi device</span>
<span class="cm"> *	@dev: block layer device</span>
<span class="cm"> *	@capacity: size in sectors</span>
<span class="cm"> *	@ip: geometry array</span>
<span class="cm"> *</span>
<span class="cm"> *	This is anyone&#39;s guess quite frankly. We use the same rules everyone</span>
<span class="cm"> *	else appears to and hope. It seems to work.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_scsi_bios_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">capacity</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
	<span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>		<span class="cm">/* heads                        */</span>
	<span class="n">ip</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>		<span class="cm">/* sectors                      */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ip</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* cylinders, test for big disk */</span>
		<span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>	<span class="cm">/* heads                        */</span>
		<span class="n">ip</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">63</span><span class="p">;</span>	<span class="cm">/* sectors                      */</span>
		<span class="n">ip</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="p">(</span><span class="mi">255</span> <span class="o">*</span> <span class="mi">63</span><span class="p">);</span>	<span class="cm">/* cylinders                    */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">i2o_scsi_host_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">proc_name</span> <span class="o">=</span> <span class="n">OSM_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">OSM_DESCRIPTION</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">i2o_scsi_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queuecommand</span> <span class="o">=</span> <span class="n">i2o_scsi_queuecommand</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_abort_handler</span> <span class="o">=</span> <span class="n">i2o_scsi_abort</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bios_param</span> <span class="o">=</span> <span class="n">i2o_scsi_bios_param</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_queue</span> <span class="o">=</span> <span class="n">I2O_SCSI_CAN_QUEUE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cmd_per_lun</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_clustering</span> <span class="o">=</span> <span class="n">ENABLE_CLUSTERING</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_scsi_init - SCSI OSM initialization function</span>
<span class="cm"> *</span>
<span class="cm"> *	Register SCSI OSM into I2O core.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">i2o_scsi_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">OSM_DESCRIPTION</span> <span class="s">&quot; v&quot;</span> <span class="n">OSM_VERSION</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Register SCSI OSM into I2O core */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2o_scsi_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;Could not register SCSI driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_scsi_exit - SCSI OSM exit function</span>
<span class="cm"> *</span>
<span class="cm"> *	Unregisters SCSI OSM from I2O core.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">i2o_scsi_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Unregister I2O SCSI OSM from I2O core */</span>
	<span class="n">i2o_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2o_scsi_driver</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Red Hat Software&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">OSM_DESCRIPTION</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">OSM_VERSION</span><span class="p">);</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">i2o_scsi_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">i2o_scsi_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
