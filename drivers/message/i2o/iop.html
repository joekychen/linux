<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › message › i2o › iop.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>iop.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	Functions to handle I2O controllers and I2O message handling</span>
<span class="cm"> *</span>
<span class="cm"> *	Copyright (C) 1999-2002	Red Hat Software</span>
<span class="cm"> *</span>
<span class="cm"> *	Written by Alan Cox, Building Number Three Ltd</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> *	under the terms of the GNU General Public License as published by the</span>
<span class="cm"> *	Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> *	option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *	A lot of the I2O message side code from this is taken from the</span>
<span class="cm"> *	Red Creek RCPCI45 adapter driver by Red Creek Communications</span>
<span class="cm"> *</span>
<span class="cm"> *	Fixes/additions:</span>
<span class="cm"> *		Philipp Rumpf</span>
<span class="cm"> *		Juha Sievänen &lt;Juha.Sievanen@cs.Helsinki.FI&gt;</span>
<span class="cm"> *		Auvo Häkkinen &lt;Auvo.Hakkinen@cs.Helsinki.FI&gt;</span>
<span class="cm"> *		Deepak Saxena &lt;deepak@plexity.net&gt;</span>
<span class="cm"> *		Boji T Kannanthanam &lt;boji.t.kannanthanam@intel.com&gt;</span>
<span class="cm"> *		Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;:</span>
<span class="cm"> *			Ported to Linux 2.5.</span>
<span class="cm"> *		Markus Lidel &lt;Markus.Lidel@shadowconnect.com&gt;:</span>
<span class="cm"> *			Minor fixes for 2.6.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/i2o.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;core.h&quot;</span>

<span class="cp">#define OSM_NAME	&quot;i2o&quot;</span>
<span class="cp">#define OSM_VERSION	&quot;1.325&quot;</span>
<span class="cp">#define OSM_DESCRIPTION	&quot;I2O subsystem&quot;</span>

<span class="cm">/* global I2O controller list */</span>
<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">i2o_controllers</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * global I2O System Table. Contains information about all the IOPs in the</span>
<span class="cm"> * system. Used to inform IOPs about each others existence.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">i2o_dma</span> <span class="n">i2o_systab</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">i2o_hrt_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_msg_get_wait - obtain an I2O message from the IOP</span>
<span class="cm"> *	@c: I2O controller</span>
<span class="cm"> *	@wait: how long to wait until timeout</span>
<span class="cm"> *</span>
<span class="cm"> *	This function waits up to wait seconds for a message slot to be</span>
<span class="cm"> *	available.</span>
<span class="cm"> *</span>
<span class="cm"> *	On a success the message is returned and the pointer to the message is</span>
<span class="cm"> *	set in msg. The returned message is the physical page frame offset</span>
<span class="cm"> *	address from the read port (see the i2o spec). If no message is</span>
<span class="cm"> *	available returns I2O_QUEUE_EMPTY and msg is leaved untouched.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="nf">i2o_msg_get_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">wait</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="n">i2o_msg_get</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: Timeout waiting for message frame.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">msg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#if BITS_PER_LONG == 64</span>
<span class="cm">/**</span>
<span class="cm"> *      i2o_cntxt_list_add - Append a pointer to context list and return a id</span>
<span class="cm"> *	@c: controller to which the context list belong</span>
<span class="cm"> *	@ptr: pointer to add to the context list</span>
<span class="cm"> *</span>
<span class="cm"> *	Because the context field in I2O is only 32-bit large, on 64-bit the</span>
<span class="cm"> *	pointer is to large to fit in the context field. The i2o_cntxt_list</span>
<span class="cm"> *	functions therefore map pointers to context fields.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns context id &gt; 0 on success or 0 on failure.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">i2o_cntxt_list_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_context_list_element</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span>
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;%s: couldn&#39;t add NULL pointer to context list!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;%s: Could not allocate memory for context list element&quot;</span>
			<span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">atomic_inc_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list_counter</span><span class="p">)))</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list_counter</span><span class="p">);</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list_counter</span><span class="p">);</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: Add context to list %p -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *      i2o_cntxt_list_remove - Remove a pointer from the context list</span>
<span class="cm"> *	@c: controller to which the context list belong</span>
<span class="cm"> *	@ptr: pointer which should be removed from the context list</span>
<span class="cm"> *</span>
<span class="cm"> *	Removes a previously added pointer from the context list and returns</span>
<span class="cm"> *	the matching context id.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns context id on success or 0 on failure.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">i2o_cntxt_list_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_context_list_element</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">==</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">context</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="p">)</span>
		<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;%s: Could not remove nonexistent ptr %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			 <span class="n">ptr</span><span class="p">);</span>

	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: remove ptr from context list %d -&gt; %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		  <span class="n">context</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">context</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *      i2o_cntxt_list_get - Get a pointer from the context list and remove it</span>
<span class="cm"> *	@c: controller to which the context list belong</span>
<span class="cm"> *	@context: context id to which the pointer belong</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns pointer to the matching context id on success or NULL on</span>
<span class="cm"> *	failure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">i2o_cntxt_list_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u32</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_context_list_element</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">==</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span>
		<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;%s: context id %d not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>

	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: get ptr from context list %d -&gt; %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span>
		  <span class="n">ptr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *      i2o_cntxt_list_get_ptr - Get a context id from the context list</span>
<span class="cm"> *	@c: controller to which the context list belong</span>
<span class="cm"> *	@ptr: pointer to which the context id should be fetched</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns context id which matches to the pointer on success or 0 on</span>
<span class="cm"> *	failure.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">i2o_cntxt_list_get_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_context_list_element</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">==</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">context</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="p">)</span>
		<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;%s: Could not find nonexistent ptr %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			 <span class="n">ptr</span><span class="p">);</span>

	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: get context id from context list %p -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		  <span class="n">ptr</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">context</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_iop_find - Find an I2O controller by id</span>
<span class="cm"> *	@unit: unit number of the I2O controller to search for</span>
<span class="cm"> *</span>
<span class="cm"> *	Lookup the I2O controller on the controller list.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns pointer to the I2O controller on success or NULL if not found.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="nf">i2o_find_iop</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2o_controllers</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">unit</span> <span class="o">==</span> <span class="n">unit</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_iop_find_device - Find a I2O device on an I2O controller</span>
<span class="cm"> *	@c: I2O controller where the I2O device hangs on</span>
<span class="cm"> *	@tid: TID of the I2O device to search for</span>
<span class="cm"> *</span>
<span class="cm"> *	Searches the devices of the I2O controller for a device with TID tid and</span>
<span class="cm"> *	returns it.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns a pointer to the I2O device if found, otherwise NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="nf">i2o_iop_find_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u16</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lct_data</span><span class="p">.</span><span class="n">tid</span> <span class="o">==</span> <span class="n">tid</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_quiesce_controller - quiesce controller</span>
<span class="cm"> *	@c: controller</span>
<span class="cm"> *</span>
<span class="cm"> *	Quiesce an IOP. Causes IOP to make external operation quiescent</span>
<span class="cm"> *	(i2o &#39;READY&#39; state). Internal operation of the IOP continues normally.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_iop_quiesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="n">i2o_status_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">status_block</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">i2o_status_get</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="cm">/* SysQuiesce discarded if IOP not in READY or OPERATIONAL state */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">iop_state</span> <span class="o">!=</span> <span class="n">ADAPTER_STATE_READY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">iop_state</span> <span class="o">!=</span> <span class="n">ADAPTER_STATE_OPERATIONAL</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">i2o_msg_get_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">I2O_TIMEOUT_MESSAGE_GET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">FOUR_WORD_MSG_SIZE</span> <span class="o">|</span> <span class="n">SGL_OFFSET_0</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2O_CMD_SYS_QUIESCE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> <span class="n">HOST_TID</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span>
			<span class="n">ADAPTER_TID</span><span class="p">);</span>

	<span class="cm">/* Long timeout needed for quiesce if lots of devices */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_msg_post_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">240</span><span class="p">)))</span>
		<span class="n">osm_info</span><span class="p">(</span><span class="s">&quot;%s: Unable to quiesce (status=%#x).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">-</span><span class="n">rc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: Quiesced.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">i2o_status_get</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>	<span class="c1">// Entered READY state</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_iop_enable - move controller from ready to OPERATIONAL</span>
<span class="cm"> *	@c: I2O controller</span>
<span class="cm"> *</span>
<span class="cm"> *	Enable IOP. This allows the IOP to resume external operations and</span>
<span class="cm"> *	reverses the effect of a quiesce. Returns zero or an error code if</span>
<span class="cm"> *	an error occurs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_iop_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="n">i2o_status_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">status_block</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">i2o_status_get</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="cm">/* Enable only allowed on READY state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">iop_state</span> <span class="o">!=</span> <span class="n">ADAPTER_STATE_READY</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">i2o_msg_get_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">I2O_TIMEOUT_MESSAGE_GET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">FOUR_WORD_MSG_SIZE</span> <span class="o">|</span> <span class="n">SGL_OFFSET_0</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2O_CMD_SYS_ENABLE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> <span class="n">HOST_TID</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span>
			<span class="n">ADAPTER_TID</span><span class="p">);</span>

	<span class="cm">/* How long of a timeout do we need? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_msg_post_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">240</span><span class="p">)))</span>
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;%s: Could not enable (status=%#x).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">-</span><span class="n">rc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: Enabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">i2o_status_get</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>	<span class="c1">// entered OPERATIONAL state</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_iop_quiesce_all - Quiesce all I2O controllers on the system</span>
<span class="cm"> *</span>
<span class="cm"> *	Quiesce all I2O controllers which are connected to the system.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i2o_iop_quiesce_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2o_controllers</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">no_quiesce</span><span class="p">)</span>
			<span class="n">i2o_iop_quiesce</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_iop_enable_all - Enables all controllers on the system</span>
<span class="cm"> *</span>
<span class="cm"> *	Enables all I2O controllers which are connected to the system.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i2o_iop_enable_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2o_controllers</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
	    <span class="n">i2o_iop_enable</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_clear_controller - Bring I2O controller into HOLD state</span>
<span class="cm"> *	@c: controller</span>
<span class="cm"> *</span>
<span class="cm"> *	Clear an IOP to HOLD state, ie. terminate external operations, clear all</span>
<span class="cm"> *	input queues and prepare for a system restart. IOP&#39;s internal operation</span>
<span class="cm"> *	continues normally and the outbound queue is alive. The IOP is not</span>
<span class="cm"> *	expected to rebuild its LCT.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_iop_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">i2o_msg_get_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">I2O_TIMEOUT_MESSAGE_GET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

	<span class="cm">/* Quiesce all IOPs first */</span>
	<span class="n">i2o_iop_quiesce_all</span><span class="p">();</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">FOUR_WORD_MSG_SIZE</span> <span class="o">|</span> <span class="n">SGL_OFFSET_0</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2O_CMD_ADAPTER_CLEAR</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> <span class="n">HOST_TID</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span>
			<span class="n">ADAPTER_TID</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_msg_post_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">30</span><span class="p">)))</span>
		<span class="n">osm_info</span><span class="p">(</span><span class="s">&quot;%s: Unable to clear (status=%#x).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">-</span><span class="n">rc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: Cleared.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* Enable all IOPs */</span>
	<span class="n">i2o_iop_enable_all</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_iop_init_outbound_queue - setup the outbound message queue</span>
<span class="cm"> *	@c: I2O controller</span>
<span class="cm"> *</span>
<span class="cm"> *	Clear and (re)initialize IOP&#39;s outbound queue and post the message</span>
<span class="cm"> *	frames to the IOP.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_iop_init_outbound_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">m</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u8</span> <span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="n">ulong</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: Initializing Outbound Queue...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">i2o_msg_get_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">I2O_TIMEOUT_MESSAGE_GET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EIGHT_WORD_MSG_SIZE</span> <span class="o">|</span> <span class="n">SGL_OFFSET_6</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2O_CMD_OUTBOUND_INIT</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> <span class="n">HOST_TID</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span>
			<span class="n">ADAPTER_TID</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">icntxt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i2o_exec_driver</span><span class="p">.</span><span class="n">context</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tcntxt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="cm">/* Outbound msg frame size in words and Initcode */</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2O_OUTBOUND_MSG_FRAME_SIZE</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span> <span class="mh">0x80</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xd0000004</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i2o_dma_low</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">phys</span><span class="p">));</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i2o_dma_high</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">phys</span><span class="p">));</span>

	<span class="n">i2o_msg_post</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">I2O_TIMEOUT_INIT_OUTBOUND_QUEUE</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">status</span> <span class="o">&lt;=</span> <span class="n">I2O_CMD_IN_PROGRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;%s: Timeout Initializing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">m</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">out_queue</span><span class="p">.</span><span class="n">phys</span><span class="p">;</span>

	<span class="cm">/* Post frames */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">I2O_MAX_OUTBOUND_MSG_FRAMES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i2o_flush_reply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>	<span class="cm">/* Promise */</span>
		<span class="n">m</span> <span class="o">+=</span> <span class="n">I2O_OUTBOUND_MSG_FRAME_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_iop_reset - reset an I2O controller</span>
<span class="cm"> *	@c: controller to reset</span>
<span class="cm"> *</span>
<span class="cm"> *	Reset the IOP into INIT state and wait until IOP gets into RESET state.</span>
<span class="cm"> *	Terminate all external operations, clear IOP&#39;s inbound and outbound</span>
<span class="cm"> *	queues, terminate all DDMs, and reload the IOP&#39;s operating environment</span>
<span class="cm"> *	and all local DDMs. The IOP rebuilds its LCT.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_iop_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="n">u8</span> <span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="n">i2o_status_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">status_block</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: Resetting controller</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">i2o_msg_get_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">I2O_TIMEOUT_MESSAGE_GET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">status_block</span><span class="p">.</span><span class="n">virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="cm">/* Quiesce all IOPs first */</span>
	<span class="n">i2o_iop_quiesce_all</span><span class="p">();</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EIGHT_WORD_MSG_SIZE</span> <span class="o">|</span> <span class="n">SGL_OFFSET_0</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2O_CMD_ADAPTER_RESET</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> <span class="n">HOST_TID</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span>
			<span class="n">ADAPTER_TID</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">icntxt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i2o_exec_driver</span><span class="p">.</span><span class="n">context</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tcntxt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i2o_dma_low</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">phys</span><span class="p">));</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i2o_dma_high</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">phys</span><span class="p">));</span>

	<span class="n">i2o_msg_post</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="cm">/* Wait for a reply */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">I2O_TIMEOUT_RESET</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!*</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">I2O_CMD_REJECTED</span>:
		<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;%s: IOP reset rejected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">I2O_CMD_IN_PROGRESS</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Once the reset is sent, the IOP goes into the INIT state</span>
<span class="cm">		 * which is indeterminate. We need to wait until the IOP has</span>
<span class="cm">		 * rebooted before we can let the system talk to it. We read</span>
<span class="cm">		 * the inbound Free_List until a message is available. If we</span>
<span class="cm">		 * can&#39;t read one in the given amount of time, we assume the</span>
<span class="cm">		 * IOP could not reboot properly.</span>
<span class="cm">		 */</span>
		<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: Reset in progress, waiting for reboot...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="n">i2o_msg_get_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">I2O_TIMEOUT_RESET</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;%s: IOP reset timeout.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">i2o_msg_nop</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

		<span class="cm">/* from here all quiesce commands are safe */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">no_quiesce</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* verify if controller is in state RESET */</span>
		<span class="n">i2o_status_get</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">promise</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">iop_state</span> <span class="o">!=</span> <span class="n">ADAPTER_STATE_RESET</span><span class="p">))</span>
			<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;%s: reset completed, but adapter not in RESET&quot;</span>
				 <span class="s">&quot; state.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: reset completed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;%s: IOP reset timeout.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

      <span class="nl">exit:</span>
	<span class="cm">/* Enable all IOPs */</span>
	<span class="n">i2o_iop_enable_all</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_iop_activate - Bring controller up to HOLD</span>
<span class="cm"> *	@c: controller</span>
<span class="cm"> *</span>
<span class="cm"> *	This function brings an I2O controller into HOLD state. The adapter</span>
<span class="cm"> *	is reset if necessary and then the queues and resource table are read.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_iop_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i2o_status_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">status_block</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/* In INIT state, Wait Inbound Q to initialize (in i2o_status_get) */</span>
	<span class="cm">/* In READY state, Get status */</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_status_get</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">osm_info</span><span class="p">(</span><span class="s">&quot;%s: Unable to obtain status, attempting a reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_iop_reset</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">i2o_version</span> <span class="o">&gt;</span> <span class="n">I2OVER15</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;%s: Not running version 1.5 of the I2O Specification.&quot;</span>
			<span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">iop_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ADAPTER_STATE_FAULTED</span>:
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;%s: hardware fault</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ADAPTER_STATE_READY</span>:
	<span class="k">case</span> <span class="n">ADAPTER_STATE_OPERATIONAL</span>:
	<span class="k">case</span> <span class="n">ADAPTER_STATE_HOLD</span>:
	<span class="k">case</span> <span class="n">ADAPTER_STATE_FAILED</span>:
		<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: already running, trying to reset...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_iop_reset</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* preserve state */</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">iop_state</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_iop_init_outbound_queue</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* if adapter was not in RESET state clear now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">ADAPTER_STATE_RESET</span><span class="p">)</span>
		<span class="n">i2o_iop_clear</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">i2o_status_get</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">iop_state</span> <span class="o">!=</span> <span class="n">ADAPTER_STATE_HOLD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;%s: failed to bring IOP into HOLD state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">i2o_hrt_get</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_iop_systab_set - Set the I2O System Table of the specified IOP</span>
<span class="cm"> *	@c: I2O controller to which the system table should be send</span>
<span class="cm"> *</span>
<span class="cm"> *	Before the systab could be set i2o_systab_build() must be called.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_iop_systab_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="n">i2o_status_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">status_block</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">current_mem_size</span> <span class="o">&lt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">desired_mem_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mem_resource</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_MEM</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">osm_info</span><span class="p">(</span><span class="s">&quot;%s: requires private memory resources.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">pci_find_parent_resource</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;%s: Can&#39;t find parent resource!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">&amp;&amp;</span> <span class="n">allocate_resource</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">desired_mem_size</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">desired_mem_size</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">desired_mem_size</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>	<span class="cm">/* Unspecified, so use 1Mb and play safe */</span>
					      <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">mem_alloc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">current_mem_size</span> <span class="o">=</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">current_mem_base</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
			<span class="n">osm_info</span><span class="p">(</span><span class="s">&quot;%s: allocated %llu bytes of PCI memory at &quot;</span>
				<span class="s">&quot;0x%016llX.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">current_io_size</span> <span class="o">&lt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">desired_io_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">io_resource</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_IO</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">osm_info</span><span class="p">(</span><span class="s">&quot;%s: requires private memory resources.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">pci_find_parent_resource</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">osm_warn</span><span class="p">(</span><span class="s">&quot;%s: Can&#39;t find parent resource!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">&amp;&amp;</span> <span class="n">allocate_resource</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">desired_io_size</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">desired_io_size</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">desired_io_size</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>	<span class="cm">/* Unspecified, so use 1Mb and play safe */</span>
					      <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">io_alloc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">current_io_size</span> <span class="o">=</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">current_mem_base</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
			<span class="n">osm_info</span><span class="p">(</span><span class="s">&quot;%s: allocated %llu bytes of PCI I/O at &quot;</span>
				<span class="s">&quot;0x%016llX.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">i2o_msg_get_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">I2O_TIMEOUT_MESSAGE_GET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

	<span class="n">i2o_systab</span><span class="p">.</span><span class="n">phys</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i2o_systab</span><span class="p">.</span><span class="n">virt</span><span class="p">,</span> <span class="n">i2o_systab</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
					 <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2o_systab</span><span class="p">.</span><span class="n">phys</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i2o_msg_nop</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2O_MESSAGE_SIZE</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="o">|</span> <span class="n">SGL_OFFSET_6</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2O_CMD_SYS_TAB_SET</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> <span class="n">HOST_TID</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span>
			<span class="n">ADAPTER_TID</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Provide three SGL-elements:</span>
<span class="cm">	 * System table (SysTab), Private memory space declaration and</span>
<span class="cm">	 * Private i/o space declaration</span>
<span class="cm">	 */</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">unit</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x54000000</span> <span class="o">|</span> <span class="n">i2o_systab</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i2o_systab</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x54000000</span> <span class="o">|</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">current_mem_size</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">current_mem_base</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xd4000000</span> <span class="o">|</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">current_io_size</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">current_io_base</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_msg_post_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">120</span><span class="p">);</span>

	<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i2o_systab</span><span class="p">.</span><span class="n">phys</span><span class="p">,</span> <span class="n">i2o_systab</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
			 <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;%s: Unable to set SysTab (status=%#x).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="o">-</span><span class="n">rc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: SysTab set.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_iop_online - Bring a controller online into OPERATIONAL state.</span>
<span class="cm"> *	@c: I2O controller</span>
<span class="cm"> *</span>
<span class="cm"> *	Send the system table and enable the I2O controller.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_iop_online</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_iop_systab_set</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* In READY state */</span>
	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: Attempting to enable...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_iop_enable</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_iop_remove - Remove the I2O controller from the I2O core</span>
<span class="cm"> *	@c: I2O controller</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove the I2O controller from the I2O core. If devices are attached to</span>
<span class="cm"> *	the controller remove these also and finally reset the controller.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2o_iop_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: deleting controller</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">i2o_driver_notify_controller_remove_all</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
	    <span class="n">i2o_device_remove</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">device_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>

	<span class="cm">/* Ask the IOP to switch to RESET state */</span>
	<span class="n">i2o_iop_reset</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_systab_build - Build system table</span>
<span class="cm"> *</span>
<span class="cm"> *	The system table contains information about all the IOPs in the system</span>
<span class="cm"> *	(duh) and is used by the Executives on the IOPs to establish peer2peer</span>
<span class="cm"> *	connections. We&#39;re not supporting peer2peer at the moment, but this</span>
<span class="cm"> *	will be needed down the road for things like lan2lan forwarding.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_systab_build</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_controllers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">change_ind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_sys_tbl</span> <span class="o">*</span><span class="n">systab</span> <span class="o">=</span> <span class="n">i2o_systab</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2o_controllers</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
	    <span class="n">num_controllers</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">systab</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">change_ind</span> <span class="o">=</span> <span class="n">systab</span><span class="o">-&gt;</span><span class="n">change_ind</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">i2o_systab</span><span class="p">.</span><span class="n">virt</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Header + IOPs */</span>
	<span class="n">i2o_systab</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_sys_tbl</span><span class="p">)</span> <span class="o">+</span> <span class="n">num_controllers</span> <span class="o">*</span>
	    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_sys_tbl_entry</span><span class="p">);</span>

	<span class="n">systab</span> <span class="o">=</span> <span class="n">i2o_systab</span><span class="p">.</span><span class="n">virt</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">i2o_systab</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">systab</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;unable to allocate memory for System Table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">systab</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">I2OVERSION</span><span class="p">;</span>
	<span class="n">systab</span><span class="o">-&gt;</span><span class="n">change_ind</span> <span class="o">=</span> <span class="n">change_ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2o_controllers</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i2o_status_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">num_controllers</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;controller added while building system table&quot;</span>
				<span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sb</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">status_block</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Get updated IOP state so we have the latest information</span>
<span class="cm">		 *</span>
<span class="cm">		 * We should delete the controller at this point if it</span>
<span class="cm">		 * doesn&#39;t respond since if it&#39;s not on the system table</span>
<span class="cm">		 * it is techninically not part of the I2O subsystem...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i2o_status_get</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;%s: Deleting b/c could not get status while &quot;</span>
				<span class="s">&quot;attempting to build system table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">i2o_iop_remove</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="c1">// try the next one</span>
		<span class="p">}</span>

		<span class="n">systab</span><span class="o">-&gt;</span><span class="n">iops</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">org_id</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">org_id</span><span class="p">;</span>
		<span class="n">systab</span><span class="o">-&gt;</span><span class="n">iops</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">iop_id</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">unit</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">systab</span><span class="o">-&gt;</span><span class="n">iops</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">seg_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">systab</span><span class="o">-&gt;</span><span class="n">iops</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">i2o_version</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">i2o_version</span><span class="p">;</span>
		<span class="n">systab</span><span class="o">-&gt;</span><span class="n">iops</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">iop_state</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">iop_state</span><span class="p">;</span>
		<span class="n">systab</span><span class="o">-&gt;</span><span class="n">iops</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">msg_type</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">msg_type</span><span class="p">;</span>
		<span class="n">systab</span><span class="o">-&gt;</span><span class="n">iops</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">frame_size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">inbound_frame_size</span><span class="p">;</span>
		<span class="n">systab</span><span class="o">-&gt;</span><span class="n">iops</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">last_changed</span> <span class="o">=</span> <span class="n">change_ind</span><span class="p">;</span>
		<span class="n">systab</span><span class="o">-&gt;</span><span class="n">iops</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">iop_capabilities</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">iop_capabilities</span><span class="p">;</span>
		<span class="n">systab</span><span class="o">-&gt;</span><span class="n">iops</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">inbound_low</span> <span class="o">=</span>
		    <span class="n">i2o_dma_low</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">phys</span> <span class="o">+</span> <span class="n">I2O_IN_PORT</span><span class="p">);</span>
		<span class="n">systab</span><span class="o">-&gt;</span><span class="n">iops</span><span class="p">[</span><span class="n">count</span><span class="p">].</span><span class="n">inbound_high</span> <span class="o">=</span>
		    <span class="n">i2o_dma_high</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">phys</span> <span class="o">+</span> <span class="n">I2O_IN_PORT</span><span class="p">);</span>

		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">systab</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_parse_hrt - Parse the hardware resource table.</span>
<span class="cm"> *	@c: I2O controller</span>
<span class="cm"> *</span>
<span class="cm"> *	We don&#39;t do anything with it except dumping it (in debug mode).</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_parse_hrt</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i2o_dump_hrt</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_status_get - Get the status block from the I2O controller</span>
<span class="cm"> *	@c: I2O controller</span>
<span class="cm"> *</span>
<span class="cm"> *	Issue a status query on the controller. This updates the attached</span>
<span class="cm"> *	status block. The status block could then be accessed through</span>
<span class="cm"> *	c-&gt;status_block.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2o_status_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">u8</span> <span class="o">*</span><span class="n">status_block</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">status_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">status_block</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">status_block</span><span class="p">.</span><span class="n">virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i2o_status_block</span><span class="p">));</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">i2o_msg_get_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">I2O_TIMEOUT_MESSAGE_GET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">NINE_WORD_MSG_SIZE</span> <span class="o">|</span> <span class="n">SGL_OFFSET_0</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2O_CMD_STATUS_GET</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> <span class="n">HOST_TID</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span>
			<span class="n">ADAPTER_TID</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">icntxt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i2o_exec_driver</span><span class="p">.</span><span class="n">context</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tcntxt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i2o_dma_low</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">status_block</span><span class="p">.</span><span class="n">phys</span><span class="p">));</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i2o_dma_high</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">status_block</span><span class="p">.</span><span class="n">phys</span><span class="p">));</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">i2o_status_block</span><span class="p">));</span>	<span class="cm">/* always 88 bytes */</span>

	<span class="n">i2o_msg_post</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="cm">/* Wait for a reply */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">I2O_TIMEOUT_STATUS_GET</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">status_block</span><span class="p">[</span><span class="mi">87</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;%s: Get status timeout.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="n">i2o_debug_state</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	i2o_hrt_get - Get the Hardware Resource Table from the I2O controller</span>
<span class="cm"> *	@c: I2O controller from which the HRT should be fetched</span>
<span class="cm"> *</span>
<span class="cm"> *	The HRT contains information about possible hidden devices but is</span>
<span class="cm"> *	mostly useless to us.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2o_hrt_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">i2o_hrt</span> <span class="o">*</span><span class="n">hrt</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">hrt</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i2o_hrt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">I2O_HRT_GET_TRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

		<span class="n">msg</span> <span class="o">=</span> <span class="n">i2o_msg_get_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">I2O_TIMEOUT_MESSAGE_GET</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">SIX_WORD_MSG_SIZE</span> <span class="o">|</span> <span class="n">SGL_OFFSET_4</span><span class="p">);</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
		    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2O_CMD_HRT_GET</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> <span class="n">HOST_TID</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span>
				<span class="n">ADAPTER_TID</span><span class="p">);</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0xd0000000</span> <span class="o">|</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">hrt</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">hrt</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_msg_post_wait_mem</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">hrt</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;%s: Unable to get HRT (status=%#x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				<span class="o">-</span><span class="n">rc</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">hrt</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">*</span> <span class="n">hrt</span><span class="o">-&gt;</span><span class="n">entry_len</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">hrt</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i2o_dma_realloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">hrt</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">hrt</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">hrt</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="n">i2o_parse_hrt</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;%s: Unable to get HRT after %d tries, giving up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		<span class="n">I2O_HRT_GET_TRIES</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_iop_release - release the memory for a I2O controller</span>
<span class="cm"> *	@dev: I2O controller which should be released</span>
<span class="cm"> *</span>
<span class="cm"> *	Release the allocated memory. This function is called if refcount of</span>
<span class="cm"> *	device reaches 0 automatically.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i2o_iop_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">to_i2o_controller</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">i2o_iop_free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_iop_alloc - Allocate and initialize a i2o_controller struct</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate the necessary memory for a i2o_controller struct and</span>
<span class="cm"> *	initialize the lists and message mempool.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns a pointer to the I2O controller or a negative error code on</span>
<span class="cm"> *	failure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="nf">i2o_iop_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">unit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* 0 and 1 are NULL IOP and Local Host */</span>
	<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">poolname</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;i2o: Insufficient memory to allocate a I2O controller.&quot;</span>
			<span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span><span class="o">++</span><span class="p">;</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;iop%d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">unit</span><span class="p">);</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">poolname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">poolname</span><span class="p">),</span> <span class="s">&quot;i2o_%s_msg_inpool&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2o_pool_alloc</span>
	    <span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">in_msg</span><span class="p">,</span> <span class="n">poolname</span><span class="p">,</span> <span class="n">I2O_INBOUND_MSG_FRAME_SIZE</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
	     <span class="n">I2O_MSG_INPOOL_MIN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">};</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lct_lock</span><span class="p">);</span>

	<span class="n">device_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i2o_iop_release</span><span class="p">;</span>

	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;iop%d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">unit</span><span class="p">);</span>

<span class="cp">#if BITS_PER_LONG == 64</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list_lock</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list_counter</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context_list</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_iop_add - Initialize the I2O controller and add him to the I2O core</span>
<span class="cm"> *	@c: controller</span>
<span class="cm"> *</span>
<span class="cm"> *	Initialize the I2O controller and if no error occurs add him to the I2O</span>
<span class="cm"> *	core.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2o_iop_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">device_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;%s: could not add controller</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">iop_reset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">osm_info</span><span class="p">(</span><span class="s">&quot;%s: Activating I2O controller...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">osm_info</span><span class="p">(</span><span class="s">&quot;%s: This may take a few minutes if there are many devices</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_iop_activate</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">osm_err</span><span class="p">(</span><span class="s">&quot;%s: could not activate controller</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">device_del</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: building sys table...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_systab_build</span><span class="p">()))</span>
		<span class="k">goto</span> <span class="n">device_del</span><span class="p">;</span>

	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: online controller...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_iop_online</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">device_del</span><span class="p">;</span>

	<span class="n">osm_debug</span><span class="p">(</span><span class="s">&quot;%s: getting LCT...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_exec_lct_get</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">device_del</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2o_controllers</span><span class="p">);</span>

	<span class="n">i2o_driver_notify_controller_add_all</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">osm_info</span><span class="p">(</span><span class="s">&quot;%s: Controller added</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

      <span class="nl">device_del:</span>
	<span class="n">device_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>

      <span class="nl">iop_reset:</span>
	<span class="n">i2o_iop_reset</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_event_register - Turn on/off event notification for a I2O device</span>
<span class="cm"> *	@dev: I2O device which should receive the event registration request</span>
<span class="cm"> *	@drv: driver which want to get notified</span>
<span class="cm"> *	@tcntxt: transaction context to use with this notifier</span>
<span class="cm"> *	@evt_mask: mask of events</span>
<span class="cm"> *</span>
<span class="cm"> *	Create and posts an event registration message to the task. No reply</span>
<span class="cm"> *	is waited for, or expected. If you do not want further notifications,</span>
<span class="cm"> *	call the i2o_event_register again with a evt_mask of 0.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2o_event_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2o_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2o_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">tcntxt</span><span class="p">,</span> <span class="n">u32</span> <span class="n">evt_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2o_controller</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">iop</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2o_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">i2o_msg_get_wait</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">I2O_TIMEOUT_MESSAGE_GET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">FIVE_WORD_MSG_SIZE</span> <span class="o">|</span> <span class="n">SGL_OFFSET_0</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
	    <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2O_CMD_UTIL_EVT_REGISTER</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> <span class="n">HOST_TID</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="o">|</span> <span class="n">dev</span><span class="o">-&gt;</span>
			<span class="n">lct_data</span><span class="p">.</span><span class="n">tid</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">icntxt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">tcntxt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">tcntxt</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">evt_mask</span><span class="p">);</span>

	<span class="n">i2o_msg_post</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_iop_init - I2O main initialization function</span>
<span class="cm"> *</span>
<span class="cm"> *	Initialize the I2O drivers (OSM) functions, register the Executive OSM,</span>
<span class="cm"> *	initialize the I2O PCI part and finally initialize I2O device stuff.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">i2o_iop_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">OSM_DESCRIPTION</span> <span class="s">&quot; v&quot;</span> <span class="n">OSM_VERSION</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_driver_init</span><span class="p">()))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_exec_init</span><span class="p">()))</span>
		<span class="k">goto</span> <span class="n">driver_exit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">i2o_pci_init</span><span class="p">()))</span>
		<span class="k">goto</span> <span class="n">exec_exit</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

      <span class="nl">exec_exit:</span>
	<span class="n">i2o_exec_exit</span><span class="p">();</span>

      <span class="nl">driver_exit:</span>
	<span class="n">i2o_driver_exit</span><span class="p">();</span>

      <span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	i2o_iop_exit - I2O main exit function</span>
<span class="cm"> *</span>
<span class="cm"> *	Removes I2O controllers from PCI subsystem and shut down OSMs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">i2o_iop_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i2o_pci_exit</span><span class="p">();</span>
	<span class="n">i2o_exec_exit</span><span class="p">();</span>
	<span class="n">i2o_driver_exit</span><span class="p">();</span>
<span class="p">};</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">i2o_iop_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">i2o_iop_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Red Hat Software&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">OSM_DESCRIPTION</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">OSM_VERSION</span><span class="p">);</span>

<span class="cp">#if BITS_PER_LONG == 64</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2o_cntxt_list_add</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2o_cntxt_list_get</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2o_cntxt_list_remove</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2o_cntxt_list_get_ptr</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2o_msg_get_wait</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2o_find_iop</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2o_iop_find_device</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2o_event_register</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2o_status_get</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2o_controllers</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
