<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › spi › spi-atmel.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>spi-atmel.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Driver for Atmel AT32 and AT91 SPI Controllers</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006 Atmel Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/spi/spi.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;mach/board.h&gt;</span>
<span class="cp">#include &lt;asm/gpio.h&gt;</span>
<span class="cp">#include &lt;mach/cpu.h&gt;</span>

<span class="cm">/* SPI register offsets */</span>
<span class="cp">#define SPI_CR					0x0000</span>
<span class="cp">#define SPI_MR					0x0004</span>
<span class="cp">#define SPI_RDR					0x0008</span>
<span class="cp">#define SPI_TDR					0x000c</span>
<span class="cp">#define SPI_SR					0x0010</span>
<span class="cp">#define SPI_IER					0x0014</span>
<span class="cp">#define SPI_IDR					0x0018</span>
<span class="cp">#define SPI_IMR					0x001c</span>
<span class="cp">#define SPI_CSR0				0x0030</span>
<span class="cp">#define SPI_CSR1				0x0034</span>
<span class="cp">#define SPI_CSR2				0x0038</span>
<span class="cp">#define SPI_CSR3				0x003c</span>
<span class="cp">#define SPI_RPR					0x0100</span>
<span class="cp">#define SPI_RCR					0x0104</span>
<span class="cp">#define SPI_TPR					0x0108</span>
<span class="cp">#define SPI_TCR					0x010c</span>
<span class="cp">#define SPI_RNPR				0x0110</span>
<span class="cp">#define SPI_RNCR				0x0114</span>
<span class="cp">#define SPI_TNPR				0x0118</span>
<span class="cp">#define SPI_TNCR				0x011c</span>
<span class="cp">#define SPI_PTCR				0x0120</span>
<span class="cp">#define SPI_PTSR				0x0124</span>

<span class="cm">/* Bitfields in CR */</span>
<span class="cp">#define SPI_SPIEN_OFFSET			0</span>
<span class="cp">#define SPI_SPIEN_SIZE				1</span>
<span class="cp">#define SPI_SPIDIS_OFFSET			1</span>
<span class="cp">#define SPI_SPIDIS_SIZE				1</span>
<span class="cp">#define SPI_SWRST_OFFSET			7</span>
<span class="cp">#define SPI_SWRST_SIZE				1</span>
<span class="cp">#define SPI_LASTXFER_OFFSET			24</span>
<span class="cp">#define SPI_LASTXFER_SIZE			1</span>

<span class="cm">/* Bitfields in MR */</span>
<span class="cp">#define SPI_MSTR_OFFSET				0</span>
<span class="cp">#define SPI_MSTR_SIZE				1</span>
<span class="cp">#define SPI_PS_OFFSET				1</span>
<span class="cp">#define SPI_PS_SIZE				1</span>
<span class="cp">#define SPI_PCSDEC_OFFSET			2</span>
<span class="cp">#define SPI_PCSDEC_SIZE				1</span>
<span class="cp">#define SPI_FDIV_OFFSET				3</span>
<span class="cp">#define SPI_FDIV_SIZE				1</span>
<span class="cp">#define SPI_MODFDIS_OFFSET			4</span>
<span class="cp">#define SPI_MODFDIS_SIZE			1</span>
<span class="cp">#define SPI_LLB_OFFSET				7</span>
<span class="cp">#define SPI_LLB_SIZE				1</span>
<span class="cp">#define SPI_PCS_OFFSET				16</span>
<span class="cp">#define SPI_PCS_SIZE				4</span>
<span class="cp">#define SPI_DLYBCS_OFFSET			24</span>
<span class="cp">#define SPI_DLYBCS_SIZE				8</span>

<span class="cm">/* Bitfields in RDR */</span>
<span class="cp">#define SPI_RD_OFFSET				0</span>
<span class="cp">#define SPI_RD_SIZE				16</span>

<span class="cm">/* Bitfields in TDR */</span>
<span class="cp">#define SPI_TD_OFFSET				0</span>
<span class="cp">#define SPI_TD_SIZE				16</span>

<span class="cm">/* Bitfields in SR */</span>
<span class="cp">#define SPI_RDRF_OFFSET				0</span>
<span class="cp">#define SPI_RDRF_SIZE				1</span>
<span class="cp">#define SPI_TDRE_OFFSET				1</span>
<span class="cp">#define SPI_TDRE_SIZE				1</span>
<span class="cp">#define SPI_MODF_OFFSET				2</span>
<span class="cp">#define SPI_MODF_SIZE				1</span>
<span class="cp">#define SPI_OVRES_OFFSET			3</span>
<span class="cp">#define SPI_OVRES_SIZE				1</span>
<span class="cp">#define SPI_ENDRX_OFFSET			4</span>
<span class="cp">#define SPI_ENDRX_SIZE				1</span>
<span class="cp">#define SPI_ENDTX_OFFSET			5</span>
<span class="cp">#define SPI_ENDTX_SIZE				1</span>
<span class="cp">#define SPI_RXBUFF_OFFSET			6</span>
<span class="cp">#define SPI_RXBUFF_SIZE				1</span>
<span class="cp">#define SPI_TXBUFE_OFFSET			7</span>
<span class="cp">#define SPI_TXBUFE_SIZE				1</span>
<span class="cp">#define SPI_NSSR_OFFSET				8</span>
<span class="cp">#define SPI_NSSR_SIZE				1</span>
<span class="cp">#define SPI_TXEMPTY_OFFSET			9</span>
<span class="cp">#define SPI_TXEMPTY_SIZE			1</span>
<span class="cp">#define SPI_SPIENS_OFFSET			16</span>
<span class="cp">#define SPI_SPIENS_SIZE				1</span>

<span class="cm">/* Bitfields in CSR0 */</span>
<span class="cp">#define SPI_CPOL_OFFSET				0</span>
<span class="cp">#define SPI_CPOL_SIZE				1</span>
<span class="cp">#define SPI_NCPHA_OFFSET			1</span>
<span class="cp">#define SPI_NCPHA_SIZE				1</span>
<span class="cp">#define SPI_CSAAT_OFFSET			3</span>
<span class="cp">#define SPI_CSAAT_SIZE				1</span>
<span class="cp">#define SPI_BITS_OFFSET				4</span>
<span class="cp">#define SPI_BITS_SIZE				4</span>
<span class="cp">#define SPI_SCBR_OFFSET				8</span>
<span class="cp">#define SPI_SCBR_SIZE				8</span>
<span class="cp">#define SPI_DLYBS_OFFSET			16</span>
<span class="cp">#define SPI_DLYBS_SIZE				8</span>
<span class="cp">#define SPI_DLYBCT_OFFSET			24</span>
<span class="cp">#define SPI_DLYBCT_SIZE				8</span>

<span class="cm">/* Bitfields in RCR */</span>
<span class="cp">#define SPI_RXCTR_OFFSET			0</span>
<span class="cp">#define SPI_RXCTR_SIZE				16</span>

<span class="cm">/* Bitfields in TCR */</span>
<span class="cp">#define SPI_TXCTR_OFFSET			0</span>
<span class="cp">#define SPI_TXCTR_SIZE				16</span>

<span class="cm">/* Bitfields in RNCR */</span>
<span class="cp">#define SPI_RXNCR_OFFSET			0</span>
<span class="cp">#define SPI_RXNCR_SIZE				16</span>

<span class="cm">/* Bitfields in TNCR */</span>
<span class="cp">#define SPI_TXNCR_OFFSET			0</span>
<span class="cp">#define SPI_TXNCR_SIZE				16</span>

<span class="cm">/* Bitfields in PTCR */</span>
<span class="cp">#define SPI_RXTEN_OFFSET			0</span>
<span class="cp">#define SPI_RXTEN_SIZE				1</span>
<span class="cp">#define SPI_RXTDIS_OFFSET			1</span>
<span class="cp">#define SPI_RXTDIS_SIZE				1</span>
<span class="cp">#define SPI_TXTEN_OFFSET			8</span>
<span class="cp">#define SPI_TXTEN_SIZE				1</span>
<span class="cp">#define SPI_TXTDIS_OFFSET			9</span>
<span class="cp">#define SPI_TXTDIS_SIZE				1</span>

<span class="cm">/* Constants for BITS */</span>
<span class="cp">#define SPI_BITS_8_BPT				0</span>
<span class="cp">#define SPI_BITS_9_BPT				1</span>
<span class="cp">#define SPI_BITS_10_BPT				2</span>
<span class="cp">#define SPI_BITS_11_BPT				3</span>
<span class="cp">#define SPI_BITS_12_BPT				4</span>
<span class="cp">#define SPI_BITS_13_BPT				5</span>
<span class="cp">#define SPI_BITS_14_BPT				6</span>
<span class="cp">#define SPI_BITS_15_BPT				7</span>
<span class="cp">#define SPI_BITS_16_BPT				8</span>

<span class="cm">/* Bit manipulation macros */</span>
<span class="cp">#define SPI_BIT(name) \</span>
<span class="cp">	(1 &lt;&lt; SPI_##name##_OFFSET)</span>
<span class="cp">#define SPI_BF(name,value) \</span>
<span class="cp">	(((value) &amp; ((1 &lt;&lt; SPI_##name##_SIZE) - 1)) &lt;&lt; SPI_##name##_OFFSET)</span>
<span class="cp">#define SPI_BFEXT(name,value) \</span>
<span class="cp">	(((value) &gt;&gt; SPI_##name##_OFFSET) &amp; ((1 &lt;&lt; SPI_##name##_SIZE) - 1))</span>
<span class="cp">#define SPI_BFINS(name,value,old) \</span>
<span class="cp">	( ((old) &amp; ~(((1 &lt;&lt; SPI_##name##_SIZE) - 1) &lt;&lt; SPI_##name##_OFFSET)) \</span>
<span class="cp">	  | SPI_BF(name,value))</span>

<span class="cm">/* Register access macros */</span>
<span class="cp">#define spi_readl(port,reg) \</span>
<span class="cp">	__raw_readl((port)-&gt;regs + SPI_##reg)</span>
<span class="cp">#define spi_writel(port,reg,value) \</span>
<span class="cp">	__raw_writel((value), (port)-&gt;regs + SPI_##reg)</span>


<span class="cm">/*</span>
<span class="cm"> * The core SPI transfer engine just talks to a register bank to set up</span>
<span class="cm"> * DMA transfers; transfer queue progress is driven by IRQs.  The clock</span>
<span class="cm"> * framework provides the base clock, subdivided for each spi_device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">atmel_spi</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>

	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span>		<span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span>	<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_device</span>	<span class="o">*</span><span class="n">stay</span><span class="p">;</span>

	<span class="n">u8</span>			<span class="n">stopping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span>	<span class="o">*</span><span class="n">current_transfer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">current_remaining_bytes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span>	<span class="o">*</span><span class="n">next_transfer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">next_remaining_bytes</span><span class="p">;</span>

	<span class="kt">void</span>			<span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">buffer_dma</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Controller-specific per-slave state */</span>
<span class="k">struct</span> <span class="n">atmel_spi_device</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">npcs_pin</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">csr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define BUFFER_SIZE		PAGE_SIZE</span>
<span class="cp">#define INVALID_DMA_ADDRESS	0xffffffff</span>

<span class="cm">/*</span>
<span class="cm"> * Version 2 of the SPI controller has</span>
<span class="cm"> *  - CR.LASTXFER</span>
<span class="cm"> *  - SPI_MR.DIV32 may become FDIV or must-be-zero (here: always zero)</span>
<span class="cm"> *  - SPI_SR.TXEMPTY, SPI_SR.NSSR (and corresponding irqs)</span>
<span class="cm"> *  - SPI_CSRx.CSAAT</span>
<span class="cm"> *  - SPI_CSRx.SBCR allows faster clocking</span>
<span class="cm"> *</span>
<span class="cm"> * We can determine the controller version by reading the VERSION</span>
<span class="cm"> * register, but I haven&#39;t checked that it exists on all chips, and</span>
<span class="cm"> * this is cheaper anyway.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">atmel_spi_is_v2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">cpu_is_at91rm9200</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Earlier SPI controllers (e.g. on at91rm9200) have a design bug whereby</span>
<span class="cm"> * they assume that spi slave device state will not change on deselect, so</span>
<span class="cm"> * that automagic deselection is OK.  (&quot;NPCSx rises if no data is to be</span>
<span class="cm"> * transmitted&quot;)  Not so!  Workaround uses nCSx pins as GPIOs; or newer</span>
<span class="cm"> * controllers have CSAAT and friends.</span>
<span class="cm"> *</span>
<span class="cm"> * Since the CSAAT functionality is a bit weird on newer controllers as</span>
<span class="cm"> * well, we use GPIO to control nCSx pins on all controllers, updating</span>
<span class="cm"> * MR.PCS to avoid confusing the controller.  Using GPIOs also lets us</span>
<span class="cm"> * support active-high chipselects despite the controller&#39;s belief that</span>
<span class="cm"> * only active-low devices/systems exists.</span>
<span class="cm"> *</span>
<span class="cm"> * However, at91rm9200 has a second erratum whereby nCS0 doesn&#39;t work</span>
<span class="cm"> * right when driven with GPIO.  (&quot;Mode Fault does not allow more than one</span>
<span class="cm"> * Master on Chip Select 0.&quot;)  No workaround exists for that ... so for</span>
<span class="cm"> * nCS0 on that chip, we (a) don&#39;t use the GPIO, (b) can&#39;t support CS_HIGH,</span>
<span class="cm"> * and (c) will trigger that first erratum in some cases.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: Test if the atmel_spi_is_v2() branch below works on</span>
<span class="cm"> * AT91RM9200 if we use some other register than CSR0. However, don&#39;t</span>
<span class="cm"> * do this unconditionally since AP7000 has an errata where the BITS</span>
<span class="cm"> * field in CSR0 overrides all other CSRs.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cs_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">atmel_spi</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atmel_spi_device</span> <span class="o">*</span><span class="n">asd</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">controller_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">active</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SPI_CS_HIGH</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atmel_spi_is_v2</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Always use CSR0. This ensures that the clock</span>
<span class="cm">		 * switches to the correct idle polarity before we</span>
<span class="cm">		 * toggle the CS.</span>
<span class="cm">		 */</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">CSR0</span><span class="p">,</span> <span class="n">asd</span><span class="o">-&gt;</span><span class="n">csr</span><span class="p">);</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">MR</span><span class="p">,</span> <span class="n">SPI_BF</span><span class="p">(</span><span class="n">PCS</span><span class="p">,</span> <span class="mh">0x0e</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">MODFDIS</span><span class="p">)</span>
				<span class="o">|</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">MSTR</span><span class="p">));</span>
		<span class="n">mr</span> <span class="o">=</span> <span class="n">spi_readl</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">MR</span><span class="p">);</span>
		<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">asd</span><span class="o">-&gt;</span><span class="n">npcs_pin</span><span class="p">,</span> <span class="n">active</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">cpol</span> <span class="o">=</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SPI_CPOL</span><span class="p">)</span> <span class="o">?</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">CPOL</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">csr</span><span class="p">;</span>

		<span class="cm">/* Make sure clock polarity is correct */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">num_chipselect</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">csr</span> <span class="o">=</span> <span class="n">spi_readl</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">CSR0</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">csr</span> <span class="o">^</span> <span class="n">cpol</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">CPOL</span><span class="p">))</span>
				<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">CSR0</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span>
						<span class="n">csr</span> <span class="o">^</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">CPOL</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">mr</span> <span class="o">=</span> <span class="n">spi_readl</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">MR</span><span class="p">);</span>
		<span class="n">mr</span> <span class="o">=</span> <span class="n">SPI_BFINS</span><span class="p">(</span><span class="n">PCS</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">chip_select</span><span class="p">),</span> <span class="n">mr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">chip_select</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">asd</span><span class="o">-&gt;</span><span class="n">npcs_pin</span><span class="p">,</span> <span class="n">active</span><span class="p">);</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">MR</span><span class="p">,</span> <span class="n">mr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;activate %u%s, mr %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">asd</span><span class="o">-&gt;</span><span class="n">npcs_pin</span><span class="p">,</span> <span class="n">active</span> <span class="o">?</span> <span class="s">&quot; (high)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="n">mr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cs_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">atmel_spi</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atmel_spi_device</span> <span class="o">*</span><span class="n">asd</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">controller_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">active</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SPI_CS_HIGH</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mr</span><span class="p">;</span>

	<span class="cm">/* only deactivate *this* device; sometimes transfers to</span>
<span class="cm">	 * another device may be active when this routine is called.</span>
<span class="cm">	 */</span>
	<span class="n">mr</span> <span class="o">=</span> <span class="n">spi_readl</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">MR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">SPI_BFEXT</span><span class="p">(</span><span class="n">PCS</span><span class="p">,</span> <span class="n">mr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">chip_select</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mr</span> <span class="o">=</span> <span class="n">SPI_BFINS</span><span class="p">(</span><span class="n">PCS</span><span class="p">,</span> <span class="mh">0xf</span><span class="p">,</span> <span class="n">mr</span><span class="p">);</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">MR</span><span class="p">,</span> <span class="n">mr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DEactivate %u%s, mr %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">asd</span><span class="o">-&gt;</span><span class="n">npcs_pin</span><span class="p">,</span> <span class="n">active</span> <span class="o">?</span> <span class="s">&quot; (low)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="n">mr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atmel_spi_is_v2</span><span class="p">()</span> <span class="o">||</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">chip_select</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">asd</span><span class="o">-&gt;</span><span class="n">npcs_pin</span><span class="p">,</span> <span class="o">!</span><span class="n">active</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">atmel_spi_xfer_is_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">transfers</span><span class="p">.</span><span class="n">prev</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">transfer_list</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">atmel_spi_xfer_can_be_chained</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">delay_usecs</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">cs_change</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">atmel_spi_next_xfer_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">,</span>
				<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">tx_dma</span><span class="p">,</span>
				<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">rx_dma</span><span class="p">,</span>
				<span class="n">u32</span> <span class="o">*</span><span class="n">plen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atmel_spi</span>	<span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="n">u32</span>			<span class="n">len</span> <span class="o">=</span> <span class="o">*</span><span class="n">plen</span><span class="p">;</span>

	<span class="cm">/* use scratch buffer only when rx or tx data is unspecified */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">)</span>
		<span class="o">*</span><span class="n">rx_dma</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_dma</span> <span class="o">+</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="o">*</span><span class="n">plen</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">rx_dma</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">buffer_dma</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">BUFFER_SIZE</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">)</span>
		<span class="o">*</span><span class="n">tx_dma</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_dma</span> <span class="o">+</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="o">*</span><span class="n">plen</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">tx_dma</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">buffer_dma</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">BUFFER_SIZE</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">as</span><span class="o">-&gt;</span><span class="n">buffer_dma</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">plen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Submit next transfer for DMA.</span>
<span class="cm"> * lock is held, spi irq is blocked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">atmel_spi_next_xfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atmel_spi</span>	<span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span>	<span class="o">*</span><span class="n">xfer</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">len</span><span class="p">,</span> <span class="n">remaining</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ieval</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">tx_dma</span><span class="p">,</span> <span class="n">rx_dma</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">current_transfer</span><span class="p">)</span>
		<span class="n">xfer</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">transfers</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">spi_transfer</span><span class="p">,</span> <span class="n">transfer_list</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">next_transfer</span><span class="p">)</span>
		<span class="n">xfer</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">current_transfer</span><span class="o">-&gt;</span><span class="n">transfer_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">spi_transfer</span><span class="p">,</span> <span class="n">transfer_list</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">xfer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">PTCR</span><span class="p">,</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">RXTDIS</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">TXTDIS</span><span class="p">));</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">atmel_spi_next_xfer_data</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">xfer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">remaining</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">RPR</span><span class="p">,</span> <span class="n">rx_dma</span><span class="p">);</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">TPR</span><span class="p">,</span> <span class="n">tx_dma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">RCR</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">TCR</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;  start xfer %p: len %u tx %p/%08x rx %p/%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xfer</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">,</span>
			<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xfer</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">next_transfer</span><span class="p">;</span>
		<span class="n">remaining</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">next_remaining_bytes</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">as</span><span class="o">-&gt;</span><span class="n">current_transfer</span> <span class="o">=</span> <span class="n">xfer</span><span class="p">;</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">current_remaining_bytes</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atmel_spi_xfer_is_last</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">xfer</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">atmel_spi_xfer_can_be_chained</span><span class="p">(</span><span class="n">xfer</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfer</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">transfer_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">spi_transfer</span><span class="p">,</span> <span class="n">transfer_list</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">xfer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">as</span><span class="o">-&gt;</span><span class="n">next_transfer</span> <span class="o">=</span> <span class="n">xfer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span>	<span class="n">total</span><span class="p">;</span>

		<span class="n">total</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">atmel_spi_next_xfer_data</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">xfer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">as</span><span class="o">-&gt;</span><span class="n">next_remaining_bytes</span> <span class="o">=</span> <span class="n">total</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">RNPR</span><span class="p">,</span> <span class="n">rx_dma</span><span class="p">);</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">TNPR</span><span class="p">,</span> <span class="n">tx_dma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">RNCR</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">TNCR</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;  next xfer %p: len %u tx %p/%08x rx %p/%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xfer</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">,</span>
			<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">);</span>
		<span class="n">ieval</span> <span class="o">=</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">ENDRX</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">OVRES</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">RNCR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">TNCR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ieval</span> <span class="o">=</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">RXBUFF</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">ENDRX</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">OVRES</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* REVISIT: We&#39;re waiting for ENDRX before we start the next</span>
<span class="cm">	 * transfer because we need to handle some difficult timing</span>
<span class="cm">	 * issues otherwise. If we wait for ENDTX in one transfer and</span>
<span class="cm">	 * then starts waiting for ENDRX in the next, it&#39;s difficult</span>
<span class="cm">	 * to tell the difference between the ENDRX interrupt we&#39;re</span>
<span class="cm">	 * actually waiting for and the ENDRX interrupt of the</span>
<span class="cm">	 * previous transfer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * It should be doable, though. Just not now...</span>
<span class="cm">	 */</span>
	<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">IER</span><span class="p">,</span> <span class="n">ieval</span><span class="p">);</span>
	<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">PTCR</span><span class="p">,</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">TXTEN</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">RXTEN</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">atmel_spi_next_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atmel_spi</span>	<span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_message</span>	<span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_device</span>	<span class="o">*</span><span class="n">spi</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">current_transfer</span><span class="p">);</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="n">spi</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&quot;start message %p for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">msg</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>

	<span class="cm">/* select chip if it&#39;s not still active */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">stay</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">stay</span> <span class="o">!=</span> <span class="n">spi</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cs_deactivate</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">stay</span><span class="p">);</span>
			<span class="n">cs_activate</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">spi</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">as</span><span class="o">-&gt;</span><span class="n">stay</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cs_activate</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">spi</span><span class="p">);</span>

	<span class="n">atmel_spi_next_xfer</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For DMA, tx_buf/tx_dma have the same relationship as rx_buf/rx_dma:</span>
<span class="cm"> *  - The buffer is either valid for CPU access, else NULL</span>
<span class="cm"> *  - If the buffer is valid, so is its DMA address</span>
<span class="cm"> *</span>
<span class="cm"> * This driver manages the dma address unless message-&gt;is_dma_mapped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">atmel_spi_dma_map_xfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">atmel_spi</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span>	<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_dma</span> <span class="o">=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_dma</span> <span class="o">=</span> <span class="n">INVALID_DMA_ADDRESS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* tx_buf is a const void* where we need a void * for the dma</span>
<span class="cm">		 * mapping */</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">nonconst_tx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">;</span>

		<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">nonconst_tx</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				<span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				<span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">)</span>
				<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
						<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
						<span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">atmel_spi_dma_unmap_xfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_dma</span> <span class="o">!=</span> <span class="n">INVALID_DMA_ADDRESS</span><span class="p">)</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">,</span>
				 <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_dma</span> <span class="o">!=</span> <span class="n">INVALID_DMA_ADDRESS</span><span class="p">)</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">,</span>
				 <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">atmel_spi_msg_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span> <span class="k">struct</span> <span class="n">atmel_spi</span> <span class="o">*</span><span class="n">as</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stay</span> <span class="o">||</span> <span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cs_deactivate</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">as</span><span class="o">-&gt;</span><span class="n">stay</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">;</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
		<span class="s">&quot;xfer complete: %u bytes transferred</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">as</span><span class="o">-&gt;</span><span class="n">current_transfer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">next_transfer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* continue if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="o">||</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">stopping</span><span class="p">)</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">PTCR</span><span class="p">,</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">RXTDIS</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">TXTDIS</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">atmel_spi_next_message</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">atmel_spi_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_master</span>	<span class="o">*</span><span class="n">master</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atmel_spi</span>	<span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_message</span>	<span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span>	<span class="o">*</span><span class="n">xfer</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">status</span><span class="p">,</span> <span class="n">pending</span><span class="p">,</span> <span class="n">imr</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">xfer</span> <span class="o">=</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">current_transfer</span><span class="p">;</span>
	<span class="n">msg</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>

	<span class="n">imr</span> <span class="o">=</span> <span class="n">spi_readl</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">IMR</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">spi_readl</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">SR</span><span class="p">);</span>
	<span class="n">pending</span> <span class="o">=</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">imr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">&amp;</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">OVRES</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">IDR</span><span class="p">,</span> <span class="p">(</span><span class="n">SPI_BIT</span><span class="p">(</span><span class="n">RXBUFF</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">ENDRX</span><span class="p">)</span>
				     <span class="o">|</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">OVRES</span><span class="p">)));</span>

		<span class="cm">/*</span>
<span class="cm">		 * When we get an overrun, we disregard the current</span>
<span class="cm">		 * transfer. Data will not be copied back from any</span>
<span class="cm">		 * bounce buffer and msg-&gt;actual_len will not be</span>
<span class="cm">		 * updated with the last xfer.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We will also not process any remaning transfers in</span>
<span class="cm">		 * the message.</span>
<span class="cm">		 *</span>
<span class="cm">		 * First, stop the transfer and unmap the DMA buffers.</span>
<span class="cm">		 */</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">PTCR</span><span class="p">,</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">RXTDIS</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">TXTDIS</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">is_dma_mapped</span><span class="p">)</span>
			<span class="n">atmel_spi_dma_unmap_xfer</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">xfer</span><span class="p">);</span>

		<span class="cm">/* REVISIT: udelay in irq is unfriendly */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">delay_usecs</span><span class="p">)</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">delay_usecs</span><span class="p">);</span>

		<span class="n">dev_warn</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&quot;overrun (%u/%u remaining)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">spi_readl</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">TCR</span><span class="p">),</span> <span class="n">spi_readl</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">RCR</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Clean up DMA registers and make sure the data</span>
<span class="cm">		 * registers are empty.</span>
<span class="cm">		 */</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">RNCR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">TNCR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">RCR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">TCR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">timeout</span><span class="p">;</span> <span class="n">timeout</span><span class="o">--</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">spi_readl</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">SR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">TXEMPTY</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeout</span><span class="p">)</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
				 <span class="s">&quot;timeout waiting for TXEMPTY&quot;</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">spi_readl</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">SR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">RDRF</span><span class="p">))</span>
			<span class="n">spi_readl</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">RDR</span><span class="p">);</span>

		<span class="cm">/* Clear any overrun happening while cleaning up */</span>
		<span class="n">spi_readl</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">SR</span><span class="p">);</span>

		<span class="n">atmel_spi_msg_done</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">as</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SPI_BIT</span><span class="p">(</span><span class="n">RXBUFF</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">ENDRX</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">IDR</span><span class="p">,</span> <span class="n">pending</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">current_remaining_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msg</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">is_dma_mapped</span><span class="p">)</span>
				<span class="n">atmel_spi_dma_unmap_xfer</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">xfer</span><span class="p">);</span>

			<span class="cm">/* REVISIT: udelay in irq is unfriendly */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">delay_usecs</span><span class="p">)</span>
				<span class="n">udelay</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">delay_usecs</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">atmel_spi_xfer_is_last</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">xfer</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* report completed message */</span>
				<span class="n">atmel_spi_msg_done</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">as</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">cs_change</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">cs_change</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">cs_deactivate</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">);</span>
					<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
					<span class="n">cs_activate</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * Not done yet. Submit the next transfer.</span>
<span class="cm">				 *</span>
<span class="cm">				 * FIXME handle protocol options for xfer</span>
<span class="cm">				 */</span>
				<span class="n">atmel_spi_next_xfer</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Keep going, we still have data to send in</span>
<span class="cm">			 * the current transfer.</span>
<span class="cm">			 */</span>
			<span class="n">atmel_spi_next_xfer</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">atmel_spi_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atmel_spi</span>	<span class="o">*</span><span class="n">as</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atmel_spi_device</span>	<span class="o">*</span><span class="n">asd</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">scbr</span><span class="p">,</span> <span class="n">csr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bits</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">bus_hz</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">npcs_pin</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ret</span><span class="p">;</span>

	<span class="n">as</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">stopping</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">chip_select</span> <span class="o">&gt;</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">num_chipselect</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;setup: invalid chipselect %u (%u defined)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">spi</span><span class="o">-&gt;</span><span class="n">chip_select</span><span class="p">,</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">num_chipselect</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="o">||</span> <span class="n">bits</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;setup: invalid bits_per_word %u (8 to 16)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bits</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* see notes above re chipselect */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atmel_spi_is_v2</span><span class="p">()</span>
			<span class="o">&amp;&amp;</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">chip_select</span> <span class="o">==</span> <span class="mi">0</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SPI_CS_HIGH</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;setup: can&#39;t be active-high</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* v1 chips start out at half the peripheral bus speed. */</span>
	<span class="n">bus_hz</span> <span class="o">=</span> <span class="n">clk_get_rate</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atmel_spi_is_v2</span><span class="p">())</span>
		<span class="n">bus_hz</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Calculate the lowest divider that satisfies the</span>
<span class="cm">		 * constraint, assuming div32/fdiv/mbz == 0.</span>
<span class="cm">		 */</span>
		<span class="n">scbr</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">bus_hz</span><span class="p">,</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the resulting divider doesn&#39;t fit into the</span>
<span class="cm">		 * register bitfield, we can&#39;t satisfy the constraint.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scbr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SPI_SCBR_SIZE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;setup: %d Hz too slow, scbr %u; min %ld Hz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span><span class="p">,</span> <span class="n">scbr</span><span class="p">,</span> <span class="n">bus_hz</span><span class="o">/</span><span class="mi">255</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* speed zero means &quot;as slow as possible&quot; */</span>
		<span class="n">scbr</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="n">csr</span> <span class="o">=</span> <span class="n">SPI_BF</span><span class="p">(</span><span class="n">SCBR</span><span class="p">,</span> <span class="n">scbr</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPI_BF</span><span class="p">(</span><span class="n">BITS</span><span class="p">,</span> <span class="n">bits</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SPI_CPOL</span><span class="p">)</span>
		<span class="n">csr</span> <span class="o">|=</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">CPOL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SPI_CPHA</span><span class="p">))</span>
		<span class="n">csr</span> <span class="o">|=</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">NCPHA</span><span class="p">);</span>

	<span class="cm">/* DLYBS is mostly irrelevant since we manage chipselect using GPIOs.</span>
<span class="cm">	 *</span>
<span class="cm">	 * DLYBCT would add delays between words, slowing down transfers.</span>
<span class="cm">	 * It could potentially be useful to cope with DMA bottlenecks, but</span>
<span class="cm">	 * in those cases it&#39;s probably best to just use a lower bitrate.</span>
<span class="cm">	 */</span>
	<span class="n">csr</span> <span class="o">|=</span> <span class="n">SPI_BF</span><span class="p">(</span><span class="n">DLYBS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">csr</span> <span class="o">|=</span> <span class="n">SPI_BF</span><span class="p">(</span><span class="n">DLYBCT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* chipselect must have been muxed as GPIO (e.g. in board setup) */</span>
	<span class="n">npcs_pin</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">controller_data</span><span class="p">;</span>
	<span class="n">asd</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">controller_state</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">asd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">atmel_spi_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asd</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">gpio_request</span><span class="p">(</span><span class="n">npcs_pin</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">asd</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">asd</span><span class="o">-&gt;</span><span class="n">npcs_pin</span> <span class="o">=</span> <span class="n">npcs_pin</span><span class="p">;</span>
		<span class="n">spi</span><span class="o">-&gt;</span><span class="n">controller_state</span> <span class="o">=</span> <span class="n">asd</span><span class="p">;</span>
		<span class="n">gpio_direction_output</span><span class="p">(</span><span class="n">npcs_pin</span><span class="p">,</span> <span class="o">!</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SPI_CS_HIGH</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">stay</span> <span class="o">==</span> <span class="n">spi</span><span class="p">)</span>
			<span class="n">as</span><span class="o">-&gt;</span><span class="n">stay</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">cs_deactivate</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">spi</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">asd</span><span class="o">-&gt;</span><span class="n">csr</span> <span class="o">=</span> <span class="n">csr</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;setup: %lu Hz bpw %u mode 0x%x -&gt; csr%d %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">bus_hz</span> <span class="o">/</span> <span class="n">scbr</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">,</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">chip_select</span><span class="p">,</span> <span class="n">csr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atmel_spi_is_v2</span><span class="p">())</span>
		<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">CSR0</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">chip_select</span><span class="p">,</span> <span class="n">csr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">atmel_spi_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atmel_spi</span>	<span class="o">*</span><span class="n">as</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span>	<span class="o">*</span><span class="n">xfer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">controller</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">bits</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atmel_spi_device</span>	<span class="o">*</span><span class="n">asd</span><span class="p">;</span>

	<span class="n">as</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="s">&quot;new message %p submitted for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">msg</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">transfers</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">stopping</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">xfer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">transfers</span><span class="p">,</span> <span class="n">transfer_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">||</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;missing rx or tx buf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">asd</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">controller_state</span><span class="p">;</span>
			<span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">asd</span><span class="o">-&gt;</span><span class="n">csr</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">!=</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;you can&#39;t yet change &quot;</span>
					 <span class="s">&quot;bits_per_word in transfers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* FIXME implement these protocol options!! */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">speed_hz</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no protocol options yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * DMA map early, for performance (empties dcache ASAP) and</span>
<span class="cm">		 * better fault reporting.  This is a DMA-only driver.</span>
<span class="cm">		 *</span>
<span class="cm">		 * NOTE that if dma_unmap_single() ever starts to do work on</span>
<span class="cm">		 * platforms supported by this driver, we would need to clean</span>
<span class="cm">		 * up mappings for previously-mapped transfers.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">is_dma_mapped</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atmel_spi_dma_map_xfer</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">xfer</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#ifdef VERBOSE</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">xfer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">transfers</span><span class="p">,</span> <span class="n">transfer_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span>
			<span class="s">&quot;  xfer %p: len %u tx %p/%08x rx %p/%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xfer</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
			<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">,</span>
			<span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">,</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">current_transfer</span><span class="p">)</span>
		<span class="n">atmel_spi_next_message</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">atmel_spi_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atmel_spi</span>	<span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">atmel_spi_device</span>	<span class="o">*</span><span class="n">asd</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">controller_state</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">gpio</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">controller_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asd</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">stay</span> <span class="o">==</span> <span class="n">spi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">as</span><span class="o">-&gt;</span><span class="n">stay</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">cs_deactivate</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">spi</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">spi</span><span class="o">-&gt;</span><span class="n">controller_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">gpio_free</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">asd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">atmel_spi_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span>		<span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span>		<span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_master</span>	<span class="o">*</span><span class="n">master</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atmel_spi</span>	<span class="o">*</span><span class="n">as</span><span class="p">;</span>

	<span class="n">regs</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">regs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>

	<span class="n">clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;spi_clk&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">clk</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>

	<span class="cm">/* setup spi core then atmel-specific driver state */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">master</span> <span class="o">=</span> <span class="n">spi_alloc_master</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">as</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">master</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="cm">/* the spi-&gt;mode bits understood by this driver: */</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">mode_bits</span> <span class="o">=</span> <span class="n">SPI_CPOL</span> <span class="o">|</span> <span class="n">SPI_CPHA</span> <span class="o">|</span> <span class="n">SPI_CS_HIGH</span><span class="p">;</span>

	<span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_num</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">num_chipselect</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">setup</span> <span class="o">=</span> <span class="n">atmel_spi_setup</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">transfer</span> <span class="o">=</span> <span class="n">atmel_spi_transfer</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">cleanup</span> <span class="o">=</span> <span class="n">atmel_spi_cleanup</span><span class="p">;</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">master</span><span class="p">);</span>

	<span class="n">as</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Scratch buffer is used for throwaway rx and tx data.</span>
<span class="cm">	 * It&#39;s coherent to minimize dcache pollution.</span>
<span class="cm">	 */</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">buffer_dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">regs</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_buffer</span><span class="p">;</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="n">clk</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">atmel_spi_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">master</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unmap_regs</span><span class="p">;</span>

	<span class="cm">/* Initialize the hardware */</span>
	<span class="n">clk_enable</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">CR</span><span class="p">,</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">SWRST</span><span class="p">));</span>
	<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">CR</span><span class="p">,</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">SWRST</span><span class="p">));</span> <span class="cm">/* AT91SAM9263 Rev B workaround */</span>
	<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">MR</span><span class="p">,</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">MSTR</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">MODFDIS</span><span class="p">));</span>
	<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">PTCR</span><span class="p">,</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">RXTDIS</span><span class="p">)</span> <span class="o">|</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">TXTDIS</span><span class="p">));</span>
	<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">CR</span><span class="p">,</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">SPIEN</span><span class="p">));</span>

	<span class="cm">/* go! */</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Atmel SPI Controller at 0x%08lx (irq %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spi_register_master</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_reset_hw</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_reset_hw:</span>
	<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">CR</span><span class="p">,</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">SWRST</span><span class="p">));</span>
	<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">CR</span><span class="p">,</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">SWRST</span><span class="p">));</span> <span class="cm">/* AT91SAM9263 Rev B workaround */</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">master</span><span class="p">);</span>
<span class="nl">out_unmap_regs:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
<span class="nl">out_free_buffer:</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">,</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span>
			<span class="n">as</span><span class="o">-&gt;</span><span class="n">buffer_dma</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">spi_master_put</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">atmel_spi_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_master</span>	<span class="o">*</span><span class="n">master</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">atmel_spi</span>	<span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_message</span>	<span class="o">*</span><span class="n">msg</span><span class="p">;</span>

	<span class="cm">/* reset the hardware and block queue progress */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">as</span><span class="o">-&gt;</span><span class="n">stopping</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">CR</span><span class="p">,</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">SWRST</span><span class="p">));</span>
	<span class="n">spi_writel</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">CR</span><span class="p">,</span> <span class="n">SPI_BIT</span><span class="p">(</span><span class="n">SWRST</span><span class="p">));</span> <span class="cm">/* AT91SAM9263 Rev B workaround */</span>
	<span class="n">spi_readl</span><span class="p">(</span><span class="n">as</span><span class="p">,</span> <span class="n">SR</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Terminate remaining queued transfers */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* REVISIT unmapping the dma is a NOP on ARM and AVR32</span>
<span class="cm">		 * but we shouldn&#39;t depend on that...</span>
<span class="cm">		 */</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">,</span> <span class="n">as</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span>
			<span class="n">as</span><span class="o">-&gt;</span><span class="n">buffer_dma</span><span class="p">);</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">master</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>

	<span class="n">spi_unregister_master</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef	CONFIG_PM</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">atmel_spi_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_master</span>	<span class="o">*</span><span class="n">master</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">atmel_spi</span>	<span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">atmel_spi_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_master</span>	<span class="o">*</span><span class="n">master</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">atmel_spi</span>	<span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="cp">#define	atmel_spi_suspend	NULL</span>
<span class="cp">#define	atmel_spi_resume	NULL</span>
<span class="cp">#endif</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">atmel_spi_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;atmel_spi&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">atmel_spi_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">atmel_spi_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">atmel_spi_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__exit_p</span><span class="p">(</span><span class="n">atmel_spi_remove</span><span class="p">),</span>
<span class="p">};</span>
<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">atmel_spi_driver</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Atmel AT32/AT91 SPI Controller driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Haavard Skinnemoen (Atmel)&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:atmel_spi&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
