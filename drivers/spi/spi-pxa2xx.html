<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › spi › spi-pxa2xx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>spi-pxa2xx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2005 Stephen Street / StreetFire Sound Labs</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/spi/pxa2xx_spi.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/spi/spi.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/gpio.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/delay.h&gt;</span>


<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Stephen Street&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;PXA2xx SSP SPI Controller&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:pxa2xx-spi&quot;</span><span class="p">);</span>

<span class="cp">#define MAX_BUSES 3</span>

<span class="cp">#define TIMOUT_DFLT		1000</span>

<span class="cp">#define DMA_INT_MASK		(DCSR_ENDINTR | DCSR_STARTINTR | DCSR_BUSERR)</span>
<span class="cp">#define RESET_DMA_CHANNEL	(DCSR_NODESC | DMA_INT_MASK)</span>
<span class="cp">#define IS_DMA_ALIGNED(x)	((((u32)(x)) &amp; 0x07) == 0)</span>
<span class="cp">#define MAX_DMA_LEN		8191</span>
<span class="cp">#define DMA_ALIGNMENT		8</span>

<span class="cm">/*</span>
<span class="cm"> * for testing SSCR1 changes that require SSP restart, basically</span>
<span class="cm"> * everything except the service and interrupt enables, the pxa270 developer</span>
<span class="cm"> * manual says only SSCR1_SCFR, SSCR1_SPH, SSCR1_SPO need to be in this</span>
<span class="cm"> * list, but the PXA255 dev man says all bits without really meaning the</span>
<span class="cm"> * service and interrupt enables</span>
<span class="cm"> */</span>
<span class="cp">#define SSCR1_CHANGE_MASK (SSCR1_TTELP | SSCR1_TTE | SSCR1_SCFR \</span>
<span class="cp">				| SSCR1_ECRA | SSCR1_ECRB | SSCR1_SCLKDIR \</span>
<span class="cp">				| SSCR1_SFRMDIR | SSCR1_RWOT | SSCR1_TRAIL \</span>
<span class="cp">				| SSCR1_IFS | SSCR1_STRF | SSCR1_EFWR \</span>
<span class="cp">				| SSCR1_RFT | SSCR1_TFT | SSCR1_MWDS \</span>
<span class="cp">				| SSCR1_SPH | SSCR1_SPO | SSCR1_LBM)</span>

<span class="cp">#define DEFINE_SSP_REG(reg, off) \</span>
<span class="cp">static inline u32 read_##reg(void const __iomem *p) \</span>
<span class="cp">{ return __raw_readl(p + (off)); } \</span>
<span class="cp">\</span>
<span class="cp">static inline void write_##reg(u32 v, void __iomem *p) \</span>
<span class="cp">{ __raw_writel(v, p + (off)); }</span>

<span class="n">DEFINE_SSP_REG</span><span class="p">(</span><span class="n">SSCR0</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">)</span>
<span class="n">DEFINE_SSP_REG</span><span class="p">(</span><span class="n">SSCR1</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">)</span>
<span class="n">DEFINE_SSP_REG</span><span class="p">(</span><span class="n">SSSR</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">)</span>
<span class="n">DEFINE_SSP_REG</span><span class="p">(</span><span class="n">SSITR</span><span class="p">,</span> <span class="mh">0x0c</span><span class="p">)</span>
<span class="n">DEFINE_SSP_REG</span><span class="p">(</span><span class="n">SSDR</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">)</span>
<span class="n">DEFINE_SSP_REG</span><span class="p">(</span><span class="n">SSTO</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">)</span>
<span class="n">DEFINE_SSP_REG</span><span class="p">(</span><span class="n">SSPSP</span><span class="p">,</span> <span class="mh">0x2c</span><span class="p">)</span>

<span class="cp">#define START_STATE ((void*)0)</span>
<span class="cp">#define RUNNING_STATE ((void*)1)</span>
<span class="cp">#define DONE_STATE ((void*)2)</span>
<span class="cp">#define ERROR_STATE ((void*)-1)</span>

<span class="cp">#define QUEUE_RUNNING 0</span>
<span class="cp">#define QUEUE_STOPPED 1</span>

<span class="k">struct</span> <span class="n">driver_data</span> <span class="p">{</span>
	<span class="cm">/* Driver model hookup */</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/* SSP Info */</span>
	<span class="k">struct</span> <span class="n">ssp_device</span> <span class="o">*</span><span class="n">ssp</span><span class="p">;</span>

	<span class="cm">/* SPI framework hookup */</span>
	<span class="k">enum</span> <span class="n">pxa_ssp_type</span> <span class="n">ssp_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">;</span>

	<span class="cm">/* PXA hookup */</span>
	<span class="k">struct</span> <span class="n">pxa2xx_spi_master</span> <span class="o">*</span><span class="n">master_info</span><span class="p">;</span>

	<span class="cm">/* DMA setup stuff */</span>
	<span class="kt">int</span> <span class="n">rx_channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_channel</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">null_dma_buf</span><span class="p">;</span>

	<span class="cm">/* SSP register addresses */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ssdr_physical</span><span class="p">;</span>

	<span class="cm">/* SSP masks*/</span>
	<span class="n">u32</span> <span class="n">dma_cr1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">int_cr1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">clear_sr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask_sr</span><span class="p">;</span>

	<span class="cm">/* Driver message queue */</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span>	<span class="o">*</span><span class="n">workqueue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">pump_messages</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">busy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">run</span><span class="p">;</span>

	<span class="cm">/* Message Transfer pump */</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">pump_transfers</span><span class="p">;</span>

	<span class="cm">/* Current message transfer state info */</span>
	<span class="k">struct</span> <span class="n">spi_message</span><span class="o">*</span> <span class="n">cur_msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span><span class="o">*</span> <span class="n">cur_transfer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chip_data</span> <span class="o">*</span><span class="n">cur_chip</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">tx</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">tx_end</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rx</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rx_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dma_mapped</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">rx_dma</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">tx_dma</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">rx_map_len</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">tx_map_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">n_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dma_width</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="n">irqreturn_t</span> <span class="p">(</span><span class="o">*</span><span class="n">transfer_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cs_control</span><span class="p">)(</span><span class="n">u32</span> <span class="n">command</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">chip_data</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">cr0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cr1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">psp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">n_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dma_width</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dma_burst_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">threshold</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dma_threshold</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">enable_dma</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bits_per_word</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">speed_hz</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">gpio_cs</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frm</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">gpio_cs_inverted</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cs_control</span><span class="p">)(</span><span class="n">u32</span> <span class="n">command</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">pump_messages</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cs_assert</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">chip_data</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_chip</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp_type</span> <span class="o">==</span> <span class="n">CE4100_SSP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_SSSR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_chip</span><span class="o">-&gt;</span><span class="n">frm</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">cs_control</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cs_control</span><span class="p">(</span><span class="n">PXA2XX_CS_ASSERT</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">gpio_cs</span><span class="p">))</span>
		<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">gpio_cs</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">gpio_cs_inverted</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cs_deassert</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">chip_data</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_chip</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp_type</span> <span class="o">==</span> <span class="n">CE4100_SSP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">cs_control</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cs_control</span><span class="p">(</span><span class="n">PXA2XX_CS_DEASSERT</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">gpio_cs</span><span class="p">))</span>
		<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">gpio_cs</span><span class="p">,</span> <span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">gpio_cs_inverted</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_SSSR_CS</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp_type</span> <span class="o">==</span> <span class="n">CE4100_SSP</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">read_SSSR</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSSR_ALT_FRM_MASK</span><span class="p">;</span>

	<span class="n">write_SSSR</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa25x_ssp_comp</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp_type</span> <span class="o">==</span> <span class="n">PXA25x_SSP</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp_type</span> <span class="o">==</span> <span class="n">CE4100_SSP</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">loops_per_jiffy</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">read_SSSR</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSSR_RNE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">read_SSDR</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">read_SSSR</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSSR_BSY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">limit</span><span class="p">);</span>
	<span class="n">write_SSSR_CS</span><span class="p">(</span><span class="n">drv_data</span><span class="p">,</span> <span class="n">SSSR_ROR</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">limit</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">null_writer</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">n_bytes</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">n_bytes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">read_SSSR</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSSR_TFL_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">SSSR_TFL_MASK</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">==</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_end</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">write_SSDR</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">+=</span> <span class="n">n_bytes</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">null_reader</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">n_bytes</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">n_bytes</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">read_SSSR</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSSR_RNE</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">&lt;</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_end</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">read_SSDR</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">+=</span> <span class="n">n_bytes</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">==</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_end</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">u8_writer</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">read_SSSR</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSSR_TFL_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">SSSR_TFL_MASK</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">==</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_end</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">write_SSDR</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>
	<span class="o">++</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">u8_reader</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">read_SSSR</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSSR_RNE</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">&lt;</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_end</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">)</span> <span class="o">=</span> <span class="n">read_SSDR</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="o">++</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">==</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_end</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">u16_writer</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">read_SSSR</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSSR_TFL_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">SSSR_TFL_MASK</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">==</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_end</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">write_SSDR</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">u16_reader</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">read_SSSR</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSSR_RNE</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">&lt;</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_end</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">)</span> <span class="o">=</span> <span class="n">read_SSDR</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">==</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_end</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">u32_writer</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">read_SSSR</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSSR_TFL_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">SSSR_TFL_MASK</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">==</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_end</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">write_SSDR</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">u32_reader</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">read_SSSR</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSSR_RNE</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">&lt;</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_end</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">)</span> <span class="o">=</span> <span class="n">read_SSDR</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">==</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_end</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">next_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_transfer</span><span class="p">;</span>

	<span class="cm">/* Move to next transfer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transfer_list</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">transfers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_transfer</span> <span class="o">=</span>
			<span class="n">list_entry</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transfer_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">spi_transfer</span><span class="p">,</span>
					<span class="n">transfer_list</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">RUNNING_STATE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="n">DONE_STATE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">map_dma_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_chip</span><span class="o">-&gt;</span><span class="n">enable_dma</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">is_dma_mapped</span><span class="p">)</span>
		<span class="k">return</span>  <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_dma</span> <span class="o">&amp;&amp;</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_DMA_ALIGNED</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">IS_DMA_ALIGNED</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Modify setup if rx buffer is null */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">null_dma_buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">null_dma_buf</span><span class="p">;</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_map_len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_map_len</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>


	<span class="cm">/* Modify setup if tx buffer is null */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">null_dma_buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">null_dma_buf</span><span class="p">;</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_map_len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_map_len</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/* Stream map the tx buffer. Always do DMA_TO_DEVICE first</span>
<span class="cm">	 * so we flush the cache *before* invalidating it, in case</span>
<span class="cm">	 * the tx and rx buffers overlap.</span>
<span class="cm">	 */</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">,</span>
					<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_map_len</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Stream map the rx buffer */</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">,</span>
					<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_map_len</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">,</span>
					<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_map_len</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unmap_dma_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_mapped</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="o">-&gt;</span><span class="n">is_dma_mapped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">,</span>
					<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_map_len</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">,</span>
					<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_map_len</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* caller already set message-&gt;status; dma and pio irqs are blocked */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">giveback</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span><span class="o">*</span> <span class="n">last_transfer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">msg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_transfer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pump_messages</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">last_transfer</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">transfers</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">spi_transfer</span><span class="p">,</span>
					<span class="n">transfer_list</span><span class="p">);</span>

	<span class="cm">/* Delay if requested before any change in chip select */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_transfer</span><span class="o">-&gt;</span><span class="n">delay_usecs</span><span class="p">)</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">last_transfer</span><span class="o">-&gt;</span><span class="n">delay_usecs</span><span class="p">);</span>

	<span class="cm">/* Drop chip select UNLESS cs_change is true or we are returning</span>
<span class="cm">	 * a message with an error, or next message is for another chip</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_transfer</span><span class="o">-&gt;</span><span class="n">cs_change</span><span class="p">)</span>
		<span class="n">cs_deassert</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">next_msg</span><span class="p">;</span>

		<span class="cm">/* Holding of cs was hinted, but we need to make sure</span>
<span class="cm">		 * the next message is for the same chip.  Don&#39;t waste</span>
<span class="cm">		 * time with the following tests unless this was hinted.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We cannot postpone this until pump_messages, because</span>
<span class="cm">		 * after calling msg-&gt;complete (below) the driver that</span>
<span class="cm">		 * sent the current message could be unloaded, which</span>
<span class="cm">		 * could invalidate the cs_control() callback...</span>
<span class="cm">		 */</span>

		<span class="cm">/* get a pointer to the next message, if any */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
			<span class="n">next_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">next_msg</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">spi_message</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* see if the next and current messages point</span>
<span class="cm">		 * to the same chip</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_msg</span> <span class="o">&amp;&amp;</span> <span class="n">next_msg</span><span class="o">-&gt;</span><span class="n">spi</span> <span class="o">!=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">)</span>
			<span class="n">next_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next_msg</span> <span class="o">||</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ERROR_STATE</span><span class="p">)</span>
			<span class="n">cs_deassert</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">)</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>

	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_chip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_ssp_rx_stall</span><span class="p">(</span><span class="kt">void</span> <span class="k">const</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">loops_per_jiffy</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">read_SSSR</span><span class="p">(</span><span class="n">ioaddr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSSR_BSY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">limit</span><span class="p">)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">limit</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_dma_channel_stop</span><span class="p">(</span><span class="kt">int</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">loops_per_jiffy</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">DCSR</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DCSR_STOPSTATE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">limit</span><span class="p">)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">limit</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_error_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="cm">/* Stop and reset */</span>
	<span class="n">DCSR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">)</span> <span class="o">=</span> <span class="n">RESET_DMA_CHANNEL</span><span class="p">;</span>
	<span class="n">DCSR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">)</span> <span class="o">=</span> <span class="n">RESET_DMA_CHANNEL</span><span class="p">;</span>
	<span class="n">write_SSSR_CS</span><span class="p">(</span><span class="n">drv_data</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">clear_sr</span><span class="p">);</span>
	<span class="n">write_SSCR1</span><span class="p">(</span><span class="n">read_SSCR1</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_cr1</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pxa25x_ssp_comp</span><span class="p">(</span><span class="n">drv_data</span><span class="p">))</span>
		<span class="n">write_SSTO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">flush</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="n">write_SSCR0</span><span class="p">(</span><span class="n">read_SSCR0</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SSCR0_SSE</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="n">unmap_dma_buffers</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ERROR_STATE</span><span class="p">;</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pump_transfers</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_transfer_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="p">;</span>

	<span class="cm">/* Clear and disable interrupts on SSP and DMA channels*/</span>
	<span class="n">write_SSCR1</span><span class="p">(</span><span class="n">read_SSCR1</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_cr1</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">write_SSSR_CS</span><span class="p">(</span><span class="n">drv_data</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">clear_sr</span><span class="p">);</span>
	<span class="n">DCSR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">)</span> <span class="o">=</span> <span class="n">RESET_DMA_CHANNEL</span><span class="p">;</span>
	<span class="n">DCSR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">)</span> <span class="o">=</span> <span class="n">RESET_DMA_CHANNEL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait_dma_channel_stop</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;dma_handler: dma rx channel stop failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait_ssp_rx_stall</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;dma_transfer: ssp rx stall failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">unmap_dma_buffers</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>

	<span class="cm">/* update the buffer pointer for the amount completed in dma */</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">+=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span>
			<span class="p">(</span><span class="n">DCMD</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DCMD_LENGTH</span><span class="p">);</span>

	<span class="cm">/* read trailing data from fifo, it does not matter how many</span>
<span class="cm">	 * bytes are in the fifo just read until buffer is full</span>
<span class="cm">	 * or fifo is empty, which ever occurs first */</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>

	<span class="cm">/* return count of what was actually read */</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span>
				<span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_end</span> <span class="o">-</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span>

	<span class="cm">/* Transfer delays and chip select release are</span>
<span class="cm">	 * handled in pump_transfers or giveback</span>
<span class="cm">	 */</span>

	<span class="cm">/* Move to next transfer */</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">next_transfer</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>

	<span class="cm">/* Schedule transfer tasklet */</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pump_transfers</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">irq_status</span> <span class="o">=</span> <span class="n">DCSR</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DMA_INT_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_status</span> <span class="o">&amp;</span> <span class="n">DCSR_BUSERR</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">)</span>
			<span class="n">dma_error_stop</span><span class="p">(</span><span class="n">drv_data</span><span class="p">,</span>
					<span class="s">&quot;dma_handler: &quot;</span>
					<span class="s">&quot;bad bus address on tx channel&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dma_error_stop</span><span class="p">(</span><span class="n">drv_data</span><span class="p">,</span>
					<span class="s">&quot;dma_handler: &quot;</span>
					<span class="s">&quot;bad bus address on rx channel&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* PXA255x_SSP has no timeout interrupt, wait for tailing bytes */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">channel</span> <span class="o">==</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">irq_status</span> <span class="o">&amp;</span> <span class="n">DCSR_ENDINTR</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp_type</span> <span class="o">==</span> <span class="n">PXA25x_SSP</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* Wait for rx to stall */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wait_ssp_rx_stall</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;dma_handler: ssp rx stall failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* finish this transfer, start the next */</span>
		<span class="n">dma_transfer_complete</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">dma_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">irq_status</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="n">irq_status</span> <span class="o">=</span> <span class="n">read_SSSR</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">mask_sr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq_status</span> <span class="o">&amp;</span> <span class="n">SSSR_ROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_error_stop</span><span class="p">(</span><span class="n">drv_data</span><span class="p">,</span> <span class="s">&quot;dma_transfer: fifo overrun&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check for false positive timeout */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">irq_status</span> <span class="o">&amp;</span> <span class="n">SSSR_TINT</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">DCSR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DCSR_RUN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">write_SSSR</span><span class="p">(</span><span class="n">SSSR_TINT</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_status</span> <span class="o">&amp;</span> <span class="n">SSSR_TINT</span> <span class="o">||</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">==</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_end</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Clear and disable timeout interrupt, do the rest in</span>
<span class="cm">		 * dma_transfer_complete */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pxa25x_ssp_comp</span><span class="p">(</span><span class="n">drv_data</span><span class="p">))</span>
			<span class="n">write_SSTO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

		<span class="cm">/* finish this transfer, start the next */</span>
		<span class="n">dma_transfer_complete</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Opps problem detected */</span>
	<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_sccr1</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chip_data</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_chip</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sccr1_reg</span><span class="p">;</span>

	<span class="n">sccr1_reg</span> <span class="o">=</span> <span class="n">read_SSCR1</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">int_cr1</span><span class="p">;</span>
	<span class="n">sccr1_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SSCR1_RFT</span><span class="p">;</span>
	<span class="n">sccr1_reg</span> <span class="o">|=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">threshold</span><span class="p">;</span>
	<span class="n">write_SSCR1</span><span class="p">(</span><span class="n">sccr1_reg</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">int_error_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="cm">/* Stop and reset SSP */</span>
	<span class="n">write_SSSR_CS</span><span class="p">(</span><span class="n">drv_data</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">clear_sr</span><span class="p">);</span>
	<span class="n">reset_sccr1</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pxa25x_ssp_comp</span><span class="p">(</span><span class="n">drv_data</span><span class="p">))</span>
		<span class="n">write_SSTO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">flush</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="n">write_SSCR0</span><span class="p">(</span><span class="n">read_SSCR0</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SSCR0_SSE</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ERROR_STATE</span><span class="p">;</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pump_transfers</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">int_transfer_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="cm">/* Stop SSP */</span>
	<span class="n">write_SSSR_CS</span><span class="p">(</span><span class="n">drv_data</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">clear_sr</span><span class="p">);</span>
	<span class="n">reset_sccr1</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pxa25x_ssp_comp</span><span class="p">(</span><span class="n">drv_data</span><span class="p">))</span>
		<span class="n">write_SSTO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="cm">/* Update total byte transferred return count actual bytes read */</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span>
				<span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_end</span> <span class="o">-</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span>

	<span class="cm">/* Transfer delays and chip select release are</span>
<span class="cm">	 * handled in pump_transfers or giveback</span>
<span class="cm">	 */</span>

	<span class="cm">/* Move to next transfer */</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">next_transfer</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>

	<span class="cm">/* Schedule transfer tasklet */</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pump_transfers</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">interrupt_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">irq_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_SSCR1</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSCR1_TIE</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">mask_sr</span> <span class="o">:</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">mask_sr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SSSR_TFS</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">irq_status</span> <span class="o">=</span> <span class="n">read_SSSR</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">irq_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_status</span> <span class="o">&amp;</span> <span class="n">SSSR_ROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">int_error_stop</span><span class="p">(</span><span class="n">drv_data</span><span class="p">,</span> <span class="s">&quot;interrupt_transfer: fifo overrun&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_status</span> <span class="o">&amp;</span> <span class="n">SSSR_TINT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_SSSR</span><span class="p">(</span><span class="n">SSSR_TINT</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">drv_data</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">int_transfer_complete</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Drain rx fifo, Fill tx fifo and prevent overruns */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">drv_data</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">int_transfer_complete</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">drv_data</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">drv_data</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">int_transfer_complete</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">==</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">bytes_left</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">sccr1_reg</span><span class="p">;</span>

		<span class="n">sccr1_reg</span> <span class="o">=</span> <span class="n">read_SSCR1</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">sccr1_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SSCR1_TIE</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * PXA25x_SSP has no timeout, set up rx threshould for the</span>
<span class="cm">		 * remaining RX bytes.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pxa25x_ssp_comp</span><span class="p">(</span><span class="n">drv_data</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">sccr1_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SSCR1_RFT</span><span class="p">;</span>

			<span class="n">bytes_left</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_end</span> <span class="o">-</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">n_bytes</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">4</span>:
				<span class="n">bytes_left</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>:
				<span class="n">bytes_left</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bytes_left</span> <span class="o">&gt;</span> <span class="n">RX_THRESH_DFLT</span><span class="p">)</span>
				<span class="n">bytes_left</span> <span class="o">=</span> <span class="n">RX_THRESH_DFLT</span><span class="p">;</span>

			<span class="n">sccr1_reg</span> <span class="o">|=</span> <span class="n">SSCR1_RxTresh</span><span class="p">(</span><span class="n">bytes_left</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">write_SSCR1</span><span class="p">(</span><span class="n">sccr1_reg</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* We did something */</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ssp_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sccr1_reg</span> <span class="o">=</span> <span class="n">read_SSCR1</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">mask_sr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">read_SSSR</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

	<span class="cm">/* Ignore possible writes if we don&#39;t need to write */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sccr1_reg</span> <span class="o">&amp;</span> <span class="n">SSCR1_TIE</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SSSR_TFS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">write_SSCR0</span><span class="p">(</span><span class="n">read_SSCR0</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SSCR0_SSE</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="n">write_SSCR1</span><span class="p">(</span><span class="n">read_SSCR1</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">int_cr1</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pxa25x_ssp_comp</span><span class="p">(</span><span class="n">drv_data</span><span class="p">))</span>
			<span class="n">write_SSTO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="n">write_SSSR_CS</span><span class="p">(</span><span class="n">drv_data</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">clear_sr</span><span class="p">);</span>

		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bad message state &quot;</span>
			<span class="s">&quot;in interrupt handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* Never fail */</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">transfer_handler</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_dma_burst_and_threshold</span><span class="p">(</span><span class="k">struct</span> <span class="n">chip_data</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span>
				<span class="n">u8</span> <span class="n">bits_per_word</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">burst_code</span><span class="p">,</span>
				<span class="n">u32</span> <span class="o">*</span><span class="n">threshold</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa2xx_spi_chip</span> <span class="o">*</span><span class="n">chip_info</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">pxa2xx_spi_chip</span> <span class="o">*</span><span class="p">)</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">controller_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes_per_word</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">burst_bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">thresh_words</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">req_burst_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Set the threshold (in registers) to equal the same amount of data</span>
<span class="cm">	 * as represented by burst size (in bytes).  The computation below</span>
<span class="cm">	 * is (burst_size rounded up to nearest 8 byte, word or long word)</span>
<span class="cm">	 * divided by (bytes/register); the tx threshold is the inverse of</span>
<span class="cm">	 * the rx, so that there will always be enough data in the rx fifo</span>
<span class="cm">	 * to satisfy a burst, and there will always be enough space in the</span>
<span class="cm">	 * tx fifo to accept a burst (a tx burst will overwrite the fifo if</span>
<span class="cm">	 * there is not enough space), there must always remain enough empty</span>
<span class="cm">	 * space in the rx fifo for any data loaded to the tx fifo.</span>
<span class="cm">	 * Whenever burst_size (in bytes) equals bits/word, the fifo threshold</span>
<span class="cm">	 * will be 8, or half the fifo;</span>
<span class="cm">	 * The threshold can only be set to 2, 4 or 8, but not 16, because</span>
<span class="cm">	 * to burst 16 to the tx fifo, the fifo would have to be empty;</span>
<span class="cm">	 * however, the minimum fifo trigger level is 1, and the tx will</span>
<span class="cm">	 * request service when the fifo is at this level, with only 15 spaces.</span>
<span class="cm">	 */</span>

	<span class="cm">/* find bytes/word */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bits_per_word</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">bytes_per_word</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bits_per_word</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">bytes_per_word</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bytes_per_word</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* use struct pxa2xx_spi_chip-&gt;dma_burst_size if available */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip_info</span><span class="p">)</span>
		<span class="n">req_burst_size</span> <span class="o">=</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">dma_burst_size</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">dma_burst_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="nl">default:</span>
			<span class="cm">/* if the default burst size is not set,</span>
<span class="cm">			 * do it now */</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">dma_burst_size</span> <span class="o">=</span> <span class="n">DCMD_BURST8</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DCMD_BURST8</span>:
			<span class="n">req_burst_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DCMD_BURST16</span>:
			<span class="n">req_burst_size</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DCMD_BURST32</span>:
			<span class="n">req_burst_size</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req_burst_size</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">burst_code</span> <span class="o">=</span> <span class="n">DCMD_BURST8</span><span class="p">;</span>
		<span class="n">burst_bytes</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">req_burst_size</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes_per_word</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* don&#39;t burst more than 1/2 the fifo */</span>
			<span class="o">*</span><span class="n">burst_code</span> <span class="o">=</span> <span class="n">DCMD_BURST8</span><span class="p">;</span>
			<span class="n">burst_bytes</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">burst_code</span> <span class="o">=</span> <span class="n">DCMD_BURST16</span><span class="p">;</span>
			<span class="n">burst_bytes</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes_per_word</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* don&#39;t burst more than 1/2 the fifo */</span>
			<span class="o">*</span><span class="n">burst_code</span> <span class="o">=</span> <span class="n">DCMD_BURST8</span><span class="p">;</span>
			<span class="n">burst_bytes</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bytes_per_word</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* don&#39;t burst more than 1/2 the fifo */</span>
			<span class="o">*</span><span class="n">burst_code</span> <span class="o">=</span> <span class="n">DCMD_BURST16</span><span class="p">;</span>
			<span class="n">burst_bytes</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">burst_code</span> <span class="o">=</span> <span class="n">DCMD_BURST32</span><span class="p">;</span>
			<span class="n">burst_bytes</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">thresh_words</span> <span class="o">=</span> <span class="n">burst_bytes</span> <span class="o">/</span> <span class="n">bytes_per_word</span><span class="p">;</span>

	<span class="cm">/* thresh_words will be between 2 and 8 */</span>
	<span class="o">*</span><span class="n">threshold</span> <span class="o">=</span> <span class="p">(</span><span class="n">SSCR1_RxTresh</span><span class="p">(</span><span class="n">thresh_words</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSCR1_RFT</span><span class="p">)</span>
			<span class="o">|</span> <span class="p">(</span><span class="n">SSCR1_TxTresh</span><span class="p">(</span><span class="mi">16</span><span class="o">-</span><span class="n">thresh_words</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSCR1_TFT</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ssp_get_clk_div</span><span class="p">(</span><span class="k">struct</span> <span class="n">ssp_device</span> <span class="o">*</span><span class="n">ssp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ssp_clk</span> <span class="o">=</span> <span class="n">clk_get_rate</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PXA25x_SSP</span> <span class="o">||</span> <span class="n">ssp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CE4100_SSP</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">ssp_clk</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">rate</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">ssp_clk</span> <span class="o">/</span> <span class="n">rate</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pump_transfers</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">message</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">transfer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">previous</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chip_data</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ssp_device</span> <span class="o">*</span><span class="n">ssp</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">clk_div</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cr0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cr1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dma_thresh</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_chip</span><span class="o">-&gt;</span><span class="n">dma_threshold</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dma_burst</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_chip</span><span class="o">-&gt;</span><span class="n">dma_burst_size</span><span class="p">;</span>

	<span class="cm">/* Get current state information */</span>
	<span class="n">message</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="p">;</span>
	<span class="n">transfer</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_transfer</span><span class="p">;</span>
	<span class="n">chip</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_chip</span><span class="p">;</span>

	<span class="cm">/* Handle for abort */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ERROR_STATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">message</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">giveback</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Handle end of message */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DONE_STATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">message</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">giveback</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Delay if requested at end of transfer before CS change */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">RUNNING_STATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">previous</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">transfer</span><span class="o">-&gt;</span><span class="n">transfer_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">spi_transfer</span><span class="p">,</span>
					<span class="n">transfer_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">previous</span><span class="o">-&gt;</span><span class="n">delay_usecs</span><span class="p">)</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">previous</span><span class="o">-&gt;</span><span class="n">delay_usecs</span><span class="p">);</span>

		<span class="cm">/* Drop chip select only if cs_change is requested */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">previous</span><span class="o">-&gt;</span><span class="n">cs_change</span><span class="p">)</span>
			<span class="n">cs_deassert</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check for transfers that need multiple DMA segments */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transfer</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">MAX_DMA_LEN</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">enable_dma</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* reject already-mapped transfers; PIO won&#39;t always work */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">is_dma_mapped</span>
				<span class="o">||</span> <span class="n">transfer</span><span class="o">-&gt;</span><span class="n">rx_dma</span> <span class="o">||</span> <span class="n">transfer</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;pump_transfers: mapped transfer length &quot;</span>
				<span class="s">&quot;of %u is greater than %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">transfer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">MAX_DMA_LEN</span><span class="p">);</span>
			<span class="n">message</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">giveback</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* warn ... we force this to PIO mode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pump_transfers: &quot;</span>
				<span class="s">&quot;DMA disabled for transfer length %ld &quot;</span>
				<span class="s">&quot;greater than %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">MAX_DMA_LEN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Setup the transfer state based on the type of transfer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flush</span><span class="p">(</span><span class="n">drv_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pump_transfers: flush failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">message</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">giveback</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">n_bytes</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">n_bytes</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_width</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">dma_width</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">transfer</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_end</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">+</span> <span class="n">transfer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">=</span> <span class="n">transfer</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_end</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">+</span> <span class="n">transfer</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_dma</span> <span class="o">=</span> <span class="n">transfer</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_dma</span> <span class="o">=</span> <span class="n">transfer</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">transfer</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&amp;</span> <span class="n">DCMD_LENGTH</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">?</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">:</span> <span class="n">null_writer</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">?</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">:</span> <span class="n">null_reader</span><span class="p">;</span>

	<span class="cm">/* Change speed and bit per word on a per transfer */</span>
	<span class="n">cr0</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">cr0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transfer</span><span class="o">-&gt;</span><span class="n">speed_hz</span> <span class="o">||</span> <span class="n">transfer</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">bits</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">;</span>
		<span class="n">speed</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">speed_hz</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">transfer</span><span class="o">-&gt;</span><span class="n">speed_hz</span><span class="p">)</span>
			<span class="n">speed</span> <span class="o">=</span> <span class="n">transfer</span><span class="o">-&gt;</span><span class="n">speed_hz</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">transfer</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">)</span>
			<span class="n">bits</span> <span class="o">=</span> <span class="n">transfer</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">;</span>

		<span class="n">clk_div</span> <span class="o">=</span> <span class="n">ssp_get_clk_div</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">n_bytes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_width</span> <span class="o">=</span> <span class="n">DCMD_WIDTH1</span><span class="p">;</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">!=</span> <span class="n">null_reader</span> <span class="o">?</span>
						<span class="n">u8_reader</span> <span class="o">:</span> <span class="n">null_reader</span><span class="p">;</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">!=</span> <span class="n">null_writer</span> <span class="o">?</span>
						<span class="n">u8_writer</span> <span class="o">:</span> <span class="n">null_writer</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">n_bytes</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_width</span> <span class="o">=</span> <span class="n">DCMD_WIDTH2</span><span class="p">;</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">!=</span> <span class="n">null_reader</span> <span class="o">?</span>
						<span class="n">u16_reader</span> <span class="o">:</span> <span class="n">null_reader</span><span class="p">;</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">!=</span> <span class="n">null_writer</span> <span class="o">?</span>
						<span class="n">u16_writer</span> <span class="o">:</span> <span class="n">null_writer</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">n_bytes</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_width</span> <span class="o">=</span> <span class="n">DCMD_WIDTH4</span><span class="p">;</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">!=</span> <span class="n">null_reader</span> <span class="o">?</span>
						<span class="n">u32_reader</span> <span class="o">:</span> <span class="n">null_reader</span><span class="p">;</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">!=</span> <span class="n">null_writer</span> <span class="o">?</span>
						<span class="n">u32_writer</span> <span class="o">:</span> <span class="n">null_writer</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* if bits/word is changed in dma mode, then must check the</span>
<span class="cm">		 * thresholds and burst also */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">enable_dma</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">set_dma_burst_and_threshold</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">message</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">,</span>
							<span class="n">bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_burst</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">dma_thresh</span><span class="p">))</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
					<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;pump_transfers: &quot;</span>
						<span class="s">&quot;DMA burst size reduced to &quot;</span>
						<span class="s">&quot;match bits_per_word</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">cr0</span> <span class="o">=</span> <span class="n">clk_div</span>
			<span class="o">|</span> <span class="n">SSCR0_Motorola</span>
			<span class="o">|</span> <span class="n">SSCR0_DataSize</span><span class="p">(</span><span class="n">bits</span> <span class="o">&gt;</span> <span class="mi">16</span> <span class="o">?</span> <span class="n">bits</span> <span class="o">-</span> <span class="mi">16</span> <span class="o">:</span> <span class="n">bits</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">SSCR0_SSE</span>
			<span class="o">|</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&gt;</span> <span class="mi">16</span> <span class="o">?</span> <span class="n">SSCR0_EDSS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">message</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RUNNING_STATE</span><span class="p">;</span>

	<span class="cm">/* Try to map dma buffer and do a dma transfer if successful, but</span>
<span class="cm">	 * only if the length is non-zero and less than MAX_DMA_LEN.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Zero-length non-descriptor DMA is illegal on PXA2xx; force use</span>
<span class="cm">	 * of PIO instead.  Care is needed above because the transfer may</span>
<span class="cm">	 * have have been passed with buffers that are already dma mapped.</span>
<span class="cm">	 * A zero-length transfer in PIO mode will not try to write/read</span>
<span class="cm">	 * to/from the buffers</span>
<span class="cm">	 *</span>
<span class="cm">	 * REVISIT large transfers are exactly where we most want to be</span>
<span class="cm">	 * using DMA.  If this happens much, split those transfers into</span>
<span class="cm">	 * multiple DMA segments rather than forcing PIO.</span>
<span class="cm">	 */</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">MAX_DMA_LEN</span><span class="p">)</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_mapped</span> <span class="o">=</span> <span class="n">map_dma_buffers</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_mapped</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Ensure we have the correct interrupt handler */</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">transfer_handler</span> <span class="o">=</span> <span class="n">dma_transfer</span><span class="p">;</span>

		<span class="cm">/* Setup rx DMA Channel */</span>
		<span class="n">DCSR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">)</span> <span class="o">=</span> <span class="n">RESET_DMA_CHANNEL</span><span class="p">;</span>
		<span class="n">DSADR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">)</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssdr_physical</span><span class="p">;</span>
		<span class="n">DTADR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">)</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_dma</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">==</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">null_dma_buf</span><span class="p">)</span>
			<span class="cm">/* No target address increment */</span>
			<span class="n">DCMD</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">)</span> <span class="o">=</span> <span class="n">DCMD_FLOWSRC</span>
							<span class="o">|</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_width</span>
							<span class="o">|</span> <span class="n">dma_burst</span>
							<span class="o">|</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">DCMD</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">)</span> <span class="o">=</span> <span class="n">DCMD_INCTRGADDR</span>
							<span class="o">|</span> <span class="n">DCMD_FLOWSRC</span>
							<span class="o">|</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_width</span>
							<span class="o">|</span> <span class="n">dma_burst</span>
							<span class="o">|</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="cm">/* Setup tx DMA Channel */</span>
		<span class="n">DCSR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">)</span> <span class="o">=</span> <span class="n">RESET_DMA_CHANNEL</span><span class="p">;</span>
		<span class="n">DSADR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">)</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_dma</span><span class="p">;</span>
		<span class="n">DTADR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">)</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssdr_physical</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">==</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">null_dma_buf</span><span class="p">)</span>
			<span class="cm">/* No source address increment */</span>
			<span class="n">DCMD</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">)</span> <span class="o">=</span> <span class="n">DCMD_FLOWTRG</span>
							<span class="o">|</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_width</span>
							<span class="o">|</span> <span class="n">dma_burst</span>
							<span class="o">|</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">DCMD</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">)</span> <span class="o">=</span> <span class="n">DCMD_INCSRCADDR</span>
							<span class="o">|</span> <span class="n">DCMD_FLOWTRG</span>
							<span class="o">|</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_width</span>
							<span class="o">|</span> <span class="n">dma_burst</span>
							<span class="o">|</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="cm">/* Enable dma end irqs on SSP to detect end of transfer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp_type</span> <span class="o">==</span> <span class="n">PXA25x_SSP</span><span class="p">)</span>
			<span class="n">DCMD</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">)</span> <span class="o">|=</span> <span class="n">DCMD_ENDIRQEN</span><span class="p">;</span>

		<span class="cm">/* Clear status and start DMA engine */</span>
		<span class="n">cr1</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">cr1</span> <span class="o">|</span> <span class="n">dma_thresh</span> <span class="o">|</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_cr1</span><span class="p">;</span>
		<span class="n">write_SSSR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">clear_sr</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="n">DCSR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">)</span> <span class="o">|=</span> <span class="n">DCSR_RUN</span><span class="p">;</span>
		<span class="n">DCSR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">)</span> <span class="o">|=</span> <span class="n">DCSR_RUN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Ensure we have the correct interrupt handler	*/</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">transfer_handler</span> <span class="o">=</span> <span class="n">interrupt_transfer</span><span class="p">;</span>

		<span class="cm">/* Clear status  */</span>
		<span class="n">cr1</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">cr1</span> <span class="o">|</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">threshold</span> <span class="o">|</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">int_cr1</span><span class="p">;</span>
		<span class="n">write_SSSR_CS</span><span class="p">(</span><span class="n">drv_data</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">clear_sr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* see if we need to reload the config registers */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">read_SSCR0</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">!=</span> <span class="n">cr0</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">read_SSCR1</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSCR1_CHANGE_MASK</span><span class="p">)</span> <span class="o">!=</span>
			<span class="p">(</span><span class="n">cr1</span> <span class="o">&amp;</span> <span class="n">SSCR1_CHANGE_MASK</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* stop the SSP, and update the other bits */</span>
		<span class="n">write_SSCR0</span><span class="p">(</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SSCR0_SSE</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pxa25x_ssp_comp</span><span class="p">(</span><span class="n">drv_data</span><span class="p">))</span>
			<span class="n">write_SSTO</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="cm">/* first set CR1 without interrupt and service enables */</span>
		<span class="n">write_SSCR1</span><span class="p">(</span><span class="n">cr1</span> <span class="o">&amp;</span> <span class="n">SSCR1_CHANGE_MASK</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="cm">/* restart the SSP */</span>
		<span class="n">write_SSCR0</span><span class="p">(</span><span class="n">cr0</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pxa25x_ssp_comp</span><span class="p">(</span><span class="n">drv_data</span><span class="p">))</span>
			<span class="n">write_SSTO</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cs_assert</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>

	<span class="cm">/* after chip select, release the data by enabling service</span>
<span class="cm">	 * requests and interrupts, without changing any mode bits */</span>
	<span class="n">write_SSCR1</span><span class="p">(</span><span class="n">cr1</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pump_messages</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">driver_data</span><span class="p">,</span> <span class="n">pump_messages</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Lock queue and check for queue work */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="o">||</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">run</span> <span class="o">==</span> <span class="n">QUEUE_STOPPED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure we are not already running a message */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Extract head of queue */</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">spi_message</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="cm">/* Initial message state*/</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">START_STATE</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_transfer</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="o">-&gt;</span><span class="n">transfers</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">spi_transfer</span><span class="p">,</span>
						<span class="n">transfer_list</span><span class="p">);</span>

	<span class="cm">/* prepare to setup the SSP, in pump_transfers, using the per</span>
<span class="cm">	 * chip configuration */</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_chip</span> <span class="o">=</span> <span class="n">spi_get_ctldata</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">);</span>

	<span class="cm">/* Mark as busy and launch transfers */</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pump_transfers</span><span class="p">);</span>

	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">run</span> <span class="o">==</span> <span class="n">QUEUE_STOPPED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">START_STATE</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">run</span> <span class="o">==</span> <span class="n">QUEUE_RUNNING</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pump_messages</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_cs</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">chip_data</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">pxa2xx_spi_chip</span> <span class="o">*</span><span class="n">chip_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">chip_info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* NOTE: setup() can be called multiple times, possibly with</span>
<span class="cm">	 * different chip_info, release previously requested GPIO</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">gpio_cs</span><span class="p">))</span>
		<span class="n">gpio_free</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">gpio_cs</span><span class="p">);</span>

	<span class="cm">/* If (*cs_control) is provided, ignore GPIO chip select */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">cs_control</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cs_control</span> <span class="o">=</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">cs_control</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">gpio_cs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">gpio_request</span><span class="p">(</span><span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">gpio_cs</span><span class="p">,</span> <span class="s">&quot;SPI_CS&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to request chip select &quot;</span>
					<span class="s">&quot;GPIO%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">gpio_cs</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">gpio_cs</span> <span class="o">=</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">gpio_cs</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">gpio_cs_inverted</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SPI_CS_HIGH</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">gpio_direction_output</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">gpio_cs</span><span class="p">,</span>
					<span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">gpio_cs_inverted</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa2xx_spi_chip</span> <span class="o">*</span><span class="n">chip_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">chip_data</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ssp_device</span> <span class="o">*</span><span class="n">ssp</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clk_div</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">tx_thres</span> <span class="o">=</span> <span class="n">TX_THRESH_DFLT</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">rx_thres</span> <span class="o">=</span> <span class="n">RX_THRESH_DFLT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pxa25x_ssp_comp</span><span class="p">(</span><span class="n">drv_data</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">||</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed setup: ssp_type=%d, bits/wrd=%d &quot;</span>
				<span class="s">&quot;b/w not 4-32 for type non-PXA25x_SSP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp_type</span><span class="p">,</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pxa25x_ssp_comp</span><span class="p">(</span><span class="n">drv_data</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">&lt;</span> <span class="mi">4</span>
				<span class="o">||</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed setup: ssp_type=%d, bits/wrd=%d &quot;</span>
				<span class="s">&quot;b/w not 4-16 for type PXA25x_SSP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp_type</span><span class="p">,</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Only alloc on first setup */</span>
	<span class="n">chip</span> <span class="o">=</span> <span class="n">spi_get_ctldata</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">chip_data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;failed setup: can&#39;t allocate chip data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp_type</span> <span class="o">==</span> <span class="n">CE4100_SSP</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">chip_select</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed setup: &quot;</span>
				<span class="s">&quot;cs number must not be &gt; 4.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">frm</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">chip_select</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">gpio_cs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">enable_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">TIMOUT_DFLT</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">dma_burst_size</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">master_info</span><span class="o">-&gt;</span><span class="n">enable_dma</span> <span class="o">?</span>
					<span class="n">DCMD_BURST8</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* protocol drivers may change the chip settings, so...</span>
<span class="cm">	 * if chip_info exists, use it */</span>
	<span class="n">chip_info</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">controller_data</span><span class="p">;</span>

	<span class="cm">/* chip_info isn&#39;t always needed */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cr1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">)</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">tx_threshold</span><span class="p">)</span>
			<span class="n">tx_thres</span> <span class="o">=</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">tx_threshold</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">rx_threshold</span><span class="p">)</span>
			<span class="n">rx_thres</span> <span class="o">=</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">rx_threshold</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">enable_dma</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">master_info</span><span class="o">-&gt;</span><span class="n">enable_dma</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">dma_threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">enable_loopback</span><span class="p">)</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cr1</span> <span class="o">=</span> <span class="n">SSCR1_LBM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">threshold</span> <span class="o">=</span> <span class="p">(</span><span class="n">SSCR1_RxTresh</span><span class="p">(</span><span class="n">rx_thres</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSCR1_RFT</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">SSCR1_TxTresh</span><span class="p">(</span><span class="n">tx_thres</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSCR1_TFT</span><span class="p">);</span>

	<span class="cm">/* set dma burst and threshold outside of chip_info path so that if</span>
<span class="cm">	 * chip_info goes away after setting chip-&gt;enable_dma, the</span>
<span class="cm">	 * burst and threshold can still respond to changes in bits_per_word */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">enable_dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* set up legal burst and threshold for dma */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set_dma_burst_and_threshold</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">spi</span><span class="p">,</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">dma_burst_size</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">dma_threshold</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;in setup: DMA burst size reduced &quot;</span>
					<span class="s">&quot;to match bits_per_word</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">clk_div</span> <span class="o">=</span> <span class="n">ssp_get_clk_div</span><span class="p">(</span><span class="n">ssp</span><span class="p">,</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">speed_hz</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cr0</span> <span class="o">=</span> <span class="n">clk_div</span>
			<span class="o">|</span> <span class="n">SSCR0_Motorola</span>
			<span class="o">|</span> <span class="n">SSCR0_DataSize</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">&gt;</span> <span class="mi">16</span> <span class="o">?</span>
				<span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">-</span> <span class="mi">16</span> <span class="o">:</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">SSCR0_SSE</span>
			<span class="o">|</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">&gt;</span> <span class="mi">16</span> <span class="o">?</span> <span class="n">SSCR0_EDSS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cr1</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SSCR1_SPO</span> <span class="o">|</span> <span class="n">SSCR1_SPH</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cr1</span> <span class="o">|=</span> <span class="p">(((</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SPI_CPHA</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">SSCR1_SPH</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">|</span> <span class="p">(((</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SPI_CPOL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">SSCR1_SPO</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* NOTE:  PXA25x_SSP _could_ use external clocking ... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pxa25x_ssp_comp</span><span class="p">(</span><span class="n">drv_data</span><span class="p">))</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%ld Hz actual, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">clk_get_rate</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">)</span>
				<span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="n">SSCR0_SCR</span><span class="p">(</span><span class="mh">0xfff</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)),</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">enable_dma</span> <span class="o">?</span> <span class="s">&quot;DMA&quot;</span> <span class="o">:</span> <span class="s">&quot;PIO&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%ld Hz actual, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">clk_get_rate</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
				<span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">cr0</span> <span class="o">&amp;</span> <span class="n">SSCR0_SCR</span><span class="p">(</span><span class="mh">0x0ff</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)),</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">enable_dma</span> <span class="o">?</span> <span class="s">&quot;DMA&quot;</span> <span class="o">:</span> <span class="s">&quot;PIO&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">n_bytes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">dma_width</span> <span class="o">=</span> <span class="n">DCMD_WIDTH1</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="n">u8_reader</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="n">u8_writer</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">n_bytes</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">dma_width</span> <span class="o">=</span> <span class="n">DCMD_WIDTH2</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="n">u16_reader</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="n">u16_writer</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cr0</span> <span class="o">|=</span> <span class="n">SSCR0_EDSS</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">n_bytes</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">dma_width</span> <span class="o">=</span> <span class="n">DCMD_WIDTH4</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">=</span> <span class="n">u32_reader</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="n">u32_writer</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid wordsize</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">;</span>

	<span class="n">spi_set_ctldata</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp_type</span> <span class="o">==</span> <span class="n">CE4100_SSP</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">setup_cs</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">chip_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">chip_data</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">spi_get_ctldata</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp_type</span> <span class="o">!=</span> <span class="n">CE4100_SSP</span> <span class="o">&amp;&amp;</span> <span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">gpio_cs</span><span class="p">))</span>
		<span class="n">gpio_free</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">gpio_cs</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">init_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">run</span> <span class="o">=</span> <span class="n">QUEUE_STOPPED</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pump_transfers</span><span class="p">,</span>
			<span class="n">pump_transfers</span><span class="p">,</span>	<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">drv_data</span><span class="p">);</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pump_messages</span><span class="p">,</span> <span class="n">pump_messages</span><span class="p">);</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">workqueue</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span>
				<span class="n">dev_name</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">workqueue</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">start_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">run</span> <span class="o">==</span> <span class="n">QUEUE_RUNNING</span> <span class="o">||</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">run</span> <span class="o">=</span> <span class="n">QUEUE_RUNNING</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_transfer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">cur_chip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">queue_work</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pump_messages</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">stop_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* This is a bit lame, but is optimized for the common execution path.</span>
<span class="cm">	 * A wait_queue on the drv_data-&gt;busy could be used, but then the common</span>
<span class="cm">	 * execution path (pump_messages) would be required to call wake_up or</span>
<span class="cm">	 * friends on every SPI message. Do this instead */</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">run</span> <span class="o">=</span> <span class="n">QUEUE_STOPPED</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="o">||</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">limit</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="o">||</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">destroy_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">stop_queue</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="cm">/* we are unloading the module or failing to load (only two calls</span>
<span class="cm">	 * to this routine), and neither call can handle a return value.</span>
<span class="cm">	 * However, destroy_workqueue calls flush_workqueue, and that will</span>
<span class="cm">	 * block until all work is done.  If the reason that stop_queue</span>
<span class="cm">	 * timed out is that the work will never finish, then it does no</span>
<span class="cm">	 * good to call destroy_workqueue, so return anyway. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">pxa2xx_spi_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa2xx_spi_master</span> <span class="o">*</span><span class="n">platform_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ssp_device</span> <span class="o">*</span><span class="n">ssp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">platform_info</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">platform_data</span><span class="p">;</span>

	<span class="n">ssp</span> <span class="o">=</span> <span class="n">pxa_ssp_request</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ssp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to request SSP%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate master with space for drv_data and null dma buffer */</span>
	<span class="n">master</span> <span class="o">=</span> <span class="n">spi_alloc_master</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">master</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot alloc spi_master</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pxa_ssp_free</span><span class="p">(</span><span class="n">ssp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">drv_data</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">=</span> <span class="n">master</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">master_info</span> <span class="o">=</span> <span class="n">platform_info</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp</span> <span class="o">=</span> <span class="n">ssp</span><span class="p">;</span>

	<span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>
	<span class="cm">/* the spi-&gt;mode bits understood by this driver: */</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">mode_bits</span> <span class="o">=</span> <span class="n">SPI_CPOL</span> <span class="o">|</span> <span class="n">SPI_CPHA</span> <span class="o">|</span> <span class="n">SPI_CS_HIGH</span><span class="p">;</span>

	<span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_num</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">num_chipselect</span> <span class="o">=</span> <span class="n">platform_info</span><span class="o">-&gt;</span><span class="n">num_chipselect</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">dma_alignment</span> <span class="o">=</span> <span class="n">DMA_ALIGNMENT</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">cleanup</span> <span class="o">=</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">setup</span> <span class="o">=</span> <span class="n">setup</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">transfer</span> <span class="o">=</span> <span class="n">transfer</span><span class="p">;</span>

	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp_type</span> <span class="o">=</span> <span class="n">ssp</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">null_dma_buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">ALIGN</span><span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">drv_data</span> <span class="o">+</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">driver_data</span><span class="p">)),</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">ssp</span><span class="o">-&gt;</span><span class="n">mmio_base</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssdr_physical</span> <span class="o">=</span> <span class="n">ssp</span><span class="o">-&gt;</span><span class="n">phys_base</span> <span class="o">+</span> <span class="n">SSDR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pxa25x_ssp_comp</span><span class="p">(</span><span class="n">drv_data</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">int_cr1</span> <span class="o">=</span> <span class="n">SSCR1_TIE</span> <span class="o">|</span> <span class="n">SSCR1_RIE</span><span class="p">;</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_cr1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">clear_sr</span> <span class="o">=</span> <span class="n">SSSR_ROR</span><span class="p">;</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">mask_sr</span> <span class="o">=</span> <span class="n">SSSR_RFS</span> <span class="o">|</span> <span class="n">SSSR_TFS</span> <span class="o">|</span> <span class="n">SSSR_ROR</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">int_cr1</span> <span class="o">=</span> <span class="n">SSCR1_TIE</span> <span class="o">|</span> <span class="n">SSCR1_RIE</span> <span class="o">|</span> <span class="n">SSCR1_TINTE</span><span class="p">;</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">dma_cr1</span> <span class="o">=</span> <span class="n">SSCR1_TSRE</span> <span class="o">|</span> <span class="n">SSCR1_RSRE</span> <span class="o">|</span> <span class="n">SSCR1_TINTE</span><span class="p">;</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">clear_sr</span> <span class="o">=</span> <span class="n">SSSR_ROR</span> <span class="o">|</span> <span class="n">SSSR_TINT</span><span class="p">;</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">mask_sr</span> <span class="o">=</span> <span class="n">SSSR_TINT</span> <span class="o">|</span> <span class="n">SSSR_RFS</span> <span class="o">|</span> <span class="n">SSSR_TFS</span> <span class="o">|</span> <span class="n">SSSR_ROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ssp_int</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span>
			<span class="n">drv_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot get IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ssp</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_error_master_alloc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Setup DMA if requested */</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">platform_info</span><span class="o">-&gt;</span><span class="n">enable_dma</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Get two DMA channels	(rx and tx) */</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span> <span class="o">=</span> <span class="n">pxa_request_dma</span><span class="p">(</span><span class="s">&quot;pxa2xx_spi_ssp_rx&quot;</span><span class="p">,</span>
							<span class="n">DMA_PRIO_HIGH</span><span class="p">,</span>
							<span class="n">dma_handler</span><span class="p">,</span>
							<span class="n">drv_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;problem (%d) requesting rx channel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_error_irq_alloc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span> <span class="o">=</span> <span class="n">pxa_request_dma</span><span class="p">(</span><span class="s">&quot;pxa2xx_spi_ssp_tx&quot;</span><span class="p">,</span>
							<span class="n">DMA_PRIO_MEDIUM</span><span class="p">,</span>
							<span class="n">dma_handler</span><span class="p">,</span>
							<span class="n">drv_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;problem (%d) requesting tx channel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_error_dma_alloc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">DRCMR</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">drcmr_rx</span><span class="p">)</span> <span class="o">=</span> <span class="n">DRCMR_MAPVLD</span> <span class="o">|</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">;</span>
		<span class="n">DRCMR</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">drcmr_tx</span><span class="p">)</span> <span class="o">=</span> <span class="n">DRCMR_MAPVLD</span> <span class="o">|</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enable SOC clock */</span>
	<span class="n">clk_enable</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="cm">/* Load default SSP configuration */</span>
	<span class="n">write_SSCR0</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">);</span>
	<span class="n">write_SSCR1</span><span class="p">(</span><span class="n">SSCR1_RxTresh</span><span class="p">(</span><span class="n">RX_THRESH_DFLT</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">SSCR1_TxTresh</span><span class="p">(</span><span class="n">TX_THRESH_DFLT</span><span class="p">),</span>
				<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">);</span>
	<span class="n">write_SSCR0</span><span class="p">(</span><span class="n">SSCR0_SCR</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">SSCR0_Motorola</span>
			<span class="o">|</span> <span class="n">SSCR0_DataSize</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
			<span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pxa25x_ssp_comp</span><span class="p">(</span><span class="n">drv_data</span><span class="p">))</span>
		<span class="n">write_SSTO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">);</span>
	<span class="n">write_SSPSP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">);</span>

	<span class="cm">/* Initial and start queue */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">init_queue</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;problem initializing queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_error_clock_enabled</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">start_queue</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;problem starting queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_error_clock_enabled</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Register with the SPI framework */</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">drv_data</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">spi_register_master</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;problem registering spi master</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_error_queue_alloc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

<span class="nl">out_error_queue_alloc:</span>
	<span class="n">destroy_queue</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>

<span class="nl">out_error_clock_enabled:</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

<span class="nl">out_error_dma_alloc:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">pxa_free_dma</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">pxa_free_dma</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">);</span>

<span class="nl">out_error_irq_alloc:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">drv_data</span><span class="p">);</span>

<span class="nl">out_error_master_alloc:</span>
	<span class="n">spi_master_put</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="n">pxa_ssp_free</span><span class="p">(</span><span class="n">ssp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa2xx_spi_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ssp_device</span> <span class="o">*</span><span class="n">ssp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ssp</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">;</span>

	<span class="cm">/* Remove the queue */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">destroy_queue</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* the kernel does not check the return status of this</span>
<span class="cm">		 * this routine (mod-&gt;exit, within the kernel).  Therefore</span>
<span class="cm">		 * nothing is gained by returning from here, the module is</span>
<span class="cm">		 * going away regardless, and we should not leave any more</span>
<span class="cm">		 * resources allocated than necessary.  We cannot free the</span>
<span class="cm">		 * message memory in drv_data-&gt;queue, but we can release the</span>
<span class="cm">		 * resources below.  I think the kernel should honor -EBUSY</span>
<span class="cm">		 * returns but... */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pxa2xx_spi_remove: workqueue will not &quot;</span>
			<span class="s">&quot;complete, message memory not freed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Disable the SSP at the peripheral and SOC level */</span>
	<span class="n">write_SSCR0</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">);</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="cm">/* Release DMA */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">master_info</span><span class="o">-&gt;</span><span class="n">enable_dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DRCMR</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">drcmr_rx</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">DRCMR</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">drcmr_tx</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pxa_free_dma</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">);</span>
		<span class="n">pxa_free_dma</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Release IRQ */</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">drv_data</span><span class="p">);</span>

	<span class="cm">/* Release SSP */</span>
	<span class="n">pxa_ssp_free</span><span class="p">(</span><span class="n">ssp</span><span class="p">);</span>

	<span class="cm">/* Disconnect from the SPI framework */</span>
	<span class="n">spi_unregister_master</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>

	<span class="cm">/* Prevent double remove */</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa2xx_spi_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">=</span> <span class="n">pxa2xx_spi_remove</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;shutdown failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa2xx_spi_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ssp_device</span> <span class="o">*</span><span class="n">ssp</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">stop_queue</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">write_SSCR0</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">);</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa2xx_spi_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">driver_data</span> <span class="o">*</span><span class="n">drv_data</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ssp_device</span> <span class="o">*</span><span class="n">ssp</span> <span class="o">=</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">DRCMR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">drcmr_rx</span><span class="p">)</span> <span class="o">=</span>
			<span class="n">DRCMR_MAPVLD</span> <span class="o">|</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">rx_channel</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">DRCMR</span><span class="p">(</span><span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">drcmr_tx</span><span class="p">)</span> <span class="o">=</span>
			<span class="n">DRCMR_MAPVLD</span> <span class="o">|</span> <span class="n">drv_data</span><span class="o">-&gt;</span><span class="n">tx_channel</span><span class="p">;</span>

	<span class="cm">/* Enable the SSP clock */</span>
	<span class="n">clk_enable</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="cm">/* Start the queue running */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">start_queue</span><span class="p">(</span><span class="n">drv_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;problem starting queue (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">pxa2xx_spi_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">pxa2xx_spi_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">pxa2xx_spi_resume</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;pxa2xx-spi&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
		<span class="p">.</span><span class="n">pm</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">pxa2xx_spi_pm_ops</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">pxa2xx_spi_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">pxa2xx_spi_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">pxa2xx_spi_shutdown</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pxa2xx_spi_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">pxa2xx_spi_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">pxa2xx_spi_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">pxa2xx_spi_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
