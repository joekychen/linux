<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › spi › spi-ep93xx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>spi-ep93xx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Driver for Cirrus Logic EP93xx SPI controller.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2010-2011 Mika Westerberg</span>
<span class="cm"> *</span>
<span class="cm"> * Explicit FIFO handling code was inspired by amba-pl022 driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Chip select support using other than built-in GPIOs by H. Hartley Sweeten.</span>
<span class="cm"> *</span>
<span class="cm"> * For more information about the SPI controller see documentation on Cirrus</span>
<span class="cm"> * Logic web site:</span>
<span class="cm"> *     http://www.cirrus.com/en/pubs/manual/EP93xx_Users_Guide_UM1.pdf</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/dmaengine.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/spi/spi.h&gt;</span>

<span class="cp">#include &lt;mach/dma.h&gt;</span>
<span class="cp">#include &lt;mach/ep93xx_spi.h&gt;</span>

<span class="cp">#define SSPCR0			0x0000</span>
<span class="cp">#define SSPCR0_MODE_SHIFT	6</span>
<span class="cp">#define SSPCR0_SCR_SHIFT	8</span>

<span class="cp">#define SSPCR1			0x0004</span>
<span class="cp">#define SSPCR1_RIE		BIT(0)</span>
<span class="cp">#define SSPCR1_TIE		BIT(1)</span>
<span class="cp">#define SSPCR1_RORIE		BIT(2)</span>
<span class="cp">#define SSPCR1_LBM		BIT(3)</span>
<span class="cp">#define SSPCR1_SSE		BIT(4)</span>
<span class="cp">#define SSPCR1_MS		BIT(5)</span>
<span class="cp">#define SSPCR1_SOD		BIT(6)</span>

<span class="cp">#define SSPDR			0x0008</span>

<span class="cp">#define SSPSR			0x000c</span>
<span class="cp">#define SSPSR_TFE		BIT(0)</span>
<span class="cp">#define SSPSR_TNF		BIT(1)</span>
<span class="cp">#define SSPSR_RNE		BIT(2)</span>
<span class="cp">#define SSPSR_RFF		BIT(3)</span>
<span class="cp">#define SSPSR_BSY		BIT(4)</span>
<span class="cp">#define SSPCPSR			0x0010</span>

<span class="cp">#define SSPIIR			0x0014</span>
<span class="cp">#define SSPIIR_RIS		BIT(0)</span>
<span class="cp">#define SSPIIR_TIS		BIT(1)</span>
<span class="cp">#define SSPIIR_RORIS		BIT(2)</span>
<span class="cp">#define SSPICR			SSPIIR</span>

<span class="cm">/* timeout in milliseconds */</span>
<span class="cp">#define SPI_TIMEOUT		5</span>
<span class="cm">/* maximum depth of RX/TX FIFO */</span>
<span class="cp">#define SPI_FIFO_SIZE		8</span>

<span class="cm">/**</span>
<span class="cm"> * struct ep93xx_spi - EP93xx SPI controller structure</span>
<span class="cm"> * @lock: spinlock that protects concurrent accesses to fields @running,</span>
<span class="cm"> *        @current_msg and @msg_queue</span>
<span class="cm"> * @pdev: pointer to platform device</span>
<span class="cm"> * @clk: clock for the controller</span>
<span class="cm"> * @regs_base: pointer to ioremap()&#39;d registers</span>
<span class="cm"> * @sspdr_phys: physical address of the SSPDR register</span>
<span class="cm"> * @min_rate: minimum clock rate (in Hz) supported by the controller</span>
<span class="cm"> * @max_rate: maximum clock rate (in Hz) supported by the controller</span>
<span class="cm"> * @running: is the queue running</span>
<span class="cm"> * @wq: workqueue used by the driver</span>
<span class="cm"> * @msg_work: work that is queued for the driver</span>
<span class="cm"> * @wait: wait here until given transfer is completed</span>
<span class="cm"> * @msg_queue: queue for the messages</span>
<span class="cm"> * @current_msg: message that is currently processed (or %NULL if none)</span>
<span class="cm"> * @tx: current byte in transfer to transmit</span>
<span class="cm"> * @rx: current byte in transfer to receive</span>
<span class="cm"> * @fifo_level: how full is FIFO (%0..%SPI_FIFO_SIZE - %1). Receiving one</span>
<span class="cm"> *              frame decreases this level and sending one frame increases it.</span>
<span class="cm"> * @dma_rx: RX DMA channel</span>
<span class="cm"> * @dma_tx: TX DMA channel</span>
<span class="cm"> * @dma_rx_data: RX parameters passed to the DMA engine</span>
<span class="cm"> * @dma_tx_data: TX parameters passed to the DMA engine</span>
<span class="cm"> * @rx_sgt: sg table for RX transfers</span>
<span class="cm"> * @tx_sgt: sg table for TX transfers</span>
<span class="cm"> * @zeropage: dummy page used as RX buffer when only TX buffer is passed in by</span>
<span class="cm"> *            the client</span>
<span class="cm"> *</span>
<span class="cm"> * This structure holds EP93xx SPI controller specific information. When</span>
<span class="cm"> * @running is %true, driver accepts transfer requests from protocol drivers.</span>
<span class="cm"> * @current_msg is used to hold pointer to the message that is currently</span>
<span class="cm"> * processed. If @current_msg is %NULL, it means that no processing is going</span>
<span class="cm"> * on.</span>
<span class="cm"> *</span>
<span class="cm"> * Most of the fields are only written once and they can be accessed without</span>
<span class="cm"> * taking the @lock. Fields that are accessed concurrently are: @current_msg,</span>
<span class="cm"> * @running, and @msg_queue.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>			<span class="n">lock</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">platform_device</span>	<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span>			<span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>			<span class="o">*</span><span class="n">regs_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">sspdr_phys</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">min_rate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">max_rate</span><span class="p">;</span>
	<span class="n">bool</span>				<span class="n">running</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span>		<span class="o">*</span><span class="n">wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>		<span class="n">msg_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>		<span class="n">wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">msg_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_message</span>		<span class="o">*</span><span class="n">current_msg</span><span class="p">;</span>
	<span class="kt">size_t</span>				<span class="n">tx</span><span class="p">;</span>
	<span class="kt">size_t</span>				<span class="n">rx</span><span class="p">;</span>
	<span class="kt">size_t</span>				<span class="n">fifo_level</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_chan</span>			<span class="o">*</span><span class="n">dma_rx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_chan</span>			<span class="o">*</span><span class="n">dma_tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ep93xx_dma_data</span>		<span class="n">dma_rx_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ep93xx_dma_data</span>		<span class="n">dma_tx_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sg_table</span>			<span class="n">rx_sgt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sg_table</span>			<span class="n">tx_sgt</span><span class="p">;</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">zeropage</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ep93xx_spi_chip - SPI device hardware settings</span>
<span class="cm"> * @spi: back pointer to the SPI device</span>
<span class="cm"> * @rate: max rate in hz this chip supports</span>
<span class="cm"> * @div_cpsr: cpsr (pre-scaler) divider</span>
<span class="cm"> * @div_scr: scr divider</span>
<span class="cm"> * @dss: bits per word (4 - 16 bits)</span>
<span class="cm"> * @ops: private chip operations</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is used to store hardware register specific settings for each</span>
<span class="cm"> * SPI device. Settings are written to hardware by function</span>
<span class="cm"> * ep93xx_spi_chip_setup().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ep93xx_spi_chip</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">spi_device</span>		<span class="o">*</span><span class="n">spi</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">rate</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">div_cpsr</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">div_scr</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">dss</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ep93xx_spi_chip_ops</span>	<span class="o">*</span><span class="n">ops</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* converts bits per word to CR0.DSS value */</span>
<span class="cp">#define bits_per_word_to_dss(bpw)	((bpw) - 1)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ep93xx_spi_write_u8</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__raw_writeb</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">regs_base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span>
<span class="nf">ep93xx_spi_read_u8</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__raw_readb</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">regs_base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ep93xx_spi_write_u16</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__raw_writew</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">regs_base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span>
<span class="nf">ep93xx_spi_read_u16</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__raw_readw</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">regs_base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep93xx_spi_enable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">regval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">clk_enable</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">regval</span> <span class="o">=</span> <span class="n">ep93xx_spi_read_u8</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPCR1</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">|=</span> <span class="n">SSPCR1_SSE</span><span class="p">;</span>
	<span class="n">ep93xx_spi_write_u8</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPCR1</span><span class="p">,</span> <span class="n">regval</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep93xx_spi_disable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">regval</span><span class="p">;</span>

	<span class="n">regval</span> <span class="o">=</span> <span class="n">ep93xx_spi_read_u8</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPCR1</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SSPCR1_SSE</span><span class="p">;</span>
	<span class="n">ep93xx_spi_write_u8</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPCR1</span><span class="p">,</span> <span class="n">regval</span><span class="p">);</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep93xx_spi_enable_interrupts</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">regval</span><span class="p">;</span>

	<span class="n">regval</span> <span class="o">=</span> <span class="n">ep93xx_spi_read_u8</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPCR1</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">|=</span> <span class="p">(</span><span class="n">SSPCR1_RORIE</span> <span class="o">|</span> <span class="n">SSPCR1_TIE</span> <span class="o">|</span> <span class="n">SSPCR1_RIE</span><span class="p">);</span>
	<span class="n">ep93xx_spi_write_u8</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPCR1</span><span class="p">,</span> <span class="n">regval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep93xx_spi_disable_interrupts</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">regval</span><span class="p">;</span>

	<span class="n">regval</span> <span class="o">=</span> <span class="n">ep93xx_spi_read_u8</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPCR1</span><span class="p">);</span>
	<span class="n">regval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SSPCR1_RORIE</span> <span class="o">|</span> <span class="n">SSPCR1_TIE</span> <span class="o">|</span> <span class="n">SSPCR1_RIE</span><span class="p">);</span>
	<span class="n">ep93xx_spi_write_u8</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPCR1</span><span class="p">,</span> <span class="n">regval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep93xx_spi_calc_divisors() - calculates SPI clock divisors</span>
<span class="cm"> * @espi: ep93xx SPI controller struct</span>
<span class="cm"> * @chip: divisors are calculated for this chip</span>
<span class="cm"> * @rate: desired SPI output clock rate</span>
<span class="cm"> *</span>
<span class="cm"> * Function calculates cpsr (clock pre-scaler) and scr divisors based on</span>
<span class="cm"> * given @rate and places them to @chip-&gt;div_cpsr and @chip-&gt;div_scr. If,</span>
<span class="cm"> * for some reason, divisors cannot be calculated nothing is stored and</span>
<span class="cm"> * %-EINVAL is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep93xx_spi_calc_divisors</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ep93xx_spi_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spi_clk_rate</span> <span class="o">=</span> <span class="n">clk_get_rate</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cpsr</span><span class="p">,</span> <span class="n">scr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure that max value is between values supported by the</span>
<span class="cm">	 * controller. Note that minimum value is already checked in</span>
<span class="cm">	 * ep93xx_spi_transfer().</span>
<span class="cm">	 */</span>
	<span class="n">rate</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">min_rate</span><span class="p">,</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">max_rate</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate divisors so that we can get speed according the</span>
<span class="cm">	 * following formula:</span>
<span class="cm">	 *	rate = spi_clock_rate / (cpsr * (1 + scr))</span>
<span class="cm">	 *</span>
<span class="cm">	 * cpsr must be even number and starts from 2, scr can be any number</span>
<span class="cm">	 * between 0 and 255.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cpsr</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">cpsr</span> <span class="o">&lt;=</span> <span class="mi">254</span><span class="p">;</span> <span class="n">cpsr</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">scr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">scr</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">;</span> <span class="n">scr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">spi_clk_rate</span> <span class="o">/</span> <span class="p">(</span><span class="n">cpsr</span> <span class="o">*</span> <span class="p">(</span><span class="n">scr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&lt;=</span> <span class="n">rate</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">div_scr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">scr</span><span class="p">;</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">div_cpsr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">cpsr</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep93xx_spi_cs_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="n">bool</span> <span class="n">control</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ep93xx_spi_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">spi_get_ctldata</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SPI_CS_HIGH</span><span class="p">)</span> <span class="o">?</span> <span class="n">control</span> <span class="o">:</span> <span class="o">!</span><span class="n">control</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">cs_control</span><span class="p">)</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">cs_control</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep93xx_spi_setup() - setup an SPI device</span>
<span class="cm"> * @spi: SPI device to setup</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets up SPI device mode, speed etc. Can be called multiple</span>
<span class="cm"> * times for a single device. Returns %0 in case of success, negative error in</span>
<span class="cm"> * case of failure. When this function returns success, the device is</span>
<span class="cm"> * deselected.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep93xx_spi_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ep93xx_spi_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">||</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid bits per word %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chip</span> <span class="o">=</span> <span class="n">spi_get_ctldata</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;initial setup for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">spi</span><span class="o">-&gt;</span><span class="n">modalias</span><span class="p">);</span>

		<span class="n">chip</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">chip</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">spi</span> <span class="o">=</span> <span class="n">spi</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">controller_data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">spi_set_ctldata</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span> <span class="o">!=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ep93xx_spi_calc_divisors</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spi_set_ctldata</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">dss</span> <span class="o">=</span> <span class="n">bits_per_word_to_dss</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">);</span>

	<span class="n">ep93xx_spi_cs_control</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep93xx_spi_transfer() - queue message to be transferred</span>
<span class="cm"> * @spi: target SPI device</span>
<span class="cm"> * @msg: message to be transferred</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by SPI device drivers when they are going to transfer</span>
<span class="cm"> * a new message. It simply puts the message in the queue and schedules</span>
<span class="cm"> * workqueue to perform the actual transfer later on.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns %0 on success and negative error in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep93xx_spi_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span> <span class="o">||</span> <span class="o">!</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* first validate each transfer */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">transfers</span><span class="p">,</span> <span class="n">transfer_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">||</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">speed_hz</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">speed_hz</span> <span class="o">&lt;</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">min_rate</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that we own the message, let&#39;s initialize it so that it is</span>
<span class="cm">	 * suitable for us. We use @msg-&gt;status to signal whether there was</span>
<span class="cm">	 * error in transfer and @msg-&gt;state is used to hold pointer to the</span>
<span class="cm">	 * current transfer (or %NULL if no active current transfer).</span>
<span class="cm">	 */</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">msg_queue</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">msg_work</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep93xx_spi_cleanup() - cleans up master controller specific state</span>
<span class="cm"> * @spi: SPI device to cleanup</span>
<span class="cm"> *</span>
<span class="cm"> * This function releases master controller specific state for given @spi</span>
<span class="cm"> * device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep93xx_spi_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ep93xx_spi_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>

	<span class="n">chip</span> <span class="o">=</span> <span class="n">spi_get_ctldata</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">cleanup</span><span class="p">)</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">cleanup</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
		<span class="n">spi_set_ctldata</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep93xx_spi_chip_setup() - configures hardware according to given @chip</span>
<span class="cm"> * @espi: ep93xx SPI controller struct</span>
<span class="cm"> * @chip: chip specific settings</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets up the actual hardware registers with settings given in</span>
<span class="cm"> * @chip. Note that no validation is done so make sure that callers validate</span>
<span class="cm"> * settings before calling this.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep93xx_spi_chip_setup</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">ep93xx_spi_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">cr0</span><span class="p">;</span>

	<span class="n">cr0</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">div_scr</span> <span class="o">&lt;&lt;</span> <span class="n">SSPCR0_SCR_SHIFT</span><span class="p">;</span>
	<span class="n">cr0</span> <span class="o">|=</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SPI_CPHA</span><span class="o">|</span><span class="n">SPI_CPOL</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">SSPCR0_MODE_SHIFT</span><span class="p">;</span>
	<span class="n">cr0</span> <span class="o">|=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">dss</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;setup: mode %d, cpsr %d, scr %d, dss %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">div_cpsr</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">div_scr</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">dss</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;setup: cr0 %#x&quot;</span><span class="p">,</span> <span class="n">cr0</span><span class="p">);</span>

	<span class="n">ep93xx_spi_write_u8</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPCPSR</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">div_cpsr</span><span class="p">);</span>
	<span class="n">ep93xx_spi_write_u16</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPCR0</span><span class="p">,</span> <span class="n">cr0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bits_per_word</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">current_msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">?</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">:</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep93xx_do_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bits_per_word</span><span class="p">(</span><span class="n">espi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">tx_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">)</span>
			<span class="n">tx_val</span> <span class="o">=</span> <span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">)[</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">];</span>
		<span class="n">ep93xx_spi_write_u16</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPDR</span><span class="p">,</span> <span class="n">tx_val</span><span class="p">);</span>
		<span class="n">espi</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tx_val</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">tx_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">)</span>
			<span class="n">tx_val</span> <span class="o">=</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">)[</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">];</span>
		<span class="n">ep93xx_spi_write_u8</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPDR</span><span class="p">,</span> <span class="n">tx_val</span><span class="p">);</span>
		<span class="n">espi</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tx_val</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep93xx_do_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bits_per_word</span><span class="p">(</span><span class="n">espi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">rx_val</span><span class="p">;</span>

		<span class="n">rx_val</span> <span class="o">=</span> <span class="n">ep93xx_spi_read_u16</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPDR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">)</span>
			<span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">)[</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">]</span> <span class="o">=</span> <span class="n">rx_val</span><span class="p">;</span>
		<span class="n">espi</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rx_val</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">rx_val</span><span class="p">;</span>

		<span class="n">rx_val</span> <span class="o">=</span> <span class="n">ep93xx_spi_read_u8</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPDR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">)</span>
			<span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">)[</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">]</span> <span class="o">=</span> <span class="n">rx_val</span><span class="p">;</span>
		<span class="n">espi</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rx_val</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep93xx_spi_read_write() - perform next RX/TX transfer</span>
<span class="cm"> * @espi: ep93xx SPI controller struct</span>
<span class="cm"> *</span>
<span class="cm"> * This function transfers next bytes (or half-words) to/from RX/TX FIFOs. If</span>
<span class="cm"> * called several times, the whole transfer will be completed. Returns</span>
<span class="cm"> * %-EINPROGRESS when current transfer was not yet completed otherwise %0.</span>
<span class="cm"> *</span>
<span class="cm"> * When this function is finished, RX FIFO should be empty and TX FIFO should be</span>
<span class="cm"> * full.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep93xx_spi_read_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">current_msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

	<span class="cm">/* read as long as RX FIFO has frames in it */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">ep93xx_spi_read_u8</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSPSR_RNE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ep93xx_do_read</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
		<span class="n">espi</span><span class="o">-&gt;</span><span class="n">fifo_level</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* write as long as TX FIFO has room */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">fifo_level</span> <span class="o">&lt;</span> <span class="n">SPI_FIFO_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep93xx_do_write</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
		<span class="n">espi</span><span class="o">-&gt;</span><span class="n">fifo_level</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">==</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep93xx_spi_pio_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now everything is set up for the current transfer. We prime the TX</span>
<span class="cm">	 * FIFO, enable interrupts, and wait for the transfer to complete.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep93xx_spi_read_write</span><span class="p">(</span><span class="n">espi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ep93xx_spi_enable_interrupts</span><span class="p">(</span><span class="n">espi</span><span class="p">);</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep93xx_spi_dma_prepare() - prepares a DMA transfer</span>
<span class="cm"> * @espi: ep93xx SPI controller struct</span>
<span class="cm"> * @dir: DMA transfer direction</span>
<span class="cm"> *</span>
<span class="cm"> * Function configures the DMA, maps the buffer and prepares the DMA</span>
<span class="cm"> * descriptor. Returns a valid DMA descriptor in case of success and ERR_PTR</span>
<span class="cm"> * in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span>
<span class="nf">ep93xx_spi_dma_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_transfer_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">current_msg</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">txd</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dma_slave_buswidth</span> <span class="n">buswidth</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_slave_config</span> <span class="n">conf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sg_table</span> <span class="o">*</span><span class="n">sgt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">pbuf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">nents</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits_per_word</span><span class="p">(</span><span class="n">espi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">buswidth</span> <span class="o">=</span> <span class="n">DMA_SLAVE_BUSWIDTH_2_BYTES</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">buswidth</span> <span class="o">=</span> <span class="n">DMA_SLAVE_BUSWIDTH_1_BYTE</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">conf</span><span class="p">));</span>
	<span class="n">conf</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">dir</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_DEV_TO_MEM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan</span> <span class="o">=</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_rx</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">;</span>
		<span class="n">sgt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">rx_sgt</span><span class="p">;</span>

		<span class="n">conf</span><span class="p">.</span><span class="n">src_addr</span> <span class="o">=</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">sspdr_phys</span><span class="p">;</span>
		<span class="n">conf</span><span class="p">.</span><span class="n">src_addr_width</span> <span class="o">=</span> <span class="n">buswidth</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">chan</span> <span class="o">=</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_tx</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">;</span>
		<span class="n">sgt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">tx_sgt</span><span class="p">;</span>

		<span class="n">conf</span><span class="p">.</span><span class="n">dst_addr</span> <span class="o">=</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">sspdr_phys</span><span class="p">;</span>
		<span class="n">conf</span><span class="p">.</span><span class="n">dst_addr_width</span> <span class="o">=</span> <span class="n">buswidth</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dmaengine_slave_config</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to split the transfer into PAGE_SIZE&#39;d chunks. This is</span>
<span class="cm">	 * because we are using @espi-&gt;zeropage to provide a zero RX buffer</span>
<span class="cm">	 * for the TX transfers and we have only allocated one page for that.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For performance reasons we allocate a new sg_table only when</span>
<span class="cm">	 * needed. Otherwise we will re-use the current one. Eventually the</span>
<span class="cm">	 * last sg_table is released in ep93xx_spi_release_dma().</span>
<span class="cm">	 */</span>

	<span class="n">nents</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nents</span> <span class="o">!=</span> <span class="n">sgt</span><span class="o">-&gt;</span><span class="n">nents</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sg_free_table</span><span class="p">(</span><span class="n">sgt</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">sg_alloc_table</span><span class="p">(</span><span class="n">sgt</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pbuf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sgt</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">sgt</span><span class="o">-&gt;</span><span class="n">nents</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sg_set_page</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">pbuf</span><span class="p">),</span> <span class="n">bytes</span><span class="p">,</span>
				    <span class="n">offset_in_page</span><span class="p">(</span><span class="n">pbuf</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sg_set_page</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">zeropage</span><span class="p">),</span>
				    <span class="n">bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">pbuf</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;len = %d expected 0!&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">nents</span> <span class="o">=</span> <span class="n">dma_map_sg</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sgt</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">,</span> <span class="n">sgt</span><span class="o">-&gt;</span><span class="n">nents</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nents</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">txd</span> <span class="o">=</span> <span class="n">dmaengine_prep_slave_sg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">sgt</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">DMA_CTRL_ACK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">txd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sgt</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">,</span> <span class="n">sgt</span><span class="o">-&gt;</span><span class="n">nents</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">txd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep93xx_spi_dma_finish() - finishes with a DMA transfer</span>
<span class="cm"> * @espi: ep93xx SPI controller struct</span>
<span class="cm"> * @dir: DMA transfer direction</span>
<span class="cm"> *</span>
<span class="cm"> * Function finishes with the DMA transfer. After this, the DMA buffer is</span>
<span class="cm"> * unmapped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep93xx_spi_dma_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">,</span>
				  <span class="k">enum</span> <span class="n">dma_transfer_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sg_table</span> <span class="o">*</span><span class="n">sgt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_DEV_TO_MEM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan</span> <span class="o">=</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_rx</span><span class="p">;</span>
		<span class="n">sgt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">rx_sgt</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">chan</span> <span class="o">=</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_tx</span><span class="p">;</span>
		<span class="n">sgt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">tx_sgt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sgt</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">,</span> <span class="n">sgt</span><span class="o">-&gt;</span><span class="n">nents</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep93xx_spi_dma_callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">callback_param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">complete</span><span class="p">(</span><span class="n">callback_param</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep93xx_spi_dma_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">current_msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">rxd</span><span class="p">,</span> <span class="o">*</span><span class="n">txd</span><span class="p">;</span>

	<span class="n">rxd</span> <span class="o">=</span> <span class="n">ep93xx_spi_dma_prepare</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">DMA_DEV_TO_MEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rxd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DMA RX failed: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">rxd</span><span class="p">));</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">rxd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">txd</span> <span class="o">=</span> <span class="n">ep93xx_spi_dma_prepare</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">DMA_MEM_TO_DEV</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">txd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ep93xx_spi_dma_finish</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">DMA_DEV_TO_MEM</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DMA TX failed: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">rxd</span><span class="p">));</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">txd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We are ready when RX is done */</span>
	<span class="n">rxd</span><span class="o">-&gt;</span><span class="n">callback</span> <span class="o">=</span> <span class="n">ep93xx_spi_dma_callback</span><span class="p">;</span>
	<span class="n">rxd</span><span class="o">-&gt;</span><span class="n">callback_param</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">;</span>

	<span class="cm">/* Now submit both descriptors and wait while they finish */</span>
	<span class="n">dmaengine_submit</span><span class="p">(</span><span class="n">rxd</span><span class="p">);</span>
	<span class="n">dmaengine_submit</span><span class="p">(</span><span class="n">txd</span><span class="p">);</span>

	<span class="n">dma_async_issue_pending</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_rx</span><span class="p">);</span>
	<span class="n">dma_async_issue_pending</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_tx</span><span class="p">);</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">ep93xx_spi_dma_finish</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">DMA_MEM_TO_DEV</span><span class="p">);</span>
	<span class="n">ep93xx_spi_dma_finish</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">DMA_DEV_TO_MEM</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ep93xx_spi_process_transfer() - processes one SPI transfer</span>
<span class="cm"> * @espi: ep93xx SPI controller struct</span>
<span class="cm"> * @msg: current message</span>
<span class="cm"> * @t: transfer to process</span>
<span class="cm"> *</span>
<span class="cm"> * This function processes one SPI transfer given in @t. Function waits until</span>
<span class="cm"> * transfer is complete (may sleep) and updates @msg-&gt;status based on whether</span>
<span class="cm"> * transfer was successfully processed or not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep93xx_spi_process_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ep93xx_spi_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">spi_get_ctldata</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">);</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Handle any transfer specific settings if needed. We use</span>
<span class="cm">	 * temporary chip settings here and restore original later when</span>
<span class="cm">	 * the transfer is finished.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">speed_hz</span> <span class="o">||</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ep93xx_spi_chip</span> <span class="n">tmp_chip</span> <span class="o">=</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">speed_hz</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">ep93xx_spi_calc_divisors</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_chip</span><span class="p">,</span>
						       <span class="n">t</span><span class="o">-&gt;</span><span class="n">speed_hz</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;failed to adjust speed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">)</span>
			<span class="n">tmp_chip</span><span class="p">.</span><span class="n">dss</span> <span class="o">=</span> <span class="n">bits_per_word_to_dss</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set up temporary new hw settings for this transfer.</span>
<span class="cm">		 */</span>
		<span class="n">ep93xx_spi_chip_setup</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_chip</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is no point of setting up DMA for the transfers which will</span>
<span class="cm">	 * fit into the FIFO and can be transferred with a single interrupt.</span>
<span class="cm">	 * So in these cases we will be using PIO and don&#39;t bother for DMA.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_rx</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">SPI_FIFO_SIZE</span><span class="p">)</span>
		<span class="n">ep93xx_spi_dma_transfer</span><span class="p">(</span><span class="n">espi</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ep93xx_spi_pio_transfer</span><span class="p">(</span><span class="n">espi</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In case of error during transmit, we bail out from processing</span>
<span class="cm">	 * the message.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">+=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * After this transfer is finished, perform any possible</span>
<span class="cm">	 * post-transfer actions requested by the protocol driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">delay_usecs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">schedule_timeout</span><span class="p">(</span><span class="n">usecs_to_jiffies</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">delay_usecs</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">cs_change</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_is_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">transfer_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">transfers</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * In case protocol driver is asking us to drop the</span>
<span class="cm">			 * chipselect briefly, we let the scheduler to handle</span>
<span class="cm">			 * any &quot;delay&quot; here.</span>
<span class="cm">			 */</span>
			<span class="n">ep93xx_spi_cs_control</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="n">ep93xx_spi_cs_control</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">speed_hz</span> <span class="o">||</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">)</span>
		<span class="n">ep93xx_spi_chip_setup</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ep93xx_spi_process_message() - process one SPI message</span>
<span class="cm"> * @espi: ep93xx SPI controller struct</span>
<span class="cm"> * @msg: message to process</span>
<span class="cm"> *</span>
<span class="cm"> * This function processes a single SPI message. We go through all transfers in</span>
<span class="cm"> * the message and pass them to ep93xx_spi_process_transfer(). Chipselect is</span>
<span class="cm"> * asserted during the whole message (unless per transfer cs_change is set).</span>
<span class="cm"> *</span>
<span class="cm"> * @msg-&gt;status contains %0 in case of success or negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep93xx_spi_process_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable the SPI controller and its clock.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ep93xx_spi_enable</span><span class="p">(</span><span class="n">espi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to enable SPI controller</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Just to be sure: flush any data from RX FIFO.</span>
<span class="cm">	 */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">SPI_TIMEOUT</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ep93xx_spi_read_u16</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SSPSR_RNE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;timeout while flushing RX FIFO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ep93xx_spi_read_u16</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPDR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We explicitly handle FIFO level. This way we don&#39;t have to check TX</span>
<span class="cm">	 * FIFO status using %SSPSR_TNF bit which may cause RX FIFO overruns.</span>
<span class="cm">	 */</span>
	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">fifo_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update SPI controller registers according to spi device and assert</span>
<span class="cm">	 * the chipselect.</span>
<span class="cm">	 */</span>
	<span class="n">ep93xx_spi_chip_setup</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">spi_get_ctldata</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">));</span>
	<span class="n">ep93xx_spi_cs_control</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">transfers</span><span class="p">,</span> <span class="n">transfer_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ep93xx_spi_process_transfer</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now the whole message is transferred (or failed for some reason). We</span>
<span class="cm">	 * deselect the device and disable the SPI controller.</span>
<span class="cm">	 */</span>
	<span class="n">ep93xx_spi_cs_control</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">ep93xx_spi_disable</span><span class="p">(</span><span class="n">espi</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define work_to_espi(work) (container_of((work), struct ep93xx_spi, msg_work))</span>

<span class="cm">/**</span>
<span class="cm"> * ep93xx_spi_work() - EP93xx SPI workqueue worker function</span>
<span class="cm"> * @work: work struct</span>
<span class="cm"> *</span>
<span class="cm"> * Workqueue worker function. This function is called when there are new</span>
<span class="cm"> * SPI messages to be processed. Message is taken out from the queue and then</span>
<span class="cm"> * passed to ep93xx_spi_process_message().</span>
<span class="cm"> *</span>
<span class="cm"> * After message is transferred, protocol driver is notified by calling</span>
<span class="cm"> * @msg-&gt;complete(). In case of error, @msg-&gt;status is set to negative error</span>
<span class="cm"> * number, otherwise it contains zero (and @msg-&gt;actual_length is updated).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep93xx_spi_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span> <span class="o">=</span> <span class="n">work_to_espi</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">||</span> <span class="n">espi</span><span class="o">-&gt;</span><span class="n">current_msg</span> <span class="o">||</span>
		<span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">msg_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">msg</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">msg_queue</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">current_msg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">ep93xx_spi_process_message</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the current message and re-schedule ourselves if there are</span>
<span class="cm">	 * more messages in the queue.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">current_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">msg_queue</span><span class="p">))</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">msg_work</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* notify the protocol driver that we are done with this message */</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ep93xx_spi_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">irq_status</span> <span class="o">=</span> <span class="n">ep93xx_spi_read_u8</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPIIR</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we got ROR (receive overrun) interrupt we know that something is</span>
<span class="cm">	 * wrong. Just abort the message.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">irq_status</span> <span class="o">&amp;</span> <span class="n">SSPIIR_RORIS</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* clear the overrun interrupt */</span>
		<span class="n">ep93xx_spi_write_u8</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPICR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;receive overrun, aborting the message</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">espi</span><span class="o">-&gt;</span><span class="n">current_msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Interrupt is either RX (RIS) or TX (TIS). For both cases we</span>
<span class="cm">		 * simply execute next data transfer.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep93xx_spi_read_write</span><span class="p">(</span><span class="n">espi</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * In normal case, there still is some processing left</span>
<span class="cm">			 * for current transfer. Let&#39;s wait for the next</span>
<span class="cm">			 * interrupt then.</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Current transfer is finished, either with error or with success. In</span>
<span class="cm">	 * any case we disable interrupts and notify the worker to handle</span>
<span class="cm">	 * any post-processing of the message.</span>
<span class="cm">	 */</span>
	<span class="n">ep93xx_spi_disable_interrupts</span><span class="p">(</span><span class="n">espi</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">ep93xx_spi_dma_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">filter_param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep93xx_dma_chan_is_m2p</span><span class="p">(</span><span class="n">chan</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">filter_param</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep93xx_spi_setup_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_cap_mask_t</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">zeropage</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">zeropage</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">dma_cap_zero</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
	<span class="n">dma_cap_set</span><span class="p">(</span><span class="n">DMA_SLAVE</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_rx_data</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">EP93XX_DMA_SSP</span><span class="p">;</span>
	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_rx_data</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_DEV_TO_MEM</span><span class="p">;</span>
	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_rx_data</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ep93xx-spi-rx&quot;</span><span class="p">;</span>

	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_rx</span> <span class="o">=</span> <span class="n">dma_request_channel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">ep93xx_spi_dma_filter</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_rx_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_rx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_free_page</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_tx_data</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">EP93XX_DMA_SSP</span><span class="p">;</span>
	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_tx_data</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_MEM_TO_DEV</span><span class="p">;</span>
	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_tx_data</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ep93xx-spi-tx&quot;</span><span class="p">;</span>

	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_tx</span> <span class="o">=</span> <span class="n">dma_request_channel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">ep93xx_spi_dma_filter</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_tx_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_tx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_release_rx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_release_rx:</span>
	<span class="n">dma_release_channel</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_rx</span><span class="p">);</span>
	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_rx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">fail_free_page:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">zeropage</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep93xx_spi_release_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_rx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_release_channel</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_rx</span><span class="p">);</span>
		<span class="n">sg_free_table</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">rx_sgt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_tx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_release_channel</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">dma_tx</span><span class="p">);</span>
		<span class="n">sg_free_table</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">tx_sgt</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">zeropage</span><span class="p">)</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">zeropage</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">ep93xx_spi_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ep93xx_spi_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>

	<span class="n">master</span> <span class="o">=</span> <span class="n">spi_alloc_master</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">espi</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">master</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to allocate spi master</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">master</span><span class="o">-&gt;</span><span class="n">setup</span> <span class="o">=</span> <span class="n">ep93xx_spi_setup</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">transfer</span> <span class="o">=</span> <span class="n">ep93xx_spi_transfer</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">cleanup</span> <span class="o">=</span> <span class="n">ep93xx_spi_cleanup</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_num</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">num_chipselect</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">num_chipselect</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">mode_bits</span> <span class="o">=</span> <span class="n">SPI_CPOL</span> <span class="o">|</span> <span class="n">SPI_CPHA</span> <span class="o">|</span> <span class="n">SPI_CS_HIGH</span><span class="p">;</span>

	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">master</span><span class="p">);</span>

	<span class="n">espi</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>

	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to get spi clock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_release_master</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate maximum and minimum supported clock rates</span>
<span class="cm">	 * for the controller.</span>
<span class="cm">	 */</span>
	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">max_rate</span> <span class="o">=</span> <span class="n">clk_get_rate</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">min_rate</span> <span class="o">=</span> <span class="n">clk_get_rate</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">254</span> <span class="o">*</span> <span class="mi">256</span><span class="p">);</span>
	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to get irq resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_put_clock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to get iomem resource</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_put_clock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">sspdr_phys</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">SSPDR</span><span class="p">;</span>

	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">regs_base</span> <span class="o">=</span> <span class="n">devm_request_and_ioremap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">regs_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to map resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_put_clock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">devm_request_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">ep93xx_spi_interrupt</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="s">&quot;ep93xx-spi&quot;</span><span class="p">,</span> <span class="n">espi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to request irq</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_put_clock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">use_dma</span> <span class="o">&amp;&amp;</span> <span class="n">ep93xx_spi_setup_dma</span><span class="p">(</span><span class="n">espi</span><span class="p">))</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DMA setup failed. Falling back to PIO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">wq</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;ep93xx_spid&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to create workqueue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_free_dma</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">msg_work</span><span class="p">,</span> <span class="n">ep93xx_spi_work</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">msg_queue</span><span class="p">);</span>
	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* make sure that the hardware is disabled */</span>
	<span class="n">ep93xx_spi_write_u8</span><span class="p">(</span><span class="n">espi</span><span class="p">,</span> <span class="n">SSPCR1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">spi_register_master</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to register SPI master</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail_free_queue</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;EP93xx SPI Controller at 0x%08lx irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_free_queue:</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
<span class="nl">fail_free_dma:</span>
	<span class="n">ep93xx_spi_release_dma</span><span class="p">(</span><span class="n">espi</span><span class="p">);</span>
<span class="nl">fail_put_clock:</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
<span class="nl">fail_release_master:</span>
	<span class="n">spi_master_put</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">ep93xx_spi_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ep93xx_spi</span> <span class="o">*</span><span class="n">espi</span> <span class="o">=</span> <span class="n">spi_master_get_devdata</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">espi</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Complete remaining messages with %-ESHUTDOWN status.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">msg_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

		<span class="n">msg</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">msg_queue</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">spi_message</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">ep93xx_spi_release_dma</span><span class="p">(</span><span class="n">espi</span><span class="p">);</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">espi</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">spi_unregister_master</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">ep93xx_spi_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ep93xx-spi&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">ep93xx_spi_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">ep93xx_spi_remove</span><span class="p">),</span>
<span class="p">};</span>
<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">ep93xx_spi_driver</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;EP93xx SPI Controller driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Mika Westerberg &lt;mika.westerberg@iki.fi&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:ep93xx-spi&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
