<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › spi › spi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>spi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * SPI init/core code</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005 David Brownell</span>
<span class="cm"> * Copyright (C) 2008 Secret Lab Technologies Ltd.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/of_device.h&gt;</span>
<span class="cp">#include &lt;linux/of_irq.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mod_devicetable.h&gt;</span>
<span class="cp">#include &lt;linux/spi/spi.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">spidev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_device</span>	<span class="o">*</span><span class="n">spi</span> <span class="o">=</span> <span class="n">to_spi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* spi masters may cleanup for released devices */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">cleanup</span><span class="p">)</span>
		<span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">cleanup</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>

	<span class="n">spi_master_put</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">modalias_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">spi_device</span>	<span class="o">*</span><span class="n">spi</span> <span class="o">=</span> <span class="n">to_spi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">modalias</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">spi_dev_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__ATTR_RO</span><span class="p">(</span><span class="n">modalias</span><span class="p">),</span>
	<span class="n">__ATTR_NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* modalias support makes &quot;modprobe $MODALIAS&quot; new-style hotplug work,</span>
<span class="cm"> * and the sysfs version makes coldplug work too.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">spi_device_id</span> <span class="o">*</span><span class="nf">spi_match_id</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">spi_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span>
						<span class="k">const</span> <span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">modalias</span><span class="p">,</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
		<span class="n">id</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">spi_device_id</span> <span class="o">*</span><span class="nf">spi_get_device_id</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">spi_driver</span> <span class="o">*</span><span class="n">sdrv</span> <span class="o">=</span> <span class="n">to_spi_driver</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">spi_match_id</span><span class="p">(</span><span class="n">sdrv</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">,</span> <span class="n">sdev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_get_device_id</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_match_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">spi_device</span>	<span class="o">*</span><span class="n">spi</span> <span class="o">=</span> <span class="n">to_spi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">spi_driver</span>	<span class="o">*</span><span class="n">sdrv</span> <span class="o">=</span> <span class="n">to_spi_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>

	<span class="cm">/* Attempt an OF style match */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_driver_match_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdrv</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">!!</span><span class="n">spi_match_id</span><span class="p">(</span><span class="n">sdrv</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">,</span> <span class="n">spi</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">modalias</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">spi_device</span>		<span class="o">*</span><span class="n">spi</span> <span class="o">=</span> <span class="n">to_spi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;MODALIAS=%s%s&quot;</span><span class="p">,</span> <span class="n">SPI_MODULE_PREFIX</span><span class="p">,</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">modalias</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_legacy_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_driver</span>	<span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">to_spi_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>

	<span class="cm">/* suspend will stop irqs and dma; no more i/o */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">)</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">(</span><span class="n">to_spi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">message</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;... can&#39;t suspend</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_legacy_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_driver</span>	<span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">to_spi_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>

	<span class="cm">/* resume may restart the i/o queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">)</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">(</span><span class="n">to_spi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;... can&#39;t resume</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_pm_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pm_generic_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">spi_legacy_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_SUSPEND</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_pm_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pm_generic_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">spi_legacy_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_pm_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pm_generic_freeze</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">spi_legacy_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_FREEZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_pm_thaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pm_generic_thaw</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">spi_legacy_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_pm_poweroff</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pm_generic_poweroff</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">spi_legacy_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_HIBERNATE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_pm_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pm_generic_restore</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">spi_legacy_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define spi_pm_suspend	NULL</span>
<span class="cp">#define spi_pm_resume	NULL</span>
<span class="cp">#define spi_pm_freeze	NULL</span>
<span class="cp">#define spi_pm_thaw	NULL</span>
<span class="cp">#define spi_pm_poweroff	NULL</span>
<span class="cp">#define spi_pm_restore	NULL</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">spi_pm</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">spi_pm_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">spi_pm_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">freeze</span> <span class="o">=</span> <span class="n">spi_pm_freeze</span><span class="p">,</span>
	<span class="p">.</span><span class="n">thaw</span> <span class="o">=</span> <span class="n">spi_pm_thaw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poweroff</span> <span class="o">=</span> <span class="n">spi_pm_poweroff</span><span class="p">,</span>
	<span class="p">.</span><span class="n">restore</span> <span class="o">=</span> <span class="n">spi_pm_restore</span><span class="p">,</span>
	<span class="n">SET_RUNTIME_PM_OPS</span><span class="p">(</span>
		<span class="n">pm_generic_runtime_suspend</span><span class="p">,</span>
		<span class="n">pm_generic_runtime_resume</span><span class="p">,</span>
		<span class="n">pm_generic_runtime_idle</span>
	<span class="p">)</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bus_type</span> <span class="n">spi_bus_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;spi&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_attrs</span>	<span class="o">=</span> <span class="n">spi_dev_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">match</span>		<span class="o">=</span> <span class="n">spi_match_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">uevent</span>		<span class="o">=</span> <span class="n">spi_uevent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pm</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">spi_pm</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_bus_type</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_drv_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">spi_driver</span>		<span class="o">*</span><span class="n">sdrv</span> <span class="o">=</span> <span class="n">to_spi_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sdrv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">to_spi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_drv_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">spi_driver</span>		<span class="o">*</span><span class="n">sdrv</span> <span class="o">=</span> <span class="n">to_spi_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sdrv</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">to_spi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">spi_drv_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">spi_driver</span>		<span class="o">*</span><span class="n">sdrv</span> <span class="o">=</span> <span class="n">to_spi_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>

	<span class="n">sdrv</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">(</span><span class="n">to_spi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spi_register_driver - register a SPI driver</span>
<span class="cm"> * @sdrv: the driver to register</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spi_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_driver</span> <span class="o">*</span><span class="n">sdrv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sdrv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spi_bus_type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdrv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">)</span>
		<span class="n">sdrv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">spi_drv_probe</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdrv</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">)</span>
		<span class="n">sdrv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">spi_drv_remove</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdrv</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="n">sdrv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">spi_drv_shutdown</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdrv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_register_driver</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* SPI devices should normally not be created by SPI device drivers; that</span>
<span class="cm"> * would make them board-specific.  Similarly with SPI master drivers.</span>
<span class="cm"> * Device registration normally goes into like arch/.../mach.../board-YYY.c</span>
<span class="cm"> * with other readonly (flashable) information about mainboard devices.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">boardinfo</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_board_info</span>	<span class="n">board_info</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">board_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">spi_master_list</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Used to protect add/del opertion for board_info list and</span>
<span class="cm"> * spi_master list, and their matching process</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">board_lock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * spi_alloc_device - Allocate a new SPI device</span>
<span class="cm"> * @master: Controller to which device is connected</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * Allows a driver to allocate and initialize a spi_device without</span>
<span class="cm"> * registering it immediately.  This allows a driver to directly</span>
<span class="cm"> * fill the spi_device with device parameters before calling</span>
<span class="cm"> * spi_add_device() on it.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller is responsible to call spi_add_device() on the returned</span>
<span class="cm"> * spi_device structure to add it to the SPI master.  If the caller</span>
<span class="cm"> * needs to discard the spi_device without adding it, then it should</span>
<span class="cm"> * call spi_dev_put() on it.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the new device, or NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="nf">spi_alloc_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_device</span>	<span class="o">*</span><span class="n">spi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spi_master_get</span><span class="p">(</span><span class="n">master</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spi</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot alloc spi_device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spi_master_put</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">=</span> <span class="n">master</span><span class="p">;</span>
	<span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spi_bus_type</span><span class="p">;</span>
	<span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">spidev_release</span><span class="p">;</span>
	<span class="n">device_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">spi</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_alloc_device</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * spi_add_device - Add spi_device allocated with spi_alloc_device</span>
<span class="cm"> * @spi: spi_device to register</span>
<span class="cm"> *</span>
<span class="cm"> * Companion function to spi_alloc_device.  Devices allocated with</span>
<span class="cm"> * spi_alloc_device can be added onto the spi bus with this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success; negative errno on failure</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spi_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">spi_add_lock</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Chipselects are numbered 0..max; validate. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">chip_select</span> <span class="o">&gt;=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">num_chipselect</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cs%d &gt;= max %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">spi</span><span class="o">-&gt;</span><span class="n">chip_select</span><span class="p">,</span>
			<span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">num_chipselect</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the bus ID string */</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s.%u&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span>
			<span class="n">spi</span><span class="o">-&gt;</span><span class="n">chip_select</span><span class="p">);</span>


	<span class="cm">/* We need to make sure there&#39;s no other device with this</span>
<span class="cm">	 * chipselect **BEFORE** we call setup(), else we&#39;ll trash</span>
<span class="cm">	 * its configuration.  Lock against concurrent add() calls.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi_add_lock</span><span class="p">);</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">bus_find_device_by_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi_bus_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;chipselect %d already in use</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">spi</span><span class="o">-&gt;</span><span class="n">chip_select</span><span class="p">);</span>
		<span class="n">put_device</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Drivers may modify this initial i/o setup, but will</span>
<span class="cm">	 * normally rely on the device being setup.  Devices</span>
<span class="cm">	 * using SPI_CS_HIGH can&#39;t coexist well otherwise...</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">spi_setup</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t setup %s, status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Device may be bound to an active driver when this returns */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">device_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t add %s, status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;registered child %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>

<span class="nl">done:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi_add_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_add_device</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * spi_new_device - instantiate one new SPI device</span>
<span class="cm"> * @master: Controller to which device is connected</span>
<span class="cm"> * @chip: Describes the SPI device</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * On typical mainboards, this is purely internal; and it&#39;s not needed</span>
<span class="cm"> * after board init creates the hard-wired devices.  Some development</span>
<span class="cm"> * platforms may not be able to use spi_register_board_info though, and</span>
<span class="cm"> * this is exported so that for example a USB or parport based adapter</span>
<span class="cm"> * driver could add devices (which it would learn about out-of-band).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the new device, or NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="nf">spi_new_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">spi_board_info</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_device</span>	<span class="o">*</span><span class="n">proxy</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>

	<span class="cm">/* NOTE:  caller did any chip-&gt;bus_num checks necessary.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Also, unless we change the return value convention to use</span>
<span class="cm">	 * error-or-pointer (not NULL-or-pointer), troubleshootability</span>
<span class="cm">	 * suggests syslogged diagnostics are best here (ugh).</span>
<span class="cm">	 */</span>

	<span class="n">proxy</span> <span class="o">=</span> <span class="n">spi_alloc_device</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proxy</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">modalias</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">proxy</span><span class="o">-&gt;</span><span class="n">modalias</span><span class="p">));</span>

	<span class="n">proxy</span><span class="o">-&gt;</span><span class="n">chip_select</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_select</span><span class="p">;</span>
	<span class="n">proxy</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span><span class="p">;</span>
	<span class="n">proxy</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
	<span class="n">proxy</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">proxy</span><span class="o">-&gt;</span><span class="n">modalias</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">modalias</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">proxy</span><span class="o">-&gt;</span><span class="n">modalias</span><span class="p">));</span>
	<span class="n">proxy</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="n">proxy</span><span class="o">-&gt;</span><span class="n">controller_data</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">controller_data</span><span class="p">;</span>
	<span class="n">proxy</span><span class="o">-&gt;</span><span class="n">controller_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">spi_add_device</span><span class="p">(</span><span class="n">proxy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spi_dev_put</span><span class="p">(</span><span class="n">proxy</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">proxy</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_new_device</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">spi_match_master_to_boardinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">spi_board_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_num</span> <span class="o">!=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bus_num</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">spi_new_device</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">bi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&quot;can&#39;t create new device for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bi</span><span class="o">-&gt;</span><span class="n">modalias</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spi_register_board_info - register SPI devices for a given board</span>
<span class="cm"> * @info: array of chip descriptors</span>
<span class="cm"> * @n: how many descriptors are provided</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * Board-specific early init code calls this (probably during arch_initcall)</span>
<span class="cm"> * with segments of the SPI device table.  Any device nodes are created later,</span>
<span class="cm"> * after the relevant parent SPI controller (bus_num) is defined.  We keep</span>
<span class="cm"> * this table of devices forever, so that reloading a controller driver will</span>
<span class="cm"> * not make Linux forget about these hard-wired devices.</span>
<span class="cm"> *</span>
<span class="cm"> * Other code can also call this, e.g. a particular add-on board might provide</span>
<span class="cm"> * SPI devices through its expansion connector, so code initializing that board</span>
<span class="cm"> * would naturally declare its SPI devices.</span>
<span class="cm"> *</span>
<span class="cm"> * The board info passed can safely be __initdata ... but be careful of</span>
<span class="cm"> * any embedded pointers (platform_data, etc), they&#39;re copied as-is.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">spi_register_board_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_board_info</span> <span class="k">const</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">boardinfo</span> <span class="o">*</span><span class="n">bi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">bi</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bi</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bi</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">bi</span><span class="o">++</span><span class="p">,</span> <span class="n">info</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">board_info</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">));</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board_lock</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">board_list</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spi_master_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="n">spi_match_master_to_boardinfo</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">board_info</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * spi_pump_messages - kthread work function which processes spi message queue</span>
<span class="cm"> * @work: pointer to kthread work struct contained in the master struct</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks if there is any spi message in the queue that</span>
<span class="cm"> * needs processing and if so call out to the driver to initialize hardware</span>
<span class="cm"> * and transfer each message.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">spi_pump_messages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kthread_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_master</span><span class="p">,</span> <span class="n">pump_messages</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">was_busy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Lock queue and check for queue work */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">&amp;&amp;</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">unprepare_transfer_hardware</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">unprepare_transfer_hardware</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;failed to unprepare transfer hardware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">master</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure we are not already running a message */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Extract head of queue */</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">cur_msg</span> <span class="o">=</span>
	    <span class="n">list_entry</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span>
		<span class="n">was_busy</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">master</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">was_busy</span> <span class="o">&amp;&amp;</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">prepare_transfer_hardware</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">prepare_transfer_hardware</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;failed to prepare transfer hardware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">transfer_one_message</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;failed to transfer one message from queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_init_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_param</span> <span class="n">param</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="n">MAX_RT_PRIO</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">};</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">);</span>

	<span class="n">master</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">init_kthread_worker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">kworker</span><span class="p">);</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">kworker_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">kthread_worker_fn</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">kworker</span><span class="p">,</span>
					   <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">kworker_task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to create message pump task</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">init_kthread_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">pump_messages</span><span class="p">,</span> <span class="n">spi_pump_messages</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Master config will indicate if this controller should run the</span>
<span class="cm">	 * message pump with high (realtime) priority to reduce the transfer</span>
<span class="cm">	 * latency on the bus by minimising the delay between a transfer</span>
<span class="cm">	 * request and the scheduling of the message pump thread. Without this</span>
<span class="cm">	 * setting the message pump thread will remain at default priority.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;will run message pump with realtime priority</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sched_setscheduler</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">kworker_task</span><span class="p">,</span> <span class="n">SCHED_FIFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spi_get_next_queued_message() - called by driver to check for queued</span>
<span class="cm"> * messages</span>
<span class="cm"> * @master: the master to check for queued messages</span>
<span class="cm"> *</span>
<span class="cm"> * If there are more messages in the queue, the next message is returned from</span>
<span class="cm"> * this call.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="nf">spi_get_next_queued_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* get a pointer to the next message, if any */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">spi_message</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_get_next_queued_message</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * spi_finalize_current_message() - the current message is complete</span>
<span class="cm"> * @master: the master to return the message to</span>
<span class="cm"> *</span>
<span class="cm"> * Called by the driver to notify the core that the message in the front of the</span>
<span class="cm"> * queue is complete and can be removed from the queue.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">spi_finalize_current_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">mesg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mesg</span> <span class="o">=</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">cur_msg</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">cur_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">queue_kthread_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">kworker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">pump_messages</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">mesg</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mesg</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">)</span>
		<span class="n">mesg</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">(</span><span class="n">mesg</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_finalize_current_message</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_start_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">||</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">master</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">cur_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">queue_kthread_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">kworker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">pump_messages</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_stop_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a bit lame, but is optimized for the common execution path.</span>
<span class="cm">	 * A wait_queue on the master-&gt;busy could be used, but then the common</span>
<span class="cm">	 * execution path (pump_messages) would be required to call wake_up or</span>
<span class="cm">	 * friends on every SPI message. Do this instead.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="o">||</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">limit</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span> <span class="o">||</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">master</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;could not stop message queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_destroy_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spi_stop_queue</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * flush_kthread_worker will block until all work is done.</span>
<span class="cm">	 * If the reason that stop_queue timed out is that the work will never</span>
<span class="cm">	 * finish, then it does no good to call flush/stop thread, so</span>
<span class="cm">	 * return anyway.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;problem destroying queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">flush_kthread_worker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">kworker</span><span class="p">);</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">kworker_task</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spi_queued_transfer - transfer function for queued transfers</span>
<span class="cm"> * @spi: spi device which is requesting transfer</span>
<span class="cm"> * @msg: spi message which is to handled is queued to driver queue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_queued_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span>
		<span class="n">queue_kthread_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">kworker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">pump_messages</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queue_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">spi_master_initialize_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">master</span><span class="o">-&gt;</span><span class="n">queued</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">transfer</span> <span class="o">=</span> <span class="n">spi_queued_transfer</span><span class="p">;</span>

	<span class="cm">/* Initialize and start queue */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">spi_init_queue</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;problem initializing queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_init_queue</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">spi_start_queue</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;problem starting queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_start_queue</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_start_queue:</span>
<span class="nl">err_init_queue:</span>
	<span class="n">spi_destroy_queue</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#if defined(CONFIG_OF) &amp;&amp; !defined(CONFIG_SPARC)</span>
<span class="cm">/**</span>
<span class="cm"> * of_register_spi_devices() - Register child devices onto the SPI bus</span>
<span class="cm"> * @master:	Pointer to spi_master device</span>
<span class="cm"> *</span>
<span class="cm"> * Registers an spi_device for each child node of master node which has a &#39;reg&#39;</span>
<span class="cm"> * property.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">of_register_spi_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">nc</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_child_of_node</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="n">nc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Alloc an spi_device */</span>
		<span class="n">spi</span> <span class="o">=</span> <span class="n">spi_alloc_device</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spi</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;spi_device alloc error for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">nc</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
			<span class="n">spi_dev_put</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Select device driver */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_modalias_node</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">modalias</span><span class="p">,</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">modalias</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot find modalias for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">nc</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
			<span class="n">spi_dev_put</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Device address */</span>
		<span class="n">prop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">prop</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s has no &#39;reg&#39; property</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">nc</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
			<span class="n">spi_dev_put</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spi</span><span class="o">-&gt;</span><span class="n">chip_select</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">prop</span><span class="p">);</span>

		<span class="cm">/* Mode (clock phase/polarity/etc.) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_find_property</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="s">&quot;spi-cpha&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">SPI_CPHA</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_find_property</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="s">&quot;spi-cpol&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">SPI_CPOL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_find_property</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="s">&quot;spi-cs-high&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">|=</span> <span class="n">SPI_CS_HIGH</span><span class="p">;</span>

		<span class="cm">/* Device speed */</span>
		<span class="n">prop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="s">&quot;spi-max-frequency&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">prop</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s has no &#39;spi-max-frequency&#39; property</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">nc</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
			<span class="n">spi_dev_put</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">prop</span><span class="p">);</span>

		<span class="cm">/* IRQ */</span>
		<span class="n">spi</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Store a pointer to the node in the device structure */</span>
		<span class="n">of_node_get</span><span class="p">(</span><span class="n">nc</span><span class="p">);</span>
		<span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span> <span class="o">=</span> <span class="n">nc</span><span class="p">;</span>

		<span class="cm">/* Register the new device */</span>
		<span class="n">request_module</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">modalias</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">spi_add_device</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;spi_device register error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">nc</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
			<span class="n">spi_dev_put</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">of_register_spi_devices</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">spi_master_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">;</span>

	<span class="n">master</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_master</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="n">spi_master_class</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;spi_master&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_release</span>	<span class="o">=</span> <span class="n">spi_master_release</span><span class="p">,</span>
<span class="p">};</span>



<span class="cm">/**</span>
<span class="cm"> * spi_alloc_master - allocate SPI master controller</span>
<span class="cm"> * @dev: the controller, possibly using the platform_bus</span>
<span class="cm"> * @size: how much zeroed driver-private data to allocate; the pointer to this</span>
<span class="cm"> *	memory is in the driver_data field of the returned device,</span>
<span class="cm"> *	accessible with spi_master_get_devdata().</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This call is used only by SPI master controller drivers, which are the</span>
<span class="cm"> * only ones directly touching chip registers.  It&#39;s how they allocate</span>
<span class="cm"> * an spi_master structure, prior to calling spi_register_master().</span>
<span class="cm"> *</span>
<span class="cm"> * This must be called from context that can sleep.  It returns the SPI</span>
<span class="cm"> * master structure on success, else NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller is responsible for assigning the bus number and initializing</span>
<span class="cm"> * the master&#39;s methods before calling spi_register_master(); and (after errors</span>
<span class="cm"> * adding the device) calling spi_master_put() and kfree() to prevent a memory</span>
<span class="cm"> * leak.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="nf">spi_alloc_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_master</span>	<span class="o">*</span><span class="n">master</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">master</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">master</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">device_initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_num</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">num_chipselect</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spi_master_class</span><span class="p">;</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">get_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spi_master_set_devdata</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">master</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">master</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_alloc_master</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * spi_register_master - register SPI master controller</span>
<span class="cm"> * @master: initialized master, originally from spi_alloc_master()</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * SPI master controllers connect to their drivers using some non-SPI bus,</span>
<span class="cm"> * such as the platform bus.  The final stage of probe() in that code</span>
<span class="cm"> * includes calling spi_register_master() to hook up to this SPI bus glue.</span>
<span class="cm"> *</span>
<span class="cm"> * SPI controllers use board specific (often SOC specific) bus numbers,</span>
<span class="cm"> * and board-specific addressing for SPI devices combines those numbers</span>
<span class="cm"> * with chip select numbers.  Since SPI does not directly support dynamic</span>
<span class="cm"> * device identification, boards need configuration tables telling which</span>
<span class="cm"> * chip is at which address.</span>
<span class="cm"> *</span>
<span class="cm"> * This must be called from context that can sleep.  It returns zero on</span>
<span class="cm"> * success, else a negative error code (dropping the master&#39;s refcount).</span>
<span class="cm"> * After a successful return, the caller is responsible for calling</span>
<span class="cm"> * spi_unregister_master().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spi_register_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">atomic_t</span>		<span class="n">dyn_bus_id</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">15</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">boardinfo</span>	<span class="o">*</span><span class="n">bi</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">dynamic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* even if it&#39;s just one always-selected device, there must</span>
<span class="cm">	 * be at least one chipselect</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">num_chipselect</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* convention:  dynamically assigned bus IDs count down from the max */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIXME switch to an IDR based scheme, something like</span>
<span class="cm">		 * I2C now uses, so we can&#39;t run out of &quot;dynamic&quot; IDs</span>
<span class="cm">		 */</span>
		<span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_num</span> <span class="o">=</span> <span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dyn_bus_id</span><span class="p">);</span>
		<span class="n">dynamic</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_lock_spinlock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_lock_mutex</span><span class="p">);</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_lock_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* register the device, then userspace will see it.</span>
<span class="cm">	 * registration fails if the bus ID is in use.</span>
<span class="cm">	 */</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;spi%u&quot;</span><span class="p">,</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_num</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">device_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;registered master %s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span>
			<span class="n">dynamic</span> <span class="o">?</span> <span class="s">&quot; (dynamic)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="cm">/* If we&#39;re using a queued driver, start the queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">transfer</span><span class="p">)</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;master is unqueued, this is deprecated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">spi_master_initialize_queue</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spi_master_list</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">board_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">spi_match_master_to_boardinfo</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">board_info</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board_lock</span><span class="p">);</span>

	<span class="cm">/* Register devices from the device tree */</span>
	<span class="n">of_register_spi_devices</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_register_master</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">null</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spi_unregister_device</span><span class="p">(</span><span class="n">to_spi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spi_unregister_master - unregister SPI master controller</span>
<span class="cm"> * @master: the master being unregistered</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This call is used only by SPI master controller drivers, which are the</span>
<span class="cm"> * only ones directly touching chip registers.</span>
<span class="cm"> *</span>
<span class="cm"> * This must be called from context that can sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">spi_unregister_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dummy</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spi_destroy_queue</span><span class="p">(</span><span class="n">master</span><span class="p">))</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;queue remove failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board_lock</span><span class="p">);</span>

	<span class="n">dummy</span> <span class="o">=</span> <span class="n">device_for_each_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">__unregister</span><span class="p">);</span>
	<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_unregister_master</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">spi_master_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Basically no-ops for non-queued masters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spi_stop_queue</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;queue stop failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_master_suspend</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">spi_master_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">queued</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spi_start_queue</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;queue restart failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_master_resume</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__spi_master_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">bus_num</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">m</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_master</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">bus_num</span> <span class="o">==</span> <span class="o">*</span><span class="n">bus_num</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spi_busnum_to_master - look up master associated with bus_num</span>
<span class="cm"> * @bus_num: the master&#39;s bus number</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This call may be used with devices that are registered after</span>
<span class="cm"> * arch init time.  It returns a refcounted pointer to the relevant</span>
<span class="cm"> * spi_master (which the caller must release), or NULL if there is</span>
<span class="cm"> * no such master registered.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="nf">spi_busnum_to_master</span><span class="p">(</span><span class="n">u16</span> <span class="n">bus_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_master</span>	<span class="o">*</span><span class="n">master</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">class_find_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi_master_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_num</span><span class="p">,</span>
				<span class="n">__spi_master_match</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">master</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_master</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* reference got in class_find_device */</span>
	<span class="k">return</span> <span class="n">master</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_busnum_to_master</span><span class="p">);</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Core methods for SPI master protocol drivers.  Some of the</span>
<span class="cm"> * other core methods are currently defined as inline functions.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * spi_setup - setup SPI mode and clock rate</span>
<span class="cm"> * @spi: the device whose settings are being modified</span>
<span class="cm"> * Context: can sleep, and no requests are queued to the device</span>
<span class="cm"> *</span>
<span class="cm"> * SPI protocol drivers may need to update the transfer mode if the</span>
<span class="cm"> * device doesn&#39;t work with its default.  They may likewise need</span>
<span class="cm"> * to update clock rates or word sizes from initial values.  This function</span>
<span class="cm"> * changes those settings, and must be called from a context that can sleep.</span>
<span class="cm"> * Except for SPI_CS_HIGH, which takes effect immediately, the changes take</span>
<span class="cm"> * effect the next time the device is selected and data is transferred to</span>
<span class="cm"> * or from it.  When this function returns, the spi device is deselected.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this call will fail if the protocol driver specifies an option</span>
<span class="cm"> * that the underlying controller or its driver does not support.  For</span>
<span class="cm"> * example, not all hardware supports wire transfers using nine bit words,</span>
<span class="cm"> * LSB-first wire encoding, or active-high chipselects.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spi_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">bad_bits</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">status</span><span class="p">;</span>

	<span class="cm">/* help drivers fail *cleanly* when they need options</span>
<span class="cm">	 * that aren&#39;t supported with their current master</span>
<span class="cm">	 */</span>
	<span class="n">bad_bits</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">mode_bits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bad_bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;setup: unsupported mode bits %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bad_bits</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">)</span>
		<span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;setup mode %d, %s%s%s%s&quot;</span>
				<span class="s">&quot;%u bits/w, %u Hz max --&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SPI_CPOL</span> <span class="o">|</span> <span class="n">SPI_CPHA</span><span class="p">)),</span>
			<span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SPI_CS_HIGH</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;cs_high, &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SPI_LSB_FIRST</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;lsb, &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SPI_3WIRE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;3wire, &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SPI_LOOP</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;loopback, &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span><span class="p">,</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">max_speed_hz</span><span class="p">,</span>
			<span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__spi_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">;</span>

	<span class="cm">/* Half-duplex links include original MicroWire, and ones with</span>
<span class="cm">	 * only one data pin like SPI_3WIRE (switches direction) or where</span>
<span class="cm">	 * either MOSI or MISO is missing.  They can also be caused by</span>
<span class="cm">	 * software limitations.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPI_MASTER_HALF_DUPLEX</span><span class="p">)</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SPI_3WIRE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">xfer</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">xfer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">transfers</span><span class="p">,</span> <span class="n">transfer_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_buf</span> <span class="o">&amp;&amp;</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPI_MASTER_NO_TX</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SPI_MASTER_NO_RX</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">xfer</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">message</span><span class="o">-&gt;</span><span class="n">spi</span> <span class="o">=</span> <span class="n">spi</span><span class="p">;</span>
	<span class="n">message</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">transfer</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spi_async - asynchronous SPI transfer</span>
<span class="cm"> * @spi: device with which data will be exchanged</span>
<span class="cm"> * @message: describes the data transfers, including completion callback</span>
<span class="cm"> * Context: any (irqs may be blocked, etc)</span>
<span class="cm"> *</span>
<span class="cm"> * This call may be used in_irq and other contexts which can&#39;t sleep,</span>
<span class="cm"> * as well as from task contexts which can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * The completion callback is invoked in a context which can&#39;t sleep.</span>
<span class="cm"> * Before that invocation, the value of message-&gt;status is undefined.</span>
<span class="cm"> * When the callback is issued, message-&gt;status holds either zero (to</span>
<span class="cm"> * indicate complete success) or a negative error code.  After that</span>
<span class="cm"> * callback returns, the driver which issued the transfer request may</span>
<span class="cm"> * deallocate the associated memory; it&#39;s no longer in use by any SPI</span>
<span class="cm"> * core or controller driver code.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that although all messages to a spi_device are handled in</span>
<span class="cm"> * FIFO order, messages may go to different devices in other orders.</span>
<span class="cm"> * Some device might be higher priority, or have various &quot;hard&quot; access</span>
<span class="cm"> * time requirements, for example.</span>
<span class="cm"> *</span>
<span class="cm"> * On detection of any fault during the transfer, processing of</span>
<span class="cm"> * the entire message is aborted, and the device is deselected.</span>
<span class="cm"> * Until returning from the associated message completion callback,</span>
<span class="cm"> * no other spi_message queued to that device will be processed.</span>
<span class="cm"> * (This rule applies equally to all the synchronous transfer calls,</span>
<span class="cm"> * which are wrappers around this core asynchronous primitive.)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spi_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_lock_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_lock_flag</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__spi_async</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_lock_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_async</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * spi_async_locked - version of spi_async with exclusive bus usage</span>
<span class="cm"> * @spi: device with which data will be exchanged</span>
<span class="cm"> * @message: describes the data transfers, including completion callback</span>
<span class="cm"> * Context: any (irqs may be blocked, etc)</span>
<span class="cm"> *</span>
<span class="cm"> * This call may be used in_irq and other contexts which can&#39;t sleep,</span>
<span class="cm"> * as well as from task contexts which can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * The completion callback is invoked in a context which can&#39;t sleep.</span>
<span class="cm"> * Before that invocation, the value of message-&gt;status is undefined.</span>
<span class="cm"> * When the callback is issued, message-&gt;status holds either zero (to</span>
<span class="cm"> * indicate complete success) or a negative error code.  After that</span>
<span class="cm"> * callback returns, the driver which issued the transfer request may</span>
<span class="cm"> * deallocate the associated memory; it&#39;s no longer in use by any SPI</span>
<span class="cm"> * core or controller driver code.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that although all messages to a spi_device are handled in</span>
<span class="cm"> * FIFO order, messages may go to different devices in other orders.</span>
<span class="cm"> * Some device might be higher priority, or have various &quot;hard&quot; access</span>
<span class="cm"> * time requirements, for example.</span>
<span class="cm"> *</span>
<span class="cm"> * On detection of any fault during the transfer, processing of</span>
<span class="cm"> * the entire message is aborted, and the device is deselected.</span>
<span class="cm"> * Until returning from the associated message completion callback,</span>
<span class="cm"> * no other spi_message queued to that device will be processed.</span>
<span class="cm"> * (This rule applies equally to all the synchronous transfer calls,</span>
<span class="cm"> * which are wrappers around this core asynchronous primitive.)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spi_async_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_lock_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__spi_async</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_lock_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_async_locked</span><span class="p">);</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* Utility methods for SPI master protocol drivers, layered on</span>
<span class="cm"> * top of the core.  Some other utility methods are defined as</span>
<span class="cm"> * inline functions.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">spi_complete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">complete</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__spi_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">bus_locked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">;</span>

	<span class="n">message</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">spi_complete</span><span class="p">;</span>
	<span class="n">message</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus_locked</span><span class="p">)</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_lock_mutex</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">spi_async_locked</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bus_locked</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_lock_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">message</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">message</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spi_sync - blocking/synchronous SPI data transfers</span>
<span class="cm"> * @spi: device with which data will be exchanged</span>
<span class="cm"> * @message: describes the data transfers</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This call may only be used from a context that may sleep.  The sleep</span>
<span class="cm"> * is non-interruptible, and has no timeout.  Low-overhead controller</span>
<span class="cm"> * drivers may DMA directly into and out of the message buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the SPI device&#39;s chip select is active during the message,</span>
<span class="cm"> * and then is normally disabled between messages.  Drivers for some</span>
<span class="cm"> * frequently-used devices may want to minimize costs of selecting a chip,</span>
<span class="cm"> * by leaving it selected in anticipation that the next message will go</span>
<span class="cm"> * to the same chip.  (That may increase power usage.)</span>
<span class="cm"> *</span>
<span class="cm"> * Also, the caller is guaranteeing that the memory associated with the</span>
<span class="cm"> * message will not be freed before this call returns.</span>
<span class="cm"> *</span>
<span class="cm"> * It returns zero on success, else a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spi_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__spi_sync</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_sync</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * spi_sync_locked - version of spi_sync with exclusive bus usage</span>
<span class="cm"> * @spi: device with which data will be exchanged</span>
<span class="cm"> * @message: describes the data transfers</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This call may only be used from a context that may sleep.  The sleep</span>
<span class="cm"> * is non-interruptible, and has no timeout.  Low-overhead controller</span>
<span class="cm"> * drivers may DMA directly into and out of the message buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * This call should be used by drivers that require exclusive access to the</span>
<span class="cm"> * SPI bus. It has to be preceded by a spi_bus_lock call. The SPI bus must</span>
<span class="cm"> * be released by a spi_bus_unlock call when the exclusive access is over.</span>
<span class="cm"> *</span>
<span class="cm"> * It returns zero on success, else a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spi_sync_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__spi_sync</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_sync_locked</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * spi_bus_lock - obtain a lock for exclusive SPI bus usage</span>
<span class="cm"> * @master: SPI bus master that should be locked for exclusive bus access</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This call may only be used from a context that may sleep.  The sleep</span>
<span class="cm"> * is non-interruptible, and has no timeout.</span>
<span class="cm"> *</span>
<span class="cm"> * This call should be used by drivers that require exclusive access to the</span>
<span class="cm"> * SPI bus. The SPI bus must be released by a spi_bus_unlock call when the</span>
<span class="cm"> * exclusive access is over. Data transfer must be done by spi_sync_locked</span>
<span class="cm"> * and spi_async_locked calls when the SPI bus lock is held.</span>
<span class="cm"> *</span>
<span class="cm"> * It returns zero on success, else a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spi_bus_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_lock_mutex</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_lock_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_lock_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_lock_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* mutex remains locked until spi_bus_unlock is called */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_bus_lock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * spi_bus_unlock - release the lock for exclusive SPI bus usage</span>
<span class="cm"> * @master: SPI bus master that was locked for exclusive bus access</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This call may only be used from a context that may sleep.  The sleep</span>
<span class="cm"> * is non-interruptible, and has no timeout.</span>
<span class="cm"> *</span>
<span class="cm"> * This call releases an SPI bus lock previously obtained by an spi_bus_lock</span>
<span class="cm"> * call.</span>
<span class="cm"> *</span>
<span class="cm"> * It returns zero on success, else a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spi_bus_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_lock_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">bus_lock_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_bus_unlock</span><span class="p">);</span>

<span class="cm">/* portable code must never pass more than 32 bytes */</span>
<span class="cp">#define	SPI_BUFSIZ	max(32,SMP_CACHE_BYTES)</span>

<span class="k">static</span> <span class="n">u8</span>	<span class="o">*</span><span class="n">buf</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * spi_write_then_read - SPI synchronous write followed by read</span>
<span class="cm"> * @spi: device with which data will be exchanged</span>
<span class="cm"> * @txbuf: data to be written (need not be dma-safe)</span>
<span class="cm"> * @n_tx: size of txbuf, in bytes</span>
<span class="cm"> * @rxbuf: buffer into which data will be read (need not be dma-safe)</span>
<span class="cm"> * @n_rx: size of rxbuf, in bytes</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This performs a half duplex MicroWire style transaction with the</span>
<span class="cm"> * device, sending txbuf and then reading rxbuf.  The return value</span>
<span class="cm"> * is zero for success, else a negative errno status code.</span>
<span class="cm"> * This call may only be used from a context that may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * Parameters to this routine are always copied using a small buffer;</span>
<span class="cm"> * portable code should never use this for more than 32 bytes.</span>
<span class="cm"> * Performance-sensitive or bulk transfer code should instead use</span>
<span class="cm"> * spi_{async,sync}() calls with dma-safe buffers.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spi_write_then_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">txbuf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n_tx</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">rxbuf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n_rx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_message</span>	<span class="n">message</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span>	<span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u8</span>			<span class="o">*</span><span class="n">local_buf</span><span class="p">;</span>

	<span class="cm">/* Use preallocated DMA-safe buffer.  We can&#39;t avoid copying here,</span>
<span class="cm">	 * (as a pure convenience thing), but we can keep heap costs</span>
<span class="cm">	 * out of the hot path ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">n_tx</span> <span class="o">+</span> <span class="n">n_rx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">SPI_BUFSIZ</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spi_message_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">x</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_tx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">n_tx</span><span class="p">;</span>
		<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_rx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">n_rx</span><span class="p">;</span>
		<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* ... unless someone else is using the pre-allocated buffer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">SPI_BUFSIZ</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">local_buf</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">local_buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">local_buf</span><span class="p">,</span> <span class="n">txbuf</span><span class="p">,</span> <span class="n">n_tx</span><span class="p">);</span>
	<span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="n">local_buf</span><span class="p">;</span>
	<span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">rx_buf</span> <span class="o">=</span> <span class="n">local_buf</span> <span class="o">+</span> <span class="n">n_tx</span><span class="p">;</span>

	<span class="cm">/* do the i/o */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">spi_sync</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">rxbuf</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">rx_buf</span><span class="p">,</span> <span class="n">n_rx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tx_buf</span> <span class="o">==</span> <span class="n">buf</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">local_buf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">spi_write_then_read</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">spi_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">status</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">SPI_BUFSIZ</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">bus_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi_bus_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err1</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi_master_class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err2</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err2:</span>
	<span class="n">bus_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi_bus_type</span><span class="p">);</span>
<span class="nl">err1:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">err0:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* board_info is normally registered in arch_initcall(),</span>
<span class="cm"> * but even essential drivers wait till later</span>
<span class="cm"> *</span>
<span class="cm"> * REVISIT only boardinfo really needs static linking. the rest (device and</span>
<span class="cm"> * driver registration) _could_ be dynamically linked (modular) ... costs</span>
<span class="cm"> * include needing to have boardinfo data structures be much more public.</span>
<span class="cm"> */</span>
<span class="n">postcore_initcall</span><span class="p">(</span><span class="n">spi_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
