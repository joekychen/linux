<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › rtc › rtc-cmos.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>rtc-cmos.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * RTC class driver for &quot;CMOS RTC&quot;:  PCs, ACPI, etc</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1996 Paul Gortmaker (drivers/char/rtc.c)</span>
<span class="cm"> * Copyright (C) 2006 David Brownell (convert to new framework)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The original &quot;cmos clock&quot; chip was an MC146818 chip, now obsolete.</span>
<span class="cm"> * That defined the register interface now provided by all PCs, some</span>
<span class="cm"> * non-PC systems, and incorporated into ACPI.  Modern PC chipsets</span>
<span class="cm"> * integrate an MC146818 clone in their southbridge, and boards use</span>
<span class="cm"> * that instead of discrete clones like the DS12887 or M48T86.  There</span>
<span class="cm"> * are also clones that connect using the LPC bus.</span>
<span class="cm"> *</span>
<span class="cm"> * That register API is also used directly by various other drivers</span>
<span class="cm"> * (notably for integrated NVRAM), infrastructure (x86 has code to</span>
<span class="cm"> * bypass the RTC framework, directly reading the RTC during boot</span>
<span class="cm"> * and updating minutes/seconds for systems using NTP synch) and</span>
<span class="cm"> * utilities (like userspace &#39;hwclock&#39;, if no /dev node exists).</span>
<span class="cm"> *</span>
<span class="cm"> * So **ALL** calls to CMOS_READ and CMOS_WRITE must be done with</span>
<span class="cm"> * interrupts disabled, holding the global rtc_lock, to exclude those</span>
<span class="cm"> * other drivers and utilities on correctly configured systems.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/mod_devicetable.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/of_platform.h&gt;</span>

<span class="cm">/* this is for &quot;generic access to PC-style RTC&quot; using CMOS_READ/CMOS_WRITE */</span>
<span class="cp">#include &lt;asm-generic/rtc.h&gt;</span>

<span class="k">struct</span> <span class="n">cmos_rtc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rtc_device</span>	<span class="o">*</span><span class="n">rtc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span>		<span class="o">*</span><span class="n">iomem</span><span class="p">;</span>

	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">wake_on</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">wake_off</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>

	<span class="n">u8</span>			<span class="n">enabled_wake</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">suspend_ctrl</span><span class="p">;</span>

	<span class="cm">/* newer hardware extends the original register set */</span>
	<span class="n">u8</span>			<span class="n">day_alrm</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">mon_alrm</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">century</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* both platform and pnp busses use negative numbers for invalid irqs */</span>
<span class="cp">#define is_valid_irq(n)		((n) &gt; 0)</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">driver_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;rtc_cmos&quot;</span><span class="p">;</span>

<span class="cm">/* The RTC_INTR register may have e.g. RTC_PF set even if RTC_PIE is clear;</span>
<span class="cm"> * always mask it against the irq enable bits in RTC_CONTROL.  Bit values</span>
<span class="cm"> * are the same: PF==PIE, AF=AIE, UF=UIE; so RTC_IRQMASK works with both.</span>
<span class="cm"> */</span>
<span class="cp">#define	RTC_IRQMASK	(RTC_PF | RTC_AF | RTC_UF)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_intr</span><span class="p">(</span><span class="n">u8</span> <span class="n">rtc_intr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rtc_intr</span> <span class="o">&amp;</span> <span class="n">RTC_IRQF</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rtc_intr</span> <span class="o">&amp;</span> <span class="n">RTC_IRQMASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="cm">/* Much modern x86 hardware has HPETs (10+ MHz timers) which, because</span>
<span class="cm"> * many BIOS programmers don&#39;t set up &quot;sane mode&quot; IRQ routing, are mostly</span>
<span class="cm"> * used in a broken &quot;legacy replacement&quot; mode.  The breakage includes</span>
<span class="cm"> * HPET #1 hijacking the IRQ for this RTC, and being unavailable for</span>
<span class="cm"> * other (better) use.</span>
<span class="cm"> *</span>
<span class="cm"> * When that broken mode is in use, platform glue provides a partial</span>
<span class="cm"> * emulation of hardware RTC IRQ facilities using HPET #1.  We don&#39;t</span>
<span class="cm"> * want to use HPET for anything except those IRQs though...</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_HPET_EMULATE_RTC</span>
<span class="cp">#include &lt;asm/hpet.h&gt;</span>
<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_hpet_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hpet_mask_rtc_irq_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hpet_set_rtc_irq_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">hpet_set_alarm_time</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">hrs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">min</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hpet_set_periodic_freq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hpet_rtc_dropped_irq</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hpet_rtc_timer_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="n">irq_handler_t</span> <span class="n">hpet_rtc_interrupt</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hpet_register_irq_handler</span><span class="p">(</span><span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hpet_unregister_irq_handler</span><span class="p">(</span><span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="cp">#ifdef RTC_PORT</span>

<span class="cm">/* Most newer x86 systems have two register banks, the first used</span>
<span class="cm"> * for RTC and NVRAM and the second only for NVRAM.  Caller must</span>
<span class="cm"> * own rtc_lock ... and we won&#39;t worry about access during NMI.</span>
<span class="cm"> */</span>
<span class="cp">#define can_bank2	true</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">cmos_read_bank2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">RTC_PORT</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">inb</span><span class="p">(</span><span class="n">RTC_PORT</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cmos_write_bank2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">RTC_PORT</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">RTC_PORT</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cp">#define can_bank2	false</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">cmos_read_bank2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cmos_write_bank2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmos_read_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rtc_time</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* REVISIT:  if the clock has a &quot;century&quot; register, use</span>
<span class="cm">	 * that instead of the heuristic in get_rtc_time().</span>
<span class="cm">	 * That&#39;ll make Y3K compatility (year &gt; 2070) easy!</span>
<span class="cm">	 */</span>
	<span class="n">get_rtc_time</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmos_set_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rtc_time</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* REVISIT:  set the &quot;century&quot; register if available</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: this ignores the issue whereby updating the seconds</span>
<span class="cm">	 * takes effect exactly 500ms after we write the register.</span>
<span class="cm">	 * (Also queueing and other delays before we get this far.)</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">set_rtc_time</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmos_read_alarm</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rtc_wkalrm</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cmos_rtc</span>	<span class="o">*</span><span class="n">cmos</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">rtc_control</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_irq</span><span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* Basic alarms only support hour, minute, and seconds fields.</span>
<span class="cm">	 * Some also support day and month, for alarms up to a year in</span>
<span class="cm">	 * the future.</span>
<span class="cm">	 */</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mday</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_sec</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_SECONDS_ALARM</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_min</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_MINUTES_ALARM</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_hour</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_HOURS_ALARM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">day_alrm</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ignore upper bits on readback per ACPI spec */</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mday</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">day_alrm</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mday</span><span class="p">)</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mday</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">mon_alrm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">mon_alrm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mon</span><span class="p">)</span>
				<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rtc_control</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rtc_control</span> <span class="o">&amp;</span> <span class="n">RTC_DM_BINARY</span><span class="p">)</span> <span class="o">||</span> <span class="n">RTC_ALWAYS_BCD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_sec</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mh">0x60</span><span class="p">)</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_sec</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_sec</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_sec</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_min</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mh">0x60</span><span class="p">)</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_min</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_min</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_hour</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mh">0x24</span><span class="p">)</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_hour</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_hour</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_hour</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">day_alrm</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mday</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mh">0x31</span><span class="p">)</span>
				<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mday</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mday</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mday</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">mon_alrm</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mon</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mh">0x12</span><span class="p">)</span>
					<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="n">bcd2bin</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mon</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_year</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">t</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">rtc_control</span> <span class="o">&amp;</span> <span class="n">RTC_AIE</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cmos_checkintr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmos_rtc</span> <span class="o">*</span><span class="n">cmos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">rtc_control</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">rtc_intr</span><span class="p">;</span>

	<span class="cm">/* NOTE after changing RTC_xIE bits we always read INTR_FLAGS;</span>
<span class="cm">	 * allegedly some older rtcs need that to handle irqs properly</span>
<span class="cm">	 */</span>
	<span class="n">rtc_intr</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_INTR_FLAGS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_hpet_enabled</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rtc_intr</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">rtc_control</span> <span class="o">&amp;</span> <span class="n">RTC_IRQMASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">RTC_IRQF</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_intr</span><span class="p">(</span><span class="n">rtc_intr</span><span class="p">))</span>
		<span class="n">rtc_update_irq</span><span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">rtc</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rtc_intr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cmos_irq_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmos_rtc</span> <span class="o">*</span><span class="n">cmos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">rtc_control</span><span class="p">;</span>

	<span class="cm">/* flush any pending IRQ status, notably for update irqs,</span>
<span class="cm">	 * before we enable new IRQs</span>
<span class="cm">	 */</span>
	<span class="n">rtc_control</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">cmos_checkintr</span><span class="p">(</span><span class="n">cmos</span><span class="p">,</span> <span class="n">rtc_control</span><span class="p">);</span>

	<span class="n">rtc_control</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">rtc_control</span><span class="p">,</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">hpet_set_rtc_irq_bit</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

	<span class="n">cmos_checkintr</span><span class="p">(</span><span class="n">cmos</span><span class="p">,</span> <span class="n">rtc_control</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cmos_irq_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmos_rtc</span> <span class="o">*</span><span class="n">cmos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">rtc_control</span><span class="p">;</span>

	<span class="n">rtc_control</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">rtc_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">rtc_control</span><span class="p">,</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">hpet_mask_rtc_irq_bit</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

	<span class="n">cmos_checkintr</span><span class="p">(</span><span class="n">cmos</span><span class="p">,</span> <span class="n">rtc_control</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmos_set_alarm</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rtc_wkalrm</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cmos_rtc</span>	<span class="o">*</span><span class="n">cmos</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
       <span class="kt">unsigned</span> <span class="kt">char</span>   <span class="n">mon</span><span class="p">,</span> <span class="n">mday</span><span class="p">,</span> <span class="n">hrs</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">sec</span><span class="p">,</span> <span class="n">rtc_control</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_irq</span><span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">mon</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mon</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mday</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_mday</span><span class="p">;</span>
	<span class="n">hrs</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_hour</span><span class="p">;</span>
	<span class="n">min</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_min</span><span class="p">;</span>
	<span class="n">sec</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_sec</span><span class="p">;</span>

	<span class="n">rtc_control</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rtc_control</span> <span class="o">&amp;</span> <span class="n">RTC_DM_BINARY</span><span class="p">)</span> <span class="o">||</span> <span class="n">RTC_ALWAYS_BCD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Writing 0xff means &quot;don&#39;t care&quot; or &quot;match all&quot;.  */</span>
		<span class="n">mon</span> <span class="o">=</span> <span class="p">(</span><span class="n">mon</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">)</span> <span class="o">?</span> <span class="n">bin2bcd</span><span class="p">(</span><span class="n">mon</span><span class="p">)</span> <span class="o">:</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">mday</span> <span class="o">=</span> <span class="p">(</span><span class="n">mday</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">mday</span> <span class="o">&lt;=</span> <span class="mi">31</span><span class="p">)</span> <span class="o">?</span> <span class="n">bin2bcd</span><span class="p">(</span><span class="n">mday</span><span class="p">)</span> <span class="o">:</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">hrs</span> <span class="o">=</span> <span class="p">(</span><span class="n">hrs</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">?</span> <span class="n">bin2bcd</span><span class="p">(</span><span class="n">hrs</span><span class="p">)</span> <span class="o">:</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">min</span> <span class="o">=</span> <span class="p">(</span><span class="n">min</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span> <span class="o">?</span> <span class="n">bin2bcd</span><span class="p">(</span><span class="n">min</span><span class="p">)</span> <span class="o">:</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">sec</span> <span class="o">=</span> <span class="p">(</span><span class="n">sec</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span> <span class="o">?</span> <span class="n">bin2bcd</span><span class="p">(</span><span class="n">sec</span><span class="p">)</span> <span class="o">:</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="cm">/* next rtc irq must not be from previous alarm setting */</span>
	<span class="n">cmos_irq_disable</span><span class="p">(</span><span class="n">cmos</span><span class="p">,</span> <span class="n">RTC_AIE</span><span class="p">);</span>

	<span class="cm">/* update alarm */</span>
	<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">hrs</span><span class="p">,</span> <span class="n">RTC_HOURS_ALARM</span><span class="p">);</span>
	<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">RTC_MINUTES_ALARM</span><span class="p">);</span>
	<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="n">RTC_SECONDS_ALARM</span><span class="p">);</span>

	<span class="cm">/* the system may support an &quot;enhanced&quot; alarm */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">day_alrm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">mday</span><span class="p">,</span> <span class="n">cmos</span><span class="o">-&gt;</span><span class="n">day_alrm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">mon_alrm</span><span class="p">)</span>
			<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">mon</span><span class="p">,</span> <span class="n">cmos</span><span class="o">-&gt;</span><span class="n">mon_alrm</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* FIXME the HPET alarm glue currently ignores day_alrm</span>
<span class="cm">	 * and mon_alrm ...</span>
<span class="cm">	 */</span>
	<span class="n">hpet_set_alarm_time</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_hour</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_min</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">.</span><span class="n">tm_sec</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">enabled</span><span class="p">)</span>
		<span class="n">cmos_irq_enable</span><span class="p">(</span><span class="n">cmos</span><span class="p">,</span> <span class="n">RTC_AIE</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmos_alarm_irq_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">enabled</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cmos_rtc</span>	<span class="o">*</span><span class="n">cmos</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_irq</span><span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enabled</span><span class="p">)</span>
		<span class="n">cmos_irq_enable</span><span class="p">(</span><span class="n">cmos</span><span class="p">,</span> <span class="n">RTC_AIE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cmos_irq_disable</span><span class="p">(</span><span class="n">cmos</span><span class="p">,</span> <span class="n">RTC_AIE</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_RTC_INTF_PROC) || defined(CONFIG_RTC_INTF_PROC_MODULE)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmos_procfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cmos_rtc</span>	<span class="o">*</span><span class="n">cmos</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">rtc_control</span><span class="p">,</span> <span class="n">valid</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="n">rtc_control</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="n">valid</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_VALID</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="cm">/* NOTE:  at least ICH6 reports battery status using a different</span>
<span class="cm">	 * (non-RTC) bit; and SQWE is ignored on many current systems.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span>
			<span class="s">&quot;periodic_IRQ</span><span class="se">\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;update_IRQ</span><span class="se">\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;HPET_emulated</span><span class="se">\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>"square_wave\t: %s\n"</p></td><td class="code"><div class="highlight"><pre>			<span class="s">&quot;BCD</span><span class="se">\t\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;DST_enable</span><span class="se">\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;periodic_freq</span><span class="se">\t</span><span class="s">: %d</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;batt_status</span><span class="se">\t</span><span class="s">: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">rtc_control</span> <span class="o">&amp;</span> <span class="n">RTC_PIE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">rtc_control</span> <span class="o">&amp;</span> <span class="n">RTC_UIE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">,</span>
			<span class="n">is_hpet_enabled</span><span class="p">()</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">,</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>(rtc<em>control &amp; RTC</em>SQWE) ? "yes" : "no",</p></td><td class="code"><div class="highlight"><pre>			<span class="p">(</span><span class="n">rtc_control</span> <span class="o">&amp;</span> <span class="n">RTC_DM_BINARY</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;no&quot;</span> <span class="o">:</span> <span class="s">&quot;yes&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">rtc_control</span> <span class="o">&amp;</span> <span class="n">RTC_DST_EN</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">,</span>
			<span class="n">cmos</span><span class="o">-&gt;</span><span class="n">rtc</span><span class="o">-&gt;</span><span class="n">irq_freq</span><span class="p">,</span>
			<span class="p">(</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">RTC_VRT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;okay&quot;</span> <span class="o">:</span> <span class="s">&quot;dead&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="cp">#define	cmos_procfs	NULL</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rtc_class_ops</span> <span class="n">cmos_rtc_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read_time</span>		<span class="o">=</span> <span class="n">cmos_read_time</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_time</span>		<span class="o">=</span> <span class="n">cmos_set_time</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_alarm</span>		<span class="o">=</span> <span class="n">cmos_read_alarm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_alarm</span>		<span class="o">=</span> <span class="n">cmos_set_alarm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc</span>			<span class="o">=</span> <span class="n">cmos_procfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alarm_irq_enable</span>	<span class="o">=</span> <span class="n">cmos_alarm_irq_enable</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * All these chips have at least 64 bytes of address space, shared by</span>
<span class="cm"> * RTC registers and NVRAM.  Most of those bytes of NVRAM are used</span>
<span class="cm"> * by boot firmware.  Modern chips have 128 or 256 bytes.</span>
<span class="cm"> */</span>

<span class="cp">#define NVRAM_OFFSET	(RTC_REG_D + 1)</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">cmos_nvram_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">off</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">off</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">off</span><span class="p">;</span>

	<span class="n">off</span> <span class="o">+=</span> <span class="n">NVRAM_OFFSET</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span><span class="p">;</span> <span class="n">count</span><span class="o">--</span><span class="p">,</span> <span class="n">off</span><span class="o">++</span><span class="p">,</span> <span class="n">retval</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">)</span>
			<span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">off</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">can_bank2</span><span class="p">)</span>
			<span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="n">cmos_read_bank2</span><span class="p">(</span><span class="n">off</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">cmos_nvram_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cmos_rtc</span>	<span class="o">*</span><span class="n">cmos</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">retval</span><span class="p">;</span>

	<span class="n">cmos</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span><span class="p">,</span> <span class="n">kobj</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">off</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">off</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">off</span><span class="p">;</span>

	<span class="cm">/* NOTE:  on at least PCs and Ataris, the boot firmware uses a</span>
<span class="cm">	 * checksum on part of the NVRAM data.  That&#39;s currently ignored</span>
<span class="cm">	 * here.  If userspace is smart enough to know what fields of</span>
<span class="cm">	 * NVRAM to update, updating checksums is also part of its job.</span>
<span class="cm">	 */</span>
	<span class="n">off</span> <span class="o">+=</span> <span class="n">NVRAM_OFFSET</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span><span class="p">;</span> <span class="n">count</span><span class="o">--</span><span class="p">,</span> <span class="n">off</span><span class="o">++</span><span class="p">,</span> <span class="n">retval</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* don&#39;t trash RTC registers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">==</span> <span class="n">cmos</span><span class="o">-&gt;</span><span class="n">day_alrm</span>
				<span class="o">||</span> <span class="n">off</span> <span class="o">==</span> <span class="n">cmos</span><span class="o">-&gt;</span><span class="n">mon_alrm</span>
				<span class="o">||</span> <span class="n">off</span> <span class="o">==</span> <span class="n">cmos</span><span class="o">-&gt;</span><span class="n">century</span><span class="p">)</span>
			<span class="n">buf</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">)</span>
			<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">can_bank2</span><span class="p">)</span>
			<span class="n">cmos_write_bank2</span><span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="n">nvram</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;nvram&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span>	<span class="o">=</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">.</span><span class="n">read</span>	<span class="o">=</span> <span class="n">cmos_nvram_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>	<span class="o">=</span> <span class="n">cmos_nvram_write</span><span class="p">,</span>
	<span class="cm">/* size gets set up later */</span>
<span class="p">};</span>

<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cmos_rtc</span>	<span class="n">cmos_rtc</span><span class="p">;</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">cmos_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span>		<span class="n">irqstat</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">rtc_control</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="cm">/* When the HPET interrupt handler calls us, the interrupt</span>
<span class="cm">	 * status is passed as arg1 instead of the irq number.  But</span>
<span class="cm">	 * always clear irq status, even when HPET is in the way.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that HPET and RTC are almost certainly out of phase,</span>
<span class="cm">	 * giving different IRQ status ...</span>
<span class="cm">	 */</span>
	<span class="n">irqstat</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_INTR_FLAGS</span><span class="p">);</span>
	<span class="n">rtc_control</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_hpet_enabled</span><span class="p">())</span>
		<span class="n">irqstat</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">irq</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">;</span>
	<span class="n">irqstat</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">rtc_control</span> <span class="o">&amp;</span> <span class="n">RTC_IRQMASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">RTC_IRQF</span><span class="p">;</span>

	<span class="cm">/* All Linux RTC alarms should be treated as if they were oneshot.</span>
<span class="cm">	 * Similar code may be needed in system wakeup paths, in case the</span>
<span class="cm">	 * alarm woke the system.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqstat</span> <span class="o">&amp;</span> <span class="n">RTC_AIE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rtc_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RTC_AIE</span><span class="p">;</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">rtc_control</span><span class="p">,</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>
		<span class="n">hpet_mask_rtc_irq_bit</span><span class="p">(</span><span class="n">RTC_AIE</span><span class="p">);</span>

		<span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_INTR_FLAGS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_intr</span><span class="p">(</span><span class="n">irqstat</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rtc_update_irq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">irqstat</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef	CONFIG_PNP</span>
<span class="cp">#define	INITSECTION</span>

<span class="cp">#else</span>
<span class="cp">#define	INITSECTION	__init</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">INITSECTION</span>
<span class="nf">cmos_do_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">ports</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rtc_irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cmos_rtc_board_info</span>	<span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>			<span class="n">rtc_control</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">address_space</span><span class="p">;</span>

	<span class="cm">/* there can be only one ... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmos_rtc</span><span class="p">.</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ports</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* Claim I/O ports ASAP, minimizing conflict with legacy driver.</span>
<span class="cm">	 *</span>
<span class="cm">	 * REVISIT non-x86 systems may instead use memory space resources</span>
<span class="cm">	 * (needing ioremap etc), not i/o space resources like this ...</span>
<span class="cm">	 */</span>
	<span class="n">ports</span> <span class="o">=</span> <span class="n">request_region</span><span class="p">(</span><span class="n">ports</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
			<span class="n">resource_size</span><span class="p">(</span><span class="n">ports</span><span class="p">),</span>
			<span class="n">driver_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ports</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;i/o registers already in use</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmos_rtc</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">rtc_irq</span><span class="p">;</span>
	<span class="n">cmos_rtc</span><span class="p">.</span><span class="n">iomem</span> <span class="o">=</span> <span class="n">ports</span><span class="p">;</span>

	<span class="cm">/* Heuristic to deduce NVRAM size ... do what the legacy NVRAM</span>
<span class="cm">	 * driver did, but don&#39;t reject unknown configs.   Old hardware</span>
<span class="cm">	 * won&#39;t address 128 bytes.  Newer chips have multiple banks,</span>
<span class="cm">	 * though they may not be listed in one I/O resource.</span>
<span class="cm">	 */</span>
<span class="cp">#if	defined(CONFIG_ATARI)</span>
	<span class="n">address_space</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
<span class="cp">#elif defined(__i386__) || defined(__x86_64__) || defined(__arm__) \</span>
<span class="cp">			|| defined(__sparc__) || defined(__mips__) \</span>
<span class="cp">			|| defined(__powerpc__)</span>
	<span class="n">address_space</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#warning Assuming 128 bytes of RTC+NVRAM address space, not 64 bytes.</span>
	<span class="n">address_space</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">can_bank2</span> <span class="o">&amp;&amp;</span> <span class="n">ports</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ports</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">address_space</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>

	<span class="cm">/* For ACPI systems extension info comes from the FADT.  On others,</span>
<span class="cm">	 * board specific setup provides it as appropriate.  Systems where</span>
<span class="cm">	 * the alarm IRQ isn&#39;t automatically a wakeup IRQ (like ACPI, and</span>
<span class="cm">	 * some almost-clones) can provide hooks to make that behave.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that ACPI doesn&#39;t preclude putting these registers into</span>
<span class="cm">	 * &quot;extended&quot; areas of the chip, including some that we won&#39;t yet</span>
<span class="cm">	 * expect CMOS_READ and friends to handle.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rtc_day_alarm</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rtc_day_alarm</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">)</span>
			<span class="n">cmos_rtc</span><span class="p">.</span><span class="n">day_alrm</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rtc_day_alarm</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rtc_mon_alarm</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rtc_mon_alarm</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">)</span>
			<span class="n">cmos_rtc</span><span class="p">.</span><span class="n">mon_alrm</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rtc_mon_alarm</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rtc_century</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rtc_century</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">)</span>
			<span class="n">cmos_rtc</span><span class="p">.</span><span class="n">century</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rtc_century</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">wake_on</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">wake_off</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmos_rtc</span><span class="p">.</span><span class="n">wake_on</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">wake_on</span><span class="p">;</span>
			<span class="n">cmos_rtc</span><span class="p">.</span><span class="n">wake_off</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">wake_off</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cmos_rtc</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmos_rtc</span><span class="p">);</span>

	<span class="n">cmos_rtc</span><span class="p">.</span><span class="n">rtc</span> <span class="o">=</span> <span class="n">rtc_device_register</span><span class="p">(</span><span class="n">driver_name</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">cmos_rtc_ops</span><span class="p">,</span> <span class="n">THIS_MODULE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cmos_rtc</span><span class="p">.</span><span class="n">rtc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cmos_rtc</span><span class="p">.</span><span class="n">rtc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rename_region</span><span class="p">(</span><span class="n">ports</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmos_rtc</span><span class="p">.</span><span class="n">rtc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="cm">/* force periodic irq to CMOS reset default of 1024Hz;</span>
<span class="cm">	 *</span>
<span class="cm">	 * REVISIT it&#39;s been reported that at least one x86_64 ALI mobo</span>
<span class="cm">	 * doesn&#39;t use 32KHz here ... for portability we might need to</span>
<span class="cm">	 * do something about other clock frequencies.</span>
<span class="cm">	 */</span>
	<span class="n">cmos_rtc</span><span class="p">.</span><span class="n">rtc</span><span class="o">-&gt;</span><span class="n">irq_freq</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="n">hpet_set_periodic_freq</span><span class="p">(</span><span class="n">cmos_rtc</span><span class="p">.</span><span class="n">rtc</span><span class="o">-&gt;</span><span class="n">irq_freq</span><span class="p">);</span>
	<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">RTC_REF_CLCK_32KHZ</span> <span class="o">|</span> <span class="mh">0x06</span><span class="p">,</span> <span class="n">RTC_FREQ_SELECT</span><span class="p">);</span>

	<span class="cm">/* disable irqs */</span>
	<span class="n">cmos_irq_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmos_rtc</span><span class="p">,</span> <span class="n">RTC_PIE</span> <span class="o">|</span> <span class="n">RTC_AIE</span> <span class="o">|</span> <span class="n">RTC_UIE</span><span class="p">);</span>

	<span class="n">rtc_control</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="cm">/* FIXME:</span>
<span class="cm">	 * &lt;asm-generic/rtc.h&gt; doesn&#39;t know 12-hour mode either.</span>
<span class="cm">	 */</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">is_valid_irq</span><span class="p">(</span><span class="n">rtc_irq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">rtc_control</span> <span class="o">&amp;</span> <span class="n">RTC_24H</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;only 24-hr supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_valid_irq</span><span class="p">(</span><span class="n">rtc_irq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">irq_handler_t</span> <span class="n">rtc_cmos_int_handler</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_hpet_enabled</span><span class="p">())</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

			<span class="n">rtc_cmos_int_handler</span> <span class="o">=</span> <span class="n">hpet_rtc_interrupt</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">hpet_register_irq_handler</span><span class="p">(</span><span class="n">cmos_interrupt</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;hpet_register_irq_handler &quot;</span>
						<span class="s">&quot; failed in rtc_init().&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">cleanup1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">rtc_cmos_int_handler</span> <span class="o">=</span> <span class="n">cmos_interrupt</span><span class="p">;</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">rtc_irq</span><span class="p">,</span> <span class="n">rtc_cmos_int_handler</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmos_rtc</span><span class="p">.</span><span class="n">rtc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span>
				<span class="n">cmos_rtc</span><span class="p">.</span><span class="n">rtc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;IRQ %d is already in use</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rtc_irq</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cleanup1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">hpet_rtc_timer_init</span><span class="p">();</span>

	<span class="cm">/* export at least the first block of NVRAM */</span>
	<span class="n">nvram</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">address_space</span> <span class="o">-</span> <span class="n">NVRAM_OFFSET</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sysfs_create_bin_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nvram</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t create nvram file? %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: %s%s, %zd bytes nvram%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmos_rtc</span><span class="p">.</span><span class="n">rtc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span>
		<span class="o">!</span><span class="n">is_valid_irq</span><span class="p">(</span><span class="n">rtc_irq</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;no alarms&quot;</span> <span class="o">:</span>
			<span class="n">cmos_rtc</span><span class="p">.</span><span class="n">mon_alrm</span> <span class="o">?</span> <span class="s">&quot;alarms up to one year&quot;</span> <span class="o">:</span>
			<span class="n">cmos_rtc</span><span class="p">.</span><span class="n">day_alrm</span> <span class="o">?</span> <span class="s">&quot;alarms up to one month&quot;</span> <span class="o">:</span>
			<span class="s">&quot;alarms up to one day&quot;</span><span class="p">,</span>
		<span class="n">cmos_rtc</span><span class="p">.</span><span class="n">century</span> <span class="o">?</span> <span class="s">&quot;, y3k&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="n">nvram</span><span class="p">.</span><span class="n">size</span><span class="p">,</span>
		<span class="n">is_hpet_enabled</span><span class="p">()</span> <span class="o">?</span> <span class="s">&quot;, hpet irqs&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">cleanup2:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_valid_irq</span><span class="p">(</span><span class="n">rtc_irq</span><span class="p">))</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">rtc_irq</span><span class="p">,</span> <span class="n">cmos_rtc</span><span class="p">.</span><span class="n">rtc</span><span class="p">);</span>
<span class="nl">cleanup1:</span>
	<span class="n">cmos_rtc</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rtc_device_unregister</span><span class="p">(</span><span class="n">cmos_rtc</span><span class="p">.</span><span class="n">rtc</span><span class="p">);</span>
<span class="nl">cleanup0:</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">ports</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">ports</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cmos_do_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="n">cmos_irq_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmos_rtc</span><span class="p">,</span> <span class="n">RTC_IRQMASK</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cmos_do_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cmos_rtc</span>	<span class="o">*</span><span class="n">cmos</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">ports</span><span class="p">;</span>

	<span class="n">cmos_do_shutdown</span><span class="p">();</span>

	<span class="n">sysfs_remove_bin_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nvram</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_valid_irq</span><span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">cmos</span><span class="o">-&gt;</span><span class="n">rtc</span><span class="p">);</span>
		<span class="n">hpet_unregister_irq_handler</span><span class="p">(</span><span class="n">cmos_interrupt</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rtc_device_unregister</span><span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">rtc</span><span class="p">);</span>
	<span class="n">cmos</span><span class="o">-&gt;</span><span class="n">rtc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ports</span> <span class="o">=</span> <span class="n">cmos</span><span class="o">-&gt;</span><span class="n">iomem</span><span class="p">;</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">ports</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">ports</span><span class="p">));</span>
	<span class="n">cmos</span><span class="o">-&gt;</span><span class="n">iomem</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cmos</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef	CONFIG_PM</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmos_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cmos_rtc</span>	<span class="o">*</span><span class="n">cmos</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* only the alarm might be a wakeup event source */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="n">cmos</span><span class="o">-&gt;</span><span class="n">suspend_ctrl</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_CONTROL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RTC_PIE</span><span class="o">|</span><span class="n">RTC_AIE</span><span class="o">|</span><span class="n">RTC_UIE</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">mask</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">device_may_wakeup</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">RTC_IRQMASK</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RTC_AIE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">RTC_IRQMASK</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>

		<span class="cm">/* shut down hpet emulation - we don&#39;t need it for alarm */</span>
		<span class="n">hpet_mask_rtc_irq_bit</span><span class="p">(</span><span class="n">RTC_PIE</span><span class="o">|</span><span class="n">RTC_AIE</span><span class="o">|</span><span class="n">RTC_UIE</span><span class="p">);</span>
		<span class="n">cmos_checkintr</span><span class="p">(</span><span class="n">cmos</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">RTC_AIE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmos</span><span class="o">-&gt;</span><span class="n">enabled_wake</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">wake_on</span><span class="p">)</span>
			<span class="n">cmos</span><span class="o">-&gt;</span><span class="n">wake_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">enable_irq_wake</span><span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: suspend%s, ctrl %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmos_rtc</span><span class="p">.</span><span class="n">rtc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span>
			<span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">RTC_AIE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;, alarm may wake&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="n">tmp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* We want RTC alarms to wake us from e.g. ACPI G2/S5 &quot;soft off&quot;, even</span>
<span class="cm"> * after a detour through G3 &quot;mechanical off&quot;, although the ACPI spec</span>
<span class="cm"> * says wakeup should only work from G1/S4 &quot;hibernate&quot;.  To most users,</span>
<span class="cm"> * distinctions between S4 and S5 are pointless.  So when the hardware</span>
<span class="cm"> * allows, don&#39;t draw that distinction.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cmos_poweroff</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cmos_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmos_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cmos_rtc</span>	<span class="o">*</span><span class="n">cmos</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">tmp</span> <span class="o">=</span> <span class="n">cmos</span><span class="o">-&gt;</span><span class="n">suspend_ctrl</span><span class="p">;</span>

	<span class="cm">/* re-enable any irqs previously active */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">RTC_IRQMASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">mask</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">enabled_wake</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">wake_off</span><span class="p">)</span>
				<span class="n">cmos</span><span class="o">-&gt;</span><span class="n">wake_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">disable_irq_wake</span><span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
			<span class="n">cmos</span><span class="o">-&gt;</span><span class="n">enabled_wake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>
			<span class="n">hpet_set_rtc_irq_bit</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">RTC_IRQMASK</span><span class="p">);</span>

			<span class="n">mask</span> <span class="o">=</span> <span class="n">CMOS_READ</span><span class="p">(</span><span class="n">RTC_INTR_FLAGS</span><span class="p">);</span>
			<span class="n">mask</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">RTC_IRQMASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">RTC_IRQF</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_hpet_enabled</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_intr</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* force one-shot behavior if HPET blocked</span>
<span class="cm">			 * the wake alarm&#39;s irq</span>
<span class="cm">			 */</span>
			<span class="n">rtc_update_irq</span><span class="p">(</span><span class="n">cmos</span><span class="o">-&gt;</span><span class="n">rtc</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
			<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RTC_AIE</span><span class="p">;</span>
			<span class="n">hpet_mask_rtc_irq_bit</span><span class="p">(</span><span class="n">RTC_AIE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">RTC_AIE</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: resume, ctrl %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmos_rtc</span><span class="p">.</span><span class="n">rtc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span>
			<span class="n">tmp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">SIMPLE_DEV_PM_OPS</span><span class="p">(</span><span class="n">cmos_pm_ops</span><span class="p">,</span> <span class="n">cmos_suspend</span><span class="p">,</span> <span class="n">cmos_resume</span><span class="p">);</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cmos_poweroff</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="cm">/* On non-x86 systems, a &quot;CMOS&quot; RTC lives most naturally on platform_bus.</span>
<span class="cm"> * ACPI systems always list these as PNPACPI devices, and pre-ACPI PCs</span>
<span class="cm"> * probably list them in similar PNPBIOS tables; so PNP is more common.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t use legacy &quot;poke at the hardware&quot; probing.  Ancient PCs that</span>
<span class="cm"> * predate even PNPBIOS should set up platform_bus devices.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef	CONFIG_ACPI</span>

<span class="cp">#include &lt;linux/acpi.h&gt;</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">rtc_handler</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>

	<span class="n">pm_wakeup_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">acpi_clear_event</span><span class="p">(</span><span class="n">ACPI_EVENT_RTC</span><span class="p">);</span>
	<span class="n">acpi_disable_event</span><span class="p">(</span><span class="n">ACPI_EVENT_RTC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ACPI_INTERRUPT_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rtc_wake_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_install_fixed_event_handler</span><span class="p">(</span><span class="n">ACPI_EVENT_RTC</span><span class="p">,</span> <span class="n">rtc_handler</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * After the RTC handler is installed, the Fixed_RTC event should</span>
<span class="cm">	 * be disabled. Only when the RTC alarm is set will it be enabled.</span>
<span class="cm">	 */</span>
	<span class="n">acpi_clear_event</span><span class="p">(</span><span class="n">ACPI_EVENT_RTC</span><span class="p">);</span>
	<span class="n">acpi_disable_event</span><span class="p">(</span><span class="n">ACPI_EVENT_RTC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rtc_wake_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_clear_event</span><span class="p">(</span><span class="n">ACPI_EVENT_RTC</span><span class="p">);</span>
	<span class="n">acpi_enable_event</span><span class="p">(</span><span class="n">ACPI_EVENT_RTC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rtc_wake_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_disable_event</span><span class="p">(</span><span class="n">ACPI_EVENT_RTC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Every ACPI platform has a mc146818 compatible &quot;cmos rtc&quot;.  Here we find</span>
<span class="cm"> * its device node and pass extra config data.  This helps its driver use</span>
<span class="cm"> * capabilities that the now-obsolete mc146818 didn&#39;t have, and informs it</span>
<span class="cm"> * that this board&#39;s RTC is wakeup-capable (per ACPI spec).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cmos_rtc_board_info</span> <span class="n">acpi_rtc_info</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span>
<span class="nf">cmos_wake_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_disabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rtc_wake_setup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">acpi_rtc_info</span><span class="p">.</span><span class="n">wake_on</span> <span class="o">=</span> <span class="n">rtc_wake_on</span><span class="p">;</span>
	<span class="n">acpi_rtc_info</span><span class="p">.</span><span class="n">wake_off</span> <span class="o">=</span> <span class="n">rtc_wake_off</span><span class="p">;</span>

	<span class="cm">/* workaround bug in some ACPI tables */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">month_alarm</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">day_alarm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bogus FADT month_alarm (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">month_alarm</span><span class="p">);</span>
		<span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">month_alarm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">acpi_rtc_info</span><span class="p">.</span><span class="n">rtc_day_alarm</span> <span class="o">=</span> <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">day_alarm</span><span class="p">;</span>
	<span class="n">acpi_rtc_info</span><span class="p">.</span><span class="n">rtc_mon_alarm</span> <span class="o">=</span> <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">month_alarm</span><span class="p">;</span>
	<span class="n">acpi_rtc_info</span><span class="p">.</span><span class="n">rtc_century</span> <span class="o">=</span> <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">century</span><span class="p">;</span>

	<span class="cm">/* NOTE:  S4_RTC_WAKE is NOT currently useful to Linux */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ACPI_FADT_S4_RTC_WAKE</span><span class="p">)</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;RTC can wake from S4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">platform_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">acpi_rtc_info</span><span class="p">;</span>

	<span class="cm">/* RTC always wakes from S1/S2/S3, and often S4/STD */</span>
	<span class="n">device_init_wakeup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span>
<span class="nf">cmos_wake_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cp">#ifdef	CONFIG_PNP</span>

<span class="cp">#include &lt;linux/pnp.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">cmos_pnp_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">pnp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cmos_wake_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pnp_port_start</span><span class="p">(</span><span class="n">pnp</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x70</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pnp_irq_valid</span><span class="p">(</span><span class="n">pnp</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
		<span class="cm">/* Some machines contain a PNP entry for the RTC, but</span>
<span class="cm">		 * don&#39;t define the IRQ. It should always be safe to</span>
<span class="cm">		 * hardcode it in these cases</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">cmos_do_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">pnp_get_resource</span><span class="p">(</span><span class="n">pnp</span><span class="p">,</span> <span class="n">IORESOURCE_IO</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">cmos_do_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">pnp_get_resource</span><span class="p">(</span><span class="n">pnp</span><span class="p">,</span> <span class="n">IORESOURCE_IO</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				<span class="n">pnp_irq</span><span class="p">(</span><span class="n">pnp</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cmos_pnp_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">pnp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cmos_do_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef	CONFIG_PM</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmos_pnp_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">pnp</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cmos_suspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmos_pnp_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">pnp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cmos_resume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="cp">#define	cmos_pnp_suspend	NULL</span>
<span class="cp">#define	cmos_pnp_resume		NULL</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cmos_pnp_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">pnp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">system_state</span> <span class="o">==</span> <span class="n">SYSTEM_POWER_OFF</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cmos_poweroff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cmos_do_shutdown</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_device_id</span> <span class="n">rtc_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;PNP0b00&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;PNP0b01&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;PNP0b02&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pnp</span><span class="p">,</span> <span class="n">rtc_ids</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">cmos_pnp_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">driver_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">rtc_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">cmos_pnp_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__exit_p</span><span class="p">(</span><span class="n">cmos_pnp_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">cmos_pnp_shutdown</span><span class="p">,</span>

	<span class="cm">/* flag ensures resume() gets called, and stops syslog spam */</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">PNP_DRIVER_RES_DO_NOT_CHANGE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">cmos_pnp_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">cmos_pnp_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_PNP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_OF</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">of_cmos_match</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;motorola,mc146818&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">of</span><span class="p">,</span> <span class="n">of_cmos_match</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">void</span> <span class="nf">cmos_of_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtc_time</span> <span class="n">time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ctrl-reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">RTC_CONTROL</span><span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;freq-reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
		<span class="n">CMOS_WRITE</span><span class="p">(</span><span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">RTC_FREQ_SELECT</span><span class="p">);</span>

	<span class="n">get_rtc_time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">rtc_valid_tm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rtc_time</span> <span class="n">def_time</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">tm_year</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
			<span class="p">.</span><span class="n">tm_mday</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">};</span>
		<span class="n">set_rtc_time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">def_time</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cmos_of_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#define of_cmos_match NULL</span>
<span class="cp">#endif</span>
<span class="cm">/*----------------------------------------------------------------*/</span>

<span class="cm">/* Platform setup should have set up an RTC device, when PNP is</span>
<span class="cm"> * unavailable ... this could happen even on (older) PCs.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cmos_platform_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cmos_of_init</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">cmos_wake_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cmos_do_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_IO</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			<span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__exit</span> <span class="nf">cmos_platform_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cmos_do_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cmos_platform_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">system_state</span> <span class="o">==</span> <span class="n">SYSTEM_POWER_OFF</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cmos_poweroff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cmos_do_shutdown</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* work with hotplug and coldplug */</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:rtc_cmos&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">cmos_platform_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__exit_p</span><span class="p">(</span><span class="n">cmos_platform_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">cmos_platform_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">driver_name</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
		<span class="p">.</span><span class="n">pm</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">cmos_pm_ops</span><span class="p">,</span>
<span class="cp">#endif</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">of_cmos_match</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_PNP</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">pnp_driver_registered</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">platform_driver_registered</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cmos_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef	CONFIG_PNP</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">pnp_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmos_pnp_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pnp_driver_registered</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cmos_rtc</span><span class="p">.</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">platform_driver_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmos_platform_driver</span><span class="p">,</span>
					       <span class="n">cmos_platform_probe</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">platform_driver_registered</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef	CONFIG_PNP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pnp_driver_registered</span><span class="p">)</span>
		<span class="n">pnp_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmos_pnp_driver</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">cmos_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cmos_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef	CONFIG_PNP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pnp_driver_registered</span><span class="p">)</span>
		<span class="n">pnp_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmos_pnp_driver</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">platform_driver_registered</span><span class="p">)</span>
		<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmos_platform_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">cmos_exit</span><span class="p">);</span>


<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;David Brownell&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Driver for PC-style &#39;CMOS&#39; RTCs&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
