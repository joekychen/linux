<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › idle › intel_idle.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>intel_idle.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * intel_idle.c - native hardware idle loop for modern Intel processors</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2010, Intel Corporation.</span>
<span class="cm"> * Len Brown &lt;len.brown@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * intel_idle is a cpuidle driver that loads on specific Intel processors</span>
<span class="cm"> * in lieu of the legacy ACPI processor_idle driver.  The intent is to</span>
<span class="cm"> * make Linux more efficient on these processors, as intel_idle knows</span>
<span class="cm"> * more than ACPI, as well as make Linux more immune to ACPI BIOS bugs.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Design Assumptions</span>
<span class="cm"> *</span>
<span class="cm"> * All CPUs have same idle states as boot CPU</span>
<span class="cm"> *</span>
<span class="cm"> * Chipset BM_STS (bus master status) bit is a NOP</span>
<span class="cm"> *	for preventing entry into deep C-stats</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Known limitations</span>
<span class="cm"> *</span>
<span class="cm"> * The driver currently initializes for_each_online_cpu() upon modprobe.</span>
<span class="cm"> * It it unaware of subsequent processors hot-added to the system.</span>
<span class="cm"> * This means that if you boot with maxcpus=n and later online</span>
<span class="cm"> * processors above n, those processors will use C1 only.</span>
<span class="cm"> *</span>
<span class="cm"> * ACPI has a .suspend hack to turn off deep c-statees during suspend</span>
<span class="cm"> * to avoid complications with the lapic timer workaround.</span>
<span class="cm"> * Have not seen issues with suspend, but may need same workaround here.</span>
<span class="cm"> *</span>
<span class="cm"> * There is currently no kernel-based automatic probing/loading mechanism</span>
<span class="cm"> * if the driver is built as a module.</span>
<span class="cm"> */</span>

<span class="cm">/* un-comment DEBUG to enable pr_debug() statements */</span>
<span class="cp">#define DEBUG</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/cpuidle.h&gt;</span>
<span class="cp">#include &lt;linux/clockchips.h&gt;</span>
<span class="cp">#include &lt;linux/hrtimer.h&gt;	</span><span class="cm">/* ktime_get_real() */</span><span class="cp"></span>
<span class="cp">#include &lt;trace/events/power.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;asm/cpu_device_id.h&gt;</span>
<span class="cp">#include &lt;asm/mwait.h&gt;</span>
<span class="cp">#include &lt;asm/msr.h&gt;</span>

<span class="cp">#define INTEL_IDLE_VERSION &quot;0.4&quot;</span>
<span class="cp">#define PREFIX &quot;intel_idle: &quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cpuidle_driver</span> <span class="n">intel_idle_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;intel_idle&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>
<span class="cm">/* intel_idle.max_cstate=0 disables driver */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_cstate</span> <span class="o">=</span> <span class="n">MWAIT_MAX_NUM_CSTATES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mwait_substates</span><span class="p">;</span>

<span class="cp">#define LAPIC_TIMER_ALWAYS_RELIABLE 0xFFFFFFFF</span>
<span class="cm">/* Reliable LAPIC Timer States, bit 1 for C1 etc.  */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lapic_timer_reliable_states</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>	 <span class="cm">/* Default to only C1 */</span>

<span class="k">struct</span> <span class="n">idle_cpu</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuidle_state</span> <span class="o">*</span><span class="n">state_table</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Hardware C-state auto-demotion may not always be optimal.</span>
<span class="cm">	 * Indicate which enable bits to clear here.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">auto_demotion_disable_flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">idle_cpu</span> <span class="o">*</span><span class="n">icpu</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cpuidle_device</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">intel_idle_cpuidle_devices</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">intel_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuidle_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cpuidle_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cpuidle_state</span> <span class="o">*</span><span class="n">cpuidle_state_table</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Set this flag for states where the HW flushes the TLB for us</span>
<span class="cm"> * and so we don&#39;t need cross-calls to keep it consistent.</span>
<span class="cm"> * If this flag is set, SW flushes the TLB, so even if the</span>
<span class="cm"> * HW doesn&#39;t do the flushing, this flag is safe to use.</span>
<span class="cm"> */</span>
<span class="cp">#define CPUIDLE_FLAG_TLB_FLUSHED	0x10000</span>

<span class="cm">/*</span>
<span class="cm"> * States are indexed by the cstate number,</span>
<span class="cm"> * which is also the index into the MWAIT hint array.</span>
<span class="cm"> * Thus C0 is a dummy.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cpuidle_state</span> <span class="n">nehalem_cstates</span><span class="p">[</span><span class="n">MWAIT_MAX_NUM_CSTATES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="cm">/* MWAIT C0 */</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* MWAIT C1 */</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;C1-NHM&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="s">&quot;MWAIT 0x00&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CPUIDLE_FLAG_TIME_VALID</span><span class="p">,</span>
		<span class="p">.</span><span class="n">exit_latency</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
		<span class="p">.</span><span class="n">target_residency</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">enter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_idle</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* MWAIT C2 */</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;C3-NHM&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="s">&quot;MWAIT 0x10&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CPUIDLE_FLAG_TIME_VALID</span> <span class="o">|</span> <span class="n">CPUIDLE_FLAG_TLB_FLUSHED</span><span class="p">,</span>
		<span class="p">.</span><span class="n">exit_latency</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
		<span class="p">.</span><span class="n">target_residency</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
		<span class="p">.</span><span class="n">enter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_idle</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* MWAIT C3 */</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;C6-NHM&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="s">&quot;MWAIT 0x20&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CPUIDLE_FLAG_TIME_VALID</span> <span class="o">|</span> <span class="n">CPUIDLE_FLAG_TLB_FLUSHED</span><span class="p">,</span>
		<span class="p">.</span><span class="n">exit_latency</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
		<span class="p">.</span><span class="n">target_residency</span> <span class="o">=</span> <span class="mi">800</span><span class="p">,</span>
		<span class="p">.</span><span class="n">enter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_idle</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cpuidle_state</span> <span class="n">snb_cstates</span><span class="p">[</span><span class="n">MWAIT_MAX_NUM_CSTATES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="cm">/* MWAIT C0 */</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* MWAIT C1 */</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;C1-SNB&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="s">&quot;MWAIT 0x00&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CPUIDLE_FLAG_TIME_VALID</span><span class="p">,</span>
		<span class="p">.</span><span class="n">exit_latency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">target_residency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">enter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_idle</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* MWAIT C2 */</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;C3-SNB&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="s">&quot;MWAIT 0x10&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CPUIDLE_FLAG_TIME_VALID</span> <span class="o">|</span> <span class="n">CPUIDLE_FLAG_TLB_FLUSHED</span><span class="p">,</span>
		<span class="p">.</span><span class="n">exit_latency</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
		<span class="p">.</span><span class="n">target_residency</span> <span class="o">=</span> <span class="mi">211</span><span class="p">,</span>
		<span class="p">.</span><span class="n">enter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_idle</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* MWAIT C3 */</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;C6-SNB&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="s">&quot;MWAIT 0x20&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CPUIDLE_FLAG_TIME_VALID</span> <span class="o">|</span> <span class="n">CPUIDLE_FLAG_TLB_FLUSHED</span><span class="p">,</span>
		<span class="p">.</span><span class="n">exit_latency</span> <span class="o">=</span> <span class="mi">104</span><span class="p">,</span>
		<span class="p">.</span><span class="n">target_residency</span> <span class="o">=</span> <span class="mi">345</span><span class="p">,</span>
		<span class="p">.</span><span class="n">enter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_idle</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* MWAIT C4 */</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;C7-SNB&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="s">&quot;MWAIT 0x30&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CPUIDLE_FLAG_TIME_VALID</span> <span class="o">|</span> <span class="n">CPUIDLE_FLAG_TLB_FLUSHED</span><span class="p">,</span>
		<span class="p">.</span><span class="n">exit_latency</span> <span class="o">=</span> <span class="mi">109</span><span class="p">,</span>
		<span class="p">.</span><span class="n">target_residency</span> <span class="o">=</span> <span class="mi">345</span><span class="p">,</span>
		<span class="p">.</span><span class="n">enter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_idle</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cpuidle_state</span> <span class="n">atom_cstates</span><span class="p">[</span><span class="n">MWAIT_MAX_NUM_CSTATES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="cm">/* MWAIT C0 */</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* MWAIT C1 */</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;C1-ATM&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="s">&quot;MWAIT 0x00&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CPUIDLE_FLAG_TIME_VALID</span><span class="p">,</span>
		<span class="p">.</span><span class="n">exit_latency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">target_residency</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">enter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_idle</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* MWAIT C2 */</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;C2-ATM&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="s">&quot;MWAIT 0x10&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CPUIDLE_FLAG_TIME_VALID</span><span class="p">,</span>
		<span class="p">.</span><span class="n">exit_latency</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
		<span class="p">.</span><span class="n">target_residency</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
		<span class="p">.</span><span class="n">enter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_idle</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* MWAIT C3 */</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* MWAIT C4 */</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;C4-ATM&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="s">&quot;MWAIT 0x30&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CPUIDLE_FLAG_TIME_VALID</span> <span class="o">|</span> <span class="n">CPUIDLE_FLAG_TLB_FLUSHED</span><span class="p">,</span>
		<span class="p">.</span><span class="n">exit_latency</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
		<span class="p">.</span><span class="n">target_residency</span> <span class="o">=</span> <span class="mi">400</span><span class="p">,</span>
		<span class="p">.</span><span class="n">enter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_idle</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* MWAIT C5 */</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* MWAIT C6 */</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;C6-ATM&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="s">&quot;MWAIT 0x52&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CPUIDLE_FLAG_TIME_VALID</span> <span class="o">|</span> <span class="n">CPUIDLE_FLAG_TLB_FLUSHED</span><span class="p">,</span>
		<span class="p">.</span><span class="n">exit_latency</span> <span class="o">=</span> <span class="mi">140</span><span class="p">,</span>
		<span class="p">.</span><span class="n">target_residency</span> <span class="o">=</span> <span class="mi">560</span><span class="p">,</span>
		<span class="p">.</span><span class="n">enter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_idle</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">get_driver_data</span><span class="p">(</span><span class="kt">int</span> <span class="n">cstate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">driver_data</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cstate</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="mi">1</span>:	<span class="cm">/* MWAIT C1 */</span>
		<span class="n">driver_data</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:	<span class="cm">/* MWAIT C2 */</span>
		<span class="n">driver_data</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:	<span class="cm">/* MWAIT C3 */</span>
		<span class="n">driver_data</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:	<span class="cm">/* MWAIT C4 */</span>
		<span class="n">driver_data</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">5</span>:	<span class="cm">/* MWAIT C5 */</span>
		<span class="n">driver_data</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">6</span>:	<span class="cm">/* MWAIT C6 */</span>
		<span class="n">driver_data</span> <span class="o">=</span> <span class="mh">0x52</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">driver_data</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">driver_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * intel_idle</span>
<span class="cm"> * @dev: cpuidle_device</span>
<span class="cm"> * @drv: cpuidle driver</span>
<span class="cm"> * @index: index of cpuidle state</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called under local_irq_disable().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuidle_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">cpuidle_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ecx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* break on interrupt flag */</span>
	<span class="k">struct</span> <span class="n">cpuidle_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">states</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">cpuidle_state_usage</span> <span class="o">*</span><span class="n">state_usage</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">states_usage</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">eax</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cpuidle_get_statedata</span><span class="p">(</span><span class="n">state_usage</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cstate</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">kt_before</span><span class="p">,</span> <span class="n">kt_after</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">usec_delta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">cstate</span> <span class="o">=</span> <span class="p">(((</span><span class="n">eax</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">MWAIT_SUBSTATE_SIZE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MWAIT_CSTATE_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * leave_mm() to avoid costly and often unnecessary wakeups</span>
<span class="cm">	 * for flushing the user TLB&#39;s associated with the active mm.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CPUIDLE_FLAG_TLB_FLUSHED</span><span class="p">)</span>
		<span class="n">leave_mm</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lapic_timer_reliable_states</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">cstate</span><span class="p">))))</span>
		<span class="n">clockevents_notify</span><span class="p">(</span><span class="n">CLOCK_EVT_NOTIFY_BROADCAST_ENTER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="p">);</span>

	<span class="n">kt_before</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>

	<span class="n">stop_critical_timings</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>

		<span class="n">__monitor</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">smp_mb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span>
			<span class="n">__mwait</span><span class="p">(</span><span class="n">eax</span><span class="p">,</span> <span class="n">ecx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">start_critical_timings</span><span class="p">();</span>

	<span class="n">kt_after</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>
	<span class="n">usec_delta</span> <span class="o">=</span> <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">kt_after</span><span class="p">,</span> <span class="n">kt_before</span><span class="p">));</span>

	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lapic_timer_reliable_states</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">cstate</span><span class="p">))))</span>
		<span class="n">clockevents_notify</span><span class="p">(</span><span class="n">CLOCK_EVT_NOTIFY_BROADCAST_EXIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/* Update cpuidle counters */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_residency</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">usec_delta</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__setup_broadcast_timer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reason</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">reason</span> <span class="o">=</span> <span class="n">reason</span> <span class="o">?</span>
		<span class="n">CLOCK_EVT_NOTIFY_BROADCAST_ON</span> <span class="o">:</span> <span class="n">CLOCK_EVT_NOTIFY_BROADCAST_OFF</span><span class="p">;</span>

	<span class="n">clockevents_notify</span><span class="p">(</span><span class="n">reason</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_broadcast_cpuhp_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">hotcpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">hotcpu</span><span class="p">,</span> <span class="n">__setup_broadcast_timer</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nb">true</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">setup_broadcast_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">setup_broadcast_cpuhp_notify</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">auto_demotion_disable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">msr_bits</span><span class="p">;</span>

	<span class="n">rdmsrl</span><span class="p">(</span><span class="n">MSR_NHM_SNB_PKG_CST_CFG_CTL</span><span class="p">,</span> <span class="n">msr_bits</span><span class="p">);</span>
	<span class="n">msr_bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">icpu</span><span class="o">-&gt;</span><span class="n">auto_demotion_disable_flags</span><span class="p">);</span>
	<span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_NHM_SNB_PKG_CST_CFG_CTL</span><span class="p">,</span> <span class="n">msr_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">idle_cpu</span> <span class="n">idle_cpu_nehalem</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">state_table</span> <span class="o">=</span> <span class="n">nehalem_cstates</span><span class="p">,</span>
	<span class="p">.</span><span class="n">auto_demotion_disable_flags</span> <span class="o">=</span> <span class="n">NHM_C1_AUTO_DEMOTE</span> <span class="o">|</span> <span class="n">NHM_C3_AUTO_DEMOTE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">idle_cpu</span> <span class="n">idle_cpu_atom</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">state_table</span> <span class="o">=</span> <span class="n">atom_cstates</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">idle_cpu</span> <span class="n">idle_cpu_lincroft</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">state_table</span> <span class="o">=</span> <span class="n">atom_cstates</span><span class="p">,</span>
	<span class="p">.</span><span class="n">auto_demotion_disable_flags</span> <span class="o">=</span> <span class="n">ATM_LNC_C6_AUTO_DEMOTE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">idle_cpu</span> <span class="n">idle_cpu_snb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">state_table</span> <span class="o">=</span> <span class="n">snb_cstates</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define ICPU(model, cpu) \</span>
<span class="cp">	{ X86_VENDOR_INTEL, 6, model, X86_FEATURE_MWAIT, (unsigned long)&amp;cpu }</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">x86_cpu_id</span> <span class="n">intel_idle_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">ICPU</span><span class="p">(</span><span class="mh">0x1a</span><span class="p">,</span> <span class="n">idle_cpu_nehalem</span><span class="p">),</span>
	<span class="n">ICPU</span><span class="p">(</span><span class="mh">0x1e</span><span class="p">,</span> <span class="n">idle_cpu_nehalem</span><span class="p">),</span>
	<span class="n">ICPU</span><span class="p">(</span><span class="mh">0x1f</span><span class="p">,</span> <span class="n">idle_cpu_nehalem</span><span class="p">),</span>
	<span class="n">ICPU</span><span class="p">(</span><span class="mh">0x25</span><span class="p">,</span> <span class="n">idle_cpu_nehalem</span><span class="p">),</span>
	<span class="n">ICPU</span><span class="p">(</span><span class="mh">0x2c</span><span class="p">,</span> <span class="n">idle_cpu_nehalem</span><span class="p">),</span>
	<span class="n">ICPU</span><span class="p">(</span><span class="mh">0x2e</span><span class="p">,</span> <span class="n">idle_cpu_nehalem</span><span class="p">),</span>
	<span class="n">ICPU</span><span class="p">(</span><span class="mh">0x1c</span><span class="p">,</span> <span class="n">idle_cpu_atom</span><span class="p">),</span>
	<span class="n">ICPU</span><span class="p">(</span><span class="mh">0x26</span><span class="p">,</span> <span class="n">idle_cpu_lincroft</span><span class="p">),</span>
	<span class="n">ICPU</span><span class="p">(</span><span class="mh">0x2f</span><span class="p">,</span> <span class="n">idle_cpu_nehalem</span><span class="p">),</span>
	<span class="n">ICPU</span><span class="p">(</span><span class="mh">0x2a</span><span class="p">,</span> <span class="n">idle_cpu_snb</span><span class="p">),</span>
	<span class="n">ICPU</span><span class="p">(</span><span class="mh">0x2d</span><span class="p">,</span> <span class="n">idle_cpu_snb</span><span class="p">),</span>
	<span class="p">{}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">x86cpu</span><span class="p">,</span> <span class="n">intel_idle_ids</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * intel_idle_probe()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_idle_probe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ecx</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">x86_cpu_id</span> <span class="o">*</span><span class="n">id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_cstate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="n">PREFIX</span> <span class="s">&quot;disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">id</span> <span class="o">=</span> <span class="n">x86_match_cpu</span><span class="p">(</span><span class="n">intel_idle_ids</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_vendor</span> <span class="o">==</span> <span class="n">X86_VENDOR_INTEL</span> <span class="o">&amp;&amp;</span>
		    <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="n">PREFIX</span> <span class="s">&quot;does not run on family %d model %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86</span><span class="p">,</span> <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_model</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">cpuid_level</span> <span class="o">&lt;</span> <span class="n">CPUID_MWAIT_LEAF</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">cpuid</span><span class="p">(</span><span class="n">CPUID_MWAIT_LEAF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mwait_substates</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ecx</span> <span class="o">&amp;</span> <span class="n">CPUID5_ECX_EXTENSIONS_SUPPORTED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">ecx</span> <span class="o">&amp;</span> <span class="n">CPUID5_ECX_INTERRUPT_BREAK</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">mwait_substates</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="n">PREFIX</span> <span class="s">&quot;MWAIT substates: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mwait_substates</span><span class="p">);</span>

	<span class="n">icpu</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">idle_cpu</span> <span class="o">*</span><span class="p">)</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="n">cpuidle_state_table</span> <span class="o">=</span> <span class="n">icpu</span><span class="o">-&gt;</span><span class="n">state_table</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_ARAT</span><span class="p">))</span>	<span class="cm">/* Always Reliable APIC Timer */</span>
		<span class="n">lapic_timer_reliable_states</span> <span class="o">=</span> <span class="n">LAPIC_TIMER_ALWAYS_RELIABLE</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">__setup_broadcast_timer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nb">true</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">register_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">setup_broadcast_notifier</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="n">PREFIX</span> <span class="s">&quot;v&quot;</span> <span class="n">INTEL_IDLE_VERSION</span>
		<span class="s">&quot; model 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_model</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="n">PREFIX</span> <span class="s">&quot;lapic_timer_reliable_states 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">lapic_timer_reliable_states</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * intel_idle_cpuidle_devices_uninit()</span>
<span class="cm"> * unregister, free cpuidle_devices</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">intel_idle_cpuidle_devices_uninit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuidle_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">intel_idle_cpuidle_devices</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">cpuidle_unregister_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">free_percpu</span><span class="p">(</span><span class="n">intel_idle_cpuidle_devices</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * intel_idle_cpuidle_driver_init()</span>
<span class="cm"> * allocate, initialize cpuidle_states</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">intel_idle_cpuidle_driver_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cstate</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuidle_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_idle_driver</span><span class="p">;</span>

	<span class="n">drv</span><span class="o">-&gt;</span><span class="n">state_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cstate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">cstate</span> <span class="o">&lt;</span> <span class="n">MWAIT_MAX_NUM_CSTATES</span><span class="p">;</span> <span class="o">++</span><span class="n">cstate</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">num_substates</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cstate</span> <span class="o">&gt;</span> <span class="n">max_cstate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">PREFIX</span> <span class="s">&quot;max_cstate %d reached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">max_cstate</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* does the state exist in CPUID.MWAIT? */</span>
		<span class="n">num_substates</span> <span class="o">=</span> <span class="p">(</span><span class="n">mwait_substates</span> <span class="o">&gt;&gt;</span> <span class="p">((</span><span class="n">cstate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span>
					<span class="o">&amp;</span> <span class="n">MWAIT_SUBSTATE_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_substates</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* is the state not enabled? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpuidle_state_table</span><span class="p">[</span><span class="n">cstate</span><span class="p">].</span><span class="n">enter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* does the driver not know about the state? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cpuidle_state_table</span><span class="p">[</span><span class="n">cstate</span><span class="p">].</span><span class="n">name</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="n">PREFIX</span> <span class="s">&quot;unaware of model 0x%x&quot;</span>
					<span class="s">&quot; MWAIT %d please&quot;</span>
					<span class="s">&quot; contact lenb@kernel.org&quot;</span><span class="p">,</span>
				<span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_model</span><span class="p">,</span> <span class="n">cstate</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">cstate</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_NONSTOP_TSC</span><span class="p">))</span>
			<span class="n">mark_tsc_unstable</span><span class="p">(</span><span class="s">&quot;TSC halts in idle&quot;</span>
					<span class="s">&quot; states deeper than C2&quot;</span><span class="p">);</span>

		<span class="n">drv</span><span class="o">-&gt;</span><span class="n">states</span><span class="p">[</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">state_count</span><span class="p">]</span> <span class="o">=</span>	<span class="cm">/* structure copy */</span>
			<span class="n">cpuidle_state_table</span><span class="p">[</span><span class="n">cstate</span><span class="p">];</span>

		<span class="n">drv</span><span class="o">-&gt;</span><span class="n">state_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icpu</span><span class="o">-&gt;</span><span class="n">auto_demotion_disable_flags</span><span class="p">)</span>
		<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">auto_demotion_disable</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * intel_idle_cpu_init()</span>
<span class="cm"> * allocate, initialize, register cpuidle_devices</span>
<span class="cm"> * @cpu: cpu/core to initialize</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">intel_idle_cpu_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cstate</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuidle_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">intel_idle_cpuidle_devices</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">state_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cstate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">cstate</span> <span class="o">&lt;</span> <span class="n">MWAIT_MAX_NUM_CSTATES</span><span class="p">;</span> <span class="o">++</span><span class="n">cstate</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">num_substates</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cstate</span> <span class="o">&gt;</span> <span class="n">max_cstate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">PREFIX</span> <span class="s">&quot;max_cstate %d reached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">max_cstate</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* does the state exist in CPUID.MWAIT? */</span>
		<span class="n">num_substates</span> <span class="o">=</span> <span class="p">(</span><span class="n">mwait_substates</span> <span class="o">&gt;&gt;</span> <span class="p">((</span><span class="n">cstate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span>
			<span class="o">&amp;</span> <span class="n">MWAIT_SUBSTATE_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_substates</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* is the state not enabled? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpuidle_state_table</span><span class="p">[</span><span class="n">cstate</span><span class="p">].</span><span class="n">enter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">states_usage</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state_count</span><span class="p">].</span><span class="n">driver_data</span> <span class="o">=</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">get_driver_data</span><span class="p">(</span><span class="n">cstate</span><span class="p">);</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">state_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuidle_register_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="n">PREFIX</span> <span class="s">&quot;cpuidle_register_device %d failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">intel_idle_cpuidle_devices_uninit</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icpu</span><span class="o">-&gt;</span><span class="n">auto_demotion_disable_flags</span><span class="p">)</span>
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">auto_demotion_disable</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">intel_idle_cpu_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">intel_idle_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Do not load intel_idle at all for now if idle= is passed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot_option_idle_override</span> <span class="o">!=</span> <span class="n">IDLE_NO_OVERRIDE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">intel_idle_probe</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">intel_idle_cpuidle_driver_init</span><span class="p">();</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">cpuidle_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intel_idle_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">PREFIX</span> <span class="s">&quot;intel_idle yielding to %s&quot;</span><span class="p">,</span>
			<span class="n">cpuidle_get_driver</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">intel_idle_cpuidle_devices</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuidle_device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intel_idle_cpuidle_devices</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">intel_idle_cpu_init</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpuidle_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intel_idle_driver</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">intel_idle_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">intel_idle_cpuidle_devices_uninit</span><span class="p">();</span>
	<span class="n">cpuidle_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intel_idle_driver</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lapic_timer_reliable_states</span> <span class="o">!=</span> <span class="n">LAPIC_TIMER_ALWAYS_RELIABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">__setup_broadcast_timer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nb">false</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">unregister_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">setup_broadcast_notifier</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">intel_idle_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">intel_idle_exit</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">max_cstate</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Len Brown &lt;len.brown@intel.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Cpuidle driver for Intel Hardware v&quot;</span> <span class="n">INTEL_IDLE_VERSION</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
