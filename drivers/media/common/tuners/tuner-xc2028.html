<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › common › tuners › tuner-xc2028.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>tuner-xc2028.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* tuner-xc2028</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2007-2008 Mauro Carvalho Chehab (mchehab@infradead.org)</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2007 Michel Ludwig (michel.ludwig@gmail.com)</span>
<span class="cm"> *       - frontend interface</span>
<span class="cm"> *</span>
<span class="cm"> * This code is placed under the terms of the GNU General Public License v2</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;asm/div64.h&gt;</span>
<span class="cp">#include &lt;linux/firmware.h&gt;</span>
<span class="cp">#include &lt;linux/videodev2.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;media/tuner.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &quot;tuner-i2c.h&quot;</span>
<span class="cp">#include &quot;tuner-xc2028.h&quot;</span>
<span class="cp">#include &quot;tuner-xc2028-types.h&quot;</span>

<span class="cp">#include &lt;linux/dvb/frontend.h&gt;</span>
<span class="cp">#include &quot;dvb_frontend.h&quot;</span>

<span class="cm">/* Registers (Write-only) */</span>
<span class="cp">#define XREG_INIT         0x00</span>
<span class="cp">#define XREG_RF_FREQ      0x02</span>
<span class="cp">#define XREG_POWER_DOWN   0x08</span>

<span class="cm">/* Registers (Read-only) */</span>
<span class="cp">#define XREG_FREQ_ERROR   0x01</span>
<span class="cp">#define XREG_LOCK         0x02</span>
<span class="cp">#define XREG_VERSION      0x04</span>
<span class="cp">#define XREG_PRODUCT_ID   0x08</span>
<span class="cp">#define XREG_HSYNC_FREQ   0x10</span>
<span class="cp">#define XREG_FRAME_LINES  0x20</span>
<span class="cp">#define XREG_SNR          0x40</span>

<span class="cp">#define XREG_ADC_ENV      0x0100</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;enable verbose debug messages&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">no_poweroff</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">no_poweroff</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">no_poweroff</span><span class="p">,</span> <span class="s">&quot;0 (default) powers device off when not used.</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;1 keep device energized and with tuner ready all the times.</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;  Faster, but consumes more power and keeps the device hotter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">audio_std</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="n">module_param_string</span><span class="p">(</span><span class="n">audio_std</span><span class="p">,</span> <span class="n">audio_std</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">audio_std</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">audio_std</span><span class="p">,</span>
	<span class="s">&quot;Audio standard. XC3028 audio decoder explicitly &quot;</span>
	<span class="s">&quot;needs to know what audio</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;standard is needed for some video standards with audio A2 or NICAM.</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;The valid values are:</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;A2</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;A2/A</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;A2/B</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;NICAM</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;NICAM/A</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;NICAM/B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">firmware_name</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
<span class="n">module_param_string</span><span class="p">(</span><span class="n">firmware_name</span><span class="p">,</span> <span class="n">firmware_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">firmware_name</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">firmware_name</span><span class="p">,</span> <span class="s">&quot;Firmware file name. Allows overriding the &quot;</span>
				<span class="s">&quot;default firmware name</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">hybrid_tuner_instance_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">xc2028_list_mutex</span><span class="p">);</span>

<span class="cm">/* struct for storing firmware table */</span>
<span class="k">struct</span> <span class="n">firmware_description</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">type</span><span class="p">;</span>
	<span class="n">v4l2_std_id</span>   <span class="n">id</span><span class="p">;</span>
	<span class="n">__u16</span>         <span class="n">int_freq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">firmware_properties</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">type</span><span class="p">;</span>
	<span class="n">v4l2_std_id</span>	<span class="n">id</span><span class="p">;</span>
	<span class="n">v4l2_std_id</span>	<span class="n">std_req</span><span class="p">;</span>
	<span class="n">__u16</span>		<span class="n">int_freq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">scode_table</span><span class="p">;</span>
	<span class="kt">int</span> 		<span class="n">scode_nr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xc2028_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>        <span class="n">hybrid_tuner_instance_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tuner_i2c_props</span>  <span class="n">i2c_props</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">frequency</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">firmware_description</span> <span class="o">*</span><span class="n">firm</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">firm_size</span><span class="p">;</span>
	<span class="n">__u16</span>			<span class="n">firm_version</span><span class="p">;</span>

	<span class="n">__u16</span>			<span class="n">hwmodel</span><span class="p">;</span>
	<span class="n">__u16</span>			<span class="n">hwvers</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">xc2028_ctrl</span>	<span class="n">ctrl</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">firmware_properties</span> <span class="n">cur_fw</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define i2c_send(priv, buf, size) ({					\</span>
<span class="cp">	int _rc;							\</span>
<span class="cp">	_rc = tuner_i2c_xfer_send(&amp;priv-&gt;i2c_props, buf, size);		\</span>
<span class="cp">	if (size != _rc)						\</span>
<span class="cp">		tuner_info(&quot;i2c output error: rc = %d (should be %d)\n&quot;,\</span>
<span class="cp">			   _rc, (int)size);				\</span>
<span class="cp">	if (priv-&gt;ctrl.msleep)						\</span>
<span class="cp">		msleep(priv-&gt;ctrl.msleep);				\</span>
<span class="cp">	_rc;								\</span>
<span class="cp">})</span>

<span class="cp">#define i2c_rcv(priv, buf, size) ({					\</span>
<span class="cp">	int _rc;							\</span>
<span class="cp">	_rc = tuner_i2c_xfer_recv(&amp;priv-&gt;i2c_props, buf, size);		\</span>
<span class="cp">	if (size != _rc)						\</span>
<span class="cp">		tuner_err(&quot;i2c input error: rc = %d (should be %d)\n&quot;,	\</span>
<span class="cp">			   _rc, (int)size); 				\</span>
<span class="cp">	_rc;								\</span>
<span class="cp">})</span>

<span class="cp">#define i2c_send_recv(priv, obuf, osize, ibuf, isize) ({		\</span>
<span class="cp">	int _rc;							\</span>
<span class="cp">	_rc = tuner_i2c_xfer_send_recv(&amp;priv-&gt;i2c_props, obuf, osize,	\</span>
<span class="cp">				       ibuf, isize);			\</span>
<span class="cp">	if (isize != _rc)						\</span>
<span class="cp">		tuner_err(&quot;i2c input error: rc = %d (should be %d)\n&quot;,	\</span>
<span class="cp">			   _rc, (int)isize); 				\</span>
<span class="cp">	if (priv-&gt;ctrl.msleep)						\</span>
<span class="cp">		msleep(priv-&gt;ctrl.msleep);				\</span>
<span class="cp">	_rc;								\</span>
<span class="cp">})</span>

<span class="cp">#define send_seq(priv, data...)	({					\</span>
<span class="cp">	static u8 _val[] = data;					\</span>
<span class="cp">	int _rc;							\</span>
<span class="cp">	if (sizeof(_val) !=						\</span>
<span class="cp">			(_rc = tuner_i2c_xfer_send(&amp;priv-&gt;i2c_props,	\</span>
<span class="cp">						_val, sizeof(_val)))) {	\</span>
<span class="cp">		tuner_err(&quot;Error on line %d: %d\n&quot;, __LINE__, _rc);	\</span>
<span class="cp">	} else if (priv-&gt;ctrl.msleep)					\</span>
<span class="cp">		msleep(priv-&gt;ctrl.msleep);				\</span>
<span class="cp">	_rc;								\</span>
<span class="cp">})</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xc2028_get_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">xc2028_data</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ibuf</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;%s %04x called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i2c_send_recv</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ibuf</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">ibuf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">ibuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define dump_firm_type(t) 	dump_firm_type_and_int_freq(t, 0)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_firm_type_and_int_freq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">u16</span> <span class="n">int_freq</span><span class="p">)</span>
<span class="p">{</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">BASE</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BASE &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">INIT1</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;INIT1 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">F8MHZ</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;F8MHZ &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">MTS</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;MTS &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">D2620</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;D2620 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">D2633</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;D2633 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">DTV6</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DTV6 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">QAM</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;QAM &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">DTV7</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DTV7 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">DTV78</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DTV78 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">DTV8</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DTV8 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">FM</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;FM &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">INPUT1</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;INPUT1 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">LCD</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;LCD &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">NOGD</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;NOGD &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">MONO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;MONO &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">ATSC</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ATSC &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">IF</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;IF &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">LG60</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;LG60 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">ATI638</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ATI638 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">OREN538</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;OREN538 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">OREN36</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;OREN36 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">TOYOTA388</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;TOYOTA388 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">TOYOTA794</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;TOYOTA794 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">DIBCOM52</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DIBCOM52 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">ZARLINK456</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ZARLINK456 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">CHINA</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CHINA &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">F6MHZ</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;F6MHZ &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">INPUT2</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;INPUT2 &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">SCODE</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SCODE &quot;</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">HAS_IF</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;HAS_IF_%d &quot;</span><span class="p">,</span> <span class="n">int_freq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span>  <span class="n">v4l2_std_id</span> <span class="nf">parse_audio_std_option</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">audio_std</span><span class="p">,</span> <span class="s">&quot;A2&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">V4L2_STD_A2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">audio_std</span><span class="p">,</span> <span class="s">&quot;A2/A&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">V4L2_STD_A2_A</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">audio_std</span><span class="p">,</span> <span class="s">&quot;A2/B&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">V4L2_STD_A2_B</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">audio_std</span><span class="p">,</span> <span class="s">&quot;NICAM&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">V4L2_STD_NICAM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">audio_std</span><span class="p">,</span> <span class="s">&quot;NICAM/A&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">V4L2_STD_NICAM_A</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">audio_std</span><span class="p">,</span> <span class="s">&quot;NICAM/B&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">V4L2_STD_NICAM_B</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">xc2028_data</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ptr</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_all_firmwares</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xc2028_data</span>    <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span>   <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span>   <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>
	<span class="kt">int</span>                   <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		      <span class="n">n</span><span class="p">,</span> <span class="n">n_array</span><span class="p">;</span>
	<span class="kt">char</span>		      <span class="n">name</span><span class="p">[</span><span class="mi">33</span><span class="p">];</span>
	<span class="kt">char</span>		      <span class="o">*</span><span class="n">fname</span><span class="p">;</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">firmware_name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">fname</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">fname</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">fname</span> <span class="o">=</span> <span class="n">firmware_name</span><span class="p">;</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;Reading firmware %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fname</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">request_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fw</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">i2c_props</span><span class="p">.</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Error: firmware %s not found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">fname</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Error %d while requesting firmware %s </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">rc</span><span class="p">,</span> <span class="n">fname</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">endp</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Error: firmware file %s has invalid size!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">fname</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">corrupt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">name</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm_version</span> <span class="o">=</span> <span class="n">get_unaligned_le16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">n_array</span> <span class="o">=</span> <span class="n">get_unaligned_le16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">tuner_info</span><span class="p">(</span><span class="s">&quot;Loading %d firmware images from %s, type: %s, ver %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">n_array</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
		   <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm_version</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm_version</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">n_array</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Not enough memory to load firmware file.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm_size</span> <span class="o">=</span> <span class="n">n_array</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">endp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__u32</span> <span class="n">type</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">v4l2_std_id</span> <span class="n">id</span><span class="p">;</span>
		<span class="n">__u16</span> <span class="n">int_freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">n_array</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;More firmware images in file than &quot;</span>
				  <span class="s">&quot;were expected!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">corrupt</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Checks if there&#39;s enough bytes to read */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">endp</span> <span class="o">-</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">header</span><span class="p">;</span>

		<span class="n">type</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>

		<span class="n">id</span> <span class="o">=</span> <span class="n">get_unaligned_le64</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">HAS_IF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">int_freq</span> <span class="o">=</span> <span class="n">get_unaligned_le16</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">int_freq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">endp</span> <span class="o">-</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">header</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">endp</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Firmware type &quot;</span><span class="p">);</span>
			<span class="n">dump_firm_type</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%x), id %llx is corrupted &quot;</span>
			       <span class="s">&quot;(size=%d, expected %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">id</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">endp</span> <span class="o">-</span> <span class="n">p</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">corrupt</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Not enough memory to load firmware file.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;Reading firmware type &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dump_firm_type_and_int_freq</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">int_freq</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%x), id %llx, size=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">id</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">ptr</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">id</span>   <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">int_freq</span> <span class="o">=</span> <span class="n">int_freq</span><span class="p">;</span>

		<span class="n">p</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Firmware file is incomplete!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">corrupt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

<span class="nl">header:</span>
	<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Firmware header is incomplete!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="nl">corrupt:</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Error: firmware file is corrupted!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">err:</span>
	<span class="n">tuner_info</span><span class="p">(</span><span class="s">&quot;Releasing partially loaded firmware file.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">free_firmware</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;Firmware files loaded.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">seek_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
			 <span class="n">v4l2_std_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xc2028_data</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span><span class="p">;</span>
	<span class="kt">int</span>                 <span class="n">i</span><span class="p">,</span> <span class="n">best_i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">best_nr_matches</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>        <span class="n">type_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;%s called, want type=&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dump_firm_type</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%x), id %016llx.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Error! firmware not loaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">type</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SCODE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="n">V4L2_STD_PAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">BASE</span><span class="p">)</span>
		<span class="n">type_mask</span> <span class="o">=</span> <span class="n">BASE_TYPES</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">SCODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">&amp;=</span> <span class="n">SCODE_TYPES</span><span class="p">;</span>
		<span class="n">type_mask</span> <span class="o">=</span> <span class="n">SCODE_TYPES</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HAS_IF</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">DTV_TYPES</span><span class="p">)</span>
		<span class="n">type_mask</span> <span class="o">=</span> <span class="n">DTV_TYPES</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">STD_SPECIFIC_TYPES</span><span class="p">)</span>
		<span class="n">type_mask</span> <span class="o">=</span> <span class="n">STD_SPECIFIC_TYPES</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">&amp;=</span> <span class="n">type_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">SCODE</span><span class="p">))</span>
		<span class="n">type_mask</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Seek for exact match */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">==</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">type_mask</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">*</span><span class="n">id</span> <span class="o">==</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Seek for generic video standard match */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">v4l2_std_id</span> <span class="n">match_mask</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nr_matches</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">type_mask</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">match_mask</span> <span class="o">=</span> <span class="o">*</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match_mask</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">match_mask</span><span class="p">)</span> <span class="o">==</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span> <span class="cm">/* Supports all the requested standards */</span>

		<span class="n">nr_matches</span> <span class="o">=</span> <span class="n">hweight64</span><span class="p">(</span><span class="n">match_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_matches</span> <span class="o">&gt;</span> <span class="n">best_nr_matches</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">best_nr_matches</span> <span class="o">=</span> <span class="n">nr_matches</span><span class="p">;</span>
			<span class="n">best_i</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">best_nr_matches</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;Selecting best matching firmware (%d bits) for &quot;</span>
			  <span class="s">&quot;type=&quot;</span><span class="p">,</span> <span class="n">best_nr_matches</span><span class="p">);</span>
		<span class="n">dump_firm_type</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%x), id %016llx:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">id</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">best_i</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*FIXME: Would make sense to seek for type &quot;hint&quot; match ? */</span>

	<span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">;</span>

<span class="nl">ret:</span>
	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;%s firmware for type=&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Can&#39;t find&quot;</span> <span class="o">:</span> <span class="s">&quot;Found&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dump_firm_type</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%x), id %016llx.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">do_tuner_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xc2028_data</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span><span class="p">;</span>

	<span class="cm">/* analog side (tuner-core) uses i2c_adap-&gt;algo_data.</span>
<span class="cm">	 * digital side is not guaranteed to have algo_data defined.</span>
<span class="cm">	 *</span>
<span class="cm">	 * digital side will always have fe-&gt;dvb defined.</span>
<span class="cm">	 * analog side (tuner-core) doesn&#39;t (yet) define fe-&gt;dvb.</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">:</span>
		<span class="n">fe</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(((</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">dvb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">dvb</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">))</span> <span class="o">?</span>
				<span class="n">fe</span><span class="o">-&gt;</span><span class="n">dvb</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">:</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">i2c_props</span><span class="p">.</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">algo_data</span><span class="p">,</span>
			     <span class="n">DVB_FRONTEND_COMPONENT_TUNER</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
			 <span class="n">v4l2_std_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xc2028_data</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span><span class="p">;</span>
	<span class="kt">int</span>                <span class="n">pos</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>      <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">endp</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">max_len</span><span class="p">];</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">seek_firmware</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>

	<span class="n">tuner_info</span><span class="p">(</span><span class="s">&quot;Loading firmware for type=&quot;</span><span class="p">);</span>
	<span class="n">dump_firm_type</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">type</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%x), id %016llx.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">type</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">id</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">ptr</span><span class="p">;</span>
	<span class="n">endp</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">endp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__u16</span> <span class="n">size</span><span class="p">;</span>

		<span class="cm">/* Checks if there&#39;s enough bytes to read */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">endp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Firmware chunk size is wrong</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Special callback command received */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">do_tuner_callback</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">XC2028_TUNER_RESET</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Error at RESET code %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0xff00</span>:
				<span class="n">rc</span> <span class="o">=</span> <span class="n">do_tuner_callback</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">XC2028_RESET_CLK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Error at RESET code %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						  <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">);</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">tuner_info</span><span class="p">(</span><span class="s">&quot;Invalid RESET code %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">size</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Checks for a sleep command */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msleep</span><span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="mh">0x7fff</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">size</span> <span class="o">+</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">endp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;missing bytes: need %d, have %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">endp</span> <span class="o">-</span> <span class="n">p</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
		<span class="n">size</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/* Sends message chunks */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">max_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span>
				   <span class="n">size</span> <span class="o">:</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">max_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

			<span class="n">rc</span> <span class="o">=</span> <span class="n">i2c_send</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;%d returned from send</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">p</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* silently fail if the frontend doesn&#39;t support I2C flush */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">do_tuner_callback</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">XC2028_I2C_FLUSH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;error executing flush: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_scode</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
			 <span class="n">v4l2_std_id</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">int_freq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">scode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xc2028_data</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span><span class="p">;</span>
	<span class="kt">int</span>                <span class="n">pos</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	   <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">int_freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">seek_firmware</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm_size</span><span class="p">;</span> <span class="n">pos</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">int_freq</span> <span class="o">==</span> <span class="n">int_freq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">HAS_IF</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm_size</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">HAS_IF</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">12</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">||</span> <span class="n">scode</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="mi">12</span> <span class="o">*</span> <span class="n">scode</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* 16 SCODE entries per file; each SCODE entry is 12 bytes and</span>
<span class="cm">		 * has a 2-byte size header in the firmware format. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">14</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">||</span> <span class="n">scode</span> <span class="o">&gt;=</span> <span class="mi">16</span> <span class="o">||</span>
		    <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__u16</span> <span class="o">*</span><span class="p">)(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">14</span> <span class="o">*</span> <span class="n">scode</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">12</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="mi">14</span> <span class="o">*</span> <span class="n">scode</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tuner_info</span><span class="p">(</span><span class="s">&quot;Loading SCODE for type=&quot;</span><span class="p">);</span>
	<span class="n">dump_firm_type_and_int_freq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">type</span><span class="p">,</span>
				    <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">int_freq</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%x), id %016llx.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">type</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm_version</span> <span class="o">&lt;</span> <span class="mh">0x0202</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">send_seq</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="p">{</span><span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">});</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">send_seq</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="p">{</span><span class="mh">0xa0</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">});</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">i2c_send</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">send_seq</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="p">{</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x8c</span><span class="p">});</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
			  <span class="n">v4l2_std_id</span> <span class="n">std</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">int_freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xc2028_data</span>         <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">firmware_properties</span> <span class="n">new_fw</span><span class="p">;</span>
	<span class="kt">int</span>			   <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span>			   <span class="n">version</span><span class="p">,</span> <span class="n">hwmodel</span><span class="p">;</span>
	<span class="n">v4l2_std_id</span>		   <span class="n">std0</span><span class="p">;</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">fname</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tuner_info</span><span class="p">(</span><span class="s">&quot;xc2028/3028 firmware name not set!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">load_all_firmwares</span><span class="p">(</span><span class="n">fe</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">mts</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">FM</span><span class="p">))</span>
		<span class="n">type</span> <span class="o">|=</span> <span class="n">MTS</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">new_fw</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">new_fw</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">std</span><span class="p">;</span>
	<span class="n">new_fw</span><span class="p">.</span><span class="n">std_req</span> <span class="o">=</span> <span class="n">std</span><span class="p">;</span>
	<span class="n">new_fw</span><span class="p">.</span><span class="n">scode_table</span> <span class="o">=</span> <span class="n">SCODE</span> <span class="o">|</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">scode_table</span><span class="p">;</span>
	<span class="n">new_fw</span><span class="p">.</span><span class="n">scode_nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">new_fw</span><span class="p">.</span><span class="n">int_freq</span> <span class="o">=</span> <span class="n">int_freq</span><span class="p">;</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;checking firmware, user requested type=&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dump_firm_type</span><span class="p">(</span><span class="n">new_fw</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%x), id %016llx, &quot;</span><span class="p">,</span> <span class="n">new_fw</span><span class="p">.</span><span class="n">type</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">new_fw</span><span class="p">.</span><span class="n">std_req</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">int_freq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;scode_tbl &quot;</span><span class="p">);</span>
			<span class="n">dump_firm_type</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">scode_table</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;(%x), &quot;</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">scode_table</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;int_freq %d, &quot;</span><span class="p">,</span> <span class="n">new_fw</span><span class="p">.</span><span class="n">int_freq</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;scode_nr %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">new_fw</span><span class="p">.</span><span class="n">scode_nr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* No need to reload base firmware if it matches */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">BASE</span> <span class="o">|</span> <span class="n">new_fw</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BASE_TYPES</span><span class="p">)</span> <span class="o">==</span>
	    <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">BASE_TYPES</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;BASE firmware not changed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">skip_base</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Updating BASE - forget about all currently loaded firmware */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">));</span>

	<span class="cm">/* Reset is needed before loading firmware */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">do_tuner_callback</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">XC2028_TUNER_RESET</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* BASE firmwares are all std0 */</span>
	<span class="n">std0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">load_firmware</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">BASE</span> <span class="o">|</span> <span class="n">new_fw</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">std0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Error %d while loading base firmware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Load INIT1, if needed */</span>
	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;Load init1 firmware, if exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">load_firmware</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">BASE</span> <span class="o">|</span> <span class="n">INIT1</span> <span class="o">|</span> <span class="n">new_fw</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">std0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">load_firmware</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="p">(</span><span class="n">BASE</span> <span class="o">|</span> <span class="n">INIT1</span> <span class="o">|</span> <span class="n">new_fw</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">F8MHZ</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">std0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Error %d while loading init1 firmware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">skip_base:</span>
	<span class="cm">/*</span>
<span class="cm">	 * No need to reload standard specific firmware if base firmware</span>
<span class="cm">	 * was not reloaded and requested video standards have not changed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="p">(</span><span class="n">BASE</span> <span class="o">|</span> <span class="n">new_fw</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">.</span><span class="n">std_req</span> <span class="o">==</span> <span class="n">std</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;Std-specific firmware already loaded.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">skip_std_specific</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Reloading std-specific firmware forces a SCODE update */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">.</span><span class="n">scode_table</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">load_firmware</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">new_fw</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_fw</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">load_firmware</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">new_fw</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">F8MHZ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_fw</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

<span class="nl">skip_std_specific:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">.</span><span class="n">scode_table</span> <span class="o">==</span> <span class="n">new_fw</span><span class="p">.</span><span class="n">scode_table</span> <span class="o">&amp;&amp;</span>
	    <span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">.</span><span class="n">scode_nr</span> <span class="o">==</span> <span class="n">new_fw</span><span class="p">.</span><span class="n">scode_nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;SCODE firmware already loaded.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">check_device</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_fw</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">FM</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">check_device</span><span class="p">;</span>

	<span class="cm">/* Load SCODE firmware, if exists */</span>
	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;Trying to load scode %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">new_fw</span><span class="p">.</span><span class="n">scode_nr</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">load_scode</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">new_fw</span><span class="p">.</span><span class="n">type</span> <span class="o">|</span> <span class="n">new_fw</span><span class="p">.</span><span class="n">scode_table</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_fw</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
			<span class="n">new_fw</span><span class="p">.</span><span class="n">int_freq</span><span class="p">,</span> <span class="n">new_fw</span><span class="p">.</span><span class="n">scode_nr</span><span class="p">);</span>

<span class="nl">check_device:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xc2028_get_reg</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mh">0x0004</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">version</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">xc2028_get_reg</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mh">0x0008</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hwmodel</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Unable to read tuner registers.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;Device is Xceive %d version %d.%d, &quot;</span>
		  <span class="s">&quot;firmware version %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">hwmodel</span><span class="p">,</span> <span class="p">(</span><span class="n">version</span> <span class="o">&amp;</span> <span class="mh">0xf000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">,</span> <span class="p">(</span><span class="n">version</span> <span class="o">&amp;</span> <span class="mh">0xf00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span>
		  <span class="p">(</span><span class="n">version</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">version</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">read_not_reliable</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">read_not_reliable</span><span class="p">;</span>

	<span class="cm">/* Check firmware version against what we downloaded. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm_version</span> <span class="o">!=</span> <span class="p">((</span><span class="n">version</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span> <span class="o">|</span> <span class="p">(</span><span class="n">version</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">read_not_reliable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Incorrect readback of firmware version.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Returned an incorrect version. However, &quot;</span>
				  <span class="s">&quot;read is not reliable enough. Ignoring it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">hwmodel</span> <span class="o">=</span> <span class="mi">3028</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check that the tuner hardware model remains consistent over time. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hwmodel</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hwmodel</span> <span class="o">==</span> <span class="mi">2028</span> <span class="o">||</span> <span class="n">hwmodel</span> <span class="o">==</span> <span class="mi">3028</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hwmodel</span> <span class="o">=</span> <span class="n">hwmodel</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hwvers</span>  <span class="o">=</span> <span class="n">version</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">hwmodel</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">hwmodel</span> <span class="o">!=</span> <span class="n">hwmodel</span> <span class="o">||</span>
		   <span class="n">priv</span><span class="o">-&gt;</span><span class="n">hwvers</span> <span class="o">!=</span> <span class="p">(</span><span class="n">version</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tuner_err</span><span class="p">(</span><span class="s">&quot;Read invalid device hardware information - tuner &quot;</span>
			  <span class="s">&quot;hung?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">read_not_reliable:</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_fw</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * By setting BASE in cur_fw.type only after successfully loading all</span>
<span class="cm">	 * firmwares, we can:</span>
<span class="cm">	 * 1. Identify that BASE firmware with type=0 has been loaded;</span>
<span class="cm">	 * 2. Tell whether BASE firmware was just changed the next time through.</span>
<span class="cm">	 */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">.</span><span class="n">type</span> <span class="o">|=</span> <span class="n">BASE</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retry_count</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
		<span class="n">retry_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;Retrying firmware load</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xc2028_signal</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">strength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xc2028_data</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span><span class="p">;</span>
	<span class="n">u16</span>                 <span class="n">frq_lock</span><span class="p">,</span> <span class="n">signal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>                 <span class="n">rc</span><span class="p">;</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Sync Lock Indicator */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">xc2028_get_reg</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">XREG_LOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frq_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Frequency is locked */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frq_lock</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">signal</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">;</span>

	<span class="cm">/* Get SNR of the video signal */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">xc2028_get_reg</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">XREG_SNR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">signal</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Use both frq_lock and signal to generate the result */</span>
	<span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span> <span class="o">||</span> <span class="p">((</span><span class="n">signal</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>

<span class="nl">ret:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="o">*</span><span class="n">strength</span> <span class="o">=</span> <span class="n">signal</span><span class="p">;</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;signal strength is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">signal</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define DIV 15625</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">generic_set_freq</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">,</span> <span class="n">u32</span> <span class="n">freq</span> <span class="cm">/* in HZ */</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">v4l2_tuner_type</span> <span class="n">new_type</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
			    <span class="n">v4l2_std_id</span> <span class="n">std</span><span class="p">,</span>
			    <span class="n">u16</span> <span class="n">int_freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xc2028_data</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span><span class="p">;</span>
	<span class="kt">int</span>		   <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	   <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span>		   <span class="n">div</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;should set frequency %d kHz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">freq</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_firmware</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">int_freq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* On some cases xc2028 can disable video output, if</span>
<span class="cm">	 * very weak signals are received. By sending a soft</span>
<span class="cm">	 * reset, this is re-enabled. So, it is better to always</span>
<span class="cm">	 * send a soft reset before changing channels, to be sure</span>
<span class="cm">	 * that xc2028 will be in a safe state.</span>
<span class="cm">	 * Maybe this might also be needed for DTV.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">new_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">V4L2_TUNER_ANALOG_TV</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">send_seq</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="p">{</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">});</span>

		<span class="cm">/* Analog mode requires offset = 0 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">V4L2_TUNER_RADIO</span>:
		<span class="cm">/* Radio mode requires offset = 0 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">V4L2_TUNER_DIGITAL_TV</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Digital modes require an offset to adjust to the</span>
<span class="cm">		 * proper frequency. The offset depends on what</span>
<span class="cm">		 * firmware version is used.</span>
<span class="cm">		 */</span>

		<span class="cm">/*</span>
<span class="cm">		 * Adjust to the center frequency. This is calculated by the</span>
<span class="cm">		 * formula: offset = 1.25MHz - BW/2</span>
<span class="cm">		 * For DTV 7/8, the firmware uses BW = 8000, so it needs a</span>
<span class="cm">		 * further adjustment to get the frequency center on VHF</span>
<span class="cm">		 */</span>

		<span class="cm">/*</span>
<span class="cm">		 * The firmware DTV78 used to work fine in UHF band (8 MHz</span>
<span class="cm">		 * bandwidth) but not at all in VHF band (7 MHz bandwidth).</span>
<span class="cm">		 * The real problem was connected to the formula used to</span>
<span class="cm">		 * calculate the center frequency offset in VHF band.</span>
<span class="cm">		 * In fact, removing the 500KHz adjustment fixed the problem.</span>
<span class="cm">		 * This is coherent to what was implemented for the DTV7</span>
<span class="cm">		 * firmware.</span>
<span class="cm">		 * In the end, now the center frequency is the same for all 3</span>
<span class="cm">		 * firmwares (DTV7, DTV8, DTV78) and doesn&#39;t depend on channel</span>
<span class="cm">		 * bandwidth.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">DTV6</span><span class="p">)</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="mi">1750000</span><span class="p">;</span>
		<span class="k">else</span>	<span class="cm">/* DTV7 or DTV8 or DTV78 */</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="mi">2750000</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * xc3028 additional &quot;magic&quot;</span>
<span class="cm">		 * Depending on the firmware version, it needs some adjustments</span>
<span class="cm">		 * to properly centralize the frequency. This seems to be</span>
<span class="cm">		 * needed to compensate the SCODE table adjustments made by</span>
<span class="cm">		 * newer firmwares</span>
<span class="cm">		 */</span>

		<span class="cm">/*</span>
<span class="cm">		 * The proper adjustment would be to do it at s-code table.</span>
<span class="cm">		 * However, this didn&#39;t work, as reported by</span>
<span class="cm">		 * Robert Lowery &lt;rglowery@exemail.com.au&gt;</span>
<span class="cm">		 */</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		/*</span>
<span class="c">		 * Still need tests for XC3028L (firmware 3.2 or upper)</span>
<span class="c">		 * So, for now, let&#39;s just comment the per-firmware</span>
<span class="c">		 * version of this change. Reports with xc3028l working</span>
<span class="c">		 * with and without the lines bellow are welcome</span>
<span class="c">		 */</span>

<span class="c">		if (priv-&gt;firm_version &lt; 0x0302) {</span>
<span class="c">			if (priv-&gt;cur_fw.type &amp; DTV7)</span>
<span class="c">				offset += 500000;</span>
<span class="c">		} else {</span>
<span class="c">			if (priv-&gt;cur_fw.type &amp; DTV7)</span>
<span class="c">				offset -= 300000;</span>
<span class="c">			else if (type != ATSC) /* DVB @6MHz, DTV 8 and DTV 7/8 */</span>
<span class="c">				offset += 200000;</span>
<span class="c">		}</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">div</span> <span class="o">=</span> <span class="p">(</span><span class="n">freq</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">DIV</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">DIV</span><span class="p">;</span>

	<span class="cm">/* CMD= Set frequency */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm_version</span> <span class="o">&lt;</span> <span class="mh">0x0202</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">send_seq</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="p">{</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">XREG_RF_FREQ</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">});</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">send_seq</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="p">{</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">XREG_RF_FREQ</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">});</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Return code shouldn&#39;t be checked.</span>
<span class="cm">	   The reset CLK is needed only with tm6000.</span>
<span class="cm">	   Driver should work fine even if this fails.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">msleep</span><span class="p">)</span>
		<span class="n">msleep</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">msleep</span><span class="p">);</span>
	<span class="n">do_tuner_callback</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">XC2028_RESET_CLK</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">div</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">div</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">div</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">div</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">i2c_send</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">frequency</span> <span class="o">=</span> <span class="n">freq</span><span class="p">;</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;divisor= %02x %02x %02x %02x (freq=%d.%03d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
	       <span class="n">freq</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span> <span class="o">%</span> <span class="mi">1000000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">ret:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xc2028_set_analog_freq</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">analog_parameters</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xc2028_data</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>       <span class="n">type</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">V4L2_TUNER_RADIO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">|=</span> <span class="n">FM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">input1</span><span class="p">)</span>
			<span class="n">type</span> <span class="o">|=</span> <span class="n">INPUT1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">generic_set_freq</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="p">(</span><span class="mi">625l</span> <span class="o">*</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">frequency</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">,</span>
				<span class="n">V4L2_TUNER_RADIO</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* if std is not defined, choose one */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">std</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">std</span> <span class="o">=</span> <span class="n">V4L2_STD_MN</span><span class="p">;</span>

	<span class="cm">/* PAL/M, PAL/N, PAL/Nc and NTSC variants should use 6MHz firmware */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">std</span> <span class="o">&amp;</span> <span class="n">V4L2_STD_MN</span><span class="p">))</span>
		<span class="n">type</span> <span class="o">|=</span> <span class="n">F8MHZ</span><span class="p">;</span>

	<span class="cm">/* Add audio hack to std mask */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">std</span> <span class="o">|=</span> <span class="n">parse_audio_std_option</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">generic_set_freq</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="mi">62500l</span> <span class="o">*</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">frequency</span><span class="p">,</span>
				<span class="n">V4L2_TUNER_ANALOG_TV</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">std</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xc2028_set_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dtv_frontend_properties</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">dtv_property_cache</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">delsys</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">delivery_system</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bw</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bandwidth_hz</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xc2028_data</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>       <span class="n">type</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span>                <span class="n">demod</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">delsys</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SYS_DVBT</span>:
	<span class="k">case</span> <span class="n">SYS_DVBT2</span>:
		<span class="cm">/*</span>
<span class="cm">		 * The only countries with 6MHz seem to be Taiwan/Uruguay.</span>
<span class="cm">		 * Both seem to require QAM firmware for OFDM decoding</span>
<span class="cm">		 * Tested in Taiwan by Terry Wu &lt;terrywu2009@gmail.com&gt;</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bw</span> <span class="o">&lt;=</span> <span class="mi">6000000</span><span class="p">)</span>
			<span class="n">type</span> <span class="o">|=</span> <span class="n">QAM</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">XC2028_D2633</span>:
			<span class="n">type</span> <span class="o">|=</span> <span class="n">D2633</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XC2028_D2620</span>:
			<span class="n">type</span> <span class="o">|=</span> <span class="n">D2620</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">XC2028_AUTO</span>:
		<span class="nl">default:</span>
			<span class="cm">/* Zarlink seems to need D2633 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">demod</span> <span class="o">==</span> <span class="n">XC3028_FE_ZARLINK456</span><span class="p">)</span>
				<span class="n">type</span> <span class="o">|=</span> <span class="n">D2633</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">type</span> <span class="o">|=</span> <span class="n">D2620</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_ATSC</span>:
		<span class="cm">/* The only ATSC firmware (at least on v2.7) is D2633 */</span>
		<span class="n">type</span> <span class="o">|=</span> <span class="n">ATSC</span> <span class="o">|</span> <span class="n">D2633</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/* DVB-S and pure QAM (FE_QAM) are not supported */</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bw</span> <span class="o">&lt;=</span> <span class="mi">6000000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">type</span> <span class="o">|=</span> <span class="n">DTV6</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">vhfbw7</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">uhfbw8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bw</span> <span class="o">&lt;=</span> <span class="mi">7000000</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">frequency</span> <span class="o">&lt;</span> <span class="mi">470000000</span><span class="p">)</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">vhfbw7</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">uhfbw8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">type</span> <span class="o">|=</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">vhfbw7</span> <span class="o">&amp;&amp;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">uhfbw8</span><span class="p">)</span> <span class="o">?</span> <span class="n">DTV78</span> <span class="o">:</span> <span class="n">DTV7</span><span class="p">;</span>
		<span class="n">type</span> <span class="o">|=</span> <span class="n">F8MHZ</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">frequency</span> <span class="o">&lt;</span> <span class="mi">470000000</span><span class="p">)</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">vhfbw7</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">uhfbw8</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">type</span> <span class="o">|=</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">vhfbw7</span> <span class="o">&amp;&amp;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">uhfbw8</span><span class="p">)</span> <span class="o">?</span> <span class="n">DTV78</span> <span class="o">:</span> <span class="n">DTV8</span><span class="p">;</span>
		<span class="n">type</span> <span class="o">|=</span> <span class="n">F8MHZ</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* All S-code tables need a 200kHz shift */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">demod</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">demod</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">demod</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Newer firmwares require a 200 kHz offset only for ATSC</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">ATSC</span> <span class="o">||</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm_version</span> <span class="o">&lt;</span> <span class="mh">0x0302</span><span class="p">)</span>
			<span class="n">demod</span> <span class="o">+=</span> <span class="mi">200</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The DTV7 S-code table needs a 700 kHz shift.</span>
<span class="cm">		 *</span>
<span class="cm">		 * DTV7 is only used in Australia.  Germany or Italy may also</span>
<span class="cm">		 * use this firmware after initialization, but a tune to a UHF</span>
<span class="cm">		 * channel should then cause DTV78 to be used.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Unfortunately, on real-field tests, the s-code offset</span>
<span class="cm">		 * didn&#39;t work as expected, as reported by</span>
<span class="cm">		 * Robert Lowery &lt;rglowery@exemail.com.au&gt;</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">generic_set_freq</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">frequency</span><span class="p">,</span>
				<span class="n">V4L2_TUNER_DIGITAL_TV</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">demod</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xc2028_sleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xc2028_data</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Avoid firmware reload on slow devices or if PM disabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">no_poweroff</span> <span class="o">||</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">disable_power_mgmt</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;Putting xc2028/3028 into poweroff mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;Printing sleep stack trace:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">firm_version</span> <span class="o">&lt;</span> <span class="mh">0x0202</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">send_seq</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="p">{</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">XREG_POWER_DOWN</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">});</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">send_seq</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="p">{</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">XREG_POWER_DOWN</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">});</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">cur_fw</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* need firmware reload */</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xc2028_dvb_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xc2028_data</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span><span class="p">;</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xc2028_list_mutex</span><span class="p">);</span>

	<span class="cm">/* only perform final cleanup if this is the last instance */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hybrid_tuner_report_instance_count</span><span class="p">(</span><span class="n">priv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">fname</span><span class="p">);</span>
		<span class="n">free_firmware</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="p">)</span>
		<span class="n">hybrid_tuner_release_state</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xc2028_list_mutex</span><span class="p">);</span>

	<span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xc2028_get_frequency</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">frequency</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xc2028_data</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span><span class="p">;</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="o">*</span><span class="n">frequency</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">frequency</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xc2028_set_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv_cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xc2028_data</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xc2028_ctrl</span> <span class="o">*</span><span class="n">p</span>    <span class="o">=</span> <span class="n">priv_cfg</span><span class="p">;</span>
	<span class="kt">int</span>                 <span class="n">rc</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tuner_dbg</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">max_len</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">)</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">max_len</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">fname</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">fname</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">fname</span><span class="p">);</span>
			<span class="n">free_firmware</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">fname</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">fname</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dvb_tuner_ops</span> <span class="n">xc2028_dvb_tuner_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
		 <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Xceive XC3028&quot;</span><span class="p">,</span>
		 <span class="p">.</span><span class="n">frequency_min</span> <span class="o">=</span> <span class="mi">42000000</span><span class="p">,</span>
		 <span class="p">.</span><span class="n">frequency_max</span> <span class="o">=</span> <span class="mi">864000000</span><span class="p">,</span>
		 <span class="p">.</span><span class="n">frequency_step</span> <span class="o">=</span> <span class="mi">50000</span><span class="p">,</span>
		 <span class="p">},</span>

	<span class="p">.</span><span class="n">set_config</span>	   <span class="o">=</span> <span class="n">xc2028_set_config</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_analog_params</span> <span class="o">=</span> <span class="n">xc2028_set_analog_freq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>           <span class="o">=</span> <span class="n">xc2028_dvb_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_frequency</span>     <span class="o">=</span> <span class="n">xc2028_get_frequency</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_rf_strength</span>   <span class="o">=</span> <span class="n">xc2028_signal</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_params</span>        <span class="o">=</span> <span class="n">xc2028_set_params</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sleep</span>             <span class="o">=</span> <span class="n">xc2028_sleep</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="nf">xc2028_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xc2028_config</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xc2028_data</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">instance</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;xc2028: Xcv2028/3028 init called!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">cfg</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;xc2028: No frontend!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xc2028_list_mutex</span><span class="p">);</span>

	<span class="n">instance</span> <span class="o">=</span> <span class="n">hybrid_tuner_request_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">xc2028_data</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span>
					      <span class="n">hybrid_tuner_instance_list</span><span class="p">,</span>
					      <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">i2c_adap</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">i2c_addr</span><span class="p">,</span>
					      <span class="s">&quot;xc2028&quot;</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/* memory allocation failure */</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="cm">/* new tuner instance */</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">max_len</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>

		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="cm">/* existing tuner instance */</span>
		<span class="n">fe</span><span class="o">-&gt;</span><span class="n">tuner_priv</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">tuner_ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xc2028_dvb_tuner_ops</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">xc2028_dvb_tuner_ops</span><span class="p">));</span>

	<span class="n">tuner_info</span><span class="p">(</span><span class="s">&quot;type set to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;XCeive xc2028/xc3028 tuner&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">)</span>
		<span class="n">xc2028_set_config</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xc2028_list_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fe</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xc2028_list_mutex</span><span class="p">);</span>

	<span class="n">xc2028_dvb_release</span><span class="p">(</span><span class="n">fe</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">xc2028_attach</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Xceive xc2028/xc3028 tuner driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Michel Ludwig &lt;michel.ludwig@gmail.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
