<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › aptina-pll.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>aptina-pll.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Aptina Sensor PLL Configuration</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2012 Laurent Pinchart &lt;laurent.pinchart@ideasonboard.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * version 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/gcd.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/lcm.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &quot;aptina-pll.h&quot;</span>

<span class="kt">int</span> <span class="nf">aptina_pll_calculate</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">aptina_pll_limits</span> <span class="o">*</span><span class="n">limits</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">aptina_pll</span> <span class="o">*</span><span class="n">pll</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mf_min</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mf_max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p1_min</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p1_max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">div</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PLL: ext clock %u pix clock %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">pll</span><span class="o">-&gt;</span><span class="n">ext_clock</span><span class="p">,</span> <span class="n">pll</span><span class="o">-&gt;</span><span class="n">pix_clock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pll</span><span class="o">-&gt;</span><span class="n">ext_clock</span> <span class="o">&lt;</span> <span class="n">limits</span><span class="o">-&gt;</span><span class="n">ext_clock_min</span> <span class="o">||</span>
	    <span class="n">pll</span><span class="o">-&gt;</span><span class="n">ext_clock</span> <span class="o">&gt;</span> <span class="n">limits</span><span class="o">-&gt;</span><span class="n">ext_clock_max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll: invalid external clock frequency.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pll</span><span class="o">-&gt;</span><span class="n">pix_clock</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pll</span><span class="o">-&gt;</span><span class="n">pix_clock</span> <span class="o">&gt;</span> <span class="n">limits</span><span class="o">-&gt;</span><span class="n">pix_clock_max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll: invalid pixel clock frequency.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Compute the multiplier M and combined N*P1 divisor. */</span>
	<span class="n">div</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">pll</span><span class="o">-&gt;</span><span class="n">pix_clock</span><span class="p">,</span> <span class="n">pll</span><span class="o">-&gt;</span><span class="n">ext_clock</span><span class="p">);</span>
	<span class="n">pll</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">=</span> <span class="n">pll</span><span class="o">-&gt;</span><span class="n">pix_clock</span> <span class="o">/</span> <span class="n">div</span><span class="p">;</span>
	<span class="n">div</span> <span class="o">=</span> <span class="n">pll</span><span class="o">-&gt;</span><span class="n">ext_clock</span> <span class="o">/</span> <span class="n">div</span><span class="p">;</span>

	<span class="cm">/* We now have the smallest M and N*P1 values that will result in the</span>
<span class="cm">	 * desired pixel clock frequency, but they might be out of the valid</span>
<span class="cm">	 * range. Compute the factor by which we should multiply them given the</span>
<span class="cm">	 * following constraints:</span>
<span class="cm">	 *</span>
<span class="cm">	 * - minimum/maximum multiplier</span>
<span class="cm">	 * - minimum/maximum multiplier output clock frequency assuming the</span>
<span class="cm">	 *   minimum/maximum N value</span>
<span class="cm">	 * - minimum/maximum combined N*P1 divisor</span>
<span class="cm">	 */</span>
	<span class="n">mf_min</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">limits</span><span class="o">-&gt;</span><span class="n">m_min</span><span class="p">,</span> <span class="n">pll</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
	<span class="n">mf_min</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">mf_min</span><span class="p">,</span> <span class="n">limits</span><span class="o">-&gt;</span><span class="n">out_clock_min</span> <span class="o">/</span>
		     <span class="p">(</span><span class="n">pll</span><span class="o">-&gt;</span><span class="n">ext_clock</span> <span class="o">/</span> <span class="n">limits</span><span class="o">-&gt;</span><span class="n">n_min</span> <span class="o">*</span> <span class="n">pll</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">));</span>
	<span class="n">mf_min</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">mf_min</span><span class="p">,</span> <span class="n">limits</span><span class="o">-&gt;</span><span class="n">n_min</span> <span class="o">*</span> <span class="n">limits</span><span class="o">-&gt;</span><span class="n">p1_min</span> <span class="o">/</span> <span class="n">div</span><span class="p">);</span>
	<span class="n">mf_max</span> <span class="o">=</span> <span class="n">limits</span><span class="o">-&gt;</span><span class="n">m_max</span> <span class="o">/</span> <span class="n">pll</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">;</span>
	<span class="n">mf_max</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">mf_max</span><span class="p">,</span> <span class="n">limits</span><span class="o">-&gt;</span><span class="n">out_clock_max</span> <span class="o">/</span>
		    <span class="p">(</span><span class="n">pll</span><span class="o">-&gt;</span><span class="n">ext_clock</span> <span class="o">/</span> <span class="n">limits</span><span class="o">-&gt;</span><span class="n">n_max</span> <span class="o">*</span> <span class="n">pll</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">));</span>
	<span class="n">mf_max</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">mf_max</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">limits</span><span class="o">-&gt;</span><span class="n">n_max</span> <span class="o">*</span> <span class="n">limits</span><span class="o">-&gt;</span><span class="n">p1_max</span><span class="p">,</span> <span class="n">div</span><span class="p">));</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll: mf min %u max %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mf_min</span><span class="p">,</span> <span class="n">mf_max</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mf_min</span> <span class="o">&gt;</span> <span class="n">mf_max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll: no valid combined N*P1 divisor.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re looking for the highest acceptable P1 value for which a</span>
<span class="cm">	 * multiplier factor MF exists that fulfills the following conditions:</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1. p1 is in the [p1_min, p1_max] range given by the limits and is</span>
<span class="cm">	 *    even</span>
<span class="cm">	 * 2. mf is in the [mf_min, mf_max] range computed above</span>
<span class="cm">	 * 3. div * mf is a multiple of p1, in order to compute</span>
<span class="cm">	 *	n = div * mf / p1</span>
<span class="cm">	 *	m = pll-&gt;m * mf</span>
<span class="cm">	 * 4. the internal clock frequency, given by ext_clock / n, is in the</span>
<span class="cm">	 *    [int_clock_min, int_clock_max] range given by the limits</span>
<span class="cm">	 * 5. the output clock frequency, given by ext_clock / n * m, is in the</span>
<span class="cm">	 *    [out_clock_min, out_clock_max] range given by the limits</span>
<span class="cm">	 *</span>
<span class="cm">	 * The first naive approach is to iterate over all p1 values acceptable</span>
<span class="cm">	 * according to (1) and all mf values acceptable according to (2), and</span>
<span class="cm">	 * stop at the first combination that fulfills (3), (4) and (5). This</span>
<span class="cm">	 * has a O(n^2) complexity.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Instead of iterating over all mf values in the [mf_min, mf_max] range</span>
<span class="cm">	 * we can compute the mf increment between two acceptable values</span>
<span class="cm">	 * according to (3) with</span>
<span class="cm">	 *</span>
<span class="cm">	 *	mf_inc = p1 / gcd(div, p1)			(6)</span>
<span class="cm">	 *</span>
<span class="cm">	 * and round the minimum up to the nearest multiple of mf_inc. This will</span>
<span class="cm">	 * restrict the number of mf values to be checked.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Furthermore, conditions (4) and (5) only restrict the range of</span>
<span class="cm">	 * acceptable p1 and mf values by modifying the minimum and maximum</span>
<span class="cm">	 * limits. (5) can be expressed as</span>
<span class="cm">	 *</span>
<span class="cm">	 *	ext_clock / (div * mf / p1) * m * mf &gt;= out_clock_min</span>
<span class="cm">	 *	ext_clock / (div * mf / p1) * m * mf &lt;= out_clock_max</span>
<span class="cm">	 *</span>
<span class="cm">	 * or</span>
<span class="cm">	 *</span>
<span class="cm">	 *	p1 &gt;= out_clock_min * div / (ext_clock * m)	(7)</span>
<span class="cm">	 *	p1 &lt;= out_clock_max * div / (ext_clock * m)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Similarly, (4) can be expressed as</span>
<span class="cm">	 *</span>
<span class="cm">	 *	mf &gt;= ext_clock * p1 / (int_clock_max * div)	(8)</span>
<span class="cm">	 *	mf &lt;= ext_clock * p1 / (int_clock_min * div)</span>
<span class="cm">	 *</span>
<span class="cm">	 * We can thus iterate over the restricted p1 range defined by the</span>
<span class="cm">	 * combination of (1) and (7), and then compute the restricted mf range</span>
<span class="cm">	 * defined by the combination of (2), (6) and (8). If the resulting mf</span>
<span class="cm">	 * range is not empty, any value in the mf range is acceptable. We thus</span>
<span class="cm">	 * select the mf lwoer bound and the corresponding p1 value.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">limits</span><span class="o">-&gt;</span><span class="n">p1_min</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll: P1 minimum value must be &gt;0.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p1_min</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">limits</span><span class="o">-&gt;</span><span class="n">p1_min</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">limits</span><span class="o">-&gt;</span><span class="n">out_clock_min</span> <span class="o">*</span> <span class="n">div</span><span class="p">,</span>
		     <span class="n">pll</span><span class="o">-&gt;</span><span class="n">ext_clock</span> <span class="o">*</span> <span class="n">pll</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">));</span>
	<span class="n">p1_max</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">limits</span><span class="o">-&gt;</span><span class="n">p1_max</span><span class="p">,</span> <span class="n">limits</span><span class="o">-&gt;</span><span class="n">out_clock_max</span> <span class="o">*</span> <span class="n">div</span> <span class="o">/</span>
		     <span class="p">(</span><span class="n">pll</span><span class="o">-&gt;</span><span class="n">ext_clock</span> <span class="o">*</span> <span class="n">pll</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p1</span> <span class="o">=</span> <span class="n">p1_max</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">;</span> <span class="n">p1</span> <span class="o">&gt;=</span> <span class="n">p1_min</span><span class="p">;</span> <span class="n">p1</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mf_inc</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">/</span> <span class="n">gcd</span><span class="p">(</span><span class="n">div</span><span class="p">,</span> <span class="n">p1</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mf_high</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mf_low</span><span class="p">;</span>

		<span class="n">mf_low</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">mf_min</span><span class="p">,</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">pll</span><span class="o">-&gt;</span><span class="n">ext_clock</span> <span class="o">*</span> <span class="n">p1</span><span class="p">,</span>
					<span class="n">limits</span><span class="o">-&gt;</span><span class="n">int_clock_max</span> <span class="o">*</span> <span class="n">div</span><span class="p">)),</span> <span class="n">mf_inc</span><span class="p">);</span>
		<span class="n">mf_high</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">mf_max</span><span class="p">,</span> <span class="n">pll</span><span class="o">-&gt;</span><span class="n">ext_clock</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">/</span>
			      <span class="p">(</span><span class="n">limits</span><span class="o">-&gt;</span><span class="n">int_clock_min</span> <span class="o">*</span> <span class="n">div</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mf_low</span> <span class="o">&gt;</span> <span class="n">mf_high</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pll</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">=</span> <span class="n">div</span> <span class="o">*</span> <span class="n">mf_low</span> <span class="o">/</span> <span class="n">p1</span><span class="p">;</span>
		<span class="n">pll</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">*=</span> <span class="n">mf_low</span><span class="p">;</span>
		<span class="n">pll</span><span class="o">-&gt;</span><span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PLL: N %u M %u P1 %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pll</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">,</span> <span class="n">pll</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">,</span> <span class="n">pll</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pll: no valid N and P1 divisors found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">aptina_pll_calculate</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Aptina PLL Helpers&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Laurent Pinchart &lt;laurent.pinchart@ideasonboard.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
