<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › via-camera.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>via-camera.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Driver for the VIA Chrome integrated camera controller.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2009,2010 Jonathan Corbet &lt;corbet@lwn.net&gt;</span>
<span class="cm"> * Distributable under the terms of the GNU General Public License, version 2</span>
<span class="cm"> *</span>
<span class="cm"> * This work was supported by the One Laptop Per Child project</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/gpio.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/videodev2.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-device.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-ioctl.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-chip-ident.h&gt;</span>
<span class="cp">#include &lt;media/ov7670.h&gt;</span>
<span class="cp">#include &lt;media/videobuf-dma-sg.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/pm_qos.h&gt;</span>
<span class="cp">#include &lt;linux/via-core.h&gt;</span>
<span class="cp">#include &lt;linux/via-gpio.h&gt;</span>
<span class="cp">#include &lt;linux/via_i2c.h&gt;</span>
<span class="cp">#include &lt;asm/olpc.h&gt;</span>

<span class="cp">#include &quot;via-camera.h&quot;</span>

<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:viafb-camera&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Jonathan Corbet &lt;corbet@lwn.net&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;VIA framebuffer-based camera controller driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">flip_image</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">flip_image</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">flip_image</span><span class="p">,</span>
		<span class="s">&quot;If set, the sensor will be instructed to flip the image &quot;</span>
		<span class="s">&quot;vertically.&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">override_serial</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">override_serial</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">override_serial</span><span class="p">,</span>
		<span class="s">&quot;The camera driver will normally refuse to load if &quot;</span>
		<span class="s">&quot;the XO 1.5 serial port is enabled.  Set this option &quot;</span>
		<span class="s">&quot;to force-enable the camera.&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Basic window sizes.</span>
<span class="cm"> */</span>
<span class="cp">#define VGA_WIDTH	640</span>
<span class="cp">#define VGA_HEIGHT	480</span>
<span class="cp">#define QCIF_WIDTH	176</span>
<span class="cp">#define	QCIF_HEIGHT	144</span>

<span class="cm">/*</span>
<span class="cm"> * The structure describing our camera.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">viacam_opstate</span> <span class="p">{</span> <span class="n">S_IDLE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">S_RUNNING</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>

<span class="k">struct</span> <span class="n">via_camera</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_device</span> <span class="n">v4l2_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">video_device</span> <span class="n">vdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sensor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">platdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">viafb_dev</span> <span class="o">*</span><span class="n">viadev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">viacam_opstate</span> <span class="n">opstate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pm_qos_request</span> <span class="n">qos_request</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * GPIO info for power/reset management</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">power_gpio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reset_gpio</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * I/O memory stuff.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">;</span>	<span class="cm">/* Where the registers live */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">fbmem</span><span class="p">;</span>	<span class="cm">/* Frame buffer memory */</span>
	<span class="n">u32</span> <span class="n">fb_offset</span><span class="p">;</span>		<span class="cm">/* Reserved memory offset (FB) */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Capture buffers and related.	 The controller supports</span>
<span class="cm">	 * up to three, so that&#39;s what we have here.  These buffers</span>
<span class="cm">	 * live in frame buffer memory, so we don&#39;t call them &quot;DMA&quot;.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cb_offsets</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* offsets into fb mem */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">cb_addrs</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* Kernel-space addresses */</span>
	<span class="kt">int</span> <span class="n">n_cap_bufs</span><span class="p">;</span>			<span class="cm">/* How many are we using? */</span>
	<span class="kt">int</span> <span class="n">next_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="n">vb_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">buffer_queue</span><span class="p">;</span>	<span class="cm">/* prot. by reg_lock */</span>
	<span class="cm">/*</span>
<span class="cm">	 * User tracking.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">users</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Video format information.  sensor_format is kept in a form</span>
<span class="cm">	 * that we can use to pass to the sensor.  We always run the</span>
<span class="cm">	 * sensor in VGA resolution, though, and let the controller</span>
<span class="cm">	 * downscale things if need be.	 So we keep the &quot;real*</span>
<span class="cm">	 * dimensions separately.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">v4l2_pix_format</span> <span class="n">sensor_format</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_pix_format</span> <span class="n">user_format</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">v4l2_mbus_pixelcode</span> <span class="n">mbus_code</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Yes, this is a hack, but there&#39;s only going to be one of these</span>
<span class="cm"> * on any system we know of.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">via_cam_info</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Flag values, manipulated with bitops</span>
<span class="cm"> */</span>
<span class="cp">#define CF_DMA_ACTIVE	 0	</span><span class="cm">/* A frame is incoming */</span><span class="cp"></span>
<span class="cp">#define CF_CONFIG_NEEDED 1	</span><span class="cm">/* Must configure hardware */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * Nasty ugly v4l2 boilerplate.</span>
<span class="cm"> */</span>
<span class="cp">#define sensor_call(cam, optype, func, args...) \</span>
<span class="cp">	v4l2_subdev_call(cam-&gt;sensor, optype, func, ##args)</span>

<span class="cm">/*</span>
<span class="cm"> * Debugging and related.</span>
<span class="cm"> */</span>
<span class="cp">#define cam_err(cam, fmt, arg...) \</span>
<span class="cp">	dev_err(&amp;(cam)-&gt;platdev-&gt;dev, fmt, ##arg);</span>
<span class="cp">#define cam_warn(cam, fmt, arg...) \</span>
<span class="cp">	dev_warn(&amp;(cam)-&gt;platdev-&gt;dev, fmt, ##arg);</span>
<span class="cp">#define cam_dbg(cam, fmt, arg...) \</span>
<span class="cp">	dev_dbg(&amp;(cam)-&gt;platdev-&gt;dev, fmt, ##arg);</span>

<span class="cm">/*</span>
<span class="cm"> * Format handling.  This is ripped almost directly from Hans&#39;s changes</span>
<span class="cm"> * to cafe_ccic.c.  It&#39;s a little unfortunate; until this change, we</span>
<span class="cm"> * didn&#39;t need to know anything about the format except its byte depth;</span>
<span class="cm"> * now this information must be managed at this level too.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">via_format</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pixelformat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bpp</span><span class="p">;</span>   <span class="cm">/* Bytes per pixel */</span>
	<span class="k">enum</span> <span class="n">v4l2_mbus_pixelcode</span> <span class="n">mbus_code</span><span class="p">;</span>
<span class="p">}</span> <span class="n">via_formats</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">desc</span>		<span class="o">=</span> <span class="s">&quot;YUYV 4:2:2&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pixelformat</span>	<span class="o">=</span> <span class="n">V4L2_PIX_FMT_YUYV</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mbus_code</span>	<span class="o">=</span> <span class="n">V4L2_MBUS_FMT_YUYV8_2X8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bpp</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="cm">/* RGB444 and Bayer should be doable, but have never been</span>
<span class="cm">	   tested with this driver. RGB565 seems to work at the default</span>
<span class="cm">	   resolution, but results in color corruption when being scaled by</span>
<span class="cm">	   viacam_set_scaled(), and is disabled as a result. */</span>
<span class="p">};</span>
<span class="cp">#define N_VIA_FMTS ARRAY_SIZE(via_formats)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">via_format</span> <span class="o">*</span><span class="nf">via_find_format</span><span class="p">(</span><span class="n">u32</span> <span class="n">pixelformat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_VIA_FMTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">via_formats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pixelformat</span> <span class="o">==</span> <span class="n">pixelformat</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">via_formats</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
	<span class="cm">/* Not found? Then return the first format. */</span>
	<span class="k">return</span> <span class="n">via_formats</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*--------------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Sensor power/reset management.  This piece is OLPC-specific for</span>
<span class="cm"> * sure; other configurations will have things connected differently.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">via_sensor_power_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">power_gpio</span> <span class="o">=</span> <span class="n">viafb_gpio_lookup</span><span class="p">(</span><span class="s">&quot;VGPIO3&quot;</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">reset_gpio</span> <span class="o">=</span> <span class="n">viafb_gpio_lookup</span><span class="p">(</span><span class="s">&quot;VGPIO2&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">power_gpio</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">reset_gpio</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">platdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to find GPIO lines</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">gpio_request</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">power_gpio</span><span class="p">,</span> <span class="s">&quot;viafb-camera&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">platdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to request power GPIO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">gpio_request</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">reset_gpio</span><span class="p">,</span> <span class="s">&quot;viafb-camera&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">platdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to request reset GPIO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">gpio_free</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">power_gpio</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">gpio_direction_output</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">power_gpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gpio_direction_output</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">reset_gpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Power up the sensor and perform the reset dance.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">via_sensor_power_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">power_gpio</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">reset_gpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>  <span class="cm">/* Probably excessive */</span>
	<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">reset_gpio</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">via_sensor_power_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">power_gpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">reset_gpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">via_sensor_power_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">via_sensor_power_down</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">gpio_free</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">power_gpio</span><span class="p">);</span>
	<span class="n">gpio_free</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">reset_gpio</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* --------------------------------------------------------------------------*/</span>
<span class="cm">/* Sensor ops */</span>

<span class="cm">/*</span>
<span class="cm"> * Manage the ov7670 &quot;flip&quot; bit, which needs special help.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_set_flip</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_control</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctrl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctrl</span><span class="p">));</span>
	<span class="n">ctrl</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">V4L2_CID_VFLIP</span><span class="p">;</span>
	<span class="n">ctrl</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">flip_image</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">s_ctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Configure the sensor.  It&#39;s up to the caller to ensure</span>
<span class="cm"> * that the camera is in the correct operating state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_configure_sensor</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_mbus_framefmt</span> <span class="n">mbus_fmt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">v4l2_fill_mbus_format</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbus_fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_format</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">mbus_code</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">s_mbus_fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbus_fmt</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * OV7670 does weird things if flip is set *before* format...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">viacam_set_flip</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/* --------------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Some simple register accessors; they assume that the lock is held.</span>
<span class="cm"> *</span>
<span class="cm"> * Should we want to support the second capture engine, we could</span>
<span class="cm"> * hide the register difference by adding 0x1000 to registers in the</span>
<span class="cm"> * 0x300-350 range.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">viacam_write_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">viacam_read_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">viacam_write_reg_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">viacam_read_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">viacam_write_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* --------------------------------------------------------------------------*/</span>
<span class="cm">/* Interrupt management and handling */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">viacam_quick_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">irqreturn_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">icv</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * All we do here is to clear the interrupts and tell</span>
<span class="cm">	 * the handler thread to wake up.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="n">icv</span> <span class="o">=</span> <span class="n">viacam_read_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_INTCTRL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icv</span> <span class="o">&amp;</span> <span class="n">VCR_IC_EAV</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">icv</span> <span class="o">|=</span> <span class="n">VCR_IC_EAV</span><span class="o">|</span><span class="n">VCR_IC_EVBI</span><span class="o">|</span><span class="n">VCR_IC_FFULL</span><span class="p">;</span>
		<span class="n">viacam_write_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_INTCTRL</span><span class="p">,</span> <span class="n">icv</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_WAKE_THREAD</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the next videobuf buffer which has somebody waiting on it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="nf">viacam_next_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">opstate</span> <span class="o">!=</span> <span class="n">S_RUNNING</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_queue</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_queue</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">videobuf_buffer</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">))</span> <span class="p">{</span><span class="cm">/* Nobody waiting */</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_ACTIVE</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The threaded IRQ handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">viacam_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bufn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">videobuf_dmabuf</span> <span class="o">*</span><span class="n">vdma</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is no place to put the data frame, don&#39;t bother</span>
<span class="cm">	 * with anything else.</span>
<span class="cm">	 */</span>
	<span class="n">vb</span> <span class="o">=</span> <span class="n">viacam_next_buffer</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Figure out which buffer we just completed.</span>
<span class="cm">	 */</span>
	<span class="n">bufn</span> <span class="o">=</span> <span class="p">(</span><span class="n">viacam_read_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_INTCTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">VCR_IC_ACTBUF</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">bufn</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bufn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">bufn</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">n_cap_bufs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy over the data and let any waiters know.</span>
<span class="cm">	 */</span>
	<span class="n">vdma</span> <span class="o">=</span> <span class="n">videobuf_to_dma</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
	<span class="n">viafb_dma_copy_out_sg</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">cb_offsets</span><span class="p">[</span><span class="n">bufn</span><span class="p">],</span> <span class="n">vdma</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">,</span> <span class="n">vdma</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">);</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_DONE</span><span class="p">;</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">user_format</span><span class="p">.</span><span class="n">sizeimage</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * These functions must mess around with the general interrupt</span>
<span class="cm"> * control register, which is relevant to much more than just the</span>
<span class="cm"> * camera.  Nothing else uses interrupts, though, as of this writing.</span>
<span class="cm"> * Should that situation change, we&#39;ll have to improve support at</span>
<span class="cm"> * the via-core level.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">viacam_int_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">viacam_write_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_INTCTRL</span><span class="p">,</span>
			<span class="n">VCR_IC_INTEN</span><span class="o">|</span><span class="n">VCR_IC_EAV</span><span class="o">|</span><span class="n">VCR_IC_EVBI</span><span class="o">|</span><span class="n">VCR_IC_FFULL</span><span class="p">);</span>
	<span class="n">viafb_irq_enable</span><span class="p">(</span><span class="n">VDE_I_C0AVEN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">viacam_int_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">viafb_irq_disable</span><span class="p">(</span><span class="n">VDE_I_C0AVEN</span><span class="p">);</span>
	<span class="n">viacam_write_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_INTCTRL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/* --------------------------------------------------------------------------*/</span>
<span class="cm">/* Controller operations */</span>

<span class="cm">/*</span>
<span class="cm"> * Set up our capture buffers in framebuffer memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_ctlr_cbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nbuf</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">camera_fbmem_size</span><span class="o">/</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_format</span><span class="p">.</span><span class="n">sizeimage</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * See how many buffers we can work with.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbuf</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">n_cap_bufs</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">viacam_write_reg_mask</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_CAPINTC</span><span class="p">,</span> <span class="n">VCR_CI_3BUFS</span><span class="p">,</span>
				<span class="n">VCR_CI_3BUFS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nbuf</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">n_cap_bufs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">viacam_write_reg_mask</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_CAPINTC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">VCR_CI_3BUFS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cam_warn</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;Insufficient frame buffer memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set them up.</span>
<span class="cm">	 */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">fb_offset</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">n_cap_bufs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">cb_offsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">cb_addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">fbmem</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">viacam_write_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_VBUF1</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="n">VCR_VBUF_MASK</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_format</span><span class="p">.</span><span class="n">sizeimage</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the scaling register for downscaling the image.</span>
<span class="cm"> *</span>
<span class="cm"> * This register works like this...  Vertical scaling is enabled</span>
<span class="cm"> * by bit 26; if that bit is set, downscaling is controlled by the</span>
<span class="cm"> * value in bits 16:25.	 Those bits are divided by 1024 to get</span>
<span class="cm"> * the scaling factor; setting just bit 25 thus cuts the height</span>
<span class="cm"> * in half.</span>
<span class="cm"> *</span>
<span class="cm"> * Horizontal scaling works about the same, but it&#39;s enabled by</span>
<span class="cm"> * bit 11, with bits 0:10 giving the numerator of a fraction</span>
<span class="cm"> * (over 2048) for the scaling value.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is naive in that, if the user departs from</span>
<span class="cm"> * the 3x4 VGA scaling factor, the image will distort.	We</span>
<span class="cm"> * could work around that if it really seemed important.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">viacam_set_scale</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">avscale</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">user_format</span><span class="p">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">VGA_WIDTH</span><span class="p">)</span>
		<span class="n">avscale</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">sf</span> <span class="o">=</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">user_format</span><span class="p">.</span><span class="n">width</span><span class="o">*</span><span class="mi">2048</span><span class="p">)</span><span class="o">/</span><span class="n">VGA_WIDTH</span><span class="p">;</span>
		<span class="n">avscale</span> <span class="o">=</span> <span class="n">VCR_AVS_HEN</span> <span class="o">|</span> <span class="n">sf</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">user_format</span><span class="p">.</span><span class="n">height</span> <span class="o">&lt;</span> <span class="n">VGA_HEIGHT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sf</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">user_format</span><span class="p">.</span><span class="n">height</span><span class="p">)</span><span class="o">/</span><span class="n">VGA_HEIGHT</span><span class="p">;</span>
		<span class="n">avscale</span> <span class="o">|=</span> <span class="n">VCR_AVS_VEN</span> <span class="o">|</span> <span class="p">(</span><span class="n">sf</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">viacam_write_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_AVSCALE</span><span class="p">,</span> <span class="n">avscale</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Configure image-related information into the capture engine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">viacam_ctlr_image</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cicreg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable clock before messing with stuff - from the via</span>
<span class="cm">	 * sample driver.</span>
<span class="cm">	 */</span>
	<span class="n">viacam_write_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_CAPINTC</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="n">VCR_CI_ENABLE</span><span class="o">|</span><span class="n">VCR_CI_CLKEN</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set up the controller for VGA resolution, modulo magic</span>
<span class="cm">	 * offsets from the via sample driver.</span>
<span class="cm">	 */</span>
	<span class="n">viacam_write_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_HORRANGE</span><span class="p">,</span> <span class="mh">0x06200120</span><span class="p">);</span>
	<span class="n">viacam_write_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_VERTRANGE</span><span class="p">,</span> <span class="mh">0x01de0000</span><span class="p">);</span>
	<span class="n">viacam_set_scale</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Image size info.</span>
<span class="cm">	 */</span>
	<span class="n">viacam_write_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_MAXDATA</span><span class="p">,</span>
			<span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_format</span><span class="p">.</span><span class="n">height</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_format</span><span class="p">.</span><span class="n">bytesperline</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">));</span>
	<span class="n">viacam_write_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_MAXVBI</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">viacam_write_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_VSTRIDE</span><span class="p">,</span>
			<span class="n">cam</span><span class="o">-&gt;</span><span class="n">user_format</span><span class="p">.</span><span class="n">bytesperline</span> <span class="o">&amp;</span> <span class="n">VCR_VS_STRIDE</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set up the capture interface control register,</span>
<span class="cm">	 * everything but the &quot;go&quot; bit.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The FIFO threshold is a bit of a magic number; 8 is what</span>
<span class="cm">	 * VIA&#39;s sample code uses.</span>
<span class="cm">	 */</span>
	<span class="n">cicreg</span> <span class="o">=</span> <span class="n">VCR_CI_CLKEN</span> <span class="o">|</span>
		<span class="mh">0x08000000</span> <span class="o">|</span>		<span class="cm">/* FIFO threshold */</span>
		<span class="n">VCR_CI_FLDINV</span> <span class="o">|</span>		<span class="cm">/* OLPC-specific? */</span>
		<span class="n">VCR_CI_VREFINV</span> <span class="o">|</span>	<span class="cm">/* OLPC-specific? */</span>
		<span class="n">VCR_CI_DIBOTH</span> <span class="o">|</span>		<span class="cm">/* Capture both fields */</span>
		<span class="n">VCR_CI_CCIR601_8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">n_cap_bufs</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">cicreg</span> <span class="o">|=</span> <span class="n">VCR_CI_3BUFS</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * YUV formats need different byte swapping than RGB.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">user_format</span><span class="p">.</span><span class="n">pixelformat</span> <span class="o">==</span> <span class="n">V4L2_PIX_FMT_YUYV</span><span class="p">)</span>
		<span class="n">cicreg</span> <span class="o">|=</span> <span class="n">VCR_CI_YUYV</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cicreg</span> <span class="o">|=</span> <span class="n">VCR_CI_UYVY</span><span class="p">;</span>
	<span class="n">viacam_write_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_CAPINTC</span><span class="p">,</span> <span class="n">cicreg</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_config_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">viacam_ctlr_cbufs</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">viacam_ctlr_image</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">CF_CONFIG_NEEDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Make it start grabbing data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">viacam_start_engine</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">next_buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">viacam_write_reg_mask</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_CAPINTC</span><span class="p">,</span> <span class="n">VCR_CI_ENABLE</span><span class="p">,</span> <span class="n">VCR_CI_ENABLE</span><span class="p">);</span>
	<span class="n">viacam_int_enable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">viacam_read_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_CAPINTC</span><span class="p">);</span> <span class="cm">/* Force post */</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">opstate</span> <span class="o">=</span> <span class="n">S_RUNNING</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">viacam_stop_engine</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
	<span class="n">viacam_int_disable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">viacam_write_reg_mask</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_CAPINTC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">VCR_CI_ENABLE</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">viacam_read_reg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">VCR_CAPINTC</span><span class="p">);</span> <span class="cm">/* Force post */</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">opstate</span> <span class="o">=</span> <span class="n">S_IDLE</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* --------------------------------------------------------------------------*/</span>
<span class="cm">/* Videobuf callback ops */</span>

<span class="cm">/*</span>
<span class="cm"> * buffer_setup.  The purpose of this one would appear to be to tell</span>
<span class="cm"> * videobuf how big a single image is.	It&#39;s also evidently up to us</span>
<span class="cm"> * to put some sort of limit on the maximum number of buffers allowed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_vb_buf_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>

	<span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">user_format</span><span class="p">.</span><span class="n">sizeimage</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">*</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)</span>	<span class="cm">/* Arbitrary number */</span>
		<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Prepare a buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_vb_buf_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span> <span class="k">enum</span> <span class="n">v4l2_field</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>

	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">user_format</span><span class="p">.</span><span class="n">sizeimage</span><span class="p">;</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">user_format</span><span class="p">.</span><span class="n">width</span><span class="p">;</span> <span class="cm">/* bytesperline???? */</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">user_format</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">field</span> <span class="o">=</span> <span class="n">field</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">VIDEOBUF_NEEDS_INIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">videobuf_iolock</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_PREPARED</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We&#39;ve got a buffer to put data into.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: check for a running engine and valid buffers?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">viacam_vb_buf_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note that videobuf holds the lock when it calls</span>
<span class="cm">	 * us, so we need not (indeed, cannot) take it here.</span>
<span class="cm">	 */</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_QUEUED</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free a buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">viacam_vb_buf_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>

	<span class="n">videobuf_dma_unmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">platdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">videobuf_to_dma</span><span class="p">(</span><span class="n">vb</span><span class="p">));</span>
	<span class="n">videobuf_dma_free</span><span class="p">(</span><span class="n">videobuf_to_dma</span><span class="p">(</span><span class="n">vb</span><span class="p">));</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_NEEDS_INIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">videobuf_queue_ops</span> <span class="n">viacam_vb_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">buf_setup</span>	<span class="o">=</span> <span class="n">viacam_vb_buf_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_prepare</span>	<span class="o">=</span> <span class="n">viacam_vb_buf_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_queue</span>	<span class="o">=</span> <span class="n">viacam_vb_buf_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_release</span>	<span class="o">=</span> <span class="n">viacam_vb_buf_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* --------------------------------------------------------------------------*/</span>
<span class="cm">/* File operations */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">video_drvdata</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>

	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">cam</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note the new user.  If this is the first one, we&#39;ll also</span>
<span class="cm">	 * need to power up the sensor.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">viafb_request_dma</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">via_sensor_power_up</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CF_CONFIG_NEEDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Hook into videobuf.	Evidently this cannot fail.</span>
<span class="cm">		 */</span>
		<span class="n">videobuf_queue_sg_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">viacam_vb_ops</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">platdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">reg_lock</span><span class="p">,</span>
				<span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">,</span> <span class="n">V4L2_FIELD_NONE</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_buffer</span><span class="p">),</span> <span class="n">cam</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">video_drvdata</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the &quot;owner&quot; is closing, shut down any ongoing</span>
<span class="cm">	 * operations.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span> <span class="o">==</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">videobuf_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We don&#39;t hold the spinlock here, but, if release()</span>
<span class="cm">		 * is being called by the owner, nobody else will</span>
<span class="cm">		 * be changing the state.  And an extra stop would</span>
<span class="cm">		 * not hurt anyway.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">opstate</span> <span class="o">!=</span> <span class="n">S_IDLE</span><span class="p">)</span>
			<span class="n">viacam_stop_engine</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Last one out needs to turn out the lights.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">videobuf_mmap_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">);</span>
		<span class="n">via_sensor_power_down</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">viafb_release_dma</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read a frame from the device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">viacam_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">video_drvdata</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Enforce the V4l2 &quot;only one owner gets to read data&quot; rule.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">&amp;&amp;</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">filp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">filp</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Do we need to configure the hardware?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CF_CONFIG_NEEDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">viacam_configure_sensor</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">viacam_config_controller</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fire up the capture engine, then have videobuf do</span>
<span class="cm">	 * the heavy lifting.  Someday it would be good to avoid</span>
<span class="cm">	 * stopping and restarting the engine each time.</span>
<span class="cm">	 */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_queue</span><span class="p">);</span>
	<span class="n">viacam_start_engine</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">videobuf_read_stream</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
	<span class="n">viacam_stop_engine</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="cm">/* videobuf_stop() ?? */</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">viacam_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">video_drvdata</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">videobuf_poll_stream</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="n">pt</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">video_drvdata</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">videobuf_mmap_mapper</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
<span class="p">}</span>



<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_file_operations</span> <span class="n">viacam_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">viacam_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">viacam_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">viacam_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">viacam_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>		<span class="o">=</span> <span class="n">viacam_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">video_ioctl2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*----------------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * The long list of v4l2 ioctl ops</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_g_chip_ident</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_dbg_chip_ident</span> <span class="o">*</span><span class="n">ident</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="n">ident</span><span class="o">-&gt;</span><span class="n">ident</span> <span class="o">=</span> <span class="n">V4L2_IDENT_NONE</span><span class="p">;</span>
	<span class="n">ident</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v4l2_chip_match_host</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ident</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ident</span><span class="o">-&gt;</span><span class="n">ident</span> <span class="o">=</span> <span class="n">V4L2_IDENT_VIA_VX855</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">g_chip_ident</span><span class="p">,</span> <span class="n">ident</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Control ops are passed through to the sensor.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_queryctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_queryctrl</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">queryctrl</span><span class="p">,</span> <span class="n">qc</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_g_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">g_ctrl</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_s_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">s_ctrl</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Only one input.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_enum_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_input</span> <span class="o">*</span><span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">input</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">V4L2_INPUT_TYPE_CAMERA</span><span class="p">;</span>
	<span class="n">input</span><span class="o">-&gt;</span><span class="n">std</span> <span class="o">=</span> <span class="n">V4L2_STD_ALL</span><span class="p">;</span> <span class="cm">/* Not sure what should go here */</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;Camera&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_g_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_s_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_s_std</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">v4l2_std_id</span> <span class="o">*</span><span class="n">std</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Video format stuff.	Here is our default format until</span>
<span class="cm"> * user space messes with things.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_pix_format</span> <span class="n">viacam_def_pix_format</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">width</span>		<span class="o">=</span> <span class="n">VGA_WIDTH</span><span class="p">,</span>
	<span class="p">.</span><span class="n">height</span>		<span class="o">=</span> <span class="n">VGA_HEIGHT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pixelformat</span>	<span class="o">=</span> <span class="n">V4L2_PIX_FMT_YUYV</span><span class="p">,</span>
	<span class="p">.</span><span class="n">field</span>		<span class="o">=</span> <span class="n">V4L2_FIELD_NONE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bytesperline</span>	<span class="o">=</span> <span class="n">VGA_WIDTH</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sizeimage</span>	<span class="o">=</span> <span class="n">VGA_WIDTH</span> <span class="o">*</span> <span class="n">VGA_HEIGHT</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">enum</span> <span class="n">v4l2_mbus_pixelcode</span> <span class="n">via_def_mbus_code</span> <span class="o">=</span> <span class="n">V4L2_MBUS_FMT_YUYV8_2X8</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_enum_fmt_vid_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_fmtdesc</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">N_VIA_FMTS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">,</span> <span class="n">via_formats</span><span class="p">[</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">desc</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">));</span>
	<span class="n">fmt</span><span class="o">-&gt;</span><span class="n">pixelformat</span> <span class="o">=</span> <span class="n">via_formats</span><span class="p">[</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">pixelformat</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Figure out proper image dimensions, but always force the</span>
<span class="cm"> * sensor to VGA.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">viacam_fmt_pre</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_pix_format</span> <span class="o">*</span><span class="n">userfmt</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_pix_format</span> <span class="o">*</span><span class="n">sensorfmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">sensorfmt</span> <span class="o">=</span> <span class="o">*</span><span class="n">userfmt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">userfmt</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">&lt;</span> <span class="n">QCIF_WIDTH</span> <span class="o">||</span> <span class="n">userfmt</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">&lt;</span> <span class="n">QCIF_HEIGHT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">userfmt</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">QCIF_WIDTH</span><span class="p">;</span>
		<span class="n">userfmt</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">QCIF_HEIGHT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">userfmt</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">&gt;</span> <span class="n">VGA_WIDTH</span> <span class="o">||</span> <span class="n">userfmt</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">&gt;</span> <span class="n">VGA_HEIGHT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">userfmt</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">VGA_WIDTH</span><span class="p">;</span>
		<span class="n">userfmt</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">VGA_HEIGHT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sensorfmt</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">VGA_WIDTH</span><span class="p">;</span>
	<span class="n">sensorfmt</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">VGA_HEIGHT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">viacam_fmt_post</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_pix_format</span> <span class="o">*</span><span class="n">userfmt</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_pix_format</span> <span class="o">*</span><span class="n">sensorfmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_format</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">via_find_format</span><span class="p">(</span><span class="n">userfmt</span><span class="o">-&gt;</span><span class="n">pixelformat</span><span class="p">);</span>

	<span class="n">sensorfmt</span><span class="o">-&gt;</span><span class="n">bytesperline</span> <span class="o">=</span> <span class="n">sensorfmt</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">*</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">bpp</span><span class="p">;</span>
	<span class="n">sensorfmt</span><span class="o">-&gt;</span><span class="n">sizeimage</span> <span class="o">=</span> <span class="n">sensorfmt</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">*</span> <span class="n">sensorfmt</span><span class="o">-&gt;</span><span class="n">bytesperline</span><span class="p">;</span>
	<span class="n">userfmt</span><span class="o">-&gt;</span><span class="n">pixelformat</span> <span class="o">=</span> <span class="n">sensorfmt</span><span class="o">-&gt;</span><span class="n">pixelformat</span><span class="p">;</span>
	<span class="n">userfmt</span><span class="o">-&gt;</span><span class="n">field</span> <span class="o">=</span> <span class="n">sensorfmt</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">;</span>
	<span class="n">userfmt</span><span class="o">-&gt;</span><span class="n">bytesperline</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">userfmt</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
	<span class="n">userfmt</span><span class="o">-&gt;</span><span class="n">sizeimage</span> <span class="o">=</span> <span class="n">userfmt</span><span class="o">-&gt;</span><span class="n">bytesperline</span> <span class="o">*</span> <span class="n">userfmt</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * The real work of figuring out a workable format.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_do_try_fmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_pix_format</span> <span class="o">*</span><span class="n">upix</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_pix_format</span> <span class="o">*</span><span class="n">spix</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_mbus_framefmt</span> <span class="n">mbus_fmt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">via_format</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">via_find_format</span><span class="p">(</span><span class="n">upix</span><span class="o">-&gt;</span><span class="n">pixelformat</span><span class="p">);</span>

	<span class="n">upix</span><span class="o">-&gt;</span><span class="n">pixelformat</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">pixelformat</span><span class="p">;</span>
	<span class="n">viacam_fmt_pre</span><span class="p">(</span><span class="n">upix</span><span class="p">,</span> <span class="n">spix</span><span class="p">);</span>
	<span class="n">v4l2_fill_mbus_format</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbus_fmt</span><span class="p">,</span> <span class="n">upix</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">mbus_code</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">try_mbus_fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbus_fmt</span><span class="p">);</span>
	<span class="n">v4l2_fill_pix_format</span><span class="p">(</span><span class="n">spix</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbus_fmt</span><span class="p">);</span>
	<span class="n">viacam_fmt_post</span><span class="p">(</span><span class="n">upix</span><span class="p">,</span> <span class="n">spix</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_try_fmt_vid_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_format</span> <span class="n">sfmt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">viacam_do_try_fmt</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sfmt</span><span class="p">.</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_g_fmt_vid_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">user_format</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_s_fmt_vid_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_format</span> <span class="n">sfmt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">via_format</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">via_find_format</span><span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="p">.</span><span class="n">pixelformat</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Camera must be idle or we can&#39;t mess with the</span>
<span class="cm">	 * video setup.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">opstate</span> <span class="o">!=</span> <span class="n">S_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Let the sensor code look over and tweak the</span>
<span class="cm">	 * requested formatting.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">viacam_do_try_fmt</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sfmt</span><span class="p">.</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * OK, let&#39;s commit to the new format.</span>
<span class="cm">	 */</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">user_format</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_format</span> <span class="o">=</span> <span class="n">sfmt</span><span class="p">.</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">mbus_code</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">mbus_code</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">viacam_configure_sensor</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">viacam_config_controller</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_querycap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_capability</span> <span class="o">*</span><span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="s">&quot;via-camera&quot;</span><span class="p">);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="s">&quot;via-camera&quot;</span><span class="p">);</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">=</span> <span class="n">V4L2_CAP_VIDEO_CAPTURE</span> <span class="o">|</span>
		<span class="n">V4L2_CAP_READWRITE</span> <span class="o">|</span> <span class="n">V4L2_CAP_STREAMING</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Streaming operations - pure videobuf stuff.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_reqbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_requestbuffers</span> <span class="o">*</span><span class="n">rb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">videobuf_reqbufs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_querybuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">videobuf_querybuf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_qbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">videobuf_qbuf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_dqbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">videobuf_dqbuf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_streamon</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">enum</span> <span class="n">v4l2_buf_type</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">opstate</span> <span class="o">!=</span> <span class="n">S_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Enforce the V4l2 &quot;only one owner gets to read data&quot; rule.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">&amp;&amp;</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">filp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">filp</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Configure things if need be.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CF_CONFIG_NEEDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">viacam_configure_sensor</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">viacam_config_controller</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the CPU goes into C3, the DMA transfer gets corrupted and</span>
<span class="cm">	 * users start filing unsightly bug reports.  Put in a &quot;latency&quot;</span>
<span class="cm">	 * requirement which will keep the CPU out of the deeper sleep</span>
<span class="cm">	 * states.</span>
<span class="cm">	 */</span>
	<span class="n">pm_qos_add_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">qos_request</span><span class="p">,</span> <span class="n">PM_QOS_CPU_DMA_LATENCY</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fire things up.</span>
<span class="cm">	 */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_queue</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">videobuf_streamon</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">viacam_start_engine</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_streamoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">enum</span> <span class="n">v4l2_buf_type</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">opstate</span> <span class="o">!=</span> <span class="n">S_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pm_qos_remove_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">qos_request</span><span class="p">);</span>
	<span class="n">viacam_stop_engine</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Videobuf will recycle all of the outstanding buffers, but</span>
<span class="cm">	 * we should be sure we don&#39;t retain any references to</span>
<span class="cm">	 * any of them.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">videobuf_streamoff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_queue</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* G/S_PARM */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_g_parm</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_streamparm</span> <span class="o">*</span><span class="n">parm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">g_parm</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">parm</span><span class="p">.</span><span class="n">capture</span><span class="p">.</span><span class="n">readbuffers</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">n_cap_bufs</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_s_parm</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_streamparm</span> <span class="o">*</span><span class="n">parm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">s_parm</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">parm</span><span class="p">.</span><span class="n">capture</span><span class="p">.</span><span class="n">readbuffers</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">n_cap_bufs</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_enum_framesizes</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_frmsizeenum</span> <span class="o">*</span><span class="n">sizes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sizes</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">sizes</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">V4L2_FRMSIZE_TYPE_CONTINUOUS</span><span class="p">;</span>
	<span class="n">sizes</span><span class="o">-&gt;</span><span class="n">stepwise</span><span class="p">.</span><span class="n">min_width</span> <span class="o">=</span> <span class="n">QCIF_WIDTH</span><span class="p">;</span>
	<span class="n">sizes</span><span class="o">-&gt;</span><span class="n">stepwise</span><span class="p">.</span><span class="n">min_height</span> <span class="o">=</span> <span class="n">QCIF_HEIGHT</span><span class="p">;</span>
	<span class="n">sizes</span><span class="o">-&gt;</span><span class="n">stepwise</span><span class="p">.</span><span class="n">max_width</span> <span class="o">=</span> <span class="n">VGA_WIDTH</span><span class="p">;</span>
	<span class="n">sizes</span><span class="o">-&gt;</span><span class="n">stepwise</span><span class="p">.</span><span class="n">max_height</span> <span class="o">=</span> <span class="n">VGA_HEIGHT</span><span class="p">;</span>
	<span class="n">sizes</span><span class="o">-&gt;</span><span class="n">stepwise</span><span class="p">.</span><span class="n">step_width</span> <span class="o">=</span> <span class="n">sizes</span><span class="o">-&gt;</span><span class="n">stepwise</span><span class="p">.</span><span class="n">step_height</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_enum_frameintervals</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_frmivalenum</span> <span class="o">*</span><span class="n">interval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">enum_frameintervals</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_ioctl_ops</span> <span class="n">viacam_ioctl_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">vidioc_g_chip_ident</span>	<span class="o">=</span> <span class="n">viacam_g_chip_ident</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_queryctrl</span>	<span class="o">=</span> <span class="n">viacam_queryctrl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_g_ctrl</span>		<span class="o">=</span> <span class="n">viacam_g_ctrl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_s_ctrl</span>		<span class="o">=</span> <span class="n">viacam_s_ctrl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_enum_input</span>	<span class="o">=</span> <span class="n">viacam_enum_input</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_g_input</span>		<span class="o">=</span> <span class="n">viacam_g_input</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_s_input</span>		<span class="o">=</span> <span class="n">viacam_s_input</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_s_std</span>		<span class="o">=</span> <span class="n">viacam_s_std</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_enum_fmt_vid_cap</span> <span class="o">=</span> <span class="n">viacam_enum_fmt_vid_cap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_try_fmt_vid_cap</span> <span class="o">=</span> <span class="n">viacam_try_fmt_vid_cap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_g_fmt_vid_cap</span>	<span class="o">=</span> <span class="n">viacam_g_fmt_vid_cap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_s_fmt_vid_cap</span>	<span class="o">=</span> <span class="n">viacam_s_fmt_vid_cap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_querycap</span>	<span class="o">=</span> <span class="n">viacam_querycap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_reqbufs</span>		<span class="o">=</span> <span class="n">viacam_reqbufs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_querybuf</span>	<span class="o">=</span> <span class="n">viacam_querybuf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_qbuf</span>		<span class="o">=</span> <span class="n">viacam_qbuf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_dqbuf</span>		<span class="o">=</span> <span class="n">viacam_dqbuf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_streamon</span>	<span class="o">=</span> <span class="n">viacam_streamon</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_streamoff</span>	<span class="o">=</span> <span class="n">viacam_streamoff</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_g_parm</span>		<span class="o">=</span> <span class="n">viacam_g_parm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_s_parm</span>		<span class="o">=</span> <span class="n">viacam_s_parm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_enum_framesizes</span> <span class="o">=</span> <span class="n">viacam_enum_framesizes</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_enum_frameintervals</span> <span class="o">=</span> <span class="n">viacam_enum_frameintervals</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*----------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Power management.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PM</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_suspend</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">viacam_opstate</span> <span class="n">state</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">opstate</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">opstate</span> <span class="o">!=</span> <span class="n">S_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">viacam_stop_engine</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">opstate</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span> <span class="cm">/* So resume restarts */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">viacam_resume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get back to a reasonable operating state.</span>
<span class="cm">	 */</span>
	<span class="n">via_write_reg_mask</span><span class="p">(</span><span class="n">VIASR</span><span class="p">,</span> <span class="mh">0x78</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
	<span class="n">via_write_reg_mask</span><span class="p">(</span><span class="n">VIASR</span><span class="p">,</span> <span class="mh">0x1e</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">);</span>
	<span class="n">viacam_int_disable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">CF_CONFIG_NEEDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure the sensor&#39;s power state is correct</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">via_sensor_power_up</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">via_sensor_power_down</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If it was operating, try to restart it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">opstate</span> <span class="o">!=</span> <span class="n">S_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">viacam_configure_sensor</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">viacam_config_controller</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">viacam_start_engine</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">viafb_pm_hooks</span> <span class="n">viacam_pm_hooks</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">viacam_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">viacam_resume</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Setup stuff.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">video_device</span> <span class="n">viacam_v4l_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;via-camera&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">minor</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tvnorms</span>	<span class="o">=</span> <span class="n">V4L2_STD_NTSC_M</span><span class="p">,</span>
	<span class="p">.</span><span class="n">current_norm</span>	<span class="o">=</span> <span class="n">V4L2_STD_NTSC_M</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">viacam_fops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">viacam_ioctl_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">video_device_release_empty</span><span class="p">,</span> <span class="cm">/* Check this */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The OLPC folks put the serial port on the same pin as</span>
<span class="cm"> * the camera.	They also get grumpy if we break the</span>
<span class="cm"> * serial port and keep them from using it.  So we have</span>
<span class="cm"> * to check the serial enable bit and not step on it.</span>
<span class="cm"> */</span>
<span class="cp">#define VIACAM_SERIAL_DEVFN 0x88</span>
<span class="cp">#define VIACAM_SERIAL_CREG 0x46</span>
<span class="cp">#define VIACAM_SERIAL_BIT 0x40</span>

<span class="k">static</span> <span class="n">__devinit</span> <span class="n">bool</span> <span class="nf">viacam_serial_is_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">pbus</span> <span class="o">=</span> <span class="n">pci_find_bus</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">cbyte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pbus</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">pci_bus_read_config_byte</span><span class="p">(</span><span class="n">pbus</span><span class="p">,</span> <span class="n">VIACAM_SERIAL_DEVFN</span><span class="p">,</span>
			<span class="n">VIACAM_SERIAL_CREG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cbyte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cbyte</span> <span class="o">&amp;</span> <span class="n">VIACAM_SERIAL_BIT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* Not enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">override_serial</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Via camera: serial port is enabled, &quot;</span> \
				<span class="s">&quot;refusing to load.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Specify override_serial=1 to force &quot;</span> \
				<span class="s">&quot;module loading.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Via camera: overriding serial port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pci_bus_write_config_byte</span><span class="p">(</span><span class="n">pbus</span><span class="p">,</span> <span class="n">VIACAM_SERIAL_DEVFN</span><span class="p">,</span>
			<span class="n">VIACAM_SERIAL_CREG</span><span class="p">,</span> <span class="n">cbyte</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">VIACAM_SERIAL_BIT</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ov7670_config</span> <span class="n">sensor_cfg</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* The XO-1.5 (only known user) clocks the camera at 90MHz. */</span>
	<span class="p">.</span><span class="n">clock_speed</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__devinit</span> <span class="kt">int</span> <span class="nf">viacam_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">sensor_adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">viafb_dev</span> <span class="o">*</span><span class="n">viadev</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_board_info</span> <span class="n">ov7670_info</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&quot;ov7670&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x42</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">platform_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sensor_cfg</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note that there are actually two capture channels on</span>
<span class="cm">	 * the device.	We only deal with one for now.	That</span>
<span class="cm">	 * is encoded here; nothing else assumes it&#39;s dealing with</span>
<span class="cm">	 * a unique capture device.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that frame buffer memory has been set aside for</span>
<span class="cm">	 * this purpose.  As an arbitrary limit, refuse to work</span>
<span class="cm">	 * with less than two frames of VGA 16-bit data.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we ever support the second port, we&#39;ll need to set</span>
<span class="cm">	 * aside more memory.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">camera_fbmem_size</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">VGA_HEIGHT</span><span class="o">*</span><span class="n">VGA_WIDTH</span><span class="o">*</span><span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;viacam: insufficient FB memory reserved</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">engine_mmio</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;viacam: No I/O memory, so no pictures</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">machine_is_olpc</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">viacam_serial_is_enabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Basic structure initialization.</span>
<span class="cm">	 */</span>
	<span class="n">cam</span> <span class="o">=</span> <span class="n">kzalloc</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">via_camera</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">via_cam_info</span> <span class="o">=</span> <span class="n">cam</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">platdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">viadev</span> <span class="o">=</span> <span class="n">viadev</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">opstate</span> <span class="o">=</span> <span class="n">S_IDLE</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">user_format</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_format</span> <span class="o">=</span> <span class="n">viacam_def_pix_format</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_queue</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">=</span> <span class="n">viadev</span><span class="o">-&gt;</span><span class="n">engine_mmio</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">fbmem</span> <span class="o">=</span> <span class="n">viadev</span><span class="o">-&gt;</span><span class="n">fbmem</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">fb_offset</span> <span class="o">=</span> <span class="n">viadev</span><span class="o">-&gt;</span><span class="n">camera_fbmem_offset</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">CF_CONFIG_NEEDED</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">mbus_code</span> <span class="o">=</span> <span class="n">via_def_mbus_code</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Tell V4L that we exist.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to register v4l2 device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Convince the system that we can do DMA.</span>
<span class="cm">	 */</span>
	<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">dma_mask</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">;</span>
	<span class="n">dma_set_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fire up the capture port.  The write to 0x78 looks purely</span>
<span class="cm">	 * OLPCish; any system will need to tweak 0x1e.</span>
<span class="cm">	 */</span>
	<span class="n">via_write_reg_mask</span><span class="p">(</span><span class="n">VIASR</span><span class="p">,</span> <span class="mh">0x78</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
	<span class="n">via_write_reg_mask</span><span class="p">(</span><span class="n">VIASR</span><span class="p">,</span> <span class="mh">0x1e</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the sensor powered up.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">via_sensor_power_setup</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unregister</span><span class="p">;</span>
	<span class="n">via_sensor_power_up</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * See if we can&#39;t find it on the bus.	The VIA_PORT_31 assumption</span>
<span class="cm">	 * is OLPC-specific.  0x42 assumption is ov7670-specific.</span>
<span class="cm">	 */</span>
	<span class="n">sensor_adapter</span> <span class="o">=</span> <span class="n">viafb_find_i2c_adapter</span><span class="p">(</span><span class="n">VIA_PORT_31</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor</span> <span class="o">=</span> <span class="n">v4l2_i2c_new_subdev_board</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">,</span> <span class="n">sensor_adapter</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ov7670_info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to find the sensor!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_power_down</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the IRQ.</span>
<span class="cm">	 */</span>
	<span class="n">viacam_int_disable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_threaded_irq</span><span class="p">(</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">viacam_quick_irq</span><span class="p">,</span>
			<span class="n">viacam_irq</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="s">&quot;via-camera&quot;</span><span class="p">,</span> <span class="n">cam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_power_down</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Tell V4l2 that we exist.</span>
<span class="cm">	 */</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">vdev</span> <span class="o">=</span> <span class="n">viacam_v4l_template</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">.</span><span class="n">v4l2_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">video_register_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span> <span class="n">VFL_TYPE_GRABBER</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_irq</span><span class="p">;</span>
	<span class="n">video_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span> <span class="n">cam</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM</span>
	<span class="cm">/*</span>
<span class="cm">	 * Hook into PM events</span>
<span class="cm">	 */</span>
	<span class="n">viacam_pm_hooks</span><span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">cam</span><span class="p">;</span>
	<span class="n">viafb_pm_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viacam_pm_hooks</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Power the sensor down until somebody opens the device */</span>
	<span class="n">via_sensor_power_down</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_irq:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">cam</span><span class="p">);</span>
<span class="nl">out_power_down:</span>
	<span class="n">via_sensor_power_release</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
<span class="nl">out_unregister:</span>
	<span class="n">v4l2_device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__devexit</span> <span class="kt">int</span> <span class="nf">viacam_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">via_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">via_cam_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">viafb_dev</span> <span class="o">*</span><span class="n">viadev</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>

	<span class="n">video_unregister_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="n">v4l2_device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">viadev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">cam</span><span class="p">);</span>
	<span class="n">via_sensor_power_release</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">via_cam_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">viacam_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;viafb-camera&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">viacam_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">viacam_remove</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">viacam_driver</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
