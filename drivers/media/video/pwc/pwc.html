<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › pwc › pwc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pwc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* (C) 1999-2003 Nemosoft Unv.</span>
<span class="cm">   (C) 2004-2006 Luc Saillard (luc@saillard.org)</span>

<span class="cm">   NOTE: this version of pwc is an unofficial (modified) release of pwc &amp; pcwx</span>
<span class="cm">   driver and thus may have bugs that are not present in the original version.</span>
<span class="cm">   Please send bug reports and support requests to &lt;luc@saillard.org&gt;.</span>
<span class="cm">   The decompression routines have been implemented by reverse-engineering the</span>
<span class="cm">   Nemosoft binary pwcx module. Caveat emptor.</span>

<span class="cm">   This program is free software; you can redistribute it and/or modify</span>
<span class="cm">   it under the terms of the GNU General Public License as published by</span>
<span class="cm">   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">   (at your option) any later version.</span>

<span class="cm">   This program is distributed in the hope that it will be useful,</span>
<span class="cm">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">   GNU General Public License for more details.</span>

<span class="cm">   You should have received a copy of the GNU General Public License</span>
<span class="cm">   along with this program; if not, write to the Free Software</span>
<span class="cm">   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm">*/</span>

<span class="cp">#ifndef PWC_H</span>
<span class="cp">#define PWC_H</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/errno.h&gt;</span>
<span class="cp">#include &lt;linux/videodev2.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-common.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-device.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-ioctl.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-ctrls.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-fh.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-event.h&gt;</span>
<span class="cp">#include &lt;media/videobuf2-vmalloc.h&gt;</span>
<span class="cp">#ifdef CONFIG_USB_PWC_INPUT_EVDEV</span>
<span class="cp">#include &lt;linux/input.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &quot;pwc-dec1.h&quot;</span>
<span class="cp">#include &quot;pwc-dec23.h&quot;</span>

<span class="cm">/* Version block */</span>
<span class="cp">#define PWC_VERSION	&quot;10.0.15&quot;</span>
<span class="cp">#define PWC_NAME 	&quot;pwc&quot;</span>
<span class="cp">#define PFX		PWC_NAME &quot;: &quot;</span>


<span class="cm">/* Trace certain actions in the driver */</span>
<span class="cp">#define PWC_DEBUG_LEVEL_MODULE	(1&lt;&lt;0)</span>
<span class="cp">#define PWC_DEBUG_LEVEL_PROBE	(1&lt;&lt;1)</span>
<span class="cp">#define PWC_DEBUG_LEVEL_OPEN	(1&lt;&lt;2)</span>
<span class="cp">#define PWC_DEBUG_LEVEL_READ	(1&lt;&lt;3)</span>
<span class="cp">#define PWC_DEBUG_LEVEL_MEMORY	(1&lt;&lt;4)</span>
<span class="cp">#define PWC_DEBUG_LEVEL_FLOW	(1&lt;&lt;5)</span>
<span class="cp">#define PWC_DEBUG_LEVEL_SIZE	(1&lt;&lt;6)</span>
<span class="cp">#define PWC_DEBUG_LEVEL_IOCTL	(1&lt;&lt;7)</span>
<span class="cp">#define PWC_DEBUG_LEVEL_TRACE	(1&lt;&lt;8)</span>

<span class="cp">#define PWC_DEBUG_MODULE(fmt, args...) PWC_DEBUG(MODULE, fmt, ##args)</span>
<span class="cp">#define PWC_DEBUG_PROBE(fmt, args...) PWC_DEBUG(PROBE, fmt, ##args)</span>
<span class="cp">#define PWC_DEBUG_OPEN(fmt, args...) PWC_DEBUG(OPEN, fmt, ##args)</span>
<span class="cp">#define PWC_DEBUG_READ(fmt, args...) PWC_DEBUG(READ, fmt, ##args)</span>
<span class="cp">#define PWC_DEBUG_MEMORY(fmt, args...) PWC_DEBUG(MEMORY, fmt, ##args)</span>
<span class="cp">#define PWC_DEBUG_FLOW(fmt, args...) PWC_DEBUG(FLOW, fmt, ##args)</span>
<span class="cp">#define PWC_DEBUG_SIZE(fmt, args...) PWC_DEBUG(SIZE, fmt, ##args)</span>
<span class="cp">#define PWC_DEBUG_IOCTL(fmt, args...) PWC_DEBUG(IOCTL, fmt, ##args)</span>
<span class="cp">#define PWC_DEBUG_TRACE(fmt, args...) PWC_DEBUG(TRACE, fmt, ##args)</span>


<span class="cp">#ifdef CONFIG_USB_PWC_DEBUG</span>

<span class="cp">#define PWC_DEBUG_LEVEL	(PWC_DEBUG_LEVEL_MODULE)</span>

<span class="cp">#define PWC_DEBUG(level, fmt, args...) do {\</span>
<span class="cp">	if ((PWC_DEBUG_LEVEL_ ##level) &amp; pwc_trace) \</span>
<span class="cp">		printk(KERN_DEBUG PFX fmt, ##args); \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define PWC_ERROR(fmt, args...) printk(KERN_ERR PFX fmt, ##args)</span>
<span class="cp">#define PWC_WARNING(fmt, args...) printk(KERN_WARNING PFX fmt, ##args)</span>
<span class="cp">#define PWC_INFO(fmt, args...) printk(KERN_INFO PFX fmt, ##args)</span>
<span class="cp">#define PWC_TRACE(fmt, args...) PWC_DEBUG(TRACE, fmt, ##args)</span>

<span class="cp">#else </span><span class="cm">/* if ! CONFIG_USB_PWC_DEBUG */</span><span class="cp"></span>

<span class="cp">#define PWC_ERROR(fmt, args...) printk(KERN_ERR PFX fmt, ##args)</span>
<span class="cp">#define PWC_WARNING(fmt, args...) printk(KERN_WARNING PFX fmt, ##args)</span>
<span class="cp">#define PWC_INFO(fmt, args...) printk(KERN_INFO PFX fmt, ##args)</span>
<span class="cp">#define PWC_TRACE(fmt, args...) do { } while(0)</span>
<span class="cp">#define PWC_DEBUG(level, fmt, args...) do { } while(0)</span>

<span class="cp">#define pwc_trace 0</span>

<span class="cp">#endif</span>

<span class="cm">/* Defines for ToUCam cameras */</span>
<span class="cp">#define TOUCAM_HEADER_SIZE		8</span>
<span class="cp">#define TOUCAM_TRAILER_SIZE		4</span>

<span class="cp">#define FEATURE_MOTOR_PANTILT		0x0001</span>
<span class="cp">#define FEATURE_CODEC1			0x0002</span>
<span class="cp">#define FEATURE_CODEC2			0x0004</span>

<span class="cp">#define MAX_WIDTH		640</span>
<span class="cp">#define MAX_HEIGHT		480</span>

<span class="cm">/* Ignore errors in the first N frames, to allow for startup delays */</span>
<span class="cp">#define FRAME_LOWMARK 5</span>

<span class="cm">/* Size and number of buffers for the ISO pipe. */</span>
<span class="cp">#define MAX_ISO_BUFS		3</span>
<span class="cp">#define ISO_FRAMES_PER_DESC	10</span>
<span class="cp">#define ISO_MAX_FRAME_SIZE	960</span>
<span class="cp">#define ISO_BUFFER_SIZE 	(ISO_FRAMES_PER_DESC * ISO_MAX_FRAME_SIZE)</span>

<span class="cm">/* Maximum size after decompression is 640x480 YUV data, 1.5 * 640 * 480 */</span>
<span class="cp">#define PWC_FRAME_SIZE 		(460800 + TOUCAM_HEADER_SIZE + TOUCAM_TRAILER_SIZE)</span>

<span class="cm">/* Absolute minimum and maximum number of buffers available for mmap() */</span>
<span class="cp">#define MIN_FRAMES		2</span>
<span class="cp">#define MAX_FRAMES		16</span>

<span class="cm">/* Some macros to quickly find the type of a webcam */</span>
<span class="cp">#define DEVICE_USE_CODEC1(x) ((x)&lt;675)</span>
<span class="cp">#define DEVICE_USE_CODEC2(x) ((x)&gt;=675 &amp;&amp; (x)&lt;700)</span>
<span class="cp">#define DEVICE_USE_CODEC3(x) ((x)&gt;=700)</span>
<span class="cp">#define DEVICE_USE_CODEC23(x) ((x)&gt;=675)</span>

<span class="cm">/* Request types: video */</span>
<span class="cp">#define SET_LUM_CTL			0x01</span>
<span class="cp">#define GET_LUM_CTL			0x02</span>
<span class="cp">#define SET_CHROM_CTL			0x03</span>
<span class="cp">#define GET_CHROM_CTL			0x04</span>
<span class="cp">#define SET_STATUS_CTL			0x05</span>
<span class="cp">#define GET_STATUS_CTL			0x06</span>
<span class="cp">#define SET_EP_STREAM_CTL		0x07</span>
<span class="cp">#define GET_EP_STREAM_CTL		0x08</span>
<span class="cp">#define GET_XX_CTL			0x09</span>
<span class="cp">#define SET_XX_CTL			0x0A</span>
<span class="cp">#define GET_XY_CTL			0x0B</span>
<span class="cp">#define SET_XY_CTL			0x0C</span>
<span class="cp">#define SET_MPT_CTL			0x0D</span>
<span class="cp">#define GET_MPT_CTL			0x0E</span>

<span class="cm">/* Selectors for the Luminance controls [GS]ET_LUM_CTL */</span>
<span class="cp">#define AGC_MODE_FORMATTER			0x2000</span>
<span class="cp">#define PRESET_AGC_FORMATTER			0x2100</span>
<span class="cp">#define SHUTTER_MODE_FORMATTER			0x2200</span>
<span class="cp">#define PRESET_SHUTTER_FORMATTER		0x2300</span>
<span class="cp">#define PRESET_CONTOUR_FORMATTER		0x2400</span>
<span class="cp">#define AUTO_CONTOUR_FORMATTER			0x2500</span>
<span class="cp">#define BACK_LIGHT_COMPENSATION_FORMATTER	0x2600</span>
<span class="cp">#define CONTRAST_FORMATTER			0x2700</span>
<span class="cp">#define DYNAMIC_NOISE_CONTROL_FORMATTER		0x2800</span>
<span class="cp">#define FLICKERLESS_MODE_FORMATTER		0x2900</span>
<span class="cp">#define AE_CONTROL_SPEED			0x2A00</span>
<span class="cp">#define BRIGHTNESS_FORMATTER			0x2B00</span>
<span class="cp">#define GAMMA_FORMATTER				0x2C00</span>

<span class="cm">/* Selectors for the Chrominance controls [GS]ET_CHROM_CTL */</span>
<span class="cp">#define WB_MODE_FORMATTER			0x1000</span>
<span class="cp">#define AWB_CONTROL_SPEED_FORMATTER		0x1100</span>
<span class="cp">#define AWB_CONTROL_DELAY_FORMATTER		0x1200</span>
<span class="cp">#define PRESET_MANUAL_RED_GAIN_FORMATTER	0x1300</span>
<span class="cp">#define PRESET_MANUAL_BLUE_GAIN_FORMATTER	0x1400</span>
<span class="cp">#define COLOUR_MODE_FORMATTER			0x1500</span>
<span class="cp">#define SATURATION_MODE_FORMATTER1		0x1600</span>
<span class="cp">#define SATURATION_MODE_FORMATTER2		0x1700</span>

<span class="cm">/* Selectors for the Status controls [GS]ET_STATUS_CTL */</span>
<span class="cp">#define SAVE_USER_DEFAULTS_FORMATTER		0x0200</span>
<span class="cp">#define RESTORE_USER_DEFAULTS_FORMATTER		0x0300</span>
<span class="cp">#define RESTORE_FACTORY_DEFAULTS_FORMATTER	0x0400</span>
<span class="cp">#define READ_AGC_FORMATTER			0x0500</span>
<span class="cp">#define READ_SHUTTER_FORMATTER			0x0600</span>
<span class="cp">#define READ_RED_GAIN_FORMATTER			0x0700</span>
<span class="cp">#define READ_BLUE_GAIN_FORMATTER		0x0800</span>

<span class="cm">/* Formatters for the motorized pan &amp; tilt [GS]ET_MPT_CTL */</span>
<span class="cp">#define PT_RELATIVE_CONTROL_FORMATTER		0x01</span>
<span class="cp">#define PT_RESET_CONTROL_FORMATTER		0x02</span>
<span class="cp">#define PT_STATUS_FORMATTER			0x03</span>

<span class="cm">/* Enumeration of image sizes */</span>
<span class="cp">#define PSZ_SQCIF	0x00</span>
<span class="cp">#define PSZ_QSIF	0x01</span>
<span class="cp">#define PSZ_QCIF	0x02</span>
<span class="cp">#define PSZ_SIF		0x03</span>
<span class="cp">#define PSZ_CIF		0x04</span>
<span class="cp">#define PSZ_VGA		0x05</span>
<span class="cp">#define PSZ_MAX		6</span>

<span class="k">struct</span> <span class="n">pwc_raw_frame</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">type</span><span class="p">;</span>		<span class="cm">/* type of the webcam */</span>
	<span class="n">__le16</span> <span class="n">vbandlength</span><span class="p">;</span>	<span class="cm">/* Size of 4 lines compressed (used by the</span>
<span class="cm">				   decompressor) */</span>
	<span class="n">__u8</span>   <span class="n">cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>		<span class="cm">/* the four byte of the command (in case of</span>
<span class="cm">				   nala, only the first 3 bytes is filled) */</span>
	<span class="n">__u8</span>   <span class="n">rawframe</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* frame_size = H / 4 * vbandlength */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* intermediate buffers with raw data from the USB cam */</span>
<span class="k">struct</span> <span class="n">pwc_frame_buf</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="n">vb</span><span class="p">;</span>	<span class="cm">/* common v4l buffer stuff -- must be first */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">filled</span><span class="p">;</span>		<span class="cm">/* number of bytes filled */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pwc_device</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">video_device</span> <span class="n">vdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_device</span> <span class="n">v4l2_dev</span><span class="p">;</span>

	<span class="cm">/* videobuf2 queue and queued buffers list */</span>
	<span class="k">struct</span> <span class="n">vb2_queue</span> <span class="n">vb_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">queued_bufs</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">queued_bufs_lock</span><span class="p">;</span> <span class="cm">/* Protects queued_bufs */</span>

	<span class="cm">/* Note if taking both locks v4l2_lock must always be locked first! */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">v4l2_lock</span><span class="p">;</span>      <span class="cm">/* Protects everything else */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">vb_queue_lock</span><span class="p">;</span>  <span class="cm">/* Protects vb_queue and capt_file */</span>

	<span class="cm">/* Pointer to our usb_device, will be NULL after unplug */</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span> <span class="cm">/* Both mutexes most be hold when setting! */</span>

	<span class="cm">/* type of cam (645, 646, 675, 680, 690, 720, 730, 740, 750) */</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">release</span><span class="p">;</span>		<span class="cm">/* release number */</span>
	<span class="kt">int</span> <span class="n">features</span><span class="p">;</span>		<span class="cm">/* feature bits */</span>

	<span class="cm">/*** Video data ***/</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">capt_file</span><span class="p">;</span>	<span class="cm">/* file doing video capture */</span>
	<span class="kt">int</span> <span class="n">vendpoint</span><span class="p">;</span>		<span class="cm">/* video isoc endpoint */</span>
	<span class="kt">int</span> <span class="n">vcinterface</span><span class="p">;</span>	<span class="cm">/* video control interface */</span>
	<span class="kt">int</span> <span class="n">valternate</span><span class="p">;</span>		<span class="cm">/* alternate interface needed */</span>
	<span class="kt">int</span> <span class="n">vframes</span><span class="p">;</span>		<span class="cm">/* frames-per-second */</span>
	<span class="kt">int</span> <span class="n">pixfmt</span><span class="p">;</span>		<span class="cm">/* pixelformat: V4L2_PIX_FMT_YUV420 or _PWCX */</span>
	<span class="kt">int</span> <span class="n">vframe_count</span><span class="p">;</span>	<span class="cm">/* received frames */</span>
	<span class="kt">int</span> <span class="n">vmax_packet_size</span><span class="p">;</span>	<span class="cm">/* USB maxpacket size */</span>
	<span class="kt">int</span> <span class="n">vlast_packet_size</span><span class="p">;</span>	<span class="cm">/* for frame synchronisation */</span>
	<span class="kt">int</span> <span class="n">visoc_errors</span><span class="p">;</span>	<span class="cm">/* number of contiguous ISOC errors */</span>
	<span class="kt">int</span> <span class="n">vbandlength</span><span class="p">;</span>	<span class="cm">/* compressed band length; 0 is uncompressed */</span>
	<span class="kt">char</span> <span class="n">vsync</span><span class="p">;</span>		<span class="cm">/* used by isoc handler */</span>
	<span class="kt">char</span> <span class="n">vmirror</span><span class="p">;</span>		<span class="cm">/* for ToUCaM series */</span>
	<span class="kt">char</span> <span class="n">power_save</span><span class="p">;</span>	<span class="cm">/* Do powersaving for this cam */</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd_buf</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ctrl_buf</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urbs</span><span class="p">[</span><span class="n">MAX_ISO_BUFS</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Frame currently being filled, this only gets touched by the</span>
<span class="cm">	 * isoc urb complete handler, and by stream start / stop since</span>
<span class="cm">	 * start / stop touch it before / after starting / killing the urbs</span>
<span class="cm">	 * no locking is needed around this</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">pwc_frame_buf</span> <span class="o">*</span><span class="n">fill_buf</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">frame_header_size</span><span class="p">,</span> <span class="n">frame_trailer_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">frame_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">frame_total_size</span><span class="p">;</span>	<span class="cm">/* including header &amp; trailer */</span>
	<span class="kt">int</span> <span class="n">drop_frames</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>	<span class="cm">/* private data for decompression engine */</span>
		<span class="k">struct</span> <span class="n">pwc_dec1_private</span> <span class="n">dec1</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">pwc_dec23_private</span> <span class="n">dec23</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have an &#39;image&#39; and a &#39;view&#39;, where &#39;image&#39; is the fixed-size img</span>
<span class="cm">	 * as delivered by the camera, and &#39;view&#39; is the size requested by the</span>
<span class="cm">	 * program. The camera image is centered in this viewport, laced with</span>
<span class="cm">	 * a gray or black border. view_min &lt;= image &lt;= view &lt;= view_max;</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">image_mask</span><span class="p">;</span>				<span class="cm">/* supported sizes */</span>
	<span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>			<span class="cm">/* current resolution */</span>

<span class="cp">#ifdef CONFIG_USB_PWC_INPUT_EVDEV</span>
	<span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">button_dev</span><span class="p">;</span>	<span class="cm">/* webcam snapshot button input */</span>
	<span class="kt">char</span> <span class="n">button_phys</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="cp">#endif</span>

	<span class="cm">/* controls */</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span>	<span class="n">ctrl_handler</span><span class="p">;</span>
	<span class="n">u16</span>				<span class="n">saturation_fmt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span>		<span class="o">*</span><span class="n">brightness</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span>		<span class="o">*</span><span class="n">contrast</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span>		<span class="o">*</span><span class="n">saturation</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span>		<span class="o">*</span><span class="n">gamma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* awb / red-blue balance cluster */</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span>	<span class="o">*</span><span class="n">auto_white_balance</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span>	<span class="o">*</span><span class="n">red_balance</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span>	<span class="o">*</span><span class="n">blue_balance</span><span class="p">;</span>
		<span class="cm">/* usb ctrl transfers are slow, so we cache things */</span>
		<span class="kt">int</span>			<span class="n">color_bal_valid</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">last_color_bal_update</span><span class="p">;</span> <span class="cm">/* In jiffies */</span>
		<span class="n">s32</span>			<span class="n">last_red_balance</span><span class="p">;</span>
		<span class="n">s32</span>			<span class="n">last_blue_balance</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* autogain / gain cluster */</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span>	<span class="o">*</span><span class="n">autogain</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span>	<span class="o">*</span><span class="n">gain</span><span class="p">;</span>
		<span class="kt">int</span>			<span class="n">gain_valid</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">last_gain_update</span><span class="p">;</span> <span class="cm">/* In jiffies */</span>
		<span class="n">s32</span>			<span class="n">last_gain</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* exposure_auto / exposure cluster */</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span>	<span class="o">*</span><span class="n">exposure_auto</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span>	<span class="o">*</span><span class="n">exposure</span><span class="p">;</span>
		<span class="kt">int</span>			<span class="n">exposure_valid</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">last_exposure_update</span><span class="p">;</span> <span class="cm">/* In jiffies */</span>
		<span class="n">s32</span>			<span class="n">last_exposure</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span>		<span class="o">*</span><span class="n">colorfx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* autocontour/contour cluster */</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span>	<span class="o">*</span><span class="n">autocontour</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span>	<span class="o">*</span><span class="n">contour</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span>		<span class="o">*</span><span class="n">backlight</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span>		<span class="o">*</span><span class="n">flicker</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span>		<span class="o">*</span><span class="n">noise_reduction</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span>		<span class="o">*</span><span class="n">save_user</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span>		<span class="o">*</span><span class="n">restore_user</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span>		<span class="o">*</span><span class="n">restore_factory</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span>		<span class="o">*</span><span class="n">awb_speed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span>		<span class="o">*</span><span class="n">awb_delay</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* motor control cluster */</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span>	<span class="o">*</span><span class="n">motor_pan</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span>	<span class="o">*</span><span class="n">motor_tilt</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span>	<span class="o">*</span><span class="n">motor_pan_reset</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span>	<span class="o">*</span><span class="n">motor_tilt_reset</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="cm">/* CODEC3 models have both gain and exposure controlled by autogain */</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span>		<span class="o">*</span><span class="n">autogain_expo_cluster</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Global variables */</span>
<span class="cp">#ifdef CONFIG_USB_PWC_DEBUG</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pwc_trace</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">pwc_test_n_set_capt_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>

<span class="cm">/** Functions in pwc-misc.c */</span>
<span class="cm">/* sizes in pixels */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">pwc_image_sizes</span><span class="p">[</span><span class="n">PSZ_MAX</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>

<span class="kt">int</span> <span class="n">pwc_get_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pwc_construct</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>

<span class="cm">/** Functions in pwc-ctrl.c */</span>
<span class="cm">/* Request a certain video mode. Returns &lt; 0 if not possible */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pwc_set_video_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">pixfmt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">frames</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">compression</span><span class="p">,</span> <span class="kt">int</span> <span class="n">send_to_cam</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pwc_get_fps</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pwc_set_leds</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on_value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off_value</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pwc_get_cmos_sensor</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">sensor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">send_control_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			    <span class="n">u8</span> <span class="n">request</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">);</span>

<span class="cm">/* Control get / set helpers */</span>
<span class="kt">int</span> <span class="n">pwc_get_u8_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">request</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pwc_set_u8_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">request</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="n">u8</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pwc_get_s8_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">request</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cp">#define pwc_set_s8_ctrl pwc_set_u8_ctrl</span>
<span class="kt">int</span> <span class="n">pwc_get_u16_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">request</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dat</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pwc_set_u16_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">request</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pwc_button_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pwc_init_controls</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>

<span class="cm">/* Power down or up the camera; not supported by all models */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pwc_camera_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">power</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_ioctl_ops</span> <span class="n">pwc_ioctl_ops</span><span class="p">;</span>

<span class="cm">/** pwc-uncompress.c */</span>
<span class="cm">/* Expand frame to image, possibly including decompression. Uses read_frame and fill_image */</span>
<span class="kt">int</span> <span class="n">pwc_decompress</span><span class="p">(</span><span class="k">struct</span> <span class="n">pwc_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pwc_frame_buf</span> <span class="o">*</span><span class="n">fbuf</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
