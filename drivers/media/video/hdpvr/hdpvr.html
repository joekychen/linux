<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › hdpvr › hdpvr.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>hdpvr.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Hauppauge HD PVR USB driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008      Janne Grunau (j@jannau.net)</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *	published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/videodev2.h&gt;</span>

<span class="cp">#include &lt;media/v4l2-device.h&gt;</span>
<span class="cp">#include &lt;media/ir-kbd-i2c.h&gt;</span>

<span class="cp">#define HDPVR_MAX 8</span>
<span class="cp">#define HDPVR_I2C_MAX_SIZE 128</span>

<span class="cm">/* Define these values to match your devices */</span>
<span class="cp">#define HD_PVR_VENDOR_ID	0x2040</span>
<span class="cp">#define HD_PVR_PRODUCT_ID	0x4900</span>
<span class="cp">#define HD_PVR_PRODUCT_ID1	0x4901</span>
<span class="cp">#define HD_PVR_PRODUCT_ID2	0x4902</span>
<span class="cp">#define HD_PVR_PRODUCT_ID4	0x4903</span>
<span class="cp">#define HD_PVR_PRODUCT_ID3	0x4982</span>

<span class="cp">#define UNSET    (-1U)</span>

<span class="cp">#define NUM_BUFFERS 64</span>

<span class="cp">#define HDPVR_FIRMWARE_VERSION		0x08</span>
<span class="cp">#define HDPVR_FIRMWARE_VERSION_AC3	0x0d</span>
<span class="cp">#define HDPVR_FIRMWARE_VERSION_0X12	0x12</span>
<span class="cp">#define HDPVR_FIRMWARE_VERSION_0X15	0x15</span>

<span class="cm">/* #define HDPVR_DEBUG */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">hdpvr_debug</span><span class="p">;</span>

<span class="cp">#define MSG_INFO	1</span>
<span class="cp">#define MSG_BUFFER	2</span>

<span class="k">struct</span> <span class="n">hdpvr_options</span> <span class="p">{</span>
	<span class="n">u8</span>	<span class="n">video_std</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">video_input</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">audio_input</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">bitrate</span><span class="p">;</span>	<span class="cm">/* in 100kbps */</span>
	<span class="n">u8</span>	<span class="n">peak_bitrate</span><span class="p">;</span>	<span class="cm">/* in 100kbps */</span>
	<span class="n">u8</span>	<span class="n">bitrate_mode</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">gop_mode</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">v4l2_mpeg_audio_encoding</span>	<span class="n">audio_codec</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">brightness</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">contrast</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">hue</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">saturation</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">sharpness</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Structure to hold all of our device specific stuff */</span>
<span class="k">struct</span> <span class="n">hdpvr_device</span> <span class="p">{</span>
	<span class="cm">/* the v4l device for this device */</span>
	<span class="k">struct</span> <span class="n">video_device</span>	<span class="o">*</span><span class="n">video_dev</span><span class="p">;</span>
	<span class="cm">/* the usb device for this device */</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="cm">/* v4l2-device unused */</span>
	<span class="k">struct</span> <span class="n">v4l2_device</span>	<span class="n">v4l2_dev</span><span class="p">;</span>

	<span class="cm">/* the max packet size of the bulk endpoint */</span>
	<span class="kt">size_t</span>			<span class="n">bulk_in_size</span><span class="p">;</span>
	<span class="cm">/* the address of the bulk in endpoint */</span>
	<span class="n">__u8</span>			<span class="n">bulk_in_endpointAddr</span><span class="p">;</span>

	<span class="cm">/* holds the current device status */</span>
	<span class="n">__u8</span>			<span class="n">status</span><span class="p">;</span>
	<span class="cm">/* count the number of openers */</span>
	<span class="n">uint</span>			<span class="n">open_count</span><span class="p">;</span>

	<span class="cm">/* holds the cureent set options */</span>
	<span class="k">struct</span> <span class="n">hdpvr_options</span>	<span class="n">options</span><span class="p">;</span>

	<span class="n">uint</span>			<span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* synchronize I/O */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">io_mutex</span><span class="p">;</span>
	<span class="cm">/* available buffers */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">free_buff_list</span><span class="p">;</span>
	<span class="cm">/* in progress buffers */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">rec_buff_list</span><span class="p">;</span>
	<span class="cm">/* waitqueue for buffers */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">wait_buffer</span><span class="p">;</span>
	<span class="cm">/* waitqueue for data */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">wait_data</span><span class="p">;</span>
	<span class="cm">/**/</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span>	<span class="o">*</span><span class="n">workqueue</span><span class="p">;</span>
	<span class="cm">/**/</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">worker</span><span class="p">;</span>

	<span class="cm">/* I2C adapter */</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span>	<span class="n">i2c_adapter</span><span class="p">;</span>
	<span class="cm">/* I2C lock */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">i2c_mutex</span><span class="p">;</span>
	<span class="cm">/* I2C message buffer space */</span>
	<span class="kt">char</span>			<span class="n">i2c_buf</span><span class="p">[</span><span class="n">HDPVR_I2C_MAX_SIZE</span><span class="p">];</span>

	<span class="cm">/* For passing data to ir-kbd-i2c */</span>
	<span class="k">struct</span> <span class="n">IR_i2c_init_data</span>	<span class="n">ir_i2c_init_data</span><span class="p">;</span>

	<span class="cm">/* usb control transfer buffer and lock */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">usbc_mutex</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="o">*</span><span class="n">usbc_buf</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">fw_ver</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hdpvr_device</span> <span class="o">*</span><span class="nf">to_hdpvr_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">v4l2_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hdpvr_device</span><span class="p">,</span> <span class="n">v4l2_dev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* buffer one bulk urb of data */</span>
<span class="k">struct</span> <span class="n">hdpvr_buffer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">buff_list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">urb</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hdpvr_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">uint</span>			<span class="n">pos</span><span class="p">;</span>

	<span class="n">__u8</span>			<span class="n">status</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* */</span>

<span class="k">struct</span> <span class="n">hdpvr_video_info</span> <span class="p">{</span>
	<span class="n">u16</span>	<span class="n">width</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">height</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">fps</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">STATUS_UNINITIALIZED</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">STATUS_IDLE</span><span class="p">,</span>
	<span class="n">STATUS_STARTING</span><span class="p">,</span>
	<span class="n">STATUS_SHUTTING_DOWN</span><span class="p">,</span>
	<span class="n">STATUS_STREAMING</span><span class="p">,</span>
	<span class="n">STATUS_ERROR</span><span class="p">,</span>
	<span class="n">STATUS_DISCONNECTED</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">HDPVR_FLAG_AC3_CAP</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">BUFSTAT_UNINITIALIZED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">BUFSTAT_AVAILABLE</span><span class="p">,</span>
	<span class="n">BUFSTAT_INPROGRESS</span><span class="p">,</span>
	<span class="n">BUFSTAT_READY</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define CTRL_START_STREAMING_VALUE	0x0700</span>
<span class="cp">#define CTRL_STOP_STREAMING_VALUE	0x0800</span>
<span class="cp">#define CTRL_BITRATE_VALUE		0x1000</span>
<span class="cp">#define CTRL_BITRATE_MODE_VALUE		0x1200</span>
<span class="cp">#define CTRL_GOP_MODE_VALUE		0x1300</span>
<span class="cp">#define CTRL_VIDEO_INPUT_VALUE		0x1500</span>
<span class="cp">#define CTRL_VIDEO_STD_TYPE		0x1700</span>
<span class="cp">#define CTRL_AUDIO_INPUT_VALUE		0x2500</span>
<span class="cp">#define CTRL_BRIGHTNESS			0x2900</span>
<span class="cp">#define CTRL_CONTRAST			0x2a00</span>
<span class="cp">#define CTRL_HUE			0x2b00</span>
<span class="cp">#define CTRL_SATURATION			0x2c00</span>
<span class="cp">#define CTRL_SHARPNESS			0x2d00</span>
<span class="cp">#define CTRL_LOW_PASS_FILTER_VALUE	0x3100</span>

<span class="cp">#define CTRL_DEFAULT_INDEX		0x0003</span>


	<span class="cm">/* :0 s 38 01 1000 0003 0004 4 = 0a00ca00</span>
<span class="cm">	 * BITRATE SETTING</span>
<span class="cm">	 *   1st and 2nd byte (little endian): average bitrate in 100 000 bit/s</span>
<span class="cm">	 *                                     min: 1 mbit/s, max: 13.5 mbit/s</span>
<span class="cm">	 *   3rd and 4th byte (little endian): peak bitrate in 100 000 bit/s</span>
<span class="cm">	 *                                     min: average + 100kbit/s,</span>
<span class="cm">	 *                                      max: 20.2 mbit/s</span>
<span class="cm">	 */</span>

	<span class="cm">/* :0 s 38 01 1200 0003 0001 1 = 02</span>
<span class="cm">	 * BIT RATE MODE</span>
<span class="cm">	 *  constant = 1, variable (peak) = 2, variable (average) = 3</span>
<span class="cm">	 */</span>

	<span class="cm">/* :0 s 38 01 1300 0003 0001 1 = 03</span>
<span class="cm">	 * GOP MODE (2 bit)</span>
<span class="cm">	 *    low bit 0/1: advanced/simple GOP</span>
<span class="cm">	 *   high bit 0/1: IDR(4/32/128) / no IDR (4/32/0)</span>
<span class="cm">	 */</span>

	<span class="cm">/* :0 s 38 01 1700 0003 0001 1 = 00</span>
<span class="cm">	 * VIDEO STANDARD or FREQUNCY 0 = 60hz, 1 = 50hz</span>
<span class="cm">	 */</span>

	<span class="cm">/* :0 s 38 01 3100 0003 0004 4 = 03030000</span>
<span class="cm">	 * FILTER CONTROL</span>
<span class="cm">	 *   1st byte luma low pass filter strength,</span>
<span class="cm">	 *   2nd byte chroma low pass filter strength,</span>
<span class="cm">	 *   3rd byte MF enable chroma, min=0, max=1</span>
<span class="cm">	 *   4th byte n</span>
<span class="cm">	 */</span>


	<span class="cm">/* :0 s 38 b9 0001 0000 0000 0 */</span>



<span class="cm">/* :0 s 38 d3 0000 0000 0001 1 = 00 */</span>
<span class="cm">/* 		ret = usb_control_msg(dev-&gt;udev, */</span>
<span class="cm">/* 				      usb_sndctrlpipe(dev-&gt;udev, 0), */</span>
<span class="cm">/* 				      0xd3, 0x38, */</span>
<span class="cm">/* 				      0, 0, */</span>
<span class="cm">/* 				      &quot;\0&quot;, 1, */</span>
<span class="cm">/* 				      1000); */</span>

<span class="cm">/* 		info(&quot;control request returned %d&quot;, ret); */</span>
<span class="cm">/* 		msleep(5000); */</span>


	<span class="cm">/* :0 s b8 81 1400 0003 0005 5 &lt;</span>
<span class="cm">	 * :0 0 5 = d0024002 19</span>
<span class="cm">	 * QUERY FRAME SIZE AND RATE</span>
<span class="cm">	 *   1st and 2nd byte (little endian): horizontal resolution</span>
<span class="cm">	 *   3rd and 4th byte (little endian): vertical resolution</span>
<span class="cm">	 *   5th byte: frame rate</span>
<span class="cm">	 */</span>

	<span class="cm">/* :0 s b8 81 1800 0003 0003 3 &lt;</span>
<span class="cm">	 * :0 0 3 = 030104</span>
<span class="cm">	 * QUERY SIGNAL AND DETECTED LINES, maybe INPUT</span>
<span class="cm">	 */</span>

<span class="k">enum</span> <span class="n">hdpvr_video_std</span> <span class="p">{</span>
	<span class="n">HDPVR_60HZ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">HDPVR_50HZ</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">hdpvr_video_input</span> <span class="p">{</span>
	<span class="n">HDPVR_COMPONENT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">HDPVR_SVIDEO</span><span class="p">,</span>
	<span class="n">HDPVR_COMPOSITE</span><span class="p">,</span>
	<span class="n">HDPVR_VIDEO_INPUTS</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">hdpvr_audio_inputs</span> <span class="p">{</span>
	<span class="n">HDPVR_RCA_BACK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">HDPVR_RCA_FRONT</span><span class="p">,</span>
	<span class="n">HDPVR_SPDIF</span><span class="p">,</span>
	<span class="n">HDPVR_AUDIO_INPUTS</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">hdpvr_bitrate_mode</span> <span class="p">{</span>
	<span class="n">HDPVR_CONSTANT</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">HDPVR_VARIABLE_PEAK</span><span class="p">,</span>
	<span class="n">HDPVR_VARIABLE_AVERAGE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">hdpvr_gop_mode</span> <span class="p">{</span>
	<span class="n">HDPVR_ADVANCED_IDR_GOP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">HDPVR_SIMPLE_IDR_GOP</span><span class="p">,</span>
	<span class="n">HDPVR_ADVANCED_NOIDR_GOP</span><span class="p">,</span>
	<span class="n">HDPVR_SIMPLE_NOIDR_GOP</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">hdpvr_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdpvr_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*========================================================================*/</span>
<span class="cm">/* hardware control functions */</span>
<span class="kt">int</span> <span class="n">hdpvr_set_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdpvr_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">hdpvr_set_bitrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdpvr_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">hdpvr_set_audio</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdpvr_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">input</span><span class="p">,</span>
		    <span class="k">enum</span> <span class="n">v4l2_mpeg_audio_encoding</span> <span class="n">codec</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">hdpvr_config_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdpvr_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">uint</span> <span class="n">value</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">valbuf</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">hdpvr_video_info</span> <span class="o">*</span><span class="n">get_video_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdpvr_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/* :0 s b8 81 1800 0003 0003 3 &lt; */</span>
<span class="cm">/* :0 0 3 = 0301ff */</span>
<span class="kt">int</span> <span class="n">get_input_lines_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdpvr_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>


<span class="cm">/*========================================================================*/</span>
<span class="cm">/* v4l2 registration */</span>
<span class="kt">int</span> <span class="n">hdpvr_register_videodev</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdpvr_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">devnumber</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">hdpvr_cancel_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdpvr_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*========================================================================*/</span>
<span class="cm">/* i2c adapter registration */</span>
<span class="kt">int</span> <span class="n">hdpvr_register_i2c_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdpvr_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">hdpvr_register_ir_rx_i2c</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdpvr_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">hdpvr_register_ir_tx_i2c</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdpvr_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*========================================================================*/</span>
<span class="cm">/* buffer management */</span>
<span class="kt">int</span> <span class="n">hdpvr_free_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdpvr_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">hdpvr_alloc_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">hdpvr_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">uint</span> <span class="n">count</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
