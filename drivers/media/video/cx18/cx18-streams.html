<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › cx18 › cx18-streams.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>cx18-streams.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  cx18 init/start/stop/exit stream functions</span>
<span class="cm"> *</span>
<span class="cm"> *  Derived from ivtv-streams.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2007  Hans Verkuil &lt;hverkuil@xs4all.nl&gt;</span>
<span class="cm"> *  Copyright (C) 2008  Andy Walls &lt;awalls@md.metrocast.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA</span>
<span class="cm"> *  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;cx18-driver.h&quot;</span>
<span class="cp">#include &quot;cx18-io.h&quot;</span>
<span class="cp">#include &quot;cx18-fileops.h&quot;</span>
<span class="cp">#include &quot;cx18-mailbox.h&quot;</span>
<span class="cp">#include &quot;cx18-i2c.h&quot;</span>
<span class="cp">#include &quot;cx18-queue.h&quot;</span>
<span class="cp">#include &quot;cx18-ioctl.h&quot;</span>
<span class="cp">#include &quot;cx18-streams.h&quot;</span>
<span class="cp">#include &quot;cx18-cards.h&quot;</span>
<span class="cp">#include &quot;cx18-scb.h&quot;</span>
<span class="cp">#include &quot;cx18-dvb.h&quot;</span>

<span class="cp">#define CX18_DSP0_INTERRUPT_MASK     	0xd0004C</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">v4l2_file_operations</span> <span class="n">cx18_v4l2_enc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">cx18_v4l2_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">cx18_v4l2_open</span><span class="p">,</span>
	<span class="cm">/* FIXME change to video_ioctl2 if serialization lock can be removed */</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">cx18_v4l2_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">cx18_v4l2_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span> <span class="n">cx18_v4l2_enc_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">cx18_v4l2_mmap</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* offset from 0 to register ts v4l2 minors on */</span>
<span class="cp">#define CX18_V4L2_ENC_TS_OFFSET   16</span>
<span class="cm">/* offset from 0 to register pcm v4l2 minors on */</span>
<span class="cp">#define CX18_V4L2_ENC_PCM_OFFSET  24</span>
<span class="cm">/* offset from 0 to register yuv v4l2 minors on */</span>
<span class="cp">#define CX18_V4L2_ENC_YUV_OFFSET  32</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vfl_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dma</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">v4l2_buf_type</span> <span class="n">buf_type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">cx18_stream_info</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>	<span class="cm">/* CX18_ENC_STREAM_TYPE_MPG */</span>
		<span class="s">&quot;encoder MPEG&quot;</span><span class="p">,</span>
		<span class="n">VFL_TYPE_GRABBER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">,</span> <span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* CX18_ENC_STREAM_TYPE_TS */</span>
		<span class="s">&quot;TS&quot;</span><span class="p">,</span>
		<span class="n">VFL_TYPE_GRABBER</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">,</span> <span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* CX18_ENC_STREAM_TYPE_YUV */</span>
		<span class="s">&quot;encoder YUV&quot;</span><span class="p">,</span>
		<span class="n">VFL_TYPE_GRABBER</span><span class="p">,</span> <span class="n">CX18_V4L2_ENC_YUV_OFFSET</span><span class="p">,</span>
		<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">,</span> <span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* CX18_ENC_STREAM_TYPE_VBI */</span>
		<span class="s">&quot;encoder VBI&quot;</span><span class="p">,</span>
		<span class="n">VFL_TYPE_VBI</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">,</span> <span class="n">V4L2_BUF_TYPE_VBI_CAPTURE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* CX18_ENC_STREAM_TYPE_PCM */</span>
		<span class="s">&quot;encoder PCM audio&quot;</span><span class="p">,</span>
		<span class="n">VFL_TYPE_GRABBER</span><span class="p">,</span> <span class="n">CX18_V4L2_ENC_PCM_OFFSET</span><span class="p">,</span>
		<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">,</span> <span class="n">V4L2_BUF_TYPE_PRIVATE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* CX18_ENC_STREAM_TYPE_IDX */</span>
		<span class="s">&quot;encoder IDX&quot;</span><span class="p">,</span>
		<span class="n">VFL_TYPE_GRABBER</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">,</span> <span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>	<span class="cm">/* CX18_ENC_STREAM_TYPE_RAD */</span>
		<span class="s">&quot;encoder radio&quot;</span><span class="p">,</span>
		<span class="n">VFL_TYPE_RADIO</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">PCI_DMA_NONE</span><span class="p">,</span> <span class="n">V4L2_BUF_TYPE_PRIVATE</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>


<span class="kt">void</span> <span class="nf">cx18_dma_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cx18_videobuf_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">videobuf_waiton</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">videobuf_vmalloc_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_NEEDS_INIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cx18_prepare_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">cx18_videobuf_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">pixelformat</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">v4l2_field</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* check settings */</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytes_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">width</span>  <span class="o">&lt;</span> <span class="mi">48</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">height</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">baddr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">bsize</span> <span class="o">&lt;</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* alloc + fill struct (if changed) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">width</span> <span class="o">!=</span> <span class="n">width</span> <span class="o">||</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">height</span> <span class="o">!=</span> <span class="n">height</span> <span class="o">||</span>
	    <span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">field</span> <span class="o">!=</span> <span class="n">field</span> <span class="o">||</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">pixelformat</span> <span class="o">!=</span> <span class="n">pixelformat</span> <span class="o">||</span>
	    <span class="n">buf</span><span class="o">-&gt;</span><span class="n">tvnorm</span> <span class="o">!=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">std</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">width</span>  <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">field</span>  <span class="o">=</span> <span class="n">field</span><span class="p">;</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">tvnorm</span>    <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">std</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">pixelformat</span> <span class="o">=</span> <span class="n">pixelformat</span><span class="p">;</span>

		<span class="cm">/* HM12 YUV size is (Y=(h*720) + UV=(h*(720/2)))</span>
<span class="cm">		   UYUV YUV size is (Y=(h*720) + UV=(h*(720))) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pixelformat</span> <span class="o">==</span> <span class="n">V4L2_PIX_FMT_HM12</span><span class="p">)</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_bytes_per_frame</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">720</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_bytes_per_frame</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">720</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">cx18_dma_free</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">baddr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">bsize</span> <span class="o">&lt;</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">field</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">V4L2_FIELD_INTERLACED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VIDEOBUF_NEEDS_INIT</span> <span class="o">==</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">width</span>  <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">field</span>  <span class="o">=</span> <span class="n">field</span><span class="p">;</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">tvnorm</span>    <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">std</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">pixelformat</span> <span class="o">=</span> <span class="n">pixelformat</span><span class="p">;</span>

		<span class="cm">/* HM12 YUV size is (Y=(h*720) + UV=(h*(720/2)))</span>
<span class="cm">		   UYUV YUV size is (Y=(h*720) + UV=(h*(720))) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pixelformat</span> <span class="o">==</span> <span class="n">V4L2_PIX_FMT_HM12</span><span class="p">)</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_bytes_per_frame</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">720</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_bytes_per_frame</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">720</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">videobuf_iolock</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_PREPARED</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">cx18_dma_free</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/* VB_MIN_BUFSIZE is lcm(1440 * 480, 1440 * 576)</span>
<span class="cm">   1440 is a single line of 4:2:2 YUV at 720 luma samples wide</span>
<span class="cm">*/</span>
<span class="cp">#define VB_MIN_BUFFERS 32</span>
<span class="cp">#define VB_MIN_BUFSIZE 4147200</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">buffer_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>

	<span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">VB_MIN_BUFFERS</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">size</span> <span class="o">*</span> <span class="o">*</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">VB_MIN_BUFFERS</span> <span class="o">*</span> <span class="n">VB_MIN_BUFSIZE</span><span class="p">)</span>
		<span class="p">(</span><span class="o">*</span><span class="n">count</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">field</span> <span class="o">=</span> <span class="n">V4L2_FIELD_INTERLACED</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">V4L2_FIELD_INTERLACED</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">buffer_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">v4l2_field</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18_videobuf_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cx18_videobuf_buffer</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cx18_prepare_buffer</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">pixelformat</span><span class="p">,</span>
		<span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">field</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">buffer_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18_videobuf_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cx18_videobuf_buffer</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>

	<span class="n">cx18_dma_free</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">buffer_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18_videobuf_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cx18_videobuf_buffer</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>

	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_QUEUED</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_capture</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">videobuf_queue_ops</span> <span class="n">cx18_videobuf_qops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">buf_setup</span>    <span class="o">=</span> <span class="n">buffer_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_prepare</span>  <span class="o">=</span> <span class="n">buffer_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_queue</span>    <span class="o">=</span> <span class="n">buffer_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_release</span>  <span class="o">=</span> <span class="n">buffer_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cx18_stream_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">video_device</span> <span class="o">*</span><span class="n">video_dev</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="p">;</span>

	<span class="cm">/* we need to keep video_dev, so restore it afterwards */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">));</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span> <span class="o">=</span> <span class="n">video_dev</span><span class="p">;</span>

	<span class="cm">/* initialize cx18_stream fields */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">dvb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span> <span class="o">=</span> <span class="n">cx</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">cx18_stream_info</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">=</span> <span class="n">CX18_INVALID_TASK_HANDLE</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">cx18_stream_info</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">dma</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">buffers</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">stream_buffers</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">buf_size</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">stream_buf_size</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buf_pool</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">bufs_per_mdl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">mdl_size</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buf_size</span> <span class="o">*</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bufs_per_mdl</span><span class="p">;</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_free</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">cx18_queue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_free</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_busy</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">cx18_queue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_busy</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_full</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">cx18_queue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_full</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_idle</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">cx18_queue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_idle</span><span class="p">);</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">out_work_order</span><span class="p">,</span> <span class="n">cx18_out_work_handler</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_capture</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_timeout</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">cx18_vb_timeout</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_timeout</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">s</span><span class="p">;</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_timeout</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_YUV</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vbuf_q_lock</span><span class="p">);</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_type</span> <span class="o">=</span> <span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">;</span>
		<span class="n">videobuf_queue_vmalloc_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vbuf_q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cx18_videobuf_qops</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vbuf_q_lock</span><span class="p">,</span>
			<span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">,</span>
			<span class="n">V4L2_FIELD_INTERLACED</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_videobuf_buffer</span><span class="p">),</span>
			<span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">serialize_lock</span><span class="p">);</span>

		<span class="cm">/* Assume the previous pixel default */</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">pixelformat</span> <span class="o">=</span> <span class="n">V4L2_PIX_FMT_HM12</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_bytes_per_frame</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">.</span><span class="n">height</span> <span class="o">*</span> <span class="mi">720</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cx18_prep_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">cap</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">v4l2_cap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_offset</span> <span class="o">=</span> <span class="n">cx18_stream_info</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">num_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">instance</span> <span class="o">+</span> <span class="n">cx18_first_minor</span> <span class="o">+</span> <span class="n">num_offset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * These five fields are always initialized.</span>
<span class="cm">	 * For analog capture related streams, if video_dev == NULL then the</span>
<span class="cm">	 * stream is not in use.</span>
<span class="cm">	 * For the TS stream, if dvb == NULL then the stream is not in use.</span>
<span class="cm">	 * In those cases no other fields but these four can be used.</span>
<span class="cm">	 */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">dvb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span> <span class="o">=</span> <span class="n">cx</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">cx18_stream_info</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/* Check whether the radio is supported */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_RAD</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="n">V4L2_CAP_RADIO</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Check whether VBI is supported */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_VBI</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">cap</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">V4L2_CAP_VBI_CAPTURE</span> <span class="o">|</span> <span class="n">V4L2_CAP_SLICED_VBI_CAPTURE</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* User explicitly selected 0 buffers for these streams, so don&#39;t</span>
<span class="cm">	   create them. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cx18_stream_info</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">dma</span> <span class="o">!=</span> <span class="n">PCI_DMA_NONE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cx</span><span class="o">-&gt;</span><span class="n">stream_buffers</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CX18_INFO</span><span class="p">(</span><span class="s">&quot;Disabled %s device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cx18_stream_info</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cx18_stream_init</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

	<span class="cm">/* Allocate the cx18_dvb struct only for the TS on cards with DTV */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_TS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">hw_all</span> <span class="o">&amp;</span> <span class="n">CX18_HW_DVB</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">dvb</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_dvb</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dvb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">CX18_ERR</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t allocate cx18_dvb structure&quot;</span>
					 <span class="s">&quot; for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Don&#39;t need buffers for the TS, if there is no DVB */</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">buffers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_offset</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* allocate and initialize the v4l2 video device structure */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span> <span class="o">=</span> <span class="n">video_device_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CX18_ERR</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t allocate v4l2 video_device for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;%s %s&quot;</span><span class="p">,</span>
		 <span class="n">cx</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="o">-&gt;</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx18_v4l2_enc_fops</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">=</span> <span class="n">video_device_release</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="o">-&gt;</span><span class="n">tvnorms</span> <span class="o">=</span> <span class="n">V4L2_STD_ALL</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">V4L2_FL_USE_FH_PRIO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">cx18_set_funcs</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize v4l2 variables and register v4l2 devices */</span>
<span class="kt">int</span> <span class="nf">cx18_streams_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Setup V4L2 Devices */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">type</span> <span class="o">&lt;</span> <span class="n">CX18_MAX_STREAMS</span><span class="p">;</span> <span class="n">type</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Prepare device */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cx18_prep_dev</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Allocate Stream */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cx18_stream_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_MAX_STREAMS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* One or more streams could not be initialized. Clean &#39;em all up. */</span>
	<span class="n">cx18_streams_cleanup</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cx18_reg_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">vfl_type</span> <span class="o">=</span> <span class="n">cx18_stream_info</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">vfl_type</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_TS</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dvb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cx18_dvb_register</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">CX18_ERR</span><span class="p">(</span><span class="s">&quot;DVB failed to register</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">num</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
	<span class="cm">/* card number + user defined offset + device offset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">CX18_ENC_STREAM_TYPE_MPG</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s_mpg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">CX18_ENC_STREAM_TYPE_MPG</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">s_mpg</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="p">)</span>
			<span class="n">num</span> <span class="o">=</span> <span class="n">s_mpg</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="o">-&gt;</span><span class="n">num</span>
			    <span class="o">+</span> <span class="n">cx18_stream_info</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">num_offset</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">video_set_drvdata</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

	<span class="cm">/* Register device. First try the desired minor, then any free one. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">video_register_device_no_warn</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="p">,</span> <span class="n">vfl_type</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CX18_ERR</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t register v4l2 device for %s (device node number %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
		<span class="n">video_device_release</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">video_device_node_name</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vfl_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VFL_TYPE_GRABBER</span>:
		<span class="n">CX18_INFO</span><span class="p">(</span><span class="s">&quot;Registered device %s for %s (%d x %d.%02d kB)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">stream_buffers</span><span class="p">[</span><span class="n">type</span><span class="p">],</span>
			  <span class="n">cx</span><span class="o">-&gt;</span><span class="n">stream_buf_size</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">stream_buf_size</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">%</span> <span class="mi">100</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">VFL_TYPE_RADIO</span>:
		<span class="n">CX18_INFO</span><span class="p">(</span><span class="s">&quot;Registered device %s for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">VFL_TYPE_VBI</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">stream_buffers</span><span class="p">[</span><span class="n">type</span><span class="p">])</span>
			<span class="n">CX18_INFO</span><span class="p">(</span><span class="s">&quot;Registered device %s for %s &quot;</span>
				  <span class="s">&quot;(%d x %d bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">stream_buffers</span><span class="p">[</span><span class="n">type</span><span class="p">],</span>
				  <span class="n">cx</span><span class="o">-&gt;</span><span class="n">stream_buf_size</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">CX18_INFO</span><span class="p">(</span><span class="s">&quot;Registered device %s for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Register v4l2 devices */</span>
<span class="kt">int</span> <span class="nf">cx18_streams_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Register V4L2 devices */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">type</span> <span class="o">&lt;</span> <span class="n">CX18_MAX_STREAMS</span><span class="p">;</span> <span class="n">type</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">cx18_reg_dev</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* One or more streams could not be initialized. Clean &#39;em all up. */</span>
	<span class="n">cx18_streams_cleanup</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Unregister v4l2 devices */</span>
<span class="kt">void</span> <span class="nf">cx18_streams_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unregister</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">video_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>

	<span class="cm">/* Teardown all streams */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">type</span> <span class="o">&lt;</span> <span class="n">CX18_MAX_STREAMS</span><span class="p">;</span> <span class="n">type</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* The TS has a cx18_dvb structure, not a video_device */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_TS</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">dvb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unregister</span><span class="p">)</span>
					<span class="n">cx18_dvb_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">dvb</span><span class="p">);</span>
				<span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">dvb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">cx18_stream_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* No struct video_device, but can have buffers allocated */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_IDX</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If the module params didn&#39;t inhibit IDX ... */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">stream_buffers</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cx</span><span class="o">-&gt;</span><span class="n">stream_buffers</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * Before calling cx18_stream_free(),</span>
<span class="cm">				 * check if the IDX stream was actually set up.</span>
<span class="cm">				 * Needed, since the cx18_probe() error path</span>
<span class="cm">				 * exits through here as well as normal clean up</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">buffers</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">cx18_stream_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If struct video_device exists, can have buffers allocated */</span>
		<span class="n">vdev</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">video_dev</span><span class="p">;</span>

		<span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">video_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_YUV</span><span class="p">)</span>
			<span class="n">videobuf_mmap_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">vbuf_q</span><span class="p">);</span>

		<span class="n">cx18_stream_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">type</span><span class="p">]);</span>

		<span class="cm">/* Unregister or release device */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unregister</span><span class="p">)</span>
			<span class="n">video_unregister_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">video_device_release</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cx18_vbi_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">raw</span> <span class="o">=</span> <span class="n">cx18_raw_vbi</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">[</span><span class="n">CX2341X_MBOX_MAX_DATA</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">lines</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">is_60hz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
		<span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">273</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>        <span class="cm">/* PAL/SECAM */</span>
		<span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
		<span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">318</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* setup VBI registers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">raw</span><span class="p">)</span>
		<span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">sd_av</span><span class="p">,</span> <span class="n">vbi</span><span class="p">,</span> <span class="n">s_raw_fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">in</span><span class="p">.</span><span class="n">fmt</span><span class="p">.</span><span class="n">vbi</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">sd_av</span><span class="p">,</span> <span class="n">vbi</span><span class="p">,</span> <span class="n">s_sliced_fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">in</span><span class="p">.</span><span class="n">fmt</span><span class="p">.</span><span class="n">sliced</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send the CX18_CPU_SET_RAW_VBI_PARAM API command to setup Encoder Raw</span>
<span class="cm">	 * VBI when the first analog capture channel starts, as once it starts</span>
<span class="cm">	 * (e.g. MPEG), we can&#39;t effect any change in the Encoder Raw VBI setup</span>
<span class="cm">	 * (i.e. for the VBI capture channels).  We also send it for each</span>
<span class="cm">	 * analog capture channel anyway just to make sure we get the proper</span>
<span class="cm">	 * behavior</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">raw</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lines</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">count</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For 525/60 systems, according to the VIP 2 &amp; BT.656 std:</span>
<span class="cm">		 * The EAV RP code&#39;s Field bit toggles on line 4, a few lines</span>
<span class="cm">		 * after the Vertcal Blank bit has already toggled.</span>
<span class="cm">		 * Tell the encoder to capture 21-4+1=18 lines per field,</span>
<span class="cm">		 * since we want lines 10 through 21.</span>
<span class="cm">		 *</span>
<span class="cm">		 * For 625/50 systems, according to the VIP 2 &amp; BT.656 std:</span>
<span class="cm">		 * The EAV RP code&#39;s Field bit toggles on line 1, a few lines</span>
<span class="cm">		 * after the Vertcal Blank bit has already toggled.</span>
<span class="cm">		 * (We&#39;ve actually set the digitizer so that the Field bit</span>
<span class="cm">		 * toggles on line 2.) Tell the encoder to capture 23-2+1=22</span>
<span class="cm">		 * lines per field, since we want lines 6 through 23.</span>
<span class="cm">		 */</span>
		<span class="n">lines</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">is_60hz</span> <span class="o">?</span> <span class="p">(</span><span class="mi">21</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">:</span> <span class="p">(</span><span class="mi">23</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">;</span>
	<span class="cm">/* Lines per field */</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lines</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">lines</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="cm">/* bytes per line */</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">raw</span> <span class="o">?</span> <span class="n">vbi_active_samples</span>
		       <span class="o">:</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">is_60hz</span> <span class="o">?</span> <span class="n">vbi_hblank_samples_60Hz</span>
				      <span class="o">:</span> <span class="n">vbi_hblank_samples_50Hz</span><span class="p">));</span>
	<span class="cm">/* Every X number of frames a VBI interrupt arrives</span>
<span class="cm">	   (frames as in 25 or 30 fps) */</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set the SAV/EAV RP codes to look for as start/stop points</span>
<span class="cm">	 * when in VIP-1.1 mode</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">raw</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Start codes for beginning of &quot;active&quot; line in vertical blank</span>
<span class="cm">		 * 0x20 (               VerticalBlank                )</span>
<span class="cm">		 * 0x60 (     EvenField VerticalBlank                )</span>
<span class="cm">		 */</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20602060</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * End codes for end of &quot;active&quot; raw lines and regular lines</span>
<span class="cm">		 * 0x30 (               VerticalBlank HorizontalBlank)</span>
<span class="cm">		 * 0x70 (     EvenField VerticalBlank HorizontalBlank)</span>
<span class="cm">		 * 0x90 (Task                         HorizontalBlank)</span>
<span class="cm">		 * 0xd0 (Task EvenField               HorizontalBlank)</span>
<span class="cm">		 */</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x307090d0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * End codes for active video, we want data in the hblank region</span>
<span class="cm">		 * 0xb0 (Task         0 VerticalBlank HorizontalBlank)</span>
<span class="cm">		 * 0xf0 (Task EvenField VerticalBlank HorizontalBlank)</span>
<span class="cm">		 *</span>
<span class="cm">		 * Since the V bit is only allowed to toggle in the EAV RP code,</span>
<span class="cm">		 * just before the first active region line, these two</span>
<span class="cm">		 * are problematic:</span>
<span class="cm">		 * 0x90 (Task                         HorizontalBlank)</span>
<span class="cm">		 * 0xd0 (Task EvenField               HorizontalBlank)</span>
<span class="cm">		 *</span>
<span class="cm">		 * We have set the digitzer such that we don&#39;t have to worry</span>
<span class="cm">		 * about these problem codes.</span>
<span class="cm">		 */</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xB0F0B0F0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Start codes for beginning of active line in vertical blank</span>
<span class="cm">		 * 0xa0 (Task           VerticalBlank                )</span>
<span class="cm">		 * 0xe0 (Task EvenField VerticalBlank                )</span>
<span class="cm">		 */</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xA0E0A0E0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;Setup VBI h: %d lines %x bpl %d fr %d %x %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>

	<span class="n">cx18_api</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_SET_RAW_VBI_PARAM</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cx18_stream_rotate_idx_mdls</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">CX18_ENC_STREAM_TYPE_IDX</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">cx18_mdl</span> <span class="o">*</span><span class="n">mdl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cx18_stream_enabled</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Return if the firmware is not running low on MDLs */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_free</span><span class="p">.</span><span class="n">depth</span><span class="p">)</span> <span class="o">+</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_busy</span><span class="p">.</span><span class="n">depth</span><span class="p">))</span> <span class="o">&gt;=</span>
					    <span class="n">CX18_ENC_STREAM_TYPE_IDX_FW_MDL_MIN</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Return if there are no MDLs to rotate back to the firmware */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_full</span><span class="p">.</span><span class="n">depth</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Take the oldest IDX MDL still holding data, and discard its index</span>
<span class="cm">	 * entries by scheduling the MDL to go back to the firmware</span>
<span class="cm">	 */</span>
	<span class="n">mdl</span> <span class="o">=</span> <span class="n">cx18_dequeue</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_full</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mdl</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">cx18_enqueue</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_free</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="k">struct</span> <span class="n">cx18_queue</span> <span class="o">*</span><span class="nf">_cx18_stream_put_mdl_fw</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">cx18_mdl</span> <span class="o">*</span><span class="n">mdl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t give it to the firmware, if we&#39;re not running a capture */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">==</span> <span class="n">CX18_INVALID_TASK_HANDLE</span> <span class="o">||</span>
	    <span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_STOPPING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">cx18_enqueue</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_free</span><span class="p">);</span>

	<span class="n">q</span> <span class="o">=</span> <span class="n">cx18_enqueue</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_busy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_busy</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">q</span><span class="p">;</span> <span class="cm">/* The firmware has the max MDLs it can handle */</span>

	<span class="n">cx18_mdl_sync_for_device</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mdl</span><span class="p">);</span>
	<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_DE_SET_MDL</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">cpu_mdl</span><span class="p">[</span><span class="n">mdl</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">-</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">enc_mem</span><span class="p">,</span>
		  <span class="n">s</span><span class="o">-&gt;</span><span class="n">bufs_per_mdl</span><span class="p">,</span> <span class="n">mdl</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">mdl_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">q</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">void</span> <span class="nf">_cx18_stream_load_fw_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_mdl</span> <span class="o">*</span><span class="n">mdl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_free</span><span class="p">.</span><span class="n">depth</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_busy</span><span class="p">.</span><span class="n">depth</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">CX18_MAX_FW_MDLS_PER_STREAM</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Move from q_free to q_busy notifying the firmware, until the limit */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">mdl</span> <span class="o">=</span> <span class="n">cx18_dequeue</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_free</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mdl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">_cx18_stream_put_mdl_fw</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mdl</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_busy</span><span class="p">.</span><span class="n">depth</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">CX18_MAX_FW_MDLS_PER_STREAM</span>
		 <span class="o">&amp;&amp;</span> <span class="n">q</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_busy</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cx18_out_work_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span>
			 <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cx18_stream</span><span class="p">,</span> <span class="n">out_work_order</span><span class="p">);</span>

	<span class="n">_cx18_stream_load_fw_queue</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cx18_stream_configure_mdls</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cx18_unload_queues</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CX18_ENC_STREAM_TYPE_YUV</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Height should be a multiple of 32 lines.</span>
<span class="cm">		 * Set the MDL size to the exact size needed for one frame.</span>
<span class="cm">		 * Use enough buffers per MDL to cover the MDL size</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pixelformat</span> <span class="o">==</span> <span class="n">V4L2_PIX_FMT_HM12</span><span class="p">)</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">mdl_size</span> <span class="o">=</span> <span class="mi">720</span> <span class="o">*</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">.</span><span class="n">height</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">mdl_size</span> <span class="o">=</span> <span class="mi">720</span> <span class="o">*</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">.</span><span class="n">height</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">bufs_per_mdl</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">mdl_size</span> <span class="o">/</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buf_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">mdl_size</span> <span class="o">%</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buf_size</span><span class="p">)</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">bufs_per_mdl</span><span class="o">++</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CX18_ENC_STREAM_TYPE_VBI</span>:
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">bufs_per_mdl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span>  <span class="p">(</span><span class="n">cx18_raw_vbi</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">mdl_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">is_60hz</span> <span class="o">?</span> <span class="mi">12</span> <span class="o">:</span> <span class="mi">18</span><span class="p">)</span>
						       <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">vbi_active_samples</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * See comment in cx18_vbi_setup() below about the</span>
<span class="cm">			 * extra lines we capture in sliced VBI mode due to</span>
<span class="cm">			 * the lines on which EAV RP codes toggle.</span>
<span class="cm">			*/</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">mdl_size</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">is_60hz</span>
				   <span class="o">?</span> <span class="p">(</span><span class="mi">21</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">vbi_hblank_samples_60Hz</span>
				   <span class="o">:</span> <span class="p">(</span><span class="mi">23</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">vbi_hblank_samples_50Hz</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">bufs_per_mdl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">mdl_size</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buf_size</span> <span class="o">*</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bufs_per_mdl</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cx18_load_queues</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cx18_start_v4l2_encode_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">[</span><span class="n">MAX_MB_ARGUMENTS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">captype</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s_idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cx18_stream_enabled</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;Start encoder stream %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CX18_ENC_STREAM_TYPE_MPG</span>:
		<span class="n">captype</span> <span class="o">=</span> <span class="n">CAPTURE_CHANNEL_TYPE_MPEG</span><span class="p">;</span>
		<span class="n">cx</span><span class="o">-&gt;</span><span class="n">mpg_data_received</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi_data_inserted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cx</span><span class="o">-&gt;</span><span class="n">dualwatch_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">cx</span><span class="o">-&gt;</span><span class="n">dualwatch_stereo_mode</span> <span class="o">=</span> <span class="n">v4l2_ctrl_g_ctrl</span><span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">.</span><span class="n">audio_mode</span><span class="p">);</span>
		<span class="n">cx</span><span class="o">-&gt;</span><span class="n">search_pack_header</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CX18_ENC_STREAM_TYPE_IDX</span>:
		<span class="n">captype</span> <span class="o">=</span> <span class="n">CAPTURE_CHANNEL_TYPE_INDEX</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CX18_ENC_STREAM_TYPE_TS</span>:
		<span class="n">captype</span> <span class="o">=</span> <span class="n">CAPTURE_CHANNEL_TYPE_TS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CX18_ENC_STREAM_TYPE_YUV</span>:
		<span class="n">captype</span> <span class="o">=</span> <span class="n">CAPTURE_CHANNEL_TYPE_YUV</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CX18_ENC_STREAM_TYPE_PCM</span>:
		<span class="n">captype</span> <span class="o">=</span> <span class="n">CAPTURE_CHANNEL_TYPE_PCM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CX18_ENC_STREAM_TYPE_VBI</span>:
<span class="cp">#ifdef CX18_ENCODER_PARSES_SLICED</span>
		<span class="n">captype</span> <span class="o">=</span> <span class="n">cx18_raw_vbi</span><span class="p">(</span><span class="n">cx</span><span class="p">)</span> <span class="o">?</span>
		     <span class="n">CAPTURE_CHANNEL_TYPE_VBI</span> <span class="o">:</span> <span class="n">CAPTURE_CHANNEL_TYPE_SLICED_VBI</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="cm">/*</span>
<span class="cm">		 * Currently we set things up so that Sliced VBI from the</span>
<span class="cm">		 * digitizer is handled as Raw VBI by the encoder</span>
<span class="cm">		 */</span>
		<span class="n">captype</span> <span class="o">=</span> <span class="n">CAPTURE_CHANNEL_TYPE_VBI</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">inserted_frame</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">sliced_mpeg_size</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">sliced_mpeg_size</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear Streamoff flags in case left from last capture */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMOFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>

	<span class="n">cx18_vapi_result</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">CX18_CREATE_TASK</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">CPU_CMD_MASK_CAPTURE</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_SET_CHANNEL_TYPE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="n">captype</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * For everything but CAPTURE_CHANNEL_TYPE_TS, play it safe and</span>
<span class="cm">	 * set up all the parameters, as it is not obvious which parameters the</span>
<span class="cm">	 * firmware shares across capture channel types and which it does not.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Some of the cx18_vapi() calls below apply to only certain capture</span>
<span class="cm">	 * channel types.  We&#39;re hoping there&#39;s no harm in calling most of them</span>
<span class="cm">	 * anyway, as long as the values are all consistent.  Setting some</span>
<span class="cm">	 * shared parameters will have no effect once an analog capture channel</span>
<span class="cm">	 * has started streaming.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">captype</span> <span class="o">!=</span> <span class="n">CAPTURE_CHANNEL_TYPE_TS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_SET_VER_CROP_LINE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_SET_MISC_PARAMETERS</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_SET_MISC_PARAMETERS</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_SET_MISC_PARAMETERS</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Audio related reset according to</span>
<span class="cm">		 * Documentation/video4linux/cx2341x/fw-encoder-api.txt</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">ana_capturing</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_SET_MISC_PARAMETERS</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
				  <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Number of lines for Field 1 &amp; Field 2 according to</span>
<span class="cm">		 * Documentation/video4linux/cx2341x/fw-encoder-api.txt</span>
<span class="cm">		 * Field 1 is 312 for 625 line systems in BT.656</span>
<span class="cm">		 * Field 2 is 313 for 625 line systems in BT.656</span>
<span class="cm">		 */</span>
		<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_SET_CAPTURE_LINE_NO</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
			  <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="mi">312</span><span class="p">,</span> <span class="mi">313</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">v4l2_cap</span> <span class="o">&amp;</span> <span class="n">V4L2_CAP_VBI_CAPTURE</span><span class="p">)</span>
			<span class="n">cx18_vbi_setup</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Select to receive I, P, and B frame index entries, if the</span>
<span class="cm">		 * index stream is enabled.  Otherwise disable index entry</span>
<span class="cm">		 * generation.</span>
<span class="cm">		 */</span>
		<span class="n">s_idx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">CX18_ENC_STREAM_TYPE_IDX</span><span class="p">];</span>
		<span class="n">cx18_vapi_result</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">CX18_CPU_SET_INDEXTABLE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
				 <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="n">cx18_stream_enabled</span><span class="p">(</span><span class="n">s_idx</span><span class="p">)</span> <span class="o">?</span> <span class="mi">7</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Call out to the common CX2341x API setup for user controls */</span>
		<span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">.</span><span class="n">priv</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
		<span class="n">cx2341x_handler_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * When starting a capture and we&#39;re set for radio,</span>
<span class="cm">		 * ensure the video is muted, despite the user control.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">.</span><span class="n">video_mute</span> <span class="o">&amp;&amp;</span>
		    <span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_I_RADIO_USER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">))</span>
			<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_SET_VIDEO_MUTE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">v4l2_ctrl_g_ctrl</span><span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">.</span><span class="n">video_mute_yuv</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Enable the Video Format Converter for UYVY 4:2:2 support,</span>
<span class="cm">		 * rather than the default HM12 Macroblovk 4:2:0 support.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">captype</span> <span class="o">==</span> <span class="n">CAPTURE_CHANNEL_TYPE_YUV</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pixelformat</span> <span class="o">==</span> <span class="n">V4L2_PIX_FMT_UYVY</span><span class="p">)</span>
				<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_SET_VFC_PARAM</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="cm">/* If in doubt, default to HM12 */</span>
				<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_SET_VFC_PARAM</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">tot_capturing</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cx2341x_handler_set_busy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_I_EOS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
		<span class="n">cx18_write_reg</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">CX18_DSP0_INTERRUPT_MASK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_DE_SET_MDL_ACK</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">cpu_mdl_ack</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">enc_mem</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">cpu_mdl_ack</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">enc_mem</span><span class="p">);</span>

	<span class="cm">/* Init all the cpu_mdls for this stream */</span>
	<span class="n">cx18_stream_configure_mdls</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">_cx18_stream_load_fw_queue</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="cm">/* begin_capture */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_CAPTURE_START</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">CX18_DEBUG_WARN</span><span class="p">(</span><span class="s">&quot;Error starting capture!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* Ensure we&#39;re really not capturing before releasing MDLs */</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CX18_F_S_STOPPING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_MPG</span><span class="p">)</span>
			<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_CAPTURE_STOP</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_CAPTURE_STOP</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
		<span class="cm">/* FIXME - CX18_F_S_STREAMOFF as well? */</span>
		<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_DE_RELEASE_MDL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
		<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_DESTROY_TASK</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">=</span> <span class="n">CX18_INVALID_TASK_HANDLE</span><span class="p">;</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_STOPPING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">tot_capturing</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">CX18_F_I_EOS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
			<span class="n">cx18_write_reg</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">CX18_DSP0_INTERRUPT_MASK</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* you&#39;re live! sit back and await interrupts :) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">captype</span> <span class="o">!=</span> <span class="n">CAPTURE_CHANNEL_TYPE_TS</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">ana_capturing</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">tot_capturing</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cx18_start_v4l2_encode_stream</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">cx18_stop_all_captures</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">CX18_MAX_STREAMS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cx18_stream_enabled</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span>
			<span class="n">cx18_stop_v4l2_encode_stream</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cx18_stop_v4l2_encode_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gop_end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cx18_stream_enabled</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* This function assumes that you are allowed to stop the capture</span>
<span class="cm">	   and that we are actually capturing */</span>

	<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;Stop Capture</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">tot_capturing</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">CX18_F_S_STOPPING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_MPG</span><span class="p">)</span>
		<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_CAPTURE_STOP</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="o">!</span><span class="n">gop_end</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_CAPTURE_STOP</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_MPG</span> <span class="o">&amp;&amp;</span> <span class="n">gop_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CX18_INFO</span><span class="p">(</span><span class="s">&quot;ignoring gop_end: not (yet?) supported by the firmware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">CX18_ENC_STREAM_TYPE_TS</span><span class="p">)</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">ana_capturing</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">tot_capturing</span><span class="p">);</span>

	<span class="cm">/* Clear capture and no-read bits */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>

	<span class="cm">/* Tell the CX23418 it can&#39;t use our buffers anymore */</span>
	<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_DE_RELEASE_MDL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>

	<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_DESTROY_TASK</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">=</span> <span class="n">CX18_INVALID_TASK_HANDLE</span><span class="p">;</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_STOPPING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">tot_capturing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cx2341x_handler_set_busy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cx18_write_reg</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">CX18_DSP0_INTERRUPT_MASK</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cx18_stop_v4l2_encode_stream</span><span class="p">);</span>

<span class="n">u32</span> <span class="nf">cx18_find_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* find first available handle to be used for global settings */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CX18_MAX_STREAMS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">!=</span> <span class="n">CX18_INVALID_TASK_HANDLE</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">CX18_INVALID_TASK_HANDLE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="nf">cx18_handle_to_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">handle</span> <span class="o">==</span> <span class="n">CX18_INVALID_TASK_HANDLE</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CX18_MAX_STREAMS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">!=</span> <span class="n">handle</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cx18_stream_enabled</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
