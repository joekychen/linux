<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › cx18 › cx18-driver.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>cx18-driver.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  cx18 driver internal defines and structures</span>
<span class="cm"> *</span>
<span class="cm"> *  Derived from ivtv-driver.h</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2007  Hans Verkuil &lt;hverkuil@xs4all.nl&gt;</span>
<span class="cm"> *  Copyright (C) 2008  Andy Walls &lt;awalls@md.metrocast.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA</span>
<span class="cm"> *  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef CX18_DRIVER_H</span>
<span class="cp">#define CX18_DRIVER_H</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/i2c-algo-bit.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &lt;media/v4l2-common.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-ioctl.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-device.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-fh.h&gt;</span>
<span class="cp">#include &lt;media/tuner.h&gt;</span>
<span class="cp">#include &lt;media/ir-kbd-i2c.h&gt;</span>
<span class="cp">#include &quot;cx18-mailbox.h&quot;</span>
<span class="cp">#include &quot;cx18-av-core.h&quot;</span>
<span class="cp">#include &quot;cx23418.h&quot;</span>

<span class="cm">/* DVB */</span>
<span class="cp">#include &quot;demux.h&quot;</span>
<span class="cp">#include &quot;dmxdev.h&quot;</span>
<span class="cp">#include &quot;dvb_demux.h&quot;</span>
<span class="cp">#include &quot;dvb_frontend.h&quot;</span>
<span class="cp">#include &quot;dvb_net.h&quot;</span>
<span class="cp">#include &quot;dvbdev.h&quot;</span>

<span class="cm">/* Videobuf / YUV support */</span>
<span class="cp">#include &lt;media/videobuf-core.h&gt;</span>
<span class="cp">#include &lt;media/videobuf-vmalloc.h&gt;</span>

<span class="cp">#ifndef CONFIG_PCI</span>
<span class="cp">#  error &quot;This driver requires kernel PCI support.&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#define CX18_MEM_OFFSET	0x00000000</span>
<span class="cp">#define CX18_MEM_SIZE	0x04000000</span>
<span class="cp">#define CX18_REG_OFFSET	0x02000000</span>

<span class="cm">/* Maximum cx18 driver instances. */</span>
<span class="cp">#define CX18_MAX_CARDS 32</span>

<span class="cm">/* Supported cards */</span>
<span class="cp">#define CX18_CARD_HVR_1600_ESMT	      0	</span><span class="cm">/* Hauppauge HVR 1600 (ESMT memory) */</span><span class="cp"></span>
<span class="cp">#define CX18_CARD_HVR_1600_SAMSUNG    1	</span><span class="cm">/* Hauppauge HVR 1600 (Samsung memory) */</span><span class="cp"></span>
<span class="cp">#define CX18_CARD_COMPRO_H900 	      2	</span><span class="cm">/* Compro VideoMate H900 */</span><span class="cp"></span>
<span class="cp">#define CX18_CARD_YUAN_MPC718 	      3	</span><span class="cm">/* Yuan MPC718 */</span><span class="cp"></span>
<span class="cp">#define CX18_CARD_CNXT_RAPTOR_PAL     4	</span><span class="cm">/* Conexant Raptor PAL */</span><span class="cp"></span>
<span class="cp">#define CX18_CARD_TOSHIBA_QOSMIO_DVBT 5 </span><span class="cm">/* Toshiba Qosmio Interal DVB-T/Analog*/</span><span class="cp"></span>
<span class="cp">#define CX18_CARD_LEADTEK_PVR2100     6 </span><span class="cm">/* Leadtek WinFast PVR2100 */</span><span class="cp"></span>
<span class="cp">#define CX18_CARD_LEADTEK_DVR3100H    7 </span><span class="cm">/* Leadtek WinFast DVR3100 H */</span><span class="cp"></span>
<span class="cp">#define CX18_CARD_GOTVIEW_PCI_DVD3    8 </span><span class="cm">/* GoTView PCI DVD3 Hybrid */</span><span class="cp"></span>
<span class="cp">#define CX18_CARD_HVR_1600_S5H1411    9 </span><span class="cm">/* Hauppauge HVR 1600 s5h1411/tda18271*/</span><span class="cp"></span>
<span class="cp">#define CX18_CARD_LAST		      9</span>

<span class="cp">#define CX18_ENC_STREAM_TYPE_MPG  0</span>
<span class="cp">#define CX18_ENC_STREAM_TYPE_TS   1</span>
<span class="cp">#define CX18_ENC_STREAM_TYPE_YUV  2</span>
<span class="cp">#define CX18_ENC_STREAM_TYPE_VBI  3</span>
<span class="cp">#define CX18_ENC_STREAM_TYPE_PCM  4</span>
<span class="cp">#define CX18_ENC_STREAM_TYPE_IDX  5</span>
<span class="cp">#define CX18_ENC_STREAM_TYPE_RAD  6</span>
<span class="cp">#define CX18_MAX_STREAMS	  7</span>

<span class="cm">/* system vendor and device IDs */</span>
<span class="cp">#define PCI_VENDOR_ID_CX      0x14f1</span>
<span class="cp">#define PCI_DEVICE_ID_CX23418 0x5b7a</span>

<span class="cm">/* subsystem vendor ID */</span>
<span class="cp">#define CX18_PCI_ID_HAUPPAUGE 		0x0070</span>
<span class="cp">#define CX18_PCI_ID_COMPRO 		0x185b</span>
<span class="cp">#define CX18_PCI_ID_YUAN 		0x12ab</span>
<span class="cp">#define CX18_PCI_ID_CONEXANT		0x14f1</span>
<span class="cp">#define CX18_PCI_ID_TOSHIBA		0x1179</span>
<span class="cp">#define CX18_PCI_ID_LEADTEK		0x107D</span>
<span class="cp">#define CX18_PCI_ID_GOTVIEW		0x5854</span>

<span class="cm">/* ======================================================================== */</span>
<span class="cm">/* ========================== START USER SETTABLE DMA VARIABLES =========== */</span>
<span class="cm">/* ======================================================================== */</span>

<span class="cm">/* DMA Buffers, Default size in MB allocated */</span>
<span class="cp">#define CX18_DEFAULT_ENC_TS_BUFFERS  1</span>
<span class="cp">#define CX18_DEFAULT_ENC_MPG_BUFFERS 2</span>
<span class="cp">#define CX18_DEFAULT_ENC_IDX_BUFFERS 1</span>
<span class="cp">#define CX18_DEFAULT_ENC_YUV_BUFFERS 2</span>
<span class="cp">#define CX18_DEFAULT_ENC_VBI_BUFFERS 1</span>
<span class="cp">#define CX18_DEFAULT_ENC_PCM_BUFFERS 1</span>

<span class="cm">/* Maximum firmware DMA buffers per stream */</span>
<span class="cp">#define CX18_MAX_FW_MDLS_PER_STREAM 63</span>

<span class="cm">/* YUV buffer sizes in bytes to ensure integer # of frames per buffer */</span>
<span class="cp">#define CX18_UNIT_ENC_YUV_BUFSIZE	(720 *  32 * 3 / 2) </span><span class="cm">/* bytes */</span><span class="cp"></span>
<span class="cp">#define CX18_625_LINE_ENC_YUV_BUFSIZE	(CX18_UNIT_ENC_YUV_BUFSIZE * 576/32)</span>
<span class="cp">#define CX18_525_LINE_ENC_YUV_BUFSIZE	(CX18_UNIT_ENC_YUV_BUFSIZE * 480/32)</span>

<span class="cm">/* IDX buffer size should be a multiple of the index entry size from the chip */</span>
<span class="k">struct</span> <span class="n">cx18_enc_idx_entry</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">offset_low</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">offset_high</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">pts_low</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">pts_high</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>
<span class="cp">#define CX18_UNIT_ENC_IDX_BUFSIZE \</span>
<span class="cp">	(sizeof(struct cx18_enc_idx_entry) * V4L2_ENC_IDX_ENTRIES)</span>

<span class="cm">/* DMA buffer, default size in kB allocated */</span>
<span class="cp">#define CX18_DEFAULT_ENC_TS_BUFSIZE   32</span>
<span class="cp">#define CX18_DEFAULT_ENC_MPG_BUFSIZE  32</span>
<span class="cp">#define CX18_DEFAULT_ENC_IDX_BUFSIZE  (CX18_UNIT_ENC_IDX_BUFSIZE * 1 / 1024 + 1)</span>
<span class="cp">#define CX18_DEFAULT_ENC_YUV_BUFSIZE  (CX18_UNIT_ENC_YUV_BUFSIZE * 3 / 1024 + 1)</span>
<span class="cp">#define CX18_DEFAULT_ENC_PCM_BUFSIZE   4</span>

<span class="cm">/* i2c stuff */</span>
<span class="cp">#define I2C_CLIENTS_MAX 16</span>

<span class="cm">/* debugging */</span>

<span class="cm">/* Flag to turn on high volume debugging */</span>
<span class="cp">#define CX18_DBGFLG_WARN  (1 &lt;&lt; 0)</span>
<span class="cp">#define CX18_DBGFLG_INFO  (1 &lt;&lt; 1)</span>
<span class="cp">#define CX18_DBGFLG_API   (1 &lt;&lt; 2)</span>
<span class="cp">#define CX18_DBGFLG_DMA   (1 &lt;&lt; 3)</span>
<span class="cp">#define CX18_DBGFLG_IOCTL (1 &lt;&lt; 4)</span>
<span class="cp">#define CX18_DBGFLG_FILE  (1 &lt;&lt; 5)</span>
<span class="cp">#define CX18_DBGFLG_I2C   (1 &lt;&lt; 6)</span>
<span class="cp">#define CX18_DBGFLG_IRQ   (1 &lt;&lt; 7)</span>
<span class="cm">/* Flag to turn on high volume debugging */</span>
<span class="cp">#define CX18_DBGFLG_HIGHVOL (1 &lt;&lt; 8)</span>

<span class="cm">/* NOTE: extra space before comma in &#39;fmt , ## args&#39; is required for</span>
<span class="cm">   gcc-2.95, otherwise it won&#39;t compile. */</span>
<span class="cp">#define CX18_DEBUG(x, type, fmt, args...) \</span>
<span class="cp">	do { \</span>
<span class="cp">		if ((x) &amp; cx18_debug) \</span>
<span class="cp">			v4l2_info(&amp;cx-&gt;v4l2_dev, &quot; &quot; type &quot;: &quot; fmt , ## args); \</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define CX18_DEBUG_WARN(fmt, args...)  CX18_DEBUG(CX18_DBGFLG_WARN, &quot;warning&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_INFO(fmt, args...)  CX18_DEBUG(CX18_DBGFLG_INFO, &quot;info&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_API(fmt, args...)   CX18_DEBUG(CX18_DBGFLG_API, &quot;api&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_DMA(fmt, args...)   CX18_DEBUG(CX18_DBGFLG_DMA, &quot;dma&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_IOCTL(fmt, args...) CX18_DEBUG(CX18_DBGFLG_IOCTL, &quot;ioctl&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_FILE(fmt, args...)  CX18_DEBUG(CX18_DBGFLG_FILE, &quot;file&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_I2C(fmt, args...)   CX18_DEBUG(CX18_DBGFLG_I2C, &quot;i2c&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_IRQ(fmt, args...)   CX18_DEBUG(CX18_DBGFLG_IRQ, &quot;irq&quot;, fmt , ## args)</span>

<span class="cp">#define CX18_DEBUG_HIGH_VOL(x, type, fmt, args...) \</span>
<span class="cp">	do { \</span>
<span class="cp">		if (((x) &amp; cx18_debug) &amp;&amp; (cx18_debug &amp; CX18_DBGFLG_HIGHVOL)) \</span>
<span class="cp">			v4l2_info(&amp;cx-&gt;v4l2_dev, &quot; &quot; type &quot;: &quot; fmt , ## args); \</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define CX18_DEBUG_HI_WARN(fmt, args...)  CX18_DEBUG_HIGH_VOL(CX18_DBGFLG_WARN, &quot;warning&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_HI_INFO(fmt, args...)  CX18_DEBUG_HIGH_VOL(CX18_DBGFLG_INFO, &quot;info&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_HI_API(fmt, args...)   CX18_DEBUG_HIGH_VOL(CX18_DBGFLG_API, &quot;api&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_HI_DMA(fmt, args...)   CX18_DEBUG_HIGH_VOL(CX18_DBGFLG_DMA, &quot;dma&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_HI_IOCTL(fmt, args...) CX18_DEBUG_HIGH_VOL(CX18_DBGFLG_IOCTL, &quot;ioctl&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_HI_FILE(fmt, args...)  CX18_DEBUG_HIGH_VOL(CX18_DBGFLG_FILE, &quot;file&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_HI_I2C(fmt, args...)   CX18_DEBUG_HIGH_VOL(CX18_DBGFLG_I2C, &quot;i2c&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_HI_IRQ(fmt, args...)   CX18_DEBUG_HIGH_VOL(CX18_DBGFLG_IRQ, &quot;irq&quot;, fmt , ## args)</span>

<span class="cm">/* Standard kernel messages */</span>
<span class="cp">#define CX18_ERR(fmt, args...)      v4l2_err(&amp;cx-&gt;v4l2_dev, fmt , ## args)</span>
<span class="cp">#define CX18_WARN(fmt, args...)     v4l2_warn(&amp;cx-&gt;v4l2_dev, fmt , ## args)</span>
<span class="cp">#define CX18_INFO(fmt, args...)     v4l2_info(&amp;cx-&gt;v4l2_dev, fmt , ## args)</span>

<span class="cm">/* Messages for internal subdevs to use */</span>
<span class="cp">#define CX18_DEBUG_DEV(x, dev, type, fmt, args...) \</span>
<span class="cp">	do { \</span>
<span class="cp">		if ((x) &amp; cx18_debug) \</span>
<span class="cp">			v4l2_info(dev, &quot; &quot; type &quot;: &quot; fmt , ## args); \</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define CX18_DEBUG_WARN_DEV(dev, fmt, args...) \</span>
<span class="cp">		CX18_DEBUG_DEV(CX18_DBGFLG_WARN, dev, &quot;warning&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_INFO_DEV(dev, fmt, args...) \</span>
<span class="cp">		CX18_DEBUG_DEV(CX18_DBGFLG_INFO, dev, &quot;info&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_API_DEV(dev, fmt, args...) \</span>
<span class="cp">		CX18_DEBUG_DEV(CX18_DBGFLG_API, dev, &quot;api&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_DMA_DEV(dev, fmt, args...) \</span>
<span class="cp">		CX18_DEBUG_DEV(CX18_DBGFLG_DMA, dev, &quot;dma&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_IOCTL_DEV(dev, fmt, args...) \</span>
<span class="cp">		CX18_DEBUG_DEV(CX18_DBGFLG_IOCTL, dev, &quot;ioctl&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_FILE_DEV(dev, fmt, args...) \</span>
<span class="cp">		CX18_DEBUG_DEV(CX18_DBGFLG_FILE, dev, &quot;file&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_I2C_DEV(dev, fmt, args...) \</span>
<span class="cp">		CX18_DEBUG_DEV(CX18_DBGFLG_I2C, dev, &quot;i2c&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_IRQ_DEV(dev, fmt, args...) \</span>
<span class="cp">		CX18_DEBUG_DEV(CX18_DBGFLG_IRQ, dev, &quot;irq&quot;, fmt , ## args)</span>

<span class="cp">#define CX18_DEBUG_HIGH_VOL_DEV(x, dev, type, fmt, args...) \</span>
<span class="cp">	do { \</span>
<span class="cp">		if (((x) &amp; cx18_debug) &amp;&amp; (cx18_debug &amp; CX18_DBGFLG_HIGHVOL)) \</span>
<span class="cp">			v4l2_info(dev, &quot; &quot; type &quot;: &quot; fmt , ## args); \</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define CX18_DEBUG_HI_WARN_DEV(dev, fmt, args...) \</span>
<span class="cp">	CX18_DEBUG_HIGH_VOL_DEV(CX18_DBGFLG_WARN, dev, &quot;warning&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_HI_INFO_DEV(dev, fmt, args...) \</span>
<span class="cp">	CX18_DEBUG_HIGH_VOL_DEV(CX18_DBGFLG_INFO, dev, &quot;info&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_HI_API_DEV(dev, fmt, args...) \</span>
<span class="cp">	CX18_DEBUG_HIGH_VOL_DEV(CX18_DBGFLG_API, dev, &quot;api&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_HI_DMA_DEV(dev, fmt, args...) \</span>
<span class="cp">	CX18_DEBUG_HIGH_VOL_DEV(CX18_DBGFLG_DMA, dev, &quot;dma&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_HI_IOCTL_DEV(dev, fmt, args...) \</span>
<span class="cp">	CX18_DEBUG_HIGH_VOL_DEV(CX18_DBGFLG_IOCTL, dev, &quot;ioctl&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_HI_FILE_DEV(dev, fmt, args...) \</span>
<span class="cp">	CX18_DEBUG_HIGH_VOL_DEV(CX18_DBGFLG_FILE, dev, &quot;file&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_HI_I2C_DEV(dev, fmt, args...) \</span>
<span class="cp">	CX18_DEBUG_HIGH_VOL_DEV(CX18_DBGFLG_I2C, dev, &quot;i2c&quot;, fmt , ## args)</span>
<span class="cp">#define CX18_DEBUG_HI_IRQ_DEV(dev, fmt, args...) \</span>
<span class="cp">	CX18_DEBUG_HIGH_VOL_DEV(CX18_DBGFLG_IRQ, dev, &quot;irq&quot;, fmt , ## args)</span>

<span class="cp">#define CX18_ERR_DEV(dev, fmt, args...)      v4l2_err(dev, fmt , ## args)</span>
<span class="cp">#define CX18_WARN_DEV(dev, fmt, args...)     v4l2_warn(dev, fmt , ## args)</span>
<span class="cp">#define CX18_INFO_DEV(dev, fmt, args...)     v4l2_info(dev, fmt , ## args)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">cx18_debug</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">cx18_options</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">megabytes</span><span class="p">[</span><span class="n">CX18_MAX_STREAMS</span><span class="p">];</span> <span class="cm">/* Size in megabytes of each stream */</span>
	<span class="kt">int</span> <span class="n">cardtype</span><span class="p">;</span>		<span class="cm">/* force card type on load */</span>
	<span class="kt">int</span> <span class="n">tuner</span><span class="p">;</span>		<span class="cm">/* set tuner on load */</span>
	<span class="kt">int</span> <span class="n">radio</span><span class="p">;</span>		<span class="cm">/* enable/disable radio */</span>
<span class="p">};</span>

<span class="cm">/* per-mdl bit flags */</span>
<span class="cp">#define CX18_F_M_NEED_SWAP  0	</span><span class="cm">/* mdl buffer data must be endianess swapped */</span><span class="cp"></span>

<span class="cm">/* per-stream, s_flags */</span>
<span class="cp">#define CX18_F_S_CLAIMED 	3	</span><span class="cm">/* this stream is claimed */</span><span class="cp"></span>
<span class="cp">#define CX18_F_S_STREAMING      4	</span><span class="cm">/* the fw is decoding/encoding this stream */</span><span class="cp"></span>
<span class="cp">#define CX18_F_S_INTERNAL_USE	5	</span><span class="cm">/* this stream is used internally (sliced VBI processing) */</span><span class="cp"></span>
<span class="cp">#define CX18_F_S_STREAMOFF	7	</span><span class="cm">/* signal end of stream EOS */</span><span class="cp"></span>
<span class="cp">#define CX18_F_S_APPL_IO        8	</span><span class="cm">/* this stream is used read/written by an application */</span><span class="cp"></span>
<span class="cp">#define CX18_F_S_STOPPING	9	</span><span class="cm">/* telling the fw to stop capturing */</span><span class="cp"></span>

<span class="cm">/* per-cx18, i_flags */</span>
<span class="cp">#define CX18_F_I_LOADED_FW		0 	</span><span class="cm">/* Loaded firmware 1st time */</span><span class="cp"></span>
<span class="cp">#define CX18_F_I_EOS			4 	</span><span class="cm">/* End of encoder stream */</span><span class="cp"></span>
<span class="cp">#define CX18_F_I_RADIO_USER		5 	</span><span class="cm">/* radio tuner is selected */</span><span class="cp"></span>
<span class="cp">#define CX18_F_I_ENC_PAUSED		13 	</span><span class="cm">/* the encoder is paused */</span><span class="cp"></span>
<span class="cp">#define CX18_F_I_INITED			21 	</span><span class="cm">/* set after first open */</span><span class="cp"></span>
<span class="cp">#define CX18_F_I_FAILED			22 	</span><span class="cm">/* set if first open failed */</span><span class="cp"></span>

<span class="cm">/* These are the VBI types as they appear in the embedded VBI private packets. */</span>
<span class="cp">#define CX18_SLICED_TYPE_TELETEXT_B     (1)</span>
<span class="cp">#define CX18_SLICED_TYPE_CAPTION_525    (4)</span>
<span class="cp">#define CX18_SLICED_TYPE_WSS_625        (5)</span>
<span class="cp">#define CX18_SLICED_TYPE_VPS            (7)</span>

<span class="cm">/**</span>
<span class="cm"> * list_entry_is_past_end - check if a previous loop cursor is off list end</span>
<span class="cm"> * @pos:	the type * previously used as a loop cursor.</span>
<span class="cm"> * @head:	the head for your list.</span>
<span class="cm"> * @member:	the name of the list_struct within the struct.</span>
<span class="cm"> *</span>
<span class="cm"> * Check if the entry&#39;s list_head is the head of the list, thus it&#39;s not a</span>
<span class="cm"> * real entry but was the loop cursor that walked past the end</span>
<span class="cm"> */</span>
<span class="cp">#define list_entry_is_past_end(pos, head, member) \</span>
<span class="cp">	(&amp;pos-&gt;member == (head))</span>

<span class="k">struct</span> <span class="n">cx18_buffer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">bytesused</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">readpos</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cx18_mdl</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>		<span class="cm">/* index into cx-&gt;scb-&gt;cpu_mdl[] of 1st cx18_mdl_ent */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">skipped</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">m_flags</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">buf_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_buffer</span> <span class="o">*</span><span class="n">curr_buf</span><span class="p">;</span> <span class="cm">/* current buffer in list for reading */</span>

	<span class="n">u32</span> <span class="n">bytesused</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">readpos</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cx18_queue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">depth</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bytesused</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cx18_stream</span><span class="p">;</span> <span class="cm">/* forward reference */</span>

<span class="k">struct</span> <span class="n">cx18_dvb</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmx_frontend</span> <span class="n">hw_frontend</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmx_frontend</span> <span class="n">mem_frontend</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmxdev</span> <span class="n">dmxdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dvb_adapter</span> <span class="n">dvb_adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dvb_demux</span> <span class="n">demux</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dvb_frontend</span> <span class="o">*</span><span class="n">fe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dvb_net</span> <span class="n">dvbnet</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">enabled</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">feeding</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">feedlock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cx18</span><span class="p">;</span>	 <span class="cm">/* forward reference */</span>
<span class="k">struct</span> <span class="n">cx18_scb</span><span class="p">;</span> <span class="cm">/* forward reference */</span>


<span class="cp">#define CX18_MAX_MDL_ACKS 2</span>
<span class="cp">#define CX18_MAX_IN_WORK_ORDERS (CX18_MAX_FW_MDLS_PER_STREAM + 7)</span>
<span class="cm">/* CPU_DE_RELEASE_MDL can burst CX18_MAX_FW_MDLS_PER_STREAM orders in a group */</span>

<span class="cp">#define CX18_F_EWO_MB_STALE_UPON_RECEIPT 0x1</span>
<span class="cp">#define CX18_F_EWO_MB_STALE_WHILE_PROC   0x2</span>
<span class="cp">#define CX18_F_EWO_MB_STALE \</span>
<span class="cp">	     (CX18_F_EWO_MB_STALE_UPON_RECEIPT | CX18_F_EWO_MB_STALE_WHILE_PROC)</span>

<span class="k">struct</span> <span class="n">cx18_in_work_order</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">pending</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_mailbox</span> <span class="n">mb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_mdl_ack</span> <span class="n">mdl_ack</span><span class="p">[</span><span class="n">CX18_MAX_MDL_ACKS</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define CX18_INVALID_TASK_HANDLE 0xffffffff</span>

<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="p">{</span>
	<span class="cm">/* These first five fields are always set, even if the stream</span>
<span class="cm">	   is not actually created. */</span>
	<span class="k">struct</span> <span class="n">video_device</span> <span class="o">*</span><span class="n">video_dev</span><span class="p">;</span>	<span class="cm">/* NULL when stream not created */</span>
	<span class="k">struct</span> <span class="n">cx18_dvb</span> <span class="o">*</span><span class="n">dvb</span><span class="p">;</span>		<span class="cm">/* DVB / Digital Transport */</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">;</span> 		<span class="cm">/* for ease of use */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>		<span class="cm">/* name of the stream */</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>			<span class="cm">/* stream type */</span>
	<span class="n">u32</span> <span class="n">handle</span><span class="p">;</span>			<span class="cm">/* task handle */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mdl_base_idx</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_flags</span><span class="p">;</span>	<span class="cm">/* status flags, see above */</span>
	<span class="kt">int</span> <span class="n">dma</span><span class="p">;</span>		<span class="cm">/* can be PCI_DMA_TODEVICE,</span>
<span class="cm">				   PCI_DMA_FROMDEVICE or</span>
<span class="cm">				   PCI_DMA_NONE */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">waitq</span><span class="p">;</span>

	<span class="cm">/* Buffers */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">buf_pool</span><span class="p">;</span>	<span class="cm">/* buffers not attached to an MDL */</span>
	<span class="n">u32</span> <span class="n">buffers</span><span class="p">;</span>			<span class="cm">/* total buffers owned by this stream */</span>
	<span class="n">u32</span> <span class="n">buf_size</span><span class="p">;</span>			<span class="cm">/* size in bytes of a single buffer */</span>

	<span class="cm">/* MDL sizes - all stream MDLs are the same size */</span>
	<span class="n">u32</span> <span class="n">bufs_per_mdl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mdl_size</span><span class="p">;</span>		<span class="cm">/* total bytes in all buffers in a mdl */</span>

	<span class="cm">/* MDL Queues */</span>
	<span class="k">struct</span> <span class="n">cx18_queue</span> <span class="n">q_free</span><span class="p">;</span>	<span class="cm">/* free - in rotation, not committed */</span>
	<span class="k">struct</span> <span class="n">cx18_queue</span> <span class="n">q_busy</span><span class="p">;</span>	<span class="cm">/* busy - in use by firmware */</span>
	<span class="k">struct</span> <span class="n">cx18_queue</span> <span class="n">q_full</span><span class="p">;</span>	<span class="cm">/* full - data for user apps */</span>
	<span class="k">struct</span> <span class="n">cx18_queue</span> <span class="n">q_idle</span><span class="p">;</span>	<span class="cm">/* idle - not in rotation */</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">out_work_order</span><span class="p">;</span>

	<span class="cm">/* Videobuf for YUV video */</span>
	<span class="n">u32</span> <span class="n">pixelformat</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vb_bytes_per_frame</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">vb_capture</span><span class="p">;</span>    <span class="cm">/* video capture queue */</span>
	<span class="n">spinlock_t</span> <span class="n">vb_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">vb_timeout</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="n">vbuf_q</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">vbuf_q_lock</span><span class="p">;</span> <span class="cm">/* Protect vbuf_q */</span>
	<span class="k">enum</span> <span class="n">v4l2_buf_type</span> <span class="n">vb_type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cx18_videobuf_buffer</span> <span class="p">{</span>
	<span class="cm">/* Common video buffer sub-system struct */</span>
	<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="n">vb</span><span class="p">;</span>
	<span class="n">v4l2_std_id</span> <span class="n">tvnorm</span><span class="p">;</span> <span class="cm">/* selected tv norm */</span>
	<span class="n">u32</span> <span class="n">bytes_used</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cx18_open_id</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_fh</span> <span class="n">fh</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">open_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cx18_open_id</span> <span class="o">*</span><span class="nf">fh2id</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">fh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cx18_open_id</span><span class="p">,</span> <span class="n">fh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cx18_open_id</span> <span class="o">*</span><span class="nf">file2id</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">fh2id</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* forward declaration of struct defined in cx18-cards.h */</span>
<span class="k">struct</span> <span class="n">cx18_card</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * A note about &quot;sliced&quot; VBI data as implemented in this driver:</span>
<span class="cm"> *</span>
<span class="cm"> * Currently we collect the sliced VBI in the form of Ancillary Data</span>
<span class="cm"> * packets, inserted by the AV core decoder/digitizer/slicer in the</span>
<span class="cm"> * horizontal blanking region of the VBI lines, in &quot;raw&quot; mode as far as</span>
<span class="cm"> * the Encoder is concerned.  We don&#39;t ever tell the Encoder itself</span>
<span class="cm"> * to provide sliced VBI. (AV Core: sliced mode - Encoder: raw mode)</span>
<span class="cm"> *</span>
<span class="cm"> * We then process the ancillary data ourselves to send the sliced data</span>
<span class="cm"> * to the user application directly or build up MPEG-2 private stream 1</span>
<span class="cm"> * packets to splice into (only!) MPEG-2 PS streams for the user app.</span>
<span class="cm"> *</span>
<span class="cm"> * (That&#39;s how ivtv essentially does it.)</span>
<span class="cm"> *</span>
<span class="cm"> * The Encoder should be able to extract certain sliced VBI data for</span>
<span class="cm"> * us and provide it in a separate stream or splice it into any type of</span>
<span class="cm"> * MPEG PS or TS stream, but this isn&#39;t implemented yet.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Number of &quot;raw&quot; VBI samples per horizontal line we tell the Encoder to</span>
<span class="cm"> * grab from the decoder/digitizer/slicer output for raw or sliced VBI.</span>
<span class="cm"> * It depends on the pixel clock and the horiz rate:</span>
<span class="cm"> *</span>
<span class="cm"> * (1/Fh)*(2*Fp) = Samples/line</span>
<span class="cm"> *     = 4 bytes EAV + Anc data in hblank + 4 bytes SAV + active samples</span>
<span class="cm"> *</span>
<span class="cm"> *  Sliced VBI data is sent as ancillary data during horizontal blanking</span>
<span class="cm"> *  Raw VBI is sent as active video samples during vertcal blanking</span>
<span class="cm"> *</span>
<span class="cm"> *  We use a  BT.656 pxiel clock of 13.5 MHz and a BT.656 active line</span>
<span class="cm"> *  length of 720 pixels @ 4:2:2 sampling.  Thus...</span>
<span class="cm"> *</span>
<span class="cm"> *  For systems that use a 15.734 kHz horizontal rate, such as</span>
<span class="cm"> *  NTSC-M, PAL-M, PAL-60, and other 60 Hz/525 line systems, we have:</span>
<span class="cm"> *</span>
<span class="cm"> *  (1/15.734 kHz) * 2 * 13.5 MHz = 1716 samples/line =</span>
<span class="cm"> *  4 bytes SAV + 268 bytes anc data + 4 bytes SAV + 1440 active samples</span>
<span class="cm"> *</span>
<span class="cm"> *  For systems that use a 15.625 kHz horizontal rate, such as</span>
<span class="cm"> *  PAL-B/G/H, PAL-I, SECAM-L and other 50 Hz/625 line systems, we have:</span>
<span class="cm"> *</span>
<span class="cm"> *  (1/15.625 kHz) * 2 * 13.5 MHz = 1728 samples/line =</span>
<span class="cm"> *  4 bytes SAV + 280 bytes anc data + 4 bytes SAV + 1440 active samples</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">vbi_active_samples</span> <span class="o">=</span> <span class="mi">1444</span><span class="p">;</span> <span class="cm">/* 4 byte SAV + 720 Y + 720 U/V */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">vbi_hblank_samples_60Hz</span> <span class="o">=</span> <span class="mi">272</span><span class="p">;</span> <span class="cm">/* 4 byte EAV + 268 anc/fill */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">vbi_hblank_samples_50Hz</span> <span class="o">=</span> <span class="mi">284</span><span class="p">;</span> <span class="cm">/* 4 byte EAV + 280 anc/fill */</span>

<span class="cp">#define CX18_VBI_FRAMES 32</span>

<span class="k">struct</span> <span class="n">vbi_info</span> <span class="p">{</span>
	<span class="cm">/* Current state of v4l2 VBI settings for this device */</span>
	<span class="k">struct</span> <span class="n">v4l2_format</span> <span class="n">in</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_sliced_vbi_format</span> <span class="o">*</span><span class="n">sliced_in</span><span class="p">;</span> <span class="cm">/* pointer to in.fmt.sliced */</span>
	<span class="n">u32</span> <span class="n">count</span><span class="p">;</span>    <span class="cm">/* Count of VBI data lines: 60 Hz: 12 or 50 Hz: 18 */</span>
	<span class="n">u32</span> <span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/* First VBI data line per field: 10 &amp; 273 or 6 &amp; 318 */</span>

	<span class="n">u32</span> <span class="n">frame</span><span class="p">;</span> <span class="cm">/* Count of VBI buffers/frames received from Encoder */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Vars for creation and insertion of MPEG Private Stream 1 packets</span>
<span class="cm">	 * of sliced VBI data into an MPEG PS</span>
<span class="cm">	 */</span>

	<span class="cm">/* Boolean: create and insert Private Stream 1 packets into the PS */</span>
	<span class="kt">int</span> <span class="n">insert_mpeg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Buffer for the maximum of 2 * 18 * packet_size sliced VBI lines.</span>
<span class="cm">	 * Used in cx18-vbi.c only for collecting sliced data, and as a source</span>
<span class="cm">	 * during conversion of sliced VBI data into MPEG Priv Stream 1 packets.</span>
<span class="cm">	 * We don&#39;t need to save state here, but the array may have been a bit</span>
<span class="cm">	 * too big (2304 bytes) to alloc from the stack.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">v4l2_sliced_vbi_data</span> <span class="n">sliced_data</span><span class="p">[</span><span class="mi">36</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * A ring buffer of driver-generated MPEG-2 PS</span>
<span class="cm">	 * Program Pack/Private Stream 1 packets for sliced VBI data insertion</span>
<span class="cm">	 * into the MPEG PS stream.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In each sliced_mpeg_data[] buffer is:</span>
<span class="cm">	 * 	16 byte MPEG-2 PS Program Pack Header</span>
<span class="cm">	 * 	16 byte MPEG-2 Private Stream 1 PES Header</span>
<span class="cm">	 * 	 4 byte magic number: &quot;itv0&quot; or &quot;ITV0&quot;</span>
<span class="cm">	 * 	 4 byte first  field line mask, if &quot;itv0&quot;</span>
<span class="cm">	 * 	 4 byte second field line mask, if &quot;itv0&quot;</span>
<span class="cm">	 * 	36 lines, if &quot;ITV0&quot;; or &lt;36 lines, if &quot;itv0&quot;; of sliced VBI data</span>
<span class="cm">	 *</span>
<span class="cm">	 * 	Each line in the payload is</span>
<span class="cm">	 *	 1 byte line header derived from the SDID (WSS, CC, VPS, etc.)</span>
<span class="cm">	 *	42 bytes of line data</span>
<span class="cm">	 *</span>
<span class="cm">	 * That&#39;s a maximum 1552 bytes of payload in the Private Stream 1 packet</span>
<span class="cm">	 * which is the payload size a PVR-350 (CX23415) MPEG decoder will</span>
<span class="cm">	 * accept for VBI data. So, including the headers, it&#39;s a maximum 1584</span>
<span class="cm">	 * bytes total.</span>
<span class="cm">	 */</span>
<span class="cp">#define CX18_SLICED_MPEG_DATA_MAXSZ	1584</span>
	<span class="cm">/* copy_vbi_buf() needs 8 temp bytes on the end for the worst case */</span>
<span class="cp">#define CX18_SLICED_MPEG_DATA_BUFSZ	(CX18_SLICED_MPEG_DATA_MAXSZ+8)</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">sliced_mpeg_data</span><span class="p">[</span><span class="n">CX18_VBI_FRAMES</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">sliced_mpeg_size</span><span class="p">[</span><span class="n">CX18_VBI_FRAMES</span><span class="p">];</span>

	<span class="cm">/* Count of Program Pack/Program Stream 1 packets inserted into PS */</span>
	<span class="n">u32</span> <span class="n">inserted_frame</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A dummy driver stream transfer mdl &amp; buffer with a copy of the next</span>
<span class="cm">	 * sliced_mpeg_data[] buffer for output to userland apps.</span>
<span class="cm">	 * Only used in cx18-fileops.c, but its state needs to persist at times.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">cx18_mdl</span> <span class="n">sliced_mpeg_mdl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_buffer</span> <span class="n">sliced_mpeg_buf</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Per cx23418, per I2C bus private algo callback data */</span>
<span class="k">struct</span> <span class="n">cx18_i2c_algo_callback_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bus_index</span><span class="p">;</span>   <span class="cm">/* 0 or 1 for the cx23418&#39;s 1st or 2nd I2C bus */</span>
<span class="p">};</span>

<span class="cp">#define CX18_MAX_MMIO_WR_RETRIES 10</span>

<span class="cm">/* Struct to hold info about cx18 cards */</span>
<span class="k">struct</span> <span class="n">cx18</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">instance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_device</span> <span class="n">v4l2_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd_av</span><span class="p">;</span>     <span class="cm">/* A/V decoder/digitizer sub-device */</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd_extmux</span><span class="p">;</span> <span class="cm">/* External multiplexer sub-dev */</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">cx18_card</span> <span class="o">*</span><span class="n">card</span><span class="p">;</span>	<span class="cm">/* card information */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">card_name</span><span class="p">;</span>  <span class="cm">/* full name of the card */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cx18_card_tuner_i2c</span> <span class="o">*</span><span class="n">card_i2c</span><span class="p">;</span> <span class="cm">/* i2c addresses to probe for tuner */</span>
	<span class="n">u8</span> <span class="n">is_50hz</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">is_60hz</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">nof_inputs</span><span class="p">;</span>		<span class="cm">/* number of video inputs */</span>
	<span class="n">u8</span> <span class="n">nof_audio_inputs</span><span class="p">;</span>	<span class="cm">/* number of audio inputs */</span>
	<span class="n">u32</span> <span class="n">v4l2_cap</span><span class="p">;</span>		<span class="cm">/* V4L2 capabilities of card */</span>
	<span class="n">u32</span> <span class="n">hw_flags</span><span class="p">;</span> 		<span class="cm">/* Hardware description of the board */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">free_mdl_idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_scb</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span> <span class="cm">/* pointer to SCB */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">epu2apu_mb_lock</span><span class="p">;</span> <span class="cm">/* protect driver to chip mailbox in SCB*/</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">epu2cpu_mb_lock</span><span class="p">;</span> <span class="cm">/* protect driver to chip mailbox in SCB*/</span>

	<span class="k">struct</span> <span class="n">cx18_av_state</span> <span class="n">av_state</span><span class="p">;</span>

	<span class="cm">/* codec settings */</span>
	<span class="k">struct</span> <span class="n">cx2341x_handler</span> <span class="n">cxhdl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">filter_mode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">temporal_strength</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">spatial_strength</span><span class="p">;</span>

	<span class="cm">/* dualwatch */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dualwatch_jiffies</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dualwatch_stereo_mode</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">serialize_lock</span><span class="p">;</span>    <span class="cm">/* mutex used to serialize open/close/start/stop/ioctl operations */</span>
	<span class="k">struct</span> <span class="n">cx18_options</span> <span class="n">options</span><span class="p">;</span> 	<span class="cm">/* User options */</span>
	<span class="kt">int</span> <span class="n">stream_buffers</span><span class="p">[</span><span class="n">CX18_MAX_STREAMS</span><span class="p">];</span> <span class="cm">/* # of buffers for each stream */</span>
	<span class="kt">int</span> <span class="n">stream_buf_size</span><span class="p">[</span><span class="n">CX18_MAX_STREAMS</span><span class="p">];</span> <span class="cm">/* Stream buffer size */</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="n">streams</span><span class="p">[</span><span class="n">CX18_MAX_STREAMS</span><span class="p">];</span> 	<span class="cm">/* Stream data */</span>
	<span class="k">struct</span> <span class="n">snd_cx18_card</span> <span class="o">*</span><span class="n">alsa</span><span class="p">;</span> <span class="cm">/* ALSA interface for PCM capture stream */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pcm_announce_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">snd_cx18_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">pcm_data</span><span class="p">,</span>
				      <span class="kt">size_t</span> <span class="n">num_bytes</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i_flags</span><span class="p">;</span>  <span class="cm">/* global cx18 flags */</span>
	<span class="n">atomic_t</span> <span class="n">ana_capturing</span><span class="p">;</span>	<span class="cm">/* count number of active analog capture streams */</span>
	<span class="n">atomic_t</span> <span class="n">tot_capturing</span><span class="p">;</span>	<span class="cm">/* total count number of active capture streams */</span>
	<span class="kt">int</span> <span class="n">search_pack_header</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">open_id</span><span class="p">;</span>		<span class="cm">/* incremented each time an open occurs, used as</span>
<span class="cm">				   unique ID. Starts at 1, so 0 can be used as</span>
<span class="cm">				   uninitialized value in the stream-&gt;id. */</span>

	<span class="n">resource_size_t</span> <span class="n">base_addr</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">card_rev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">enc_mem</span><span class="p">,</span> <span class="o">*</span><span class="n">reg_mem</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">vbi_info</span> <span class="n">vbi</span><span class="p">;</span>

	<span class="n">u64</span> <span class="n">mpg_data_received</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">vbi_data_inserted</span><span class="p">;</span>

	<span class="n">wait_queue_head_t</span> <span class="n">mb_apu_waitq</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">mb_cpu_waitq</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">cap_w</span><span class="p">;</span>
	<span class="cm">/* when the current DMA is finished this queue is woken up */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">dma_waitq</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">sw1_irq_mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sw2_irq_mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hw2_irq_mask</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">in_work_queue</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">in_workq_name</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span> <span class="cm">/* &quot;cx18-NN-in&quot; */</span>
	<span class="k">struct</span> <span class="n">cx18_in_work_order</span> <span class="n">in_work_order</span><span class="p">[</span><span class="n">CX18_MAX_IN_WORK_ORDERS</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">epu_debug_str</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span> <span class="cm">/* CX18_EPU_DEBUG is rare: use shared space */</span>

	<span class="cm">/* i2c */</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="n">i2c_adap</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">i2c_algo_bit_data</span> <span class="n">i2c_algo</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">cx18_i2c_algo_callback_data</span> <span class="n">i2c_algo_cb_data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">IR_i2c_init_data</span> <span class="n">ir_i2c_init_data</span><span class="p">;</span>

	<span class="cm">/* gpio */</span>
	<span class="n">u32</span> <span class="n">gpio_dir</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gpio_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">gpio_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="n">sd_gpiomux</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="n">sd_resetctrl</span><span class="p">;</span>

	<span class="cm">/* v4l2 and User settings */</span>

	<span class="cm">/* codec settings */</span>
	<span class="n">u32</span> <span class="n">audio_input</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">active_input</span><span class="p">;</span>
	<span class="n">v4l2_std_id</span> <span class="n">std</span><span class="p">;</span>
	<span class="n">v4l2_std_id</span> <span class="n">tuner_std</span><span class="p">;</span>	<span class="cm">/* The norm of the tuner (fixed) */</span>

	<span class="cm">/* Used for cx18-alsa module loading */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">request_module_wk</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="nf">to_cx18</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">v4l2_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cx18</span><span class="p">,</span> <span class="n">v4l2_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* cx18 extensions to be loaded */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cx18_ext_init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Globals */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cx18_first_minor</span><span class="p">;</span>

<span class="cm">/*==============Prototypes==================*/</span>

<span class="cm">/* Return non-zero if a signal is pending */</span>
<span class="kt">int</span> <span class="n">cx18_msleep_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msecs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">intr</span><span class="p">);</span>

<span class="cm">/* Read Hauppauge eeprom */</span>
<span class="k">struct</span> <span class="n">tveeprom</span><span class="p">;</span> <span class="cm">/* forward reference */</span>
<span class="kt">void</span> <span class="n">cx18_read_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tveeprom</span> <span class="o">*</span><span class="n">tv</span><span class="p">);</span>

<span class="cm">/* First-open initialization: load firmware, etc. */</span>
<span class="kt">int</span> <span class="n">cx18_init_on_first_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">);</span>

<span class="cm">/* Test if the current VBI mode is raw (1) or sliced (0) */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cx18_raw_vbi</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">in</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">V4L2_BUF_TYPE_VBI_CAPTURE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Call the specified callback for all subdevs with a grp_id bit matching the</span>
<span class="cm"> * mask in hw (if 0, then match them all). Ignore any errors. */</span>
<span class="cp">#define cx18_call_hw(cx, hw, o, f, args...)				\</span>
<span class="cp">	do {								\</span>
<span class="cp">		struct v4l2_subdev *__sd;				\</span>
<span class="cp">		__v4l2_device_call_subdevs_p(&amp;(cx)-&gt;v4l2_dev, __sd,	\</span>
<span class="cp">			!(hw) || (__sd-&gt;grp_id &amp; (hw)), o, f , ##args);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define cx18_call_all(cx, o, f, args...) cx18_call_hw(cx, 0, o, f , ##args)</span>

<span class="cm">/* Call the specified callback for all subdevs with a grp_id bit matching the</span>
<span class="cm"> * mask in hw (if 0, then match them all). If the callback returns an error</span>
<span class="cm"> * other than 0 or -ENOIOCTLCMD, then return with that error code. */</span>
<span class="cp">#define cx18_call_hw_err(cx, hw, o, f, args...)				\</span>
<span class="cp">({									\</span>
<span class="cp">	struct v4l2_subdev *__sd;					\</span>
<span class="cp">	__v4l2_device_call_subdevs_until_err_p(&amp;(cx)-&gt;v4l2_dev,		\</span>
<span class="cp">			__sd, !(hw) || (__sd-&gt;grp_id &amp; (hw)), o, f,	\</span>
<span class="cp">			##args);					\</span>
<span class="cp">})</span>

<span class="cp">#define cx18_call_all_err(cx, o, f, args...) \</span>
<span class="cp">	cx18_call_hw_err(cx, 0, o, f , ##args)</span>

<span class="cp">#endif </span><span class="cm">/* CX18_DRIVER_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
