<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › cx18 › cx18-fileops.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>cx18-fileops.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  cx18 file operation functions</span>
<span class="cm"> *</span>
<span class="cm"> *  Derived from ivtv-fileops.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2007  Hans Verkuil &lt;hverkuil@xs4all.nl&gt;</span>
<span class="cm"> *  Copyright (C) 2008  Andy Walls &lt;awalls@md.metrocast.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA</span>
<span class="cm"> *  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;cx18-driver.h&quot;</span>
<span class="cp">#include &quot;cx18-fileops.h&quot;</span>
<span class="cp">#include &quot;cx18-i2c.h&quot;</span>
<span class="cp">#include &quot;cx18-queue.h&quot;</span>
<span class="cp">#include &quot;cx18-vbi.h&quot;</span>
<span class="cp">#include &quot;cx18-audio.h&quot;</span>
<span class="cp">#include &quot;cx18-mailbox.h&quot;</span>
<span class="cp">#include &quot;cx18-scb.h&quot;</span>
<span class="cp">#include &quot;cx18-streams.h&quot;</span>
<span class="cp">#include &quot;cx18-controls.h&quot;</span>
<span class="cp">#include &quot;cx18-ioctl.h&quot;</span>
<span class="cp">#include &quot;cx18-cards.h&quot;</span>

<span class="cm">/* This function tries to claim the stream for a specific file descriptor.</span>
<span class="cm">   If no one else is using this stream then the stream is claimed and</span>
<span class="cm">   associated VBI and IDX streams are also automatically claimed.</span>
<span class="cm">   Possible error returns: -EBUSY if someone else has claimed</span>
<span class="cm">   the stream or 0 on success. */</span>
<span class="kt">int</span> <span class="nf">cx18_claim_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_open_id</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s_assoc</span><span class="p">;</span>

	<span class="cm">/* Nothing should ever try to directly claim the IDX stream */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_IDX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CX18_WARN</span><span class="p">(</span><span class="s">&quot;MPEG Index stream cannot be claimed &quot;</span>
			  <span class="s">&quot;directly, but something tried.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">CX18_F_S_CLAIMED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* someone already claimed this stream */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">open_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* yes, this file descriptor did. So that&#39;s OK. */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_VBI</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* VBI is handled already internally, now also assign</span>
<span class="cm">			   the file descriptor to this stream for external</span>
<span class="cm">			   reading of the stream. */</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">open_id</span><span class="p">;</span>
			<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;Start Read VBI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* someone else is using this stream already */</span>
		<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;Stream %d is busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">open_id</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * CX18_ENC_STREAM_TYPE_MPG needs to claim:</span>
<span class="cm">	 * CX18_ENC_STREAM_TYPE_VBI, if VBI insertion is on for sliced VBI, or</span>
<span class="cm">	 * CX18_ENC_STREAM_TYPE_IDX, if VBI insertion is off for sliced VBI</span>
<span class="cm">	 * (We don&#39;t yet fix up MPEG Index entries for our inserted packets).</span>
<span class="cm">	 *</span>
<span class="cm">	 * For all other streams we&#39;re done.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">CX18_ENC_STREAM_TYPE_MPG</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">s_assoc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">CX18_ENC_STREAM_TYPE_IDX</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">insert_mpeg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cx18_raw_vbi</span><span class="p">(</span><span class="n">cx</span><span class="p">))</span>
		<span class="n">s_assoc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">CX18_ENC_STREAM_TYPE_VBI</span><span class="p">];</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cx18_stream_enabled</span><span class="p">(</span><span class="n">s_assoc</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">CX18_F_S_CLAIMED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_assoc</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>

	<span class="cm">/* mark that it is used internally */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">CX18_F_S_INTERNAL_USE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_assoc</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cx18_claim_stream</span><span class="p">);</span>

<span class="cm">/* This function releases a previously claimed stream. It will take into</span>
<span class="cm">   account associated VBI streams. */</span>
<span class="kt">void</span> <span class="nf">cx18_release_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s_assoc</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_IDX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The IDX stream is only used internally, and can</span>
<span class="cm">		 * only be indirectly unclaimed by unclaiming the MPG stream.</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_VBI</span> <span class="o">&amp;&amp;</span>
		<span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_INTERNAL_USE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* this stream is still in use internally */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_CLAIMED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">CX18_DEBUG_WARN</span><span class="p">(</span><span class="s">&quot;Release stream %s not in use!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cx18_flush_queues</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * CX18_ENC_STREAM_TYPE_MPG needs to release the</span>
<span class="cm">	 * CX18_ENC_STREAM_TYPE_VBI and/or CX18_ENC_STREAM_TYPE_IDX streams.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For all other streams we&#39;re done.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">CX18_ENC_STREAM_TYPE_MPG</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Unclaim the associated MPEG Index stream */</span>
	<span class="n">s_assoc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">CX18_ENC_STREAM_TYPE_IDX</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_INTERNAL_USE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_assoc</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_CLAIMED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_assoc</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
		<span class="n">cx18_flush_queues</span><span class="p">(</span><span class="n">s_assoc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Unclaim the associated VBI stream */</span>
	<span class="n">s_assoc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">CX18_ENC_STREAM_TYPE_VBI</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_INTERNAL_USE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_assoc</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s_assoc</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The VBI stream is not still claimed by a file</span>
<span class="cm">			 * descriptor, so completely unclaim it.</span>
<span class="cm">			 */</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_CLAIMED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_assoc</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
			<span class="n">cx18_flush_queues</span><span class="p">(</span><span class="n">s_assoc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cx18_release_stream</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cx18_dualwatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_tuner</span> <span class="n">vt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new_stereo_mode</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">dual</span> <span class="o">=</span> <span class="mh">0x0200</span><span class="p">;</span>

	<span class="n">new_stereo_mode</span> <span class="o">=</span> <span class="n">v4l2_ctrl_g_ctrl</span><span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">.</span><span class="n">audio_mode</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vt</span><span class="p">));</span>
	<span class="n">cx18_call_all</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">tuner</span><span class="p">,</span> <span class="n">g_tuner</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vt</span><span class="p">.</span><span class="n">audmode</span> <span class="o">==</span> <span class="n">V4L2_TUNER_MODE_LANG1_LANG2</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">vt</span><span class="p">.</span><span class="n">rxsubchans</span> <span class="o">&amp;</span> <span class="n">V4L2_TUNER_SUB_LANG2</span><span class="p">))</span>
		<span class="n">new_stereo_mode</span> <span class="o">=</span> <span class="n">dual</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_stereo_mode</span> <span class="o">==</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">dualwatch_stereo_mode</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;dualwatch: change stereo flag from 0x%x to 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">cx</span><span class="o">-&gt;</span><span class="n">dualwatch_stereo_mode</span><span class="p">,</span> <span class="n">new_stereo_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v4l2_ctrl_s_ctrl</span><span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">.</span><span class="n">audio_mode</span><span class="p">,</span> <span class="n">new_stereo_mode</span><span class="p">))</span>
		<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;dualwatch: changing stereo flag failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">cx18_mdl</span> <span class="o">*</span><span class="nf">cx18_get_mdl</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">non_block</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s_vbi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">CX18_ENC_STREAM_TYPE_VBI</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">cx18_mdl</span> <span class="o">*</span><span class="n">mdl</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_MPG</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Process pending program updates and VBI data */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">dualwatch_jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">1000</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">cx</span><span class="o">-&gt;</span><span class="n">dualwatch_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
				<span class="n">cx18_dualwatch</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_INTERNAL_USE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_vbi</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_APPL_IO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_vbi</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">while</span> <span class="p">((</span><span class="n">mdl</span> <span class="o">=</span> <span class="n">cx18_dequeue</span><span class="p">(</span><span class="n">s_vbi</span><span class="p">,</span>
							   <span class="o">&amp;</span><span class="n">s_vbi</span><span class="o">-&gt;</span><span class="n">q_full</span><span class="p">)))</span> <span class="p">{</span>
					<span class="cm">/* byteswap and process VBI data */</span>
					<span class="n">cx18_process_vbi_data</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span>
							      <span class="n">s_vbi</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
					<span class="n">cx18_stream_put_mdl_fw</span><span class="p">(</span><span class="n">s_vbi</span><span class="p">,</span> <span class="n">mdl</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">mdl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">sliced_mpeg_mdl</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mdl</span><span class="o">-&gt;</span><span class="n">readpos</span> <span class="o">!=</span> <span class="n">mdl</span><span class="o">-&gt;</span><span class="n">bytesused</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">mdl</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* do we have new data? */</span>
		<span class="n">mdl</span> <span class="o">=</span> <span class="n">cx18_dequeue</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_full</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mdl</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">CX18_F_M_NEED_SWAP</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">mdl</span><span class="o">-&gt;</span><span class="n">m_flags</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">mdl</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_MPG</span><span class="p">)</span>
				<span class="cm">/* byteswap MPG data */</span>
				<span class="n">cx18_mdl_swap</span><span class="p">(</span><span class="n">mdl</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* byteswap and process VBI data */</span>
				<span class="n">cx18_process_vbi_data</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">mdl</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* return if end of stream */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;EOS %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* return if file was opened with O_NONBLOCK */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">non_block</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* wait for more data to arrive */</span>
		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="cm">/* New buffers might have become available before we were added</span>
<span class="cm">		   to the waitqueue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_full</span><span class="p">.</span><span class="n">depth</span><span class="p">))</span>
			<span class="n">schedule</span><span class="p">();</span>
		<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* return if a signal was received */</span>
			<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;User stopped %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cx18_setup_sliced_vbi_mdl</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18_mdl</span> <span class="o">*</span><span class="n">mdl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">sliced_mpeg_mdl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">sliced_mpeg_buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">inserted_frame</span> <span class="o">%</span> <span class="n">CX18_VBI_FRAMES</span><span class="p">;</span>

	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">sliced_mpeg_data</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytesused</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">sliced_mpeg_size</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">readpos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mdl</span><span class="o">-&gt;</span><span class="n">curr_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mdl</span><span class="o">-&gt;</span><span class="n">bytesused</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">sliced_mpeg_size</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="n">mdl</span><span class="o">-&gt;</span><span class="n">readpos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">cx18_copy_buf_to_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">cx18_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ucount</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytesused</span> <span class="o">-</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">readpos</span><span class="p">;</span>

	<span class="o">*</span><span class="n">stop</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">ucount</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ucount</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">insert_mpeg</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_MPG</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">cx18_raw_vbi</span><span class="p">(</span><span class="n">cx</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">sliced_mpeg_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Try to find a good splice point in the PS, just before</span>
<span class="cm">		 * an MPEG-2 Program Pack start code, and provide only</span>
<span class="cm">		 * up to that point to the user, so it&#39;s easy to insert VBI data</span>
<span class="cm">		 * the next time around.</span>
<span class="cm">		 *</span>
<span class="cm">		 * This will not work for an MPEG-2 TS and has only been</span>
<span class="cm">		 * verified by analysis to work for an MPEG-2 PS.  Helen Buus</span>
<span class="cm">		 * pointed out this works for the CX23416 MPEG-2 DVD compatible</span>
<span class="cm">		 * stream, and research indicates both the MPEG 2 SVCD and DVD</span>
<span class="cm">		 * stream types use an MPEG-2 PS container.</span>
<span class="cm">		 */</span>
		<span class="cm">/*</span>
<span class="cm">		 * An MPEG-2 Program Stream (PS) is a series of</span>
<span class="cm">		 * MPEG-2 Program Packs terminated by an</span>
<span class="cm">		 * MPEG Program End Code after the last Program Pack.</span>
<span class="cm">		 * A Program Pack may hold a PS System Header packet and any</span>
<span class="cm">		 * number of Program Elementary Stream (PES) Packets</span>
<span class="cm">		 */</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">readpos</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">search_pack_header</span> <span class="o">?</span> <span class="mh">0xba</span> <span class="o">:</span> <span class="mh">0xe0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">stuffing</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Scan for a 0 to find a potential MPEG-2 start code */</span>
			<span class="n">q</span> <span class="o">=</span> <span class="n">memchr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="n">p</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Keep looking if not a</span>
<span class="cm">			 * MPEG-2 Pack header start code:  0x00 0x00 0x01 0xba</span>
<span class="cm">			 * or MPEG-2 video PES start code: 0x00 0x00 0x01 0xe0</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">q</span> <span class="o">+</span> <span class="mi">15</span> <span class="o">&gt;=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytesused</span> <span class="o">||</span>
			    <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ch</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* If expecting the primary video PES */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">search_pack_header</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Continue if it couldn&#39;t be a PES packet */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">q</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x80</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="cm">/* Check if a PTS or PTS &amp; DTS follow */</span>
				<span class="k">if</span> <span class="p">(((</span><span class="n">q</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x80</span> <span class="o">&amp;&amp;</span>  <span class="cm">/* PTS only */</span>
				     <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">||</span> <span class="cm">/* PTS only */</span>
				    <span class="p">((</span><span class="n">q</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xc0</span> <span class="o">&amp;&amp;</span>  <span class="cm">/* PTS &amp; DTS */</span>
				     <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x30</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* DTS follows */</span>
					<span class="cm">/* Assume we found the video PES hdr */</span>
					<span class="n">ch</span> <span class="o">=</span> <span class="mh">0xba</span><span class="p">;</span> <span class="cm">/* next want a Program Pack*/</span>
					<span class="n">cx</span><span class="o">-&gt;</span><span class="n">search_pack_header</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">p</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">9</span><span class="p">;</span> <span class="cm">/* Skip this video PES hdr */</span>
				<span class="p">}</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* We may have found a Program Pack start code */</span>

			<span class="cm">/* Get the count of stuffing bytes &amp; verify them */</span>
			<span class="n">stuffing</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
			<span class="cm">/* all stuffing bytes must be 0xff */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stuffing</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">14</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">stuffing</span> <span class="o">&amp;&amp;</span> <span class="cm">/* right number of stuffing bytes*/</span>
			    <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xc4</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x44</span> <span class="o">&amp;&amp;</span> <span class="cm">/* marker check */</span>
			    <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span>  <span class="cm">/* marker check */</span>
			    <span class="n">q</span><span class="p">[</span><span class="mi">14</span> <span class="o">+</span> <span class="n">stuffing</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="cm">/* PES Pack or Sys Hdr */</span>
			    <span class="n">q</span><span class="p">[</span><span class="mi">15</span> <span class="o">+</span> <span class="n">stuffing</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="n">q</span><span class="p">[</span><span class="mi">16</span> <span class="o">+</span> <span class="n">stuffing</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* We declare we actually found a Program Pack*/</span>
				<span class="n">cx</span><span class="o">-&gt;</span><span class="n">search_pack_header</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* expect vid PES */</span>
				<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">q</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
				<span class="n">cx18_setup_sliced_vbi_mdl</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>
				<span class="o">*</span><span class="n">stop</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">ubuf</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">readpos</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">CX18_DEBUG_WARN</span><span class="p">(</span><span class="s">&quot;copy %zd bytes to user failed for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">len</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">readpos</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_MPG</span> <span class="o">&amp;&amp;</span>
	    <span class="n">buf</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">sliced_mpeg_buf</span><span class="p">)</span>
		<span class="n">cx</span><span class="o">-&gt;</span><span class="n">mpg_data_received</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">cx18_copy_mdl_to_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">cx18_mdl</span> <span class="o">*</span><span class="n">mdl</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ucount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">tot_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">stop</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mdl</span><span class="o">-&gt;</span><span class="n">curr_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">mdl</span><span class="o">-&gt;</span><span class="n">curr_buf</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdl</span><span class="o">-&gt;</span><span class="n">buf_list</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">cx18_buffer</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_entry_is_past_end</span><span class="p">(</span><span class="n">mdl</span><span class="o">-&gt;</span><span class="n">curr_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdl</span><span class="o">-&gt;</span><span class="n">buf_list</span><span class="p">,</span> <span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For some reason we&#39;ve exhausted the buffers, but the MDL</span>
<span class="cm">		 * object still said some data was unread.</span>
<span class="cm">		 * Fix that and bail out.</span>
<span class="cm">		 */</span>
		<span class="n">mdl</span><span class="o">-&gt;</span><span class="n">readpos</span> <span class="o">=</span> <span class="n">mdl</span><span class="o">-&gt;</span><span class="n">bytesused</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_from</span><span class="p">(</span><span class="n">mdl</span><span class="o">-&gt;</span><span class="n">curr_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdl</span><span class="o">-&gt;</span><span class="n">buf_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mdl</span><span class="o">-&gt;</span><span class="n">curr_buf</span><span class="o">-&gt;</span><span class="n">readpos</span> <span class="o">&gt;=</span> <span class="n">mdl</span><span class="o">-&gt;</span><span class="n">curr_buf</span><span class="o">-&gt;</span><span class="n">bytesused</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">cx18_copy_buf_to_user</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mdl</span><span class="o">-&gt;</span><span class="n">curr_buf</span><span class="p">,</span> <span class="n">ubuf</span> <span class="o">+</span> <span class="n">tot_written</span><span class="p">,</span>
					   <span class="n">ucount</span> <span class="o">-</span> <span class="n">tot_written</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stop</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">mdl</span><span class="o">-&gt;</span><span class="n">readpos</span> <span class="o">+=</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">tot_written</span> <span class="o">+=</span> <span class="n">rc</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">stop</span> <span class="o">||</span>	<span class="cm">/* Forced stopping point for VBI insertion */</span>
		    <span class="n">tot_written</span> <span class="o">&gt;=</span> <span class="n">ucount</span> <span class="o">||</span>	<span class="cm">/* Reader request statisfied */</span>
		    <span class="n">mdl</span><span class="o">-&gt;</span><span class="n">curr_buf</span><span class="o">-&gt;</span><span class="n">readpos</span> <span class="o">&lt;</span> <span class="n">mdl</span><span class="o">-&gt;</span><span class="n">curr_buf</span><span class="o">-&gt;</span><span class="n">bytesused</span> <span class="o">||</span>
		    <span class="n">mdl</span><span class="o">-&gt;</span><span class="n">readpos</span> <span class="o">&gt;=</span> <span class="n">mdl</span><span class="o">-&gt;</span><span class="n">bytesused</span><span class="p">)</span> <span class="cm">/* MDL buffers drained */</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">tot_written</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cx18_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">tot_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">non_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">tot_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">single_frame</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">ana_capturing</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* shouldn&#39;t happen */</span>
		<span class="n">CX18_DEBUG_WARN</span><span class="p">(</span><span class="s">&quot;Stream %s not initialized before read</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Each VBI buffer is one frame, the v4l2 API says that for VBI the</span>
<span class="cm">	   frames should arrive one-by-one, so make sure we never output more</span>
<span class="cm">	   than one VBI frame at a time */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_VBI</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cx18_raw_vbi</span><span class="p">(</span><span class="n">cx</span><span class="p">))</span>
		<span class="n">single_frame</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cx18_mdl</span> <span class="o">*</span><span class="n">mdl</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

		<span class="n">mdl</span> <span class="o">=</span> <span class="n">cx18_get_mdl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">non_block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rc</span><span class="p">);</span>
		<span class="cm">/* if there is no data available... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mdl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* if we got data, then return that regardless */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tot_written</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* EOS condition */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMOFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_APPL_IO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
				<span class="n">cx18_release_stream</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* set errno */</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">cx18_copy_mdl_to_user</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="n">ubuf</span> <span class="o">+</span> <span class="n">tot_written</span><span class="p">,</span>
				<span class="n">tot_count</span> <span class="o">-</span> <span class="n">tot_written</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mdl</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">sliced_mpeg_mdl</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mdl</span><span class="o">-&gt;</span><span class="n">readpos</span> <span class="o">==</span> <span class="n">mdl</span><span class="o">-&gt;</span><span class="n">bytesused</span><span class="p">)</span>
				<span class="n">cx18_stream_put_mdl_fw</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mdl</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">cx18_push</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mdl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_full</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mdl</span><span class="o">-&gt;</span><span class="n">readpos</span> <span class="o">==</span> <span class="n">mdl</span><span class="o">-&gt;</span><span class="n">bytesused</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">inserted_frame</span> <span class="o">%</span> <span class="n">CX18_VBI_FRAMES</span><span class="p">;</span>

			<span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">sliced_mpeg_size</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi</span><span class="p">.</span><span class="n">inserted_frame</span><span class="o">++</span><span class="p">;</span>
			<span class="n">cx</span><span class="o">-&gt;</span><span class="n">vbi_data_inserted</span> <span class="o">+=</span> <span class="n">mdl</span><span class="o">-&gt;</span><span class="n">bytesused</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">tot_written</span> <span class="o">+=</span> <span class="n">rc</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tot_written</span> <span class="o">==</span> <span class="n">tot_count</span> <span class="o">||</span> <span class="n">single_frame</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">tot_written</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cx18_read_pos</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">non_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">count</span> <span class="o">?</span> <span class="n">cx18_read</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">non_block</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>

	<span class="n">CX18_DEBUG_HI_FILE</span><span class="p">(</span><span class="s">&quot;read %zd from %s, got %zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cx18_start_capture</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_open_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s_vbi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s_idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_RAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* you cannot read from these stream types. */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Try to claim this stream. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cx18_claim_stream</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* If capture is already in progress, then we also have to</span>
<span class="cm">	   do nothing extra. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMOFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CX18_F_S_APPL_IO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Start associated VBI or IDX stream capture if required */</span>
	<span class="n">s_vbi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">CX18_ENC_STREAM_TYPE_VBI</span><span class="p">];</span>
	<span class="n">s_idx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">CX18_ENC_STREAM_TYPE_IDX</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_MPG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The VBI and IDX streams should have been claimed</span>
<span class="cm">		 * automatically, if for internal use, when the MPG stream was</span>
<span class="cm">		 * claimed.  We only need to start these streams capturing.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_INTERNAL_USE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_idx</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_idx</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cx18_start_v4l2_encode_stream</span><span class="p">(</span><span class="n">s_idx</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">CX18_DEBUG_WARN</span><span class="p">(</span><span class="s">&quot;IDX capture start failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_idx</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">start_failed</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;IDX capture started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_INTERNAL_USE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_vbi</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_vbi</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cx18_start_v4l2_encode_stream</span><span class="p">(</span><span class="n">s_vbi</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">CX18_DEBUG_WARN</span><span class="p">(</span><span class="s">&quot;VBI capture start failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_vbi</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">start_failed</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;VBI insertion started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Tell the card to start capturing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cx18_start_v4l2_encode_stream</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We&#39;re done */</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CX18_F_S_APPL_IO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
		<span class="cm">/* Resume a possibly paused encoder */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">CX18_F_I_ENC_PAUSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">))</span>
			<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_CAPTURE_PAUSE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">start_failed:</span>
	<span class="n">CX18_DEBUG_WARN</span><span class="p">(</span><span class="s">&quot;Failed to start capturing for stream %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The associated VBI and IDX streams for internal use are released</span>
<span class="cm">	 * automatically when the MPG stream is released.  We only need to stop</span>
<span class="cm">	 * the associated stream.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_MPG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Stop the IDX stream which is always for internal use */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_idx</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cx18_stop_v4l2_encode_stream</span><span class="p">(</span><span class="n">s_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_idx</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Stop the VBI stream, if only running for internal use */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_vbi</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_APPL_IO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_vbi</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cx18_stop_v4l2_encode_stream</span><span class="p">(</span><span class="n">s_vbi</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_vbi</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
	<span class="n">cx18_release_stream</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="cm">/* Also releases associated streams */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">ssize_t</span> <span class="nf">cx18_v4l2_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18_open_id</span> <span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="n">file2id</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">CX18_DEBUG_HI_FILE</span><span class="p">(</span><span class="s">&quot;read %zd bytes from %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">serialize_lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">cx18_start_capture</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">serialize_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_type</span> <span class="o">==</span> <span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_YUV</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">videobuf_read_stream</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vbuf_q</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cx18_read_pos</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cx18_v4l2_enc_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18_open_id</span> <span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="n">file2id</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">eof</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMOFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>

	<span class="cm">/* Start a capture if there is none */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eof</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">serialize_lock</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cx18_start_capture</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">serialize_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;Could not start capture for %s (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">POLLERR</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">CX18_DEBUG_FILE</span><span class="p">(</span><span class="s">&quot;Encoder poll started capture</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_type</span> <span class="o">==</span> <span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_YUV</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">videobuf_poll</span> <span class="o">=</span> <span class="n">videobuf_poll_stream</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vbuf_q</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">eof</span> <span class="o">&amp;&amp;</span> <span class="n">videobuf_poll</span> <span class="o">==</span> <span class="n">POLLERR</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">POLLHUP</span><span class="p">;</span>
                <span class="k">else</span>
                        <span class="k">return</span> <span class="n">videobuf_poll</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* add stream&#39;s waitq to the poll list */</span>
	<span class="n">CX18_DEBUG_HI_FILE</span><span class="p">(</span><span class="s">&quot;Encoder poll</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">poll_wait</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">q_full</span><span class="p">.</span><span class="n">depth</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eof</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">POLLHUP</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cx18_v4l2_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18_open_id</span> <span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">eof</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMOFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_type</span> <span class="o">==</span> <span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_YUV</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* Start a capture if there is none */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eof</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">serialize_lock</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">cx18_start_capture</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">serialize_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span>
					<span class="s">&quot;Could not start capture for %s (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">CX18_DEBUG_FILE</span><span class="p">(</span><span class="s">&quot;Encoder mmap started capture</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">videobuf_mmap_mapper</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vbuf_q</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cx18_vb_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_videobuf_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Return all of the buffers in error state, so the vbi/vid inode</span>
<span class="cm">	 * can return from blocking.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_capture</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_capture</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">cx18_videobuf_buffer</span><span class="p">,</span> <span class="n">vb</span><span class="p">.</span><span class="n">queue</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">queue</span><span class="p">);</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">;</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">done</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">vb_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cx18_stop_capture</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_open_id</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gop_end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s_vbi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">CX18_ENC_STREAM_TYPE_VBI</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s_idx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">CX18_ENC_STREAM_TYPE_IDX</span><span class="p">];</span>

	<span class="n">CX18_DEBUG_IOCTL</span><span class="p">(</span><span class="s">&quot;close() of %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* &#39;Unclaim&#39; this stream */</span>

	<span class="cm">/* Stop capturing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;close stopping capture</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_MPG</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Stop internal use associated VBI and IDX streams */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_vbi</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_APPL_IO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_vbi</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;close stopping embedded VBI &quot;</span>
						<span class="s">&quot;capture</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">cx18_stop_v4l2_encode_stream</span><span class="p">(</span><span class="n">s_vbi</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_idx</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;close stopping IDX capture</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">cx18_stop_v4l2_encode_stream</span><span class="p">(</span><span class="n">s_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_VBI</span> <span class="o">&amp;&amp;</span>
		    <span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_S_INTERNAL_USE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">))</span>
			<span class="cm">/* Also used internally, don&#39;t stop capturing */</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">cx18_stop_v4l2_encode_stream</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gop_end</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gop_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_APPL_IO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_S_STREAMOFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">);</span>
		<span class="n">cx18_release_stream</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cx18_v4l2_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_fh</span> <span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_open_id</span> <span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="n">fh2id</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">];</span>

	<span class="n">CX18_DEBUG_IOCTL</span><span class="p">(</span><span class="s">&quot;close() of %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">serialize_lock</span><span class="p">);</span>
	<span class="cm">/* Stop radio */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_RAD</span> <span class="o">&amp;&amp;</span>
			<span class="n">v4l2_fh_is_singular_file</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Closing radio device, return to TV mode */</span>
		<span class="n">cx18_mute</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>
		<span class="cm">/* Mark that the radio is no longer in use */</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CX18_F_I_RADIO_USER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
		<span class="cm">/* Switch tuner to TV */</span>
		<span class="n">cx18_call_all</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">s_std</span><span class="p">,</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">std</span><span class="p">);</span>
		<span class="cm">/* Select correct audio input (i.e. TV tuner or Line in) */</span>
		<span class="n">cx18_audio_set_io</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">ana_capturing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Undo video mute */</span>
			<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_SET_VIDEO_MUTE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">v4l2_ctrl_g_ctrl</span><span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">.</span><span class="n">video_mute</span><span class="p">)</span> <span class="o">|</span>
			    <span class="p">(</span><span class="n">v4l2_ctrl_g_ctrl</span><span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">cxhdl</span><span class="p">.</span><span class="n">video_mute_yuv</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)));</span>
		<span class="p">}</span>
		<span class="cm">/* Done! Unmute and continue. */</span>
		<span class="n">cx18_unmute</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">v4l2_fh_del</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
	<span class="n">v4l2_fh_exit</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>

	<span class="cm">/* &#39;Unclaim&#39; this stream */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">open_id</span><span class="p">)</span>
		<span class="n">cx18_stop_capture</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">serialize_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cx18_serialized_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx18_open_id</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>

	<span class="n">CX18_DEBUG_FILE</span><span class="p">(</span><span class="s">&quot;open %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* Allocate memory */</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18_open_id</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CX18_DEBUG_WARN</span><span class="p">(</span><span class="s">&quot;nomem on v4l2 open</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">v4l2_fh_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">video_dev</span><span class="p">);</span>

	<span class="n">item</span><span class="o">-&gt;</span><span class="n">cx</span> <span class="o">=</span> <span class="n">cx</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

	<span class="n">item</span><span class="o">-&gt;</span><span class="n">open_id</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">open_id</span><span class="o">++</span><span class="p">;</span>
	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">;</span>
	<span class="n">v4l2_fh_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">CX18_ENC_STREAM_TYPE_RAD</span> <span class="o">&amp;&amp;</span>
			<span class="n">v4l2_fh_is_singular_file</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CX18_F_I_RADIO_USER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">ana_capturing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* switching to radio while capture is</span>
<span class="cm">				   in progress is not polite */</span>
				<span class="n">v4l2_fh_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>
				<span class="n">v4l2_fh_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Mark that the radio is being used. */</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CX18_F_I_RADIO_USER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
		<span class="cm">/* We have the radio */</span>
		<span class="n">cx18_mute</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>
		<span class="cm">/* Switch tuner to radio */</span>
		<span class="n">cx18_call_all</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">tuner</span><span class="p">,</span> <span class="n">s_radio</span><span class="p">);</span>
		<span class="cm">/* Select the correct audio input (i.e. radio tuner) */</span>
		<span class="n">cx18_audio_set_io</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>
		<span class="cm">/* Done! Unmute and continue. */</span>
		<span class="n">cx18_unmute</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cx18_v4l2_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">video_device</span> <span class="o">*</span><span class="n">video_dev</span> <span class="o">=</span> <span class="n">video_devdata</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cx18_stream</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">video_get_drvdata</span><span class="p">(</span><span class="n">video_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cx</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">serialize_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cx18_init_on_first_open</span><span class="p">(</span><span class="n">cx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">CX18_ERR</span><span class="p">(</span><span class="s">&quot;Failed to initialize on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">video_device_node_name</span><span class="p">(</span><span class="n">video_dev</span><span class="p">));</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">serialize_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">cx18_serialized_open</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">serialize_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cx18_mute</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">h</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">ana_capturing</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">h</span> <span class="o">=</span> <span class="n">cx18_find_handle</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">!=</span> <span class="n">CX18_INVALID_TASK_HANDLE</span><span class="p">)</span>
			<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_SET_AUDIO_MUTE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">CX18_ERR</span><span class="p">(</span><span class="s">&quot;Can&#39;t find valid task handle for mute</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;Mute</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cx18_unmute</span><span class="p">(</span><span class="k">struct</span> <span class="n">cx18</span> <span class="o">*</span><span class="n">cx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">h</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">ana_capturing</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">h</span> <span class="o">=</span> <span class="n">cx18_find_handle</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">!=</span> <span class="n">CX18_INVALID_TASK_HANDLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cx18_msleep_timeout</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_SET_MISC_PARAMETERS</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
			<span class="n">cx18_vapi</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">CX18_CPU_SET_AUDIO_MUTE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">CX18_ERR</span><span class="p">(</span><span class="s">&quot;Can&#39;t find valid task handle for unmute</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">CX18_DEBUG_INFO</span><span class="p">(</span><span class="s">&quot;Unmute</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
