<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › s5p-fimc › fimc-core.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>fimc-core.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2010 - 2012 Samsung Electronics Co., Ltd.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef FIMC_CORE_H_</span>
<span class="cp">#define FIMC_CORE_H_</span>

<span class="cm">/*#define DEBUG*/</span>

<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/videodev2.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;asm/sizes.h&gt;</span>

<span class="cp">#include &lt;media/media-entity.h&gt;</span>
<span class="cp">#include &lt;media/videobuf2-core.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-ctrls.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-device.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-mem2mem.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-mediabus.h&gt;</span>
<span class="cp">#include &lt;media/s5p_fimc.h&gt;</span>

<span class="cp">#define err(fmt, args...) \</span>
<span class="cp">	printk(KERN_ERR &quot;%s:%d: &quot; fmt &quot;\n&quot;, __func__, __LINE__, ##args)</span>

<span class="cp">#define dbg(fmt, args...) \</span>
<span class="cp">	pr_debug(&quot;%s:%d: &quot; fmt &quot;\n&quot;, __func__, __LINE__, ##args)</span>

<span class="cm">/* Time to wait for next frame VSYNC interrupt while stopping operation. */</span>
<span class="cp">#define FIMC_SHUTDOWN_TIMEOUT	((100*HZ)/1000)</span>
<span class="cp">#define MAX_FIMC_CLOCKS		2</span>
<span class="cp">#define FIMC_MODULE_NAME	&quot;s5p-fimc&quot;</span>
<span class="cp">#define FIMC_MAX_DEVS		4</span>
<span class="cp">#define FIMC_MAX_OUT_BUFS	4</span>
<span class="cp">#define SCALER_MAX_HRATIO	64</span>
<span class="cp">#define SCALER_MAX_VRATIO	64</span>
<span class="cp">#define DMA_MIN_SIZE		8</span>
<span class="cp">#define FIMC_CAMIF_MAX_HEIGHT	0x2000</span>

<span class="cm">/* indices to the clocks array */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">CLK_BUS</span><span class="p">,</span>
	<span class="n">CLK_GATE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">fimc_dev_flags</span> <span class="p">{</span>
	<span class="n">ST_LPM</span><span class="p">,</span>
	<span class="cm">/* m2m node */</span>
	<span class="n">ST_M2M_RUN</span><span class="p">,</span>
	<span class="n">ST_M2M_PEND</span><span class="p">,</span>
	<span class="n">ST_M2M_SUSPENDING</span><span class="p">,</span>
	<span class="n">ST_M2M_SUSPENDED</span><span class="p">,</span>
	<span class="cm">/* capture node */</span>
	<span class="n">ST_CAPT_PEND</span><span class="p">,</span>
	<span class="n">ST_CAPT_RUN</span><span class="p">,</span>
	<span class="n">ST_CAPT_STREAM</span><span class="p">,</span>
	<span class="n">ST_CAPT_ISP_STREAM</span><span class="p">,</span>
	<span class="n">ST_CAPT_SUSPENDED</span><span class="p">,</span>
	<span class="n">ST_CAPT_SHUT</span><span class="p">,</span>
	<span class="n">ST_CAPT_BUSY</span><span class="p">,</span>
	<span class="n">ST_CAPT_APPLY_CFG</span><span class="p">,</span>
	<span class="n">ST_CAPT_JPEG</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define fimc_m2m_active(dev) test_bit(ST_M2M_RUN, &amp;(dev)-&gt;state)</span>
<span class="cp">#define fimc_m2m_pending(dev) test_bit(ST_M2M_PEND, &amp;(dev)-&gt;state)</span>

<span class="cp">#define fimc_capture_running(dev) test_bit(ST_CAPT_RUN, &amp;(dev)-&gt;state)</span>
<span class="cp">#define fimc_capture_pending(dev) test_bit(ST_CAPT_PEND, &amp;(dev)-&gt;state)</span>
<span class="cp">#define fimc_capture_busy(dev) test_bit(ST_CAPT_BUSY, &amp;(dev)-&gt;state)</span>

<span class="k">enum</span> <span class="n">fimc_datapath</span> <span class="p">{</span>
	<span class="n">FIMC_IO_NONE</span><span class="p">,</span>
	<span class="n">FIMC_IO_CAMERA</span><span class="p">,</span>
	<span class="n">FIMC_IO_DMA</span><span class="p">,</span>
	<span class="n">FIMC_IO_LCDFIFO</span><span class="p">,</span>
	<span class="n">FIMC_IO_WRITEBACK</span><span class="p">,</span>
	<span class="n">FIMC_IO_ISP</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">fimc_color_fmt</span> <span class="p">{</span>
	<span class="n">FIMC_FMT_RGB444</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">FIMC_FMT_RGB555</span><span class="p">,</span>
	<span class="n">FIMC_FMT_RGB565</span><span class="p">,</span>
	<span class="n">FIMC_FMT_RGB666</span><span class="p">,</span>
	<span class="n">FIMC_FMT_RGB888</span><span class="p">,</span>
	<span class="n">FIMC_FMT_RGB30_LOCAL</span><span class="p">,</span>
	<span class="n">FIMC_FMT_YCBCR420</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
	<span class="n">FIMC_FMT_YCBYCR422</span><span class="p">,</span>
	<span class="n">FIMC_FMT_YCRYCB422</span><span class="p">,</span>
	<span class="n">FIMC_FMT_CBYCRY422</span><span class="p">,</span>
	<span class="n">FIMC_FMT_CRYCBY422</span><span class="p">,</span>
	<span class="n">FIMC_FMT_YCBCR444_LOCAL</span><span class="p">,</span>
	<span class="n">FIMC_FMT_JPEG</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
	<span class="n">FIMC_FMT_RAW8</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span>
	<span class="n">FIMC_FMT_RAW10</span><span class="p">,</span>
	<span class="n">FIMC_FMT_RAW12</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define fimc_fmt_is_rgb(x) (!!((x) &amp; 0x10))</span>
<span class="cp">#define fimc_fmt_is_jpeg(x) (!!((x) &amp; 0x40))</span>

<span class="cp">#define IS_M2M(__strt) ((__strt) == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE || \</span>
<span class="cp">			__strt == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)</span>

<span class="cm">/* The hardware context state. */</span>
<span class="cp">#define	FIMC_PARAMS		(1 &lt;&lt; 0)</span>
<span class="cp">#define	FIMC_SRC_FMT		(1 &lt;&lt; 3)</span>
<span class="cp">#define	FIMC_DST_FMT		(1 &lt;&lt; 4)</span>
<span class="cp">#define	FIMC_COMPOSE		(1 &lt;&lt; 5)</span>
<span class="cp">#define	FIMC_CTX_M2M		(1 &lt;&lt; 16)</span>
<span class="cp">#define	FIMC_CTX_CAP		(1 &lt;&lt; 17)</span>
<span class="cp">#define	FIMC_CTX_SHUT		(1 &lt;&lt; 18)</span>

<span class="cm">/* Image conversion flags */</span>
<span class="cp">#define	FIMC_IN_DMA_ACCESS_TILED	(1 &lt;&lt; 0)</span>
<span class="cp">#define	FIMC_IN_DMA_ACCESS_LINEAR	(0 &lt;&lt; 0)</span>
<span class="cp">#define	FIMC_OUT_DMA_ACCESS_TILED	(1 &lt;&lt; 1)</span>
<span class="cp">#define	FIMC_OUT_DMA_ACCESS_LINEAR	(0 &lt;&lt; 1)</span>
<span class="cp">#define	FIMC_SCAN_MODE_PROGRESSIVE	(0 &lt;&lt; 2)</span>
<span class="cp">#define	FIMC_SCAN_MODE_INTERLACED	(1 &lt;&lt; 2)</span>
<span class="cm">/*</span>
<span class="cm"> * YCbCr data dynamic range for RGB-YUV color conversion.</span>
<span class="cm"> * Y/Cb/Cr: (0 ~ 255) */</span>
<span class="cp">#define	FIMC_COLOR_RANGE_WIDE		(0 &lt;&lt; 3)</span>
<span class="cm">/* Y (16 ~ 235), Cb/Cr (16 ~ 240) */</span>
<span class="cp">#define	FIMC_COLOR_RANGE_NARROW		(1 &lt;&lt; 3)</span>

<span class="cm">/**</span>
<span class="cm"> * struct fimc_fmt - the driver&#39;s internal color format data</span>
<span class="cm"> * @mbus_code: Media Bus pixel code, -1 if not applicable</span>
<span class="cm"> * @name: format description</span>
<span class="cm"> * @fourcc: the fourcc code for this format, 0 if not applicable</span>
<span class="cm"> * @color: the corresponding fimc_color_fmt</span>
<span class="cm"> * @memplanes: number of physically non-contiguous data planes</span>
<span class="cm"> * @colplanes: number of physically contiguous data planes</span>
<span class="cm"> * @depth: per plane driver&#39;s private &#39;number of bits per pixel&#39;</span>
<span class="cm"> * @flags: flags indicating which operation mode format applies to</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fimc_fmt</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">v4l2_mbus_pixelcode</span> <span class="n">mbus_code</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">fourcc</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">color</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">memplanes</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">colplanes</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">depth</span><span class="p">[</span><span class="n">VIDEO_MAX_PLANES</span><span class="p">];</span>
	<span class="n">u16</span>	<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define FMT_FLAGS_CAM		(1 &lt;&lt; 0)</span>
<span class="cp">#define FMT_FLAGS_M2M_IN	(1 &lt;&lt; 1)</span>
<span class="cp">#define FMT_FLAGS_M2M_OUT	(1 &lt;&lt; 2)</span>
<span class="cp">#define FMT_FLAGS_M2M		(1 &lt;&lt; 1 | 1 &lt;&lt; 2)</span>
<span class="cp">#define FMT_HAS_ALPHA		(1 &lt;&lt; 3)</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fimc_dma_offset - pixel offset information for DMA</span>
<span class="cm"> * @y_h:	y value horizontal offset</span>
<span class="cm"> * @y_v:	y value vertical offset</span>
<span class="cm"> * @cb_h:	cb value horizontal offset</span>
<span class="cm"> * @cb_v:	cb value vertical offset</span>
<span class="cm"> * @cr_h:	cr value horizontal offset</span>
<span class="cm"> * @cr_v:	cr value vertical offset</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fimc_dma_offset</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">y_h</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">y_v</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">cb_h</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">cb_v</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">cr_h</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">cr_v</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fimc_effect - color effect information</span>
<span class="cm"> * @type:	effect type</span>
<span class="cm"> * @pat_cb:	cr value when type is &quot;arbitrary&quot;</span>
<span class="cm"> * @pat_cr:	cr value when type is &quot;arbitrary&quot;</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fimc_effect</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">type</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">pat_cb</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">pat_cr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fimc_scaler - the configuration data for FIMC inetrnal scaler</span>
<span class="cm"> * @scaleup_h:		flag indicating scaling up horizontally</span>
<span class="cm"> * @scaleup_v:		flag indicating scaling up vertically</span>
<span class="cm"> * @copy_mode:		flag indicating transparent DMA transfer (no scaling</span>
<span class="cm"> *			and color format conversion)</span>
<span class="cm"> * @enabled:		flag indicating if the scaler is used</span>
<span class="cm"> * @hfactor:		horizontal shift factor</span>
<span class="cm"> * @vfactor:		vertical shift factor</span>
<span class="cm"> * @pre_hratio:		horizontal ratio of the prescaler</span>
<span class="cm"> * @pre_vratio:		vertical ratio of the prescaler</span>
<span class="cm"> * @pre_dst_width:	the prescaler&#39;s destination width</span>
<span class="cm"> * @pre_dst_height:	the prescaler&#39;s destination height</span>
<span class="cm"> * @main_hratio:	the main scaler&#39;s horizontal ratio</span>
<span class="cm"> * @main_vratio:	the main scaler&#39;s vertical ratio</span>
<span class="cm"> * @real_width:		source pixel (width - offset)</span>
<span class="cm"> * @real_height:	source pixel (height - offset)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fimc_scaler</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scaleup_h</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scaleup_v</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">copy_mode</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">enabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">hfactor</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">vfactor</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">pre_hratio</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">pre_vratio</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">pre_dst_width</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">pre_dst_height</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">main_hratio</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">main_vratio</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">real_width</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">real_height</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fimc_addr - the FIMC physical address set for DMA</span>
<span class="cm"> * @y:	 luminance plane physical address</span>
<span class="cm"> * @cb:	 Cb plane physical address</span>
<span class="cm"> * @cr:	 Cr plane physical address</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fimc_addr</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">y</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">cb</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">cr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fimc_vid_buffer - the driver&#39;s video buffer</span>
<span class="cm"> * @vb:    v4l videobuf buffer</span>
<span class="cm"> * @list:  linked list structure for buffer queue</span>
<span class="cm"> * @paddr: precalculated physical address set</span>
<span class="cm"> * @index: buffer index for the output DMA engine</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fimc_vid_buffer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_buffer</span>	<span class="n">vb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fimc_addr</span>	<span class="n">paddr</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">index</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fimc_frame - source/target frame properties</span>
<span class="cm"> * @f_width:	image full width (virtual screen size)</span>
<span class="cm"> * @f_height:	image full height (virtual screen size)</span>
<span class="cm"> * @o_width:	original image width as set by S_FMT</span>
<span class="cm"> * @o_height:	original image height as set by S_FMT</span>
<span class="cm"> * @offs_h:	image horizontal pixel offset</span>
<span class="cm"> * @offs_v:	image vertical pixel offset</span>
<span class="cm"> * @width:	image pixel width</span>
<span class="cm"> * @height:	image pixel weight</span>
<span class="cm"> * @payload:	image size in bytes (w x h x bpp)</span>
<span class="cm"> * @paddr:	image frame buffer physical addresses</span>
<span class="cm"> * @dma_offset:	DMA offset in bytes</span>
<span class="cm"> * @fmt:	fimc color format pointer</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fimc_frame</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">f_width</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">f_height</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">o_width</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">o_height</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">offs_h</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">offs_v</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">width</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">height</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">payload</span><span class="p">[</span><span class="n">VIDEO_MAX_PLANES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">fimc_addr</span>	<span class="n">paddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fimc_dma_offset</span>	<span class="n">dma_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fimc_fmt</span>		<span class="o">*</span><span class="n">fmt</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">alpha</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fimc_m2m_device - v4l2 memory-to-memory device data</span>
<span class="cm"> * @vfd: the video device node for v4l2 m2m mode</span>
<span class="cm"> * @m2m_dev: v4l2 memory-to-memory device data</span>
<span class="cm"> * @ctx: hardware context data</span>
<span class="cm"> * @refcnt: the reference counter</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fimc_m2m_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">video_device</span>	<span class="o">*</span><span class="n">vfd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_m2m_dev</span>	<span class="o">*</span><span class="n">m2m_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fimc_ctx</span>		<span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">refcnt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define FIMC_SD_PAD_SINK	0</span>
<span class="cp">#define FIMC_SD_PAD_SOURCE	1</span>
<span class="cp">#define FIMC_SD_PADS_NUM	2</span>

<span class="cm">/**</span>
<span class="cm"> * struct fimc_vid_cap - camera capture device information</span>
<span class="cm"> * @ctx: hardware context data</span>
<span class="cm"> * @vfd: video device node for camera capture mode</span>
<span class="cm"> * @subdev: subdev exposing the FIMC processing block</span>
<span class="cm"> * @vd_pad: fimc video capture node pad</span>
<span class="cm"> * @sd_pads: fimc video processing block pads</span>
<span class="cm"> * @mf: media bus format at the FIMC camera input (and the scaler output) pad</span>
<span class="cm"> * @pending_buf_q: the pending buffer queue head</span>
<span class="cm"> * @active_buf_q: the queue head of buffers scheduled in hardware</span>
<span class="cm"> * @vbq: the capture am video buffer queue</span>
<span class="cm"> * @active_buf_cnt: number of video buffers scheduled in hardware</span>
<span class="cm"> * @buf_index: index for managing the output DMA buffers</span>
<span class="cm"> * @frame_count: the frame counter for statistics</span>
<span class="cm"> * @reqbufs_count: the number of buffers requested in REQBUFS ioctl</span>
<span class="cm"> * @input_index: input (camera sensor) index</span>
<span class="cm"> * @refcnt: driver&#39;s private reference counter</span>
<span class="cm"> * @input: capture input type, grp_id of the attached subdev</span>
<span class="cm"> * @user_subdev_api: true if subdevs are not configured by the host driver</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fimc_vid_cap</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fimc_ctx</span>			<span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vb2_alloc_ctx</span>		<span class="o">*</span><span class="n">alloc_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">video_device</span>		<span class="o">*</span><span class="n">vfd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span>		<span class="n">subdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">media_pad</span>		<span class="n">vd_pad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_mbus_framefmt</span>	<span class="n">mf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">media_pad</span>		<span class="n">sd_pads</span><span class="p">[</span><span class="n">FIMC_SD_PADS_NUM</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">pending_buf_q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">active_buf_q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vb2_queue</span>		<span class="n">vbq</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">active_buf_cnt</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">buf_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">frame_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">reqbufs_count</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">input_index</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">refcnt</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">input</span><span class="p">;</span>
	<span class="n">bool</span>				<span class="n">user_subdev_api</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *  struct fimc_pix_limit - image pixel size limits in various IP configurations</span>
<span class="cm"> *</span>
<span class="cm"> *  @scaler_en_w: max input pixel width when the scaler is enabled</span>
<span class="cm"> *  @scaler_dis_w: max input pixel width when the scaler is disabled</span>
<span class="cm"> *  @in_rot_en_h: max input width with the input rotator is on</span>
<span class="cm"> *  @in_rot_dis_w: max input width with the input rotator is off</span>
<span class="cm"> *  @out_rot_en_w: max output width with the output rotator on</span>
<span class="cm"> *  @out_rot_dis_w: max output width with the output rotator off</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fimc_pix_limit</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">scaler_en_w</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">scaler_dis_w</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">in_rot_en_h</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">in_rot_dis_w</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">out_rot_en_w</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">out_rot_dis_w</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fimc_variant - FIMC device variant information</span>
<span class="cm"> * @pix_hoff: indicate whether horizontal offset is in pixels or in bytes</span>
<span class="cm"> * @has_inp_rot: set if has input rotator</span>
<span class="cm"> * @has_out_rot: set if has output rotator</span>
<span class="cm"> * @has_cistatus2: 1 if CISTATUS2 register is present in this IP revision</span>
<span class="cm"> * @has_mainscaler_ext: 1 if extended mainscaler ratios in CIEXTEN register</span>
<span class="cm"> *			 are present in this IP revision</span>
<span class="cm"> * @has_cam_if: set if this instance has a camera input interface</span>
<span class="cm"> * @pix_limit: pixel size constraints for the scaler</span>
<span class="cm"> * @min_inp_pixsize: minimum input pixel size</span>
<span class="cm"> * @min_out_pixsize: minimum output pixel size</span>
<span class="cm"> * @hor_offs_align: horizontal pixel offset aligment</span>
<span class="cm"> * @min_vsize_align: minimum vertical pixel size alignment</span>
<span class="cm"> * @out_buf_count: the number of buffers in output DMA sequence</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fimc_variant</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">pix_hoff</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">has_inp_rot</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">has_out_rot</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">has_cistatus2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">has_mainscaler_ext</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">has_cam_if</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">has_alpha</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fimc_pix_limit</span> <span class="o">*</span><span class="n">pix_limit</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">min_inp_pixsize</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">min_out_pixsize</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">hor_offs_align</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">min_vsize_align</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">out_buf_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fimc_drvdata - per device type driver data</span>
<span class="cm"> * @variant: variant information for this device</span>
<span class="cm"> * @num_entities: number of fimc instances available in a SoC</span>
<span class="cm"> * @lclk_frequency: local bus clock frequency</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fimc_drvdata</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fimc_variant</span> <span class="o">*</span><span class="n">variant</span><span class="p">[</span><span class="n">FIMC_MAX_DEVS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">num_entities</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lclk_frequency</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define fimc_get_drvdata(_pdev) \</span>
<span class="cp">	((struct fimc_drvdata *) platform_get_device_id(_pdev)-&gt;driver_data)</span>

<span class="k">struct</span> <span class="n">fimc_ctx</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct fimc_dev - abstraction for FIMC entity</span>
<span class="cm"> * @slock:	the spinlock protecting this data structure</span>
<span class="cm"> * @lock:	the mutex protecting this data structure</span>
<span class="cm"> * @pdev:	pointer to the FIMC platform device</span>
<span class="cm"> * @pdata:	pointer to the device platform data</span>
<span class="cm"> * @variant:	the IP variant information</span>
<span class="cm"> * @id:		FIMC device index (0..FIMC_MAX_DEVS)</span>
<span class="cm"> * @clock:	clocks required for FIMC operation</span>
<span class="cm"> * @regs:	the mapped hardware registers</span>
<span class="cm"> * @irq_queue:	interrupt handler waitqueue</span>
<span class="cm"> * @v4l2_dev:	root v4l2_device</span>
<span class="cm"> * @m2m:	memory-to-memory V4L2 device information</span>
<span class="cm"> * @vid_cap:	camera capture device information</span>
<span class="cm"> * @state:	flags used to synchronize m2m and capture mode operation</span>
<span class="cm"> * @alloc_ctx:	videobuf2 memory allocator context</span>
<span class="cm"> * @pipeline:	fimc video capture pipeline data structure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fimc_dev</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>			<span class="n">slock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>			<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span>		<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">s5p_platform_fimc</span>	<span class="o">*</span><span class="n">pdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fimc_variant</span>		<span class="o">*</span><span class="n">variant</span><span class="p">;</span>
	<span class="n">u16</span>				<span class="n">id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span>			<span class="o">*</span><span class="n">clock</span><span class="p">[</span><span class="n">MAX_FIMC_CLOCKS</span><span class="p">];</span>
	<span class="kt">void</span> <span class="n">__iomem</span>			<span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>		<span class="n">irq_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_device</span>		<span class="o">*</span><span class="n">v4l2_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fimc_m2m_device</span>		<span class="n">m2m</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fimc_vid_cap</span>		<span class="n">vid_cap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vb2_alloc_ctx</span>		<span class="o">*</span><span class="n">alloc_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fimc_pipeline</span>		<span class="n">pipeline</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fimc_ctrls - v4l2 controls structure</span>
<span class="cm"> * @handler: the control handler</span>
<span class="cm"> * @colorfx: image effect control</span>
<span class="cm"> * @colorfx_cbcr: Cb/Cr coefficients control</span>
<span class="cm"> * @rotate: image rotation control</span>
<span class="cm"> * @hflip: horizontal flip control</span>
<span class="cm"> * @vflip: vertical flip control</span>
<span class="cm"> * @alpha: RGB alpha control</span>
<span class="cm"> * @ready: true if @handler is initialized</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fimc_ctrls</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl_handler</span> <span class="n">handler</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">colorfx</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">colorfx_cbcr</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">rotate</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">hflip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">vflip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_ctrl</span> <span class="o">*</span><span class="n">alpha</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ready</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * fimc_ctx - the device context data</span>
<span class="cm"> * @s_frame:		source frame properties</span>
<span class="cm"> * @d_frame:		destination frame properties</span>
<span class="cm"> * @out_order_1p:	output 1-plane YCBCR order</span>
<span class="cm"> * @out_order_2p:	output 2-plane YCBCR order</span>
<span class="cm"> * @in_order_1p		input 1-plane YCBCR order</span>
<span class="cm"> * @in_order_2p:	input 2-plane YCBCR order</span>
<span class="cm"> * @in_path:		input mode (DMA or camera)</span>
<span class="cm"> * @out_path:		output mode (DMA or FIFO)</span>
<span class="cm"> * @scaler:		image scaler properties</span>
<span class="cm"> * @effect:		image effect</span>
<span class="cm"> * @rotation:		image clockwise rotation in degrees</span>
<span class="cm"> * @hflip:		indicates image horizontal flip if set</span>
<span class="cm"> * @vflip:		indicates image vertical flip if set</span>
<span class="cm"> * @flags:		additional flags for image conversion</span>
<span class="cm"> * @state:		flags to keep track of user configuration</span>
<span class="cm"> * @fimc_dev:		the FIMC device this context applies to</span>
<span class="cm"> * @m2m_ctx:		memory-to-memory device context</span>
<span class="cm"> * @fh:			v4l2 file handle</span>
<span class="cm"> * @ctrls:		v4l2 controls structure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fimc_ctx</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fimc_frame</span>	<span class="n">s_frame</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fimc_frame</span>	<span class="n">d_frame</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">out_order_1p</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">out_order_2p</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">in_order_1p</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">in_order_2p</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fimc_datapath</span>	<span class="n">in_path</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">fimc_datapath</span>	<span class="n">out_path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fimc_scaler</span>	<span class="n">scaler</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fimc_effect</span>	<span class="n">effect</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rotation</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">hflip</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">vflip</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fimc_dev</span>		<span class="o">*</span><span class="n">fimc_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_m2m_ctx</span>	<span class="o">*</span><span class="n">m2m_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_fh</span>		<span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fimc_ctrls</span>	<span class="n">ctrls</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define fh_to_ctx(__fh) container_of(__fh, struct fimc_ctx, fh)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_frame_bounds</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_frame</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">u32</span> <span class="n">width</span><span class="p">,</span> <span class="n">u32</span> <span class="n">height</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">o_width</span>  <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">o_height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">f_width</span>  <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">f_height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_frame_crop</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_frame</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">left</span><span class="p">,</span> <span class="n">u32</span> <span class="n">top</span><span class="p">,</span> <span class="n">u32</span> <span class="n">width</span><span class="p">,</span> <span class="n">u32</span> <span class="n">height</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">offs_h</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">offs_v</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">width</span>  <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">fimc_get_format_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_fmt</span> <span class="o">*</span><span class="n">ff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ff</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ff</span><span class="o">-&gt;</span><span class="n">colplanes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">depth</span> <span class="o">+=</span> <span class="n">ff</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">depth</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">fimc_capture_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_dev</span> <span class="o">*</span><span class="n">fimc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fimc</span><span class="o">-&gt;</span><span class="n">slock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">fimc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ST_CAPT_RUN</span><span class="p">)</span> <span class="o">||</span>
		 <span class="n">fimc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ST_CAPT_PEND</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fimc</span><span class="o">-&gt;</span><span class="n">slock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fimc_ctx_state_set</span><span class="p">(</span><span class="n">u32</span> <span class="n">state</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fimc_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fimc_dev</span><span class="o">-&gt;</span><span class="n">slock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fimc_dev</span><span class="o">-&gt;</span><span class="n">slock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">fimc_ctx_state_is_set</span><span class="p">(</span><span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fimc_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fimc_dev</span><span class="o">-&gt;</span><span class="n">slock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fimc_dev</span><span class="o">-&gt;</span><span class="n">slock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tiled_fmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_fmt</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fourcc</span> <span class="o">==</span> <span class="n">V4L2_PIX_FMT_NV12MT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return the alpha component bit mask */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fimc_get_alpha_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_fmt</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">color</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FIMC_FMT_RGB444</span>:	<span class="k">return</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FIMC_FMT_RGB555</span>:	<span class="k">return</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FIMC_FMT_RGB888</span>:	<span class="k">return</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="nl">default:</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fimc_frame</span> <span class="o">*</span><span class="nf">ctx_get_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
					       <span class="k">enum</span> <span class="n">v4l2_buf_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fimc_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fimc_ctx_state_is_set</span><span class="p">(</span><span class="n">FIMC_CTX_M2M</span><span class="p">,</span> <span class="n">ctx</span><span class="p">))</span>
			<span class="n">frame</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">s_frame</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">frame</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">d_frame</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">v4l2_err</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fimc_dev</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">,</span>
			<span class="s">&quot;Wrong buffer/video queue type (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">frame</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* -----------------------------------------------------*/</span>
<span class="cm">/* fimc-core.c */</span>
<span class="kt">int</span> <span class="n">fimc_vidioc_enum_fmt_mplane</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">v4l2_fmtdesc</span> <span class="o">*</span><span class="n">f</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fimc_ctrls_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fimc_ctrls_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fimc_ctrls_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">bool</span> <span class="n">active</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fimc_alpha_ctrl_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fimc_fill_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">f</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fimc_adjust_mplane_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_fmt</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="n">u32</span> <span class="n">width</span><span class="p">,</span> <span class="n">u32</span> <span class="n">height</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">v4l2_pix_format_mplane</span> <span class="o">*</span><span class="n">pix</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">fimc_fmt</span> <span class="o">*</span><span class="n">fimc_find_format</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pixelformat</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">mbus_code</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">fimc_fmt</span> <span class="o">*</span><span class="n">fimc_get_format</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">fimc_check_scaler_ratio</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sh</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">dw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rotation</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fimc_set_scaler_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fimc_prepare_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fimc_prepare_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">fimc_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fimc_addr</span> <span class="o">*</span><span class="n">paddr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fimc_prepare_dma_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fimc_frame</span> <span class="o">*</span><span class="n">f</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fimc_set_yuv_order</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fimc_fill_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">f</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fimc_capture_irq_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_dev</span> <span class="o">*</span><span class="n">fimc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">deq_buf</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">fimc_register_m2m_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_dev</span> <span class="o">*</span><span class="n">fimc</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fimc_unregister_m2m_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_dev</span> <span class="o">*</span><span class="n">fimc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fimc_register_driver</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fimc_unregister_driver</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* -----------------------------------------------------*/</span>
<span class="cm">/* fimc-m2m.c */</span>
<span class="kt">void</span> <span class="n">fimc_m2m_job_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vb_state</span><span class="p">);</span>

<span class="cm">/* -----------------------------------------------------*/</span>
<span class="cm">/* fimc-capture.c					*/</span>
<span class="kt">int</span> <span class="n">fimc_initialize_capture_subdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_dev</span> <span class="o">*</span><span class="n">fimc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fimc_unregister_capture_subdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_dev</span> <span class="o">*</span><span class="n">fimc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fimc_capture_ctrls_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_dev</span> <span class="o">*</span><span class="n">fimc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fimc_sensor_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">notification</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fimc_capture_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_dev</span> <span class="o">*</span><span class="n">fimc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fimc_capture_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_dev</span> <span class="o">*</span><span class="n">fimc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Buffer list manipulation functions. Must be called with fimc.slock held.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * fimc_active_queue_add - add buffer to the capture active buffers queue</span>
<span class="cm"> * @buf: buffer to add to the active buffers list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fimc_active_queue_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_vid_cap</span> <span class="o">*</span><span class="n">vid_cap</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">fimc_vid_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vid_cap</span><span class="o">-&gt;</span><span class="n">active_buf_q</span><span class="p">);</span>
	<span class="n">vid_cap</span><span class="o">-&gt;</span><span class="n">active_buf_cnt</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fimc_active_queue_pop - pop buffer from the capture active buffers queue</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must assure the active_buf_q list is not empty.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fimc_vid_buffer</span> <span class="o">*</span><span class="nf">fimc_active_queue_pop</span><span class="p">(</span>
				    <span class="k">struct</span> <span class="n">fimc_vid_cap</span> <span class="o">*</span><span class="n">vid_cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fimc_vid_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">vid_cap</span><span class="o">-&gt;</span><span class="n">active_buf_q</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">fimc_vid_buffer</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">vid_cap</span><span class="o">-&gt;</span><span class="n">active_buf_cnt</span><span class="o">--</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fimc_pending_queue_add - add buffer to the capture pending buffers queue</span>
<span class="cm"> * @buf: buffer to add to the pending buffers list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fimc_pending_queue_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">fimc_vid_cap</span> <span class="o">*</span><span class="n">vid_cap</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">fimc_vid_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vid_cap</span><span class="o">-&gt;</span><span class="n">pending_buf_q</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fimc_pending_queue_pop - pop buffer from the capture pending buffers queue</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must assure the pending_buf_q list is not empty.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fimc_vid_buffer</span> <span class="o">*</span><span class="nf">fimc_pending_queue_pop</span><span class="p">(</span>
				     <span class="k">struct</span> <span class="n">fimc_vid_cap</span> <span class="o">*</span><span class="n">vid_cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fimc_vid_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">vid_cap</span><span class="o">-&gt;</span><span class="n">pending_buf_q</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">fimc_vid_buffer</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* FIMC_CORE_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
