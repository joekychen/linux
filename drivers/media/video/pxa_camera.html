<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › pxa_camera.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pxa_camera.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * V4L2 Driver for PXA camera host</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006, Sascha Hauer, Pengutronix</span>
<span class="cm"> * Copyright (C) 2008, Guennadi Liakhovetski &lt;kernel@pengutronix.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;media/v4l2-common.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-dev.h&gt;</span>
<span class="cp">#include &lt;media/videobuf-dma-sg.h&gt;</span>
<span class="cp">#include &lt;media/soc_camera.h&gt;</span>
<span class="cp">#include &lt;media/soc_mediabus.h&gt;</span>

<span class="cp">#include &lt;linux/videodev2.h&gt;</span>

<span class="cp">#include &lt;mach/dma.h&gt;</span>
<span class="cp">#include &lt;mach/camera.h&gt;</span>

<span class="cp">#define PXA_CAM_VERSION &quot;0.0.6&quot;</span>
<span class="cp">#define PXA_CAM_DRV_NAME &quot;pxa27x-camera&quot;</span>

<span class="cm">/* Camera Interface */</span>
<span class="cp">#define CICR0		0x0000</span>
<span class="cp">#define CICR1		0x0004</span>
<span class="cp">#define CICR2		0x0008</span>
<span class="cp">#define CICR3		0x000C</span>
<span class="cp">#define CICR4		0x0010</span>
<span class="cp">#define CISR		0x0014</span>
<span class="cp">#define CIFR		0x0018</span>
<span class="cp">#define CITOR		0x001C</span>
<span class="cp">#define CIBR0		0x0028</span>
<span class="cp">#define CIBR1		0x0030</span>
<span class="cp">#define CIBR2		0x0038</span>

<span class="cp">#define CICR0_DMAEN	(1 &lt;&lt; 31)	</span><span class="cm">/* DMA request enable */</span><span class="cp"></span>
<span class="cp">#define CICR0_PAR_EN	(1 &lt;&lt; 30)	</span><span class="cm">/* Parity enable */</span><span class="cp"></span>
<span class="cp">#define CICR0_SL_CAP_EN	(1 &lt;&lt; 29)	</span><span class="cm">/* Capture enable for slave mode */</span><span class="cp"></span>
<span class="cp">#define CICR0_ENB	(1 &lt;&lt; 28)	</span><span class="cm">/* Camera interface enable */</span><span class="cp"></span>
<span class="cp">#define CICR0_DIS	(1 &lt;&lt; 27)	</span><span class="cm">/* Camera interface disable */</span><span class="cp"></span>
<span class="cp">#define CICR0_SIM	(0x7 &lt;&lt; 24)	</span><span class="cm">/* Sensor interface mode mask */</span><span class="cp"></span>
<span class="cp">#define CICR0_TOM	(1 &lt;&lt; 9)	</span><span class="cm">/* Time-out mask */</span><span class="cp"></span>
<span class="cp">#define CICR0_RDAVM	(1 &lt;&lt; 8)	</span><span class="cm">/* Receive-data-available mask */</span><span class="cp"></span>
<span class="cp">#define CICR0_FEM	(1 &lt;&lt; 7)	</span><span class="cm">/* FIFO-empty mask */</span><span class="cp"></span>
<span class="cp">#define CICR0_EOLM	(1 &lt;&lt; 6)	</span><span class="cm">/* End-of-line mask */</span><span class="cp"></span>
<span class="cp">#define CICR0_PERRM	(1 &lt;&lt; 5)	</span><span class="cm">/* Parity-error mask */</span><span class="cp"></span>
<span class="cp">#define CICR0_QDM	(1 &lt;&lt; 4)	</span><span class="cm">/* Quick-disable mask */</span><span class="cp"></span>
<span class="cp">#define CICR0_CDM	(1 &lt;&lt; 3)	</span><span class="cm">/* Disable-done mask */</span><span class="cp"></span>
<span class="cp">#define CICR0_SOFM	(1 &lt;&lt; 2)	</span><span class="cm">/* Start-of-frame mask */</span><span class="cp"></span>
<span class="cp">#define CICR0_EOFM	(1 &lt;&lt; 1)	</span><span class="cm">/* End-of-frame mask */</span><span class="cp"></span>
<span class="cp">#define CICR0_FOM	(1 &lt;&lt; 0)	</span><span class="cm">/* FIFO-overrun mask */</span><span class="cp"></span>

<span class="cp">#define CICR1_TBIT	(1 &lt;&lt; 31)	</span><span class="cm">/* Transparency bit */</span><span class="cp"></span>
<span class="cp">#define CICR1_RGBT_CONV	(0x3 &lt;&lt; 29)	</span><span class="cm">/* RGBT conversion mask */</span><span class="cp"></span>
<span class="cp">#define CICR1_PPL	(0x7ff &lt;&lt; 15)	</span><span class="cm">/* Pixels per line mask */</span><span class="cp"></span>
<span class="cp">#define CICR1_RGB_CONV	(0x7 &lt;&lt; 12)	</span><span class="cm">/* RGB conversion mask */</span><span class="cp"></span>
<span class="cp">#define CICR1_RGB_F	(1 &lt;&lt; 11)	</span><span class="cm">/* RGB format */</span><span class="cp"></span>
<span class="cp">#define CICR1_YCBCR_F	(1 &lt;&lt; 10)	</span><span class="cm">/* YCbCr format */</span><span class="cp"></span>
<span class="cp">#define CICR1_RGB_BPP	(0x7 &lt;&lt; 7)	</span><span class="cm">/* RGB bis per pixel mask */</span><span class="cp"></span>
<span class="cp">#define CICR1_RAW_BPP	(0x3 &lt;&lt; 5)	</span><span class="cm">/* Raw bis per pixel mask */</span><span class="cp"></span>
<span class="cp">#define CICR1_COLOR_SP	(0x3 &lt;&lt; 3)	</span><span class="cm">/* Color space mask */</span><span class="cp"></span>
<span class="cp">#define CICR1_DW	(0x7 &lt;&lt; 0)	</span><span class="cm">/* Data width mask */</span><span class="cp"></span>

<span class="cp">#define CICR2_BLW	(0xff &lt;&lt; 24)	</span><span class="cm">/* Beginning-of-line pixel clock</span>
<span class="cm">					   wait count mask */</span><span class="cp"></span>
<span class="cp">#define CICR2_ELW	(0xff &lt;&lt; 16)	</span><span class="cm">/* End-of-line pixel clock</span>
<span class="cm">					   wait count mask */</span><span class="cp"></span>
<span class="cp">#define CICR2_HSW	(0x3f &lt;&lt; 10)	</span><span class="cm">/* Horizontal sync pulse width mask */</span><span class="cp"></span>
<span class="cp">#define CICR2_BFPW	(0x3f &lt;&lt; 3)	</span><span class="cm">/* Beginning-of-frame pixel clock</span>
<span class="cm">					   wait count mask */</span><span class="cp"></span>
<span class="cp">#define CICR2_FSW	(0x7 &lt;&lt; 0)	</span><span class="cm">/* Frame stabilization</span>
<span class="cm">					   wait count mask */</span><span class="cp"></span>

<span class="cp">#define CICR3_BFW	(0xff &lt;&lt; 24)	</span><span class="cm">/* Beginning-of-frame line clock</span>
<span class="cm">					   wait count mask */</span><span class="cp"></span>
<span class="cp">#define CICR3_EFW	(0xff &lt;&lt; 16)	</span><span class="cm">/* End-of-frame line clock</span>
<span class="cm">					   wait count mask */</span><span class="cp"></span>
<span class="cp">#define CICR3_VSW	(0x3f &lt;&lt; 10)	</span><span class="cm">/* Vertical sync pulse width mask */</span><span class="cp"></span>
<span class="cp">#define CICR3_BFPW	(0x3f &lt;&lt; 3)	</span><span class="cm">/* Beginning-of-frame pixel clock</span>
<span class="cm">					   wait count mask */</span><span class="cp"></span>
<span class="cp">#define CICR3_LPF	(0x7ff &lt;&lt; 0)	</span><span class="cm">/* Lines per frame mask */</span><span class="cp"></span>

<span class="cp">#define CICR4_MCLK_DLY	(0x3 &lt;&lt; 24)	</span><span class="cm">/* MCLK Data Capture Delay mask */</span><span class="cp"></span>
<span class="cp">#define CICR4_PCLK_EN	(1 &lt;&lt; 23)	</span><span class="cm">/* Pixel clock enable */</span><span class="cp"></span>
<span class="cp">#define CICR4_PCP	(1 &lt;&lt; 22)	</span><span class="cm">/* Pixel clock polarity */</span><span class="cp"></span>
<span class="cp">#define CICR4_HSP	(1 &lt;&lt; 21)	</span><span class="cm">/* Horizontal sync polarity */</span><span class="cp"></span>
<span class="cp">#define CICR4_VSP	(1 &lt;&lt; 20)	</span><span class="cm">/* Vertical sync polarity */</span><span class="cp"></span>
<span class="cp">#define CICR4_MCLK_EN	(1 &lt;&lt; 19)	</span><span class="cm">/* MCLK enable */</span><span class="cp"></span>
<span class="cp">#define CICR4_FR_RATE	(0x7 &lt;&lt; 8)	</span><span class="cm">/* Frame rate mask */</span><span class="cp"></span>
<span class="cp">#define CICR4_DIV	(0xff &lt;&lt; 0)	</span><span class="cm">/* Clock divisor mask */</span><span class="cp"></span>

<span class="cp">#define CISR_FTO	(1 &lt;&lt; 15)	</span><span class="cm">/* FIFO time-out */</span><span class="cp"></span>
<span class="cp">#define CISR_RDAV_2	(1 &lt;&lt; 14)	</span><span class="cm">/* Channel 2 receive data available */</span><span class="cp"></span>
<span class="cp">#define CISR_RDAV_1	(1 &lt;&lt; 13)	</span><span class="cm">/* Channel 1 receive data available */</span><span class="cp"></span>
<span class="cp">#define CISR_RDAV_0	(1 &lt;&lt; 12)	</span><span class="cm">/* Channel 0 receive data available */</span><span class="cp"></span>
<span class="cp">#define CISR_FEMPTY_2	(1 &lt;&lt; 11)	</span><span class="cm">/* Channel 2 FIFO empty */</span><span class="cp"></span>
<span class="cp">#define CISR_FEMPTY_1	(1 &lt;&lt; 10)	</span><span class="cm">/* Channel 1 FIFO empty */</span><span class="cp"></span>
<span class="cp">#define CISR_FEMPTY_0	(1 &lt;&lt; 9)	</span><span class="cm">/* Channel 0 FIFO empty */</span><span class="cp"></span>
<span class="cp">#define CISR_EOL	(1 &lt;&lt; 8)	</span><span class="cm">/* End of line */</span><span class="cp"></span>
<span class="cp">#define CISR_PAR_ERR	(1 &lt;&lt; 7)	</span><span class="cm">/* Parity error */</span><span class="cp"></span>
<span class="cp">#define CISR_CQD	(1 &lt;&lt; 6)	</span><span class="cm">/* Camera interface quick disable */</span><span class="cp"></span>
<span class="cp">#define CISR_CDD	(1 &lt;&lt; 5)	</span><span class="cm">/* Camera interface disable done */</span><span class="cp"></span>
<span class="cp">#define CISR_SOF	(1 &lt;&lt; 4)	</span><span class="cm">/* Start of frame */</span><span class="cp"></span>
<span class="cp">#define CISR_EOF	(1 &lt;&lt; 3)	</span><span class="cm">/* End of frame */</span><span class="cp"></span>
<span class="cp">#define CISR_IFO_2	(1 &lt;&lt; 2)	</span><span class="cm">/* FIFO overrun for Channel 2 */</span><span class="cp"></span>
<span class="cp">#define CISR_IFO_1	(1 &lt;&lt; 1)	</span><span class="cm">/* FIFO overrun for Channel 1 */</span><span class="cp"></span>
<span class="cp">#define CISR_IFO_0	(1 &lt;&lt; 0)	</span><span class="cm">/* FIFO overrun for Channel 0 */</span><span class="cp"></span>

<span class="cp">#define CIFR_FLVL2	(0x7f &lt;&lt; 23)	</span><span class="cm">/* FIFO 2 level mask */</span><span class="cp"></span>
<span class="cp">#define CIFR_FLVL1	(0x7f &lt;&lt; 16)	</span><span class="cm">/* FIFO 1 level mask */</span><span class="cp"></span>
<span class="cp">#define CIFR_FLVL0	(0xff &lt;&lt; 8)	</span><span class="cm">/* FIFO 0 level mask */</span><span class="cp"></span>
<span class="cp">#define CIFR_THL_0	(0x3 &lt;&lt; 4)	</span><span class="cm">/* Threshold Level for Channel 0 FIFO */</span><span class="cp"></span>
<span class="cp">#define CIFR_RESET_F	(1 &lt;&lt; 3)	</span><span class="cm">/* Reset input FIFOs */</span><span class="cp"></span>
<span class="cp">#define CIFR_FEN2	(1 &lt;&lt; 2)	</span><span class="cm">/* FIFO enable for channel 2 */</span><span class="cp"></span>
<span class="cp">#define CIFR_FEN1	(1 &lt;&lt; 1)	</span><span class="cm">/* FIFO enable for channel 1 */</span><span class="cp"></span>
<span class="cp">#define CIFR_FEN0	(1 &lt;&lt; 0)	</span><span class="cm">/* FIFO enable for channel 0 */</span><span class="cp"></span>

<span class="cp">#define CICR0_SIM_MP	(0 &lt;&lt; 24)</span>
<span class="cp">#define CICR0_SIM_SP	(1 &lt;&lt; 24)</span>
<span class="cp">#define CICR0_SIM_MS	(2 &lt;&lt; 24)</span>
<span class="cp">#define CICR0_SIM_EP	(3 &lt;&lt; 24)</span>
<span class="cp">#define CICR0_SIM_ES	(4 &lt;&lt; 24)</span>

<span class="cp">#define CICR1_DW_VAL(x)   ((x) &amp; CICR1_DW)	    </span><span class="cm">/* Data bus width */</span><span class="cp"></span>
<span class="cp">#define CICR1_PPL_VAL(x)  (((x) &lt;&lt; 15) &amp; CICR1_PPL) </span><span class="cm">/* Pixels per line */</span><span class="cp"></span>
<span class="cp">#define CICR1_COLOR_SP_VAL(x)	(((x) &lt;&lt; 3) &amp; CICR1_COLOR_SP)	</span><span class="cm">/* color space */</span><span class="cp"></span>
<span class="cp">#define CICR1_RGB_BPP_VAL(x)	(((x) &lt;&lt; 7) &amp; CICR1_RGB_BPP)	</span><span class="cm">/* bpp for rgb */</span><span class="cp"></span>
<span class="cp">#define CICR1_RGBT_CONV_VAL(x)	(((x) &lt;&lt; 29) &amp; CICR1_RGBT_CONV)	</span><span class="cm">/* rgbt conv */</span><span class="cp"></span>

<span class="cp">#define CICR2_BLW_VAL(x)  (((x) &lt;&lt; 24) &amp; CICR2_BLW) </span><span class="cm">/* Beginning-of-line pixel clock wait count */</span><span class="cp"></span>
<span class="cp">#define CICR2_ELW_VAL(x)  (((x) &lt;&lt; 16) &amp; CICR2_ELW) </span><span class="cm">/* End-of-line pixel clock wait count */</span><span class="cp"></span>
<span class="cp">#define CICR2_HSW_VAL(x)  (((x) &lt;&lt; 10) &amp; CICR2_HSW) </span><span class="cm">/* Horizontal sync pulse width */</span><span class="cp"></span>
<span class="cp">#define CICR2_BFPW_VAL(x) (((x) &lt;&lt; 3) &amp; CICR2_BFPW) </span><span class="cm">/* Beginning-of-frame pixel clock wait count */</span><span class="cp"></span>
<span class="cp">#define CICR2_FSW_VAL(x)  (((x) &lt;&lt; 0) &amp; CICR2_FSW)  </span><span class="cm">/* Frame stabilization wait count */</span><span class="cp"></span>

<span class="cp">#define CICR3_BFW_VAL(x)  (((x) &lt;&lt; 24) &amp; CICR3_BFW) </span><span class="cm">/* Beginning-of-frame line clock wait count  */</span><span class="cp"></span>
<span class="cp">#define CICR3_EFW_VAL(x)  (((x) &lt;&lt; 16) &amp; CICR3_EFW) </span><span class="cm">/* End-of-frame line clock wait count */</span><span class="cp"></span>
<span class="cp">#define CICR3_VSW_VAL(x)  (((x) &lt;&lt; 11) &amp; CICR3_VSW) </span><span class="cm">/* Vertical sync pulse width */</span><span class="cp"></span>
<span class="cp">#define CICR3_LPF_VAL(x)  (((x) &lt;&lt; 0) &amp; CICR3_LPF)  </span><span class="cm">/* Lines per frame */</span><span class="cp"></span>

<span class="cp">#define CICR0_IRQ_MASK (CICR0_TOM | CICR0_RDAVM | CICR0_FEM | CICR0_EOLM | \</span>
<span class="cp">			CICR0_PERRM | CICR0_QDM | CICR0_CDM | CICR0_SOFM | \</span>
<span class="cp">			CICR0_EOFM | CICR0_FOM)</span>

<span class="cm">/*</span>
<span class="cm"> * Structures</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">pxa_camera_active_dma</span> <span class="p">{</span>
	<span class="n">DMA_Y</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">DMA_U</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
	<span class="n">DMA_V</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* descriptor needed for the PXA DMA engine */</span>
<span class="k">struct</span> <span class="n">pxa_cam_dma</span> <span class="p">{</span>
	<span class="n">dma_addr_t</span>		<span class="n">sg_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_dma_desc</span>	<span class="o">*</span><span class="n">sg_cpu</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">sg_size</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sglen</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* buffer for one video frame */</span>
<span class="k">struct</span> <span class="n">pxa_buffer</span> <span class="p">{</span>
	<span class="cm">/* common v4l buffer stuff -- must be first */</span>
	<span class="k">struct</span> <span class="n">videobuf_buffer</span>		<span class="n">vb</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">v4l2_mbus_pixelcode</span>	<span class="n">code</span><span class="p">;</span>
	<span class="cm">/* our descriptor lists for Y, U and V channels */</span>
	<span class="k">struct</span> <span class="n">pxa_cam_dma</span>		<span class="n">dmas</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">int</span>				<span class="n">inwork</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">pxa_camera_active_dma</span>	<span class="n">active_dma</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span>	<span class="n">soc_host</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * PXA27x is only supposed to handle one camera on its Quick Capture</span>
<span class="cm">	 * interface. If anyone ever builds hardware to enable more than</span>
<span class="cm">	 * one camera, they will have to modify this driver too</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span>		<span class="o">*</span><span class="n">clk</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">irq</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">base</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">channels</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">dma_chans</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">pxacamera_platform_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span>		<span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">platform_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ciclk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">mclk</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">mclk_divisor</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">width_flags</span><span class="p">;</span>	<span class="cm">/* max 10 bits */</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">capture</span><span class="p">;</span>

	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">pxa_buffer</span>	<span class="o">*</span><span class="n">active</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_dma_desc</span>	<span class="o">*</span><span class="n">sg_tail</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="n">u32</span>			<span class="n">save_cicr</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pxa_cam</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pxa_cam_driver_description</span> <span class="o">=</span> <span class="s">&quot;PXA_Camera&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vid_limit</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>	<span class="cm">/* Video memory limit, in Mb */</span>

<span class="cm">/*</span>
<span class="cm"> *  Videobuf operations</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_videobuf_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="s">&quot;count=%d, size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="o">*</span><span class="n">size</span><span class="p">);</span>

	<span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">sizeimage</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
		<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">size</span> <span class="o">*</span> <span class="o">*</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">vid_limit</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
		<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">vid_limit</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">/</span> <span class="o">*</span><span class="n">size</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">videobuf_dmabuf</span> <span class="o">*</span><span class="n">dma</span> <span class="o">=</span> <span class="n">videobuf_to_dma</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">());</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="s">&quot;%s (vb=0x%p) 0x%08lx %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">baddr</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">bsize</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This waits until this buffer is out of danger, i.e., until it is no</span>
<span class="cm">	 * longer in STATE_QUEUED or STATE_ACTIVE</span>
<span class="cm">	 */</span>
	<span class="n">videobuf_waiton</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">videobuf_dma_unmap</span><span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma</span><span class="p">);</span>
	<span class="n">videobuf_dma_free</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sg_cpu</span><span class="p">)</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">ici</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span>
					  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sg_size</span><span class="p">,</span>
					  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sg_cpu</span><span class="p">,</span>
					  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sg_dma</span><span class="p">);</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sg_cpu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_NEEDS_INIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">calculate_dma_sglen</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sglen</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">sg_first_ofs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dma_len</span><span class="p">,</span> <span class="n">xfer_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">sg_first_ofs</span><span class="p">;</span>
	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sglist</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">sglen</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>

		<span class="cm">/* PXA27x Developer&#39;s Manual 27.4.4.1: round up to 8 bytes */</span>
		<span class="n">xfer_len</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">dma_len</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="n">xfer_len</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_init_dma_channel - init dma descriptors</span>
<span class="cm"> * @pcdev: pxa camera device</span>
<span class="cm"> * @buf: pxa buffer to find pxa dma channel</span>
<span class="cm"> * @dma: dma video buffer</span>
<span class="cm"> * @channel: dma channel (0 =&gt; &#39;Y&#39;, 1 =&gt; &#39;U&#39;, 2 =&gt; &#39;V&#39;)</span>
<span class="cm"> * @cibr: camera Receive Buffer Register</span>
<span class="cm"> * @size: bytes to transfer</span>
<span class="cm"> * @sg_first: first element of sg_list</span>
<span class="cm"> * @sg_first_ofs: offset in first element of sg_list</span>
<span class="cm"> *</span>
<span class="cm"> * Prepares the pxa dma descriptors to transfer one camera channel.</span>
<span class="cm"> * Beware sg_first and sg_first_ofs are both input and output parameters.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 or -ENOMEM if no coherent memory is available</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_init_dma_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pxa_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">videobuf_dmabuf</span> <span class="o">*</span><span class="n">dma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">cibr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">**</span><span class="n">sg_first</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">sg_first_ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_cam_dma</span> <span class="o">*</span><span class="n">pxa_dma</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="n">channel</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">v4l2_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">sglen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dma_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xfer_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_cpu</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_size</span><span class="p">,</span>
				  <span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_cpu</span><span class="p">,</span> <span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_dma</span><span class="p">);</span>

	<span class="n">sglen</span> <span class="o">=</span> <span class="n">calculate_dma_sglen</span><span class="p">(</span><span class="o">*</span><span class="n">sg_first</span><span class="p">,</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span>
				    <span class="o">*</span><span class="n">sg_first_ofs</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">sglen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_dma_desc</span><span class="p">);</span>
	<span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_cpu</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_size</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_cpu</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">=</span> <span class="n">sglen</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">sg_first_ofs</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DMA: sg_first=%p, sglen=%d, ofs=%d, dma.desc=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="o">*</span><span class="n">sg_first</span><span class="p">,</span> <span class="n">sglen</span><span class="p">,</span> <span class="o">*</span><span class="n">sg_first_ofs</span><span class="p">,</span> <span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_dma</span><span class="p">);</span>


	<span class="n">for_each_sg</span><span class="p">(</span><span class="o">*</span><span class="n">sg_first</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">sglen</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>

		<span class="cm">/* PXA27x Developer&#39;s Manual 27.4.4.1: round up to 8 bytes */</span>
		<span class="n">xfer_len</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">dma_len</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="n">xfer_len</span><span class="p">);</span>

		<span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_cpu</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dsadr</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">cibr</span><span class="p">;</span>
		<span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_cpu</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dtadr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_cpu</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dcmd</span> <span class="o">=</span>
			<span class="n">DCMD_FLOWSRC</span> <span class="o">|</span> <span class="n">DCMD_BURST8</span> <span class="o">|</span> <span class="n">DCMD_INCTRGADDR</span> <span class="o">|</span> <span class="n">xfer_len</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>
			<span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_cpu</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dcmd</span> <span class="o">|=</span> <span class="n">DCMD_STARTIRQEN</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_cpu</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ddadr</span> <span class="o">=</span>
			<span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_dma</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_dma_desc</span><span class="p">);</span>

		<span class="n">dev_vdbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DMA: desc.%08x-&gt;@phys=0x%08x, len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_dma</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_dma_desc</span><span class="p">),</span>
			 <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">xfer_len</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_cpu</span><span class="p">[</span><span class="n">sglen</span><span class="p">].</span><span class="n">ddadr</span> <span class="o">=</span> <span class="n">DDADR_STOP</span><span class="p">;</span>
	<span class="n">pxa_dma</span><span class="o">-&gt;</span><span class="n">sg_cpu</span><span class="p">[</span><span class="n">sglen</span><span class="p">].</span><span class="n">dcmd</span>  <span class="o">=</span> <span class="n">DCMD_FLOWSRC</span> <span class="o">|</span> <span class="n">DCMD_BURST8</span> <span class="o">|</span> <span class="n">DCMD_ENDIRQEN</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Handle 1 special case :</span>
<span class="cm">	 *  - in 3 planes (YUV422P format), we might finish with xfer_len equal</span>
<span class="cm">	 *    to dma_len (end on PAGE boundary). In this case, the sg element</span>
<span class="cm">	 *    for next plane should be the next after the last used to store the</span>
<span class="cm">	 *    last scatter gather RAM page</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer_len</span> <span class="o">&gt;=</span> <span class="n">dma_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">sg_first_ofs</span> <span class="o">=</span> <span class="n">xfer_len</span> <span class="o">-</span> <span class="n">dma_len</span><span class="p">;</span>
		<span class="o">*</span><span class="n">sg_first</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">sg_first_ofs</span> <span class="o">=</span> <span class="n">xfer_len</span><span class="p">;</span>
		<span class="o">*</span><span class="n">sg_first</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_videobuf_set_actdma</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">pxa_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">active_dma</span> <span class="o">=</span> <span class="n">DMA_Y</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">active_dma</span> <span class="o">|=</span> <span class="n">DMA_U</span> <span class="o">|</span> <span class="n">DMA_V</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Please check the DMA prepared buffer structure in :</span>
<span class="cm"> *   Documentation/video4linux/pxa_camera.txt</span>
<span class="cm"> * Please check also in pxa_camera_check_link_miss() to understand why DMA chain</span>
<span class="cm"> * modification while DMA chain is running will work anyway.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_videobuf_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span> <span class="k">enum</span> <span class="n">v4l2_field</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">v4l2_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa_buffer</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size_y</span><span class="p">,</span> <span class="n">size_u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size_v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (vb=0x%p) 0x%08lx %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">vb</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">baddr</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">);</span>

	<span class="cm">/* Added list head initialization on alloc */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">));</span>

<span class="cp">#ifdef DEBUG</span>
	<span class="cm">/*</span>
<span class="cm">	 * This can be useful if you want to see if we actually fill</span>
<span class="cm">	 * the buffer with something</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">baddr</span><span class="p">,</span> <span class="mh">0xaa</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">current_fmt</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * I think, in buf_prepare you only have to protect global data,</span>
<span class="cm">	 * the actual buffer is yours</span>
<span class="cm">	 */</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">inwork</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">code</span>	<span class="o">!=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">current_fmt</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">||</span>
	    <span class="n">vb</span><span class="o">-&gt;</span><span class="n">width</span>	<span class="o">!=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">user_width</span> <span class="o">||</span>
	    <span class="n">vb</span><span class="o">-&gt;</span><span class="n">height</span>	<span class="o">!=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">user_height</span> <span class="o">||</span>
	    <span class="n">vb</span><span class="o">-&gt;</span><span class="n">field</span>	<span class="o">!=</span> <span class="n">field</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">code</span>	<span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">current_fmt</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">width</span>	<span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">user_width</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">height</span>	<span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">user_height</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">field</span>	<span class="o">=</span> <span class="n">field</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span>	<span class="o">=</span> <span class="n">VIDEOBUF_NEEDS_INIT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">sizeimage</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">baddr</span> <span class="o">&amp;&amp;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">bsize</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">VIDEOBUF_NEEDS_INIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">next_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">videobuf_dmabuf</span> <span class="o">*</span><span class="n">dma</span> <span class="o">=</span> <span class="n">videobuf_to_dma</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">videobuf_iolock</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">size_y</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">size_u</span> <span class="o">=</span> <span class="n">size_v</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">size_y</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sg</span> <span class="o">=</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">;</span>

		<span class="cm">/* init DMA for Y channel */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pxa_init_dma_channel</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">dma</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CIBR0</span><span class="p">,</span> <span class="n">size_y</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next_ofs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DMA initialization for Y/RGB failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* init DMA for U channel */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size_u</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">pxa_init_dma_channel</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">dma</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">CIBR1</span><span class="p">,</span>
						   <span class="n">size_u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next_ofs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DMA initialization for U failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail_u</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* init DMA for V channel */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size_v</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">pxa_init_dma_channel</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">dma</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">CIBR2</span><span class="p">,</span>
						   <span class="n">size_v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next_ofs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DMA initialization for V failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail_v</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_PREPARED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">inwork</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pxa_videobuf_set_actdma</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_v:</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">sg_size</span><span class="p">,</span>
			  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">sg_cpu</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">sg_dma</span><span class="p">);</span>
<span class="nl">fail_u:</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sg_size</span><span class="p">,</span>
			  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sg_cpu</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sg_dma</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="n">free_buffer</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">inwork</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_dma_start_channels - start DMA channel for active buffer</span>
<span class="cm"> * @pcdev: pxa camera device</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize DMA channels to the beginning of the active video buffer, and</span>
<span class="cm"> * start these channels.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_dma_start_channels</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_buffer</span> <span class="o">*</span><span class="n">active</span><span class="p">;</span>

	<span class="n">active</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">v4l2_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s (channel=%d) ddadr=%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span> <span class="n">active</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sg_dma</span><span class="p">);</span>
		<span class="n">DDADR</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="n">active</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sg_dma</span><span class="p">;</span>
		<span class="n">DCSR</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="n">DCSR_RUN</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_dma_stop_channels</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">v4l2_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s (channel=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">DCSR</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_dma_add_tail_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">pxa_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_dma_desc</span> <span class="o">*</span><span class="n">buf_last_desc</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf_last_desc</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sg_cpu</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sglen</span><span class="p">;</span>
		<span class="n">buf_last_desc</span><span class="o">-&gt;</span><span class="n">ddadr</span> <span class="o">=</span> <span class="n">DDADR_STOP</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">sg_tail</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="cm">/* Link the new buffer to the old tail */</span>
			<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">sg_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ddadr</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dmas</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sg_dma</span><span class="p">;</span>

		<span class="cm">/* Update the channel tail */</span>
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">sg_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf_last_desc</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_camera_start_capture - start video capturing</span>
<span class="cm"> * @pcdev: camera device</span>
<span class="cm"> *</span>
<span class="cm"> * Launch capturing. DMA channels should not be active yet. They should get</span>
<span class="cm"> * activated at the end of frame interrupt, to capture only whole frames, and</span>
<span class="cm"> * never begin the capture of a partial frame.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_camera_start_capture</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cicr0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">v4l2_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="cm">/* Enable End-Of-Frame Interrupt */</span>
	<span class="n">cicr0</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR0</span><span class="p">)</span> <span class="o">|</span> <span class="n">CICR0_ENB</span><span class="p">;</span>
	<span class="n">cicr0</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CICR0_EOFM</span><span class="p">;</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">cicr0</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_camera_stop_capture</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cicr0</span><span class="p">;</span>

	<span class="n">pxa_dma_stop_channels</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>

	<span class="n">cicr0</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CICR0_ENB</span><span class="p">;</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">cicr0</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR0</span><span class="p">);</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">v4l2_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Called under spinlock_irqsave(&amp;pcdev-&gt;lock, ...) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_videobuf_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa_buffer</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="s">&quot;%s (vb=0x%p) 0x%08lx %d active=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">baddr</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">);</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">capture</span><span class="p">);</span>

	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_ACTIVE</span><span class="p">;</span>
	<span class="n">pxa_dma_add_tail_buf</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
		<span class="n">pxa_camera_start_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_videobuf_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa_buffer</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (vb=0x%p) 0x%08lx %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">vb</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">baddr</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">bsize</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VIDEOBUF_ACTIVE</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (active)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VIDEOBUF_QUEUED</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (queued)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VIDEOBUF_PREPARED</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (prepared)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (unknown)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">free_buffer</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_camera_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">pxa_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* _init is used to debug races, see comment in pxa_camera_reqbufs() */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_DONE</span><span class="p">;</span>
	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">ts</span><span class="p">);</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">v4l2_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s dequeud buffer (vb=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">capture</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pxa_camera_stop_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">sg_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">capture</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">pxa_buffer</span><span class="p">,</span> <span class="n">vb</span><span class="p">.</span><span class="n">queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pxa_camera_check_link_miss - check missed DMA linking</span>
<span class="cm"> * @pcdev: camera device</span>
<span class="cm"> *</span>
<span class="cm"> * The DMA chaining is done with DMA running. This means a tiny temporal window</span>
<span class="cm"> * remains, where a buffer is queued on the chain, while the chain is already</span>
<span class="cm"> * stopped. This means the tailed buffer would never be transferred by DMA.</span>
<span class="cm"> * This function restarts the capture for this corner case, where :</span>
<span class="cm"> *  - DADR() == DADDR_STOP</span>
<span class="cm"> *  - a videobuffer is queued on the pcdev-&gt;capture list</span>
<span class="cm"> *</span>
<span class="cm"> * Please check the &quot;DMA hot chaining timeslice issue&quot; in</span>
<span class="cm"> *   Documentation/video4linux/pxa_camera.txt</span>
<span class="cm"> *</span>
<span class="cm"> * Context: should only be called within the dma irq handler</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_camera_check_link_miss</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">is_dma_stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DDADR</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="n">DDADR_STOP</span><span class="p">)</span>
			<span class="n">is_dma_stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">v4l2_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;%s : top queued buffer=%p, dma_stopped=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">,</span> <span class="n">is_dma_stopped</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">&amp;&amp;</span> <span class="n">is_dma_stopped</span><span class="p">)</span>
		<span class="n">pxa_camera_start_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_camera_dma_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">pxa_camera_active_dma</span> <span class="n">act_dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">v4l2_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">,</span> <span class="n">camera_status</span><span class="p">,</span> <span class="n">overrun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">DCSR</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
	<span class="n">DCSR</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">camera_status</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CISR</span><span class="p">);</span>
	<span class="n">overrun</span> <span class="o">=</span> <span class="n">CISR_IFO_0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">overrun</span> <span class="o">|=</span> <span class="n">CISR_IFO_1</span> <span class="o">|</span> <span class="n">CISR_IFO_2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">DCSR_BUSERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DMA Bus Error IRQ!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DCSR_ENDINTR</span> <span class="o">|</span> <span class="n">DCSR_STARTINTR</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unknown DMA IRQ source, status: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * pcdev-&gt;active should not be NULL in DMA irq handler.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But there is one corner case : if capture was stopped due to an</span>
<span class="cm">	 * overrun of channel 1, and at that same channel 2 was completed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * When handling the overrun in DMA irq for channel 1, we&#39;ll stop the</span>
<span class="cm">	 * capture and restart it (and thus set pcdev-&gt;active to NULL). But the</span>
<span class="cm">	 * DMA irq handler will already be pending for channel 2. So on entering</span>
<span class="cm">	 * the DMA irq handler for channel 2 there will be no active buffer, yet</span>
<span class="cm">	 * that is normal.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">vb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa_buffer</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">inwork</span> <span class="o">||</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">));</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s channel=%d %s%s(vb=0x%p) dma.desc=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">DCSR_STARTINTR</span> <span class="o">?</span> <span class="s">&quot;SOF &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="n">status</span> <span class="o">&amp;</span> <span class="n">DCSR_ENDINTR</span> <span class="o">?</span> <span class="s">&quot;EOF &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">DDADR</span><span class="p">(</span><span class="n">channel</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">DCSR_ENDINTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s normal if the last frame creates an overrun, as there</span>
<span class="cm">		 * are no more DMA descriptors to fetch from QCI fifos</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">camera_status</span> <span class="o">&amp;</span> <span class="n">overrun</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">list_is_last</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">capture</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">capture</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;FIFO overrun! CISR: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">camera_status</span><span class="p">);</span>
			<span class="n">pxa_camera_stop_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
			<span class="n">pxa_camera_start_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">active_dma</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">act_dma</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">active_dma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pxa_camera_wakeup</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="n">pxa_camera_check_link_miss</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_camera_dma_irq_y</span><span class="p">(</span><span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">pxa_camera_dma_irq</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">pcdev</span><span class="p">,</span> <span class="n">DMA_Y</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_camera_dma_irq_u</span><span class="p">(</span><span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">pxa_camera_dma_irq</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">pcdev</span><span class="p">,</span> <span class="n">DMA_U</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_camera_dma_irq_v</span><span class="p">(</span><span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">pxa_camera_dma_irq</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">pcdev</span><span class="p">,</span> <span class="n">DMA_V</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">videobuf_queue_ops</span> <span class="n">pxa_videobuf_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">buf_setup</span>      <span class="o">=</span> <span class="n">pxa_videobuf_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_prepare</span>    <span class="o">=</span> <span class="n">pxa_videobuf_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_queue</span>      <span class="o">=</span> <span class="n">pxa_videobuf_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_release</span>    <span class="o">=</span> <span class="n">pxa_videobuf_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_camera_init_videobuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must pass NULL as dev pointer, then all pci_* dma operations</span>
<span class="cm">	 * transform to normal dma_* ones.</span>
<span class="cm">	 */</span>
	<span class="n">videobuf_queue_sg_init</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pxa_videobuf_ops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span>
				<span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">,</span> <span class="n">V4L2_FIELD_NONE</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_buffer</span><span class="p">),</span> <span class="n">icd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">video_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">mclk_get_divisor</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mclk</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">mclk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">div</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lcdclk</span><span class="p">;</span>

	<span class="n">lcdclk</span> <span class="o">=</span> <span class="n">clk_get_rate</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">ciclk</span> <span class="o">=</span> <span class="n">lcdclk</span><span class="p">;</span>

	<span class="cm">/* mclk &lt;= ciclk / 4 (27.4.2) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mclk</span> <span class="o">&gt;</span> <span class="n">lcdclk</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mclk</span> <span class="o">=</span> <span class="n">lcdclk</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Limiting master clock to %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mclk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* We verify mclk != 0, so if anyone breaks it, here comes their Oops */</span>
	<span class="n">div</span> <span class="o">=</span> <span class="p">(</span><span class="n">lcdclk</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mclk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mclk</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* If we&#39;re not supplying MCLK, leave it at 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_MCLK_EN</span><span class="p">)</span>
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">mclk</span> <span class="o">=</span> <span class="n">lcdclk</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">div</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;LCD clock %luHz, target freq %luHz, divisor %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">lcdclk</span><span class="p">,</span> <span class="n">mclk</span><span class="p">,</span> <span class="n">div</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">div</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">recalculate_fifo_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pclk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We want a timeout &gt; 1 pixel time, not &quot;&gt;=&quot; */</span>
	<span class="n">u32</span> <span class="n">ciclk_per_pixel</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">ciclk</span> <span class="o">/</span> <span class="n">pclk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">ciclk_per_pixel</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CITOR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_camera_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cicr4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* disable all interrupts */</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="mh">0x3ff</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_PCLK_EN</span><span class="p">)</span>
		<span class="n">cicr4</span> <span class="o">|=</span> <span class="n">CICR4_PCLK_EN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_MCLK_EN</span><span class="p">)</span>
		<span class="n">cicr4</span> <span class="o">|=</span> <span class="n">CICR4_MCLK_EN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_PCP</span><span class="p">)</span>
		<span class="n">cicr4</span> <span class="o">|=</span> <span class="n">CICR4_PCP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_HSP</span><span class="p">)</span>
		<span class="n">cicr4</span> <span class="o">|=</span> <span class="n">CICR4_HSP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_VSP</span><span class="p">)</span>
		<span class="n">cicr4</span> <span class="o">|=</span> <span class="n">CICR4_VSP</span><span class="p">;</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">mclk_divisor</span> <span class="o">|</span> <span class="n">cicr4</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR4</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_MCLK_EN</span><span class="p">)</span>
		<span class="cm">/* Initialise the timeout under the assumption pclk = mclk */</span>
		<span class="n">recalculate_fifo_timeout</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">mclk</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/* &quot;Safe default&quot; - 13MHz */</span>
		<span class="n">recalculate_fifo_timeout</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="mi">13000000</span><span class="p">);</span>

	<span class="n">clk_prepare_enable</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_camera_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clk_disable_unprepare</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">pxa_camera_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">,</span> <span class="n">cifr</span><span class="p">,</span> <span class="n">cicr0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CISR</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">v4l2_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;Camera interrupt status 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CISR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">CISR_EOF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Reset the FIFOs */</span>
		<span class="n">cifr</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CIFR</span><span class="p">)</span> <span class="o">|</span> <span class="n">CIFR_RESET_F</span><span class="p">;</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">cifr</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CIFR</span><span class="p">);</span>

		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">capture</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">pxa_buffer</span><span class="p">,</span> <span class="n">vb</span><span class="p">.</span><span class="n">queue</span><span class="p">);</span>
		<span class="n">vb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa_buffer</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
		<span class="n">pxa_videobuf_set_actdma</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

		<span class="n">pxa_dma_start_channels</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>

		<span class="n">cicr0</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR0</span><span class="p">)</span> <span class="o">|</span> <span class="n">CICR0_EOFM</span><span class="p">;</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">cicr0</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The following two functions absolutely depend on the fact, that</span>
<span class="cm"> * there can be only one camera on PXA quick capture interface</span>
<span class="cm"> * Called with .video_lock held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_camera_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">icd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">pxa_camera_activate</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">icd</span> <span class="o">=</span> <span class="n">icd</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="s">&quot;PXA Camera driver attached to camera %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">icd</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Called with .video_lock held */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_camera_remove_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">icd</span> <span class="o">!=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">icd</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="s">&quot;PXA Camera driver detached from camera %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">icd</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">);</span>

	<span class="cm">/* disable capture, disable interrupts */</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="mh">0x3ff</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR0</span><span class="p">);</span>

	<span class="cm">/* Stop DMA engine */</span>
	<span class="n">DCSR</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DCSR</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DCSR</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pxa_camera_deactivate</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">icd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">test_platform_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buswidth</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Platform specified synchronization and pixel clock polarities are</span>
<span class="cm">	 * only a recommendation and are only used during probing. The PXA270</span>
<span class="cm">	 * quick capture interface supports both.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_MASTER</span> <span class="o">?</span>
		  <span class="n">V4L2_MBUS_MASTER</span> <span class="o">:</span> <span class="n">V4L2_MBUS_SLAVE</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">V4L2_MBUS_HSYNC_ACTIVE_HIGH</span> <span class="o">|</span>
		<span class="n">V4L2_MBUS_HSYNC_ACTIVE_LOW</span> <span class="o">|</span>
		<span class="n">V4L2_MBUS_VSYNC_ACTIVE_HIGH</span> <span class="o">|</span>
		<span class="n">V4L2_MBUS_VSYNC_ACTIVE_LOW</span> <span class="o">|</span>
		<span class="n">V4L2_MBUS_DATA_ACTIVE_HIGH</span> <span class="o">|</span>
		<span class="n">V4L2_MBUS_PCLK_SAMPLE_RISING</span> <span class="o">|</span>
		<span class="n">V4L2_MBUS_PCLK_SAMPLE_FALLING</span><span class="p">;</span>

	<span class="cm">/* If requested data width is supported by the platform, use it */</span>
	<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">buswidth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">width_flags</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_camera_setup_cicr</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">pixfmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">soc_camera_to_subdev</span><span class="p">(</span><span class="n">icd</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dw</span><span class="p">,</span> <span class="n">bpp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cicr0</span><span class="p">,</span> <span class="n">cicr1</span><span class="p">,</span> <span class="n">cicr2</span><span class="p">,</span> <span class="n">cicr3</span><span class="p">,</span> <span class="n">cicr4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y_skip_top</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">sensor</span><span class="p">,</span> <span class="n">g_skip_top_lines</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y_skip_top</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">y_skip_top</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Datawidth is now guaranteed to be equal to one of the three values.</span>
<span class="cm">	 * We fix bit-per-pixel equal to data-width...</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">current_fmt</span><span class="o">-&gt;</span><span class="n">host_fmt</span><span class="o">-&gt;</span><span class="n">bits_per_sample</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">10</span>:
		<span class="n">dw</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">bpp</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">9</span>:
		<span class="n">dw</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">bpp</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/*</span>
<span class="cm">		 * Actually it can only be 8 now,</span>
<span class="cm">		 * default is just to silence compiler warnings</span>
<span class="cm">		 */</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="n">dw</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">bpp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_PCLK_EN</span><span class="p">)</span>
		<span class="n">cicr4</span> <span class="o">|=</span> <span class="n">CICR4_PCLK_EN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_MCLK_EN</span><span class="p">)</span>
		<span class="n">cicr4</span> <span class="o">|=</span> <span class="n">CICR4_MCLK_EN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">V4L2_MBUS_PCLK_SAMPLE_FALLING</span><span class="p">)</span>
		<span class="n">cicr4</span> <span class="o">|=</span> <span class="n">CICR4_PCP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">V4L2_MBUS_HSYNC_ACTIVE_LOW</span><span class="p">)</span>
		<span class="n">cicr4</span> <span class="o">|=</span> <span class="n">CICR4_HSP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">V4L2_MBUS_VSYNC_ACTIVE_LOW</span><span class="p">)</span>
		<span class="n">cicr4</span> <span class="o">|=</span> <span class="n">CICR4_VSP</span><span class="p">;</span>

	<span class="n">cicr0</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cicr0</span> <span class="o">&amp;</span> <span class="n">CICR0_ENB</span><span class="p">)</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">cicr0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CICR0_ENB</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR0</span><span class="p">);</span>

	<span class="n">cicr1</span> <span class="o">=</span> <span class="n">CICR1_PPL_VAL</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">user_width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">bpp</span> <span class="o">|</span> <span class="n">dw</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">pixfmt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">V4L2_PIX_FMT_YUV422P</span>:
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">cicr1</span> <span class="o">|=</span> <span class="n">CICR1_YCBCR_F</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Normally, pxa bus wants as input UYVY format. We allow all</span>
<span class="cm">		 * reorderings of the YUV422 format, as no processing is done,</span>
<span class="cm">		 * and the YUV stream is just passed through without any</span>
<span class="cm">		 * transformation. Note that UYVY is the only format that</span>
<span class="cm">		 * should be used if pxa framebuffer Overlay2 is used.</span>
<span class="cm">		 */</span>
	<span class="k">case</span> <span class="n">V4L2_PIX_FMT_UYVY</span>:
	<span class="k">case</span> <span class="n">V4L2_PIX_FMT_VYUY</span>:
	<span class="k">case</span> <span class="n">V4L2_PIX_FMT_YUYV</span>:
	<span class="k">case</span> <span class="n">V4L2_PIX_FMT_YVYU</span>:
		<span class="n">cicr1</span> <span class="o">|=</span> <span class="n">CICR1_COLOR_SP_VAL</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">V4L2_PIX_FMT_RGB555</span>:
		<span class="n">cicr1</span> <span class="o">|=</span> <span class="n">CICR1_RGB_BPP_VAL</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">CICR1_RGBT_CONV_VAL</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">CICR1_TBIT</span> <span class="o">|</span> <span class="n">CICR1_COLOR_SP_VAL</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">V4L2_PIX_FMT_RGB565</span>:
		<span class="n">cicr1</span> <span class="o">|=</span> <span class="n">CICR1_COLOR_SP_VAL</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">CICR1_RGB_BPP_VAL</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cicr2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cicr3</span> <span class="o">=</span> <span class="n">CICR3_LPF_VAL</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">user_height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">CICR3_BFW_VAL</span><span class="p">(</span><span class="n">min</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="mi">255</span><span class="p">,</span> <span class="n">y_skip_top</span><span class="p">));</span>
	<span class="n">cicr4</span> <span class="o">|=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">mclk_divisor</span><span class="p">;</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">cicr1</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR1</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">cicr2</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR2</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">cicr3</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR3</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">cicr4</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR4</span><span class="p">);</span>

	<span class="cm">/* CIF interrupts are not used, only DMA */</span>
	<span class="n">cicr0</span> <span class="o">=</span> <span class="p">(</span><span class="n">cicr0</span> <span class="o">&amp;</span> <span class="n">CICR0_ENB</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_MASTER</span> <span class="o">?</span>
		<span class="n">CICR0_SIM_MP</span> <span class="o">:</span> <span class="p">(</span><span class="n">CICR0_SL_CAP_EN</span> <span class="o">|</span> <span class="n">CICR0_SIM_SP</span><span class="p">));</span>
	<span class="n">cicr0</span> <span class="o">|=</span> <span class="n">CICR0_DMAEN</span> <span class="o">|</span> <span class="n">CICR0_IRQ_MASK</span><span class="p">;</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">cicr0</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_camera_set_bus_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">soc_camera_to_subdev</span><span class="p">(</span><span class="n">icd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_mbus_config</span> <span class="n">cfg</span> <span class="o">=</span> <span class="p">{.</span><span class="n">type</span> <span class="o">=</span> <span class="n">V4L2_MBUS_PARALLEL</span><span class="p">,};</span>
	<span class="n">u32</span> <span class="n">pixfmt</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">current_fmt</span><span class="o">-&gt;</span><span class="n">host_fmt</span><span class="o">-&gt;</span><span class="n">fourcc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bus_flags</span><span class="p">,</span> <span class="n">common_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_cam</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">host_priv</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">test_platform_param</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">current_fmt</span><span class="o">-&gt;</span><span class="n">host_fmt</span><span class="o">-&gt;</span><span class="n">bits_per_sample</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">bus_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">g_mbus_config</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">common_flags</span> <span class="o">=</span> <span class="n">soc_mbus_config_compatible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg</span><span class="p">,</span>
							  <span class="n">bus_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">common_flags</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span>
				 <span class="s">&quot;Flags incompatible: camera 0x%x, host 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">cfg</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span> <span class="n">bus_flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">common_flags</span> <span class="o">=</span> <span class="n">bus_flags</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Make choises, based on platform preferences */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">common_flags</span> <span class="o">&amp;</span> <span class="n">V4L2_MBUS_HSYNC_ACTIVE_HIGH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">common_flags</span> <span class="o">&amp;</span> <span class="n">V4L2_MBUS_HSYNC_ACTIVE_LOW</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_HSP</span><span class="p">)</span>
			<span class="n">common_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">V4L2_MBUS_HSYNC_ACTIVE_HIGH</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">common_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">V4L2_MBUS_HSYNC_ACTIVE_LOW</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">common_flags</span> <span class="o">&amp;</span> <span class="n">V4L2_MBUS_VSYNC_ACTIVE_HIGH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">common_flags</span> <span class="o">&amp;</span> <span class="n">V4L2_MBUS_VSYNC_ACTIVE_LOW</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_VSP</span><span class="p">)</span>
			<span class="n">common_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">V4L2_MBUS_VSYNC_ACTIVE_HIGH</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">common_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">V4L2_MBUS_VSYNC_ACTIVE_LOW</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">common_flags</span> <span class="o">&amp;</span> <span class="n">V4L2_MBUS_PCLK_SAMPLE_RISING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">common_flags</span> <span class="o">&amp;</span> <span class="n">V4L2_MBUS_PCLK_SAMPLE_FALLING</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_PCP</span><span class="p">)</span>
			<span class="n">common_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">V4L2_MBUS_PCLK_SAMPLE_RISING</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">common_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">V4L2_MBUS_PCLK_SAMPLE_FALLING</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cfg</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">common_flags</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">s_mbus_config</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="s">&quot;camera s_mbus_config(0x%lx) returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">common_flags</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">common_flags</span><span class="p">;</span>

	<span class="n">pxa_camera_setup_cicr</span><span class="p">(</span><span class="n">icd</span><span class="p">,</span> <span class="n">common_flags</span><span class="p">,</span> <span class="n">pixfmt</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_camera_try_bus_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buswidth</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">soc_camera_to_subdev</span><span class="p">(</span><span class="n">icd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_mbus_config</span> <span class="n">cfg</span> <span class="o">=</span> <span class="p">{.</span><span class="n">type</span> <span class="o">=</span> <span class="n">V4L2_MBUS_PARALLEL</span><span class="p">,};</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bus_flags</span><span class="p">,</span> <span class="n">common_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">test_platform_param</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">buswidth</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">g_mbus_config</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">common_flags</span> <span class="o">=</span> <span class="n">soc_mbus_config_compatible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg</span><span class="p">,</span>
							  <span class="n">bus_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">common_flags</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span>
				 <span class="s">&quot;Flags incompatible: camera 0x%x, host 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">cfg</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span> <span class="n">bus_flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">soc_mbus_pixelfmt</span> <span class="n">pxa_camera_formats</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">fourcc</span>			<span class="o">=</span> <span class="n">V4L2_PIX_FMT_YUV422P</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;Planar YUV422 16 bit&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bits_per_sample</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">packing</span>		<span class="o">=</span> <span class="n">SOC_MBUS_PACKING_2X8_PADHI</span><span class="p">,</span>
		<span class="p">.</span><span class="n">order</span>			<span class="o">=</span> <span class="n">SOC_MBUS_ORDER_LE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">layout</span>			<span class="o">=</span> <span class="n">SOC_MBUS_LAYOUT_PLANAR_2Y_U_V</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cm">/* This will be corrected as we get more formats */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">pxa_camera_packing_supported</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">soc_mbus_pixelfmt</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>	<span class="n">fmt</span><span class="o">-&gt;</span><span class="n">packing</span> <span class="o">==</span> <span class="n">SOC_MBUS_PACKING_NONE</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bits_per_sample</span> <span class="o">==</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span>
		 <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">packing</span> <span class="o">==</span> <span class="n">SOC_MBUS_PACKING_2X8_PADHI</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bits_per_sample</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span>
		 <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">packing</span> <span class="o">==</span> <span class="n">SOC_MBUS_PACKING_EXTEND16</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_camera_get_formats</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">soc_camera_format_xlate</span> <span class="o">*</span><span class="n">xlate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">soc_camera_to_subdev</span><span class="p">(</span><span class="n">icd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">formats</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_cam</span> <span class="o">*</span><span class="n">cam</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">v4l2_mbus_pixelcode</span> <span class="n">code</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">soc_mbus_pixelfmt</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">enum_mbus_fmt</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">code</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* No more formats */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fmt</span> <span class="o">=</span> <span class="n">soc_mbus_get_fmtdesc</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fmt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid format code #%u: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This also checks support for the requested bits-per-sample */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pxa_camera_try_bus_param</span><span class="p">(</span><span class="n">icd</span><span class="p">,</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bits_per_sample</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">host_priv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cam</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cam</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cam</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">icd</span><span class="o">-&gt;</span><span class="n">host_priv</span> <span class="o">=</span> <span class="n">cam</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cam</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">host_priv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">V4L2_MBUS_FMT_UYVY8_2X8</span>:
		<span class="n">formats</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xlate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xlate</span><span class="o">-&gt;</span><span class="n">host_fmt</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">pxa_camera_formats</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">xlate</span><span class="o">-&gt;</span><span class="n">code</span>	<span class="o">=</span> <span class="n">code</span><span class="p">;</span>
			<span class="n">xlate</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Providing format %s using code %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pxa_camera_formats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">V4L2_MBUS_FMT_VYUY8_2X8</span>:
	<span class="k">case</span> <span class="n">V4L2_MBUS_FMT_YUYV8_2X8</span>:
	<span class="k">case</span> <span class="n">V4L2_MBUS_FMT_YVYU8_2X8</span>:
	<span class="k">case</span> <span class="n">V4L2_MBUS_FMT_RGB565_2X8_LE</span>:
	<span class="k">case</span> <span class="n">V4L2_MBUS_FMT_RGB555_2X8_PADHI_LE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">xlate</span><span class="p">)</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Providing format %s packed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">fmt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pxa_camera_packing_supported</span><span class="p">(</span><span class="n">fmt</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xlate</span><span class="p">)</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Providing format %s in pass-through mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">fmt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Generic pass-through */</span>
	<span class="n">formats</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xlate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xlate</span><span class="o">-&gt;</span><span class="n">host_fmt</span>	<span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
		<span class="n">xlate</span><span class="o">-&gt;</span><span class="n">code</span>	<span class="o">=</span> <span class="n">code</span><span class="p">;</span>
		<span class="n">xlate</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">formats</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pxa_camera_put_formats</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">host_priv</span><span class="p">);</span>
	<span class="n">icd</span><span class="o">-&gt;</span><span class="n">host_priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_camera_check_frame</span><span class="p">(</span><span class="n">u32</span> <span class="n">width</span><span class="p">,</span> <span class="n">u32</span> <span class="n">height</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* limit to pxa hardware capabilities */</span>
	<span class="k">return</span> <span class="n">height</span> <span class="o">&lt;</span> <span class="mi">32</span> <span class="o">||</span> <span class="n">height</span> <span class="o">&gt;</span> <span class="mi">2048</span> <span class="o">||</span> <span class="n">width</span> <span class="o">&lt;</span> <span class="mi">48</span> <span class="o">||</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="mi">2048</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">width</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_camera_set_crop</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">v4l2_crop</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_rect</span> <span class="o">*</span><span class="n">rect</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">soc_camera_to_subdev</span><span class="p">(</span><span class="n">icd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">soc_camera_sense</span> <span class="n">sense</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">master_clock</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">mclk</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pixel_clock_max</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">ciclk</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">v4l2_mbus_framefmt</span> <span class="n">mf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_cam</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">host_priv</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fourcc</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">current_fmt</span><span class="o">-&gt;</span><span class="n">host_fmt</span><span class="o">-&gt;</span><span class="n">fourcc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* If PCLK is used to latch data from the sensor, check sense */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_PCLK_EN</span><span class="p">)</span>
		<span class="n">icd</span><span class="o">-&gt;</span><span class="n">sense</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sense</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">s_crop</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>

	<span class="n">icd</span><span class="o">-&gt;</span><span class="n">sense</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to crop to %ux%u@%u:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">rect</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">rect</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span> <span class="n">rect</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">rect</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">g_mbus_fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pxa_camera_check_frame</span><span class="p">(</span><span class="n">mf</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">mf</span><span class="p">.</span><span class="n">height</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Camera cropping produced a frame beyond our capabilities.</span>
<span class="cm">		 * FIXME: just extract a subframe, that we can process.</span>
<span class="cm">		 */</span>
		<span class="n">v4l_bound_align_image</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mf</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">mf</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">fourcc</span> <span class="o">==</span> <span class="n">V4L2_PIX_FMT_YUV422P</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">s_mbus_fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pxa_camera_check_frame</span><span class="p">(</span><span class="n">mf</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">mf</span><span class="p">.</span><span class="n">height</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span>
				 <span class="s">&quot;Inconsistent state. Use S_FMT to repair</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sense</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SOCAM_SENSE_PCLK_CHANGED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sense</span><span class="p">.</span><span class="n">pixel_clock</span> <span class="o">&gt;</span> <span class="n">sense</span><span class="p">.</span><span class="n">pixel_clock_max</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;pixel clock %lu set by the camera too high!&quot;</span><span class="p">,</span>
				<span class="n">sense</span><span class="p">.</span><span class="n">pixel_clock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">recalculate_fifo_timeout</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">sense</span><span class="p">.</span><span class="n">pixel_clock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">icd</span><span class="o">-&gt;</span><span class="n">user_width</span>		<span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
	<span class="n">icd</span><span class="o">-&gt;</span><span class="n">user_height</span>	<span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>

	<span class="n">pxa_camera_setup_cicr</span><span class="p">(</span><span class="n">icd</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">fourcc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_camera_set_fmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">soc_camera_to_subdev</span><span class="p">(</span><span class="n">icd</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">soc_camera_format_xlate</span> <span class="o">*</span><span class="n">xlate</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">soc_camera_sense</span> <span class="n">sense</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">master_clock</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">mclk</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pixel_clock_max</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">ciclk</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">v4l2_pix_format</span> <span class="o">*</span><span class="n">pix</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_mbus_framefmt</span> <span class="n">mf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">xlate</span> <span class="o">=</span> <span class="n">soc_camera_xlate_by_fourcc</span><span class="p">(</span><span class="n">icd</span><span class="p">,</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">pixelformat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xlate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Format %x not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">pixelformat</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If PCLK is used to latch data from the sensor, check sense */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_PCLK_EN</span><span class="p">)</span>
		<span class="cm">/* The caller holds a mutex. */</span>
		<span class="n">icd</span><span class="o">-&gt;</span><span class="n">sense</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sense</span><span class="p">;</span>

	<span class="n">mf</span><span class="p">.</span><span class="n">width</span>	<span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">height</span>	<span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">field</span>	<span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">;</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">colorspace</span>	<span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">colorspace</span><span class="p">;</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">code</span>		<span class="o">=</span> <span class="n">xlate</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">s_mbus_fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mf</span><span class="p">.</span><span class="n">code</span> <span class="o">!=</span> <span class="n">xlate</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">icd</span><span class="o">-&gt;</span><span class="n">sense</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to configure for format %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">pix</span><span class="o">-&gt;</span><span class="n">pixelformat</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pxa_camera_check_frame</span><span class="p">(</span><span class="n">mf</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">mf</span><span class="p">.</span><span class="n">height</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;Camera driver produced an unsupported frame %dx%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">mf</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">mf</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sense</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SOCAM_SENSE_PCLK_CHANGED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sense</span><span class="p">.</span><span class="n">pixel_clock</span> <span class="o">&gt;</span> <span class="n">sense</span><span class="p">.</span><span class="n">pixel_clock_max</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;pixel clock %lu set by the camera too high!&quot;</span><span class="p">,</span>
				<span class="n">sense</span><span class="p">.</span><span class="n">pixel_clock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">recalculate_fifo_timeout</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">sense</span><span class="p">.</span><span class="n">pixel_clock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">width</span>		<span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">height</span>		<span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">field</span>		<span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">field</span><span class="p">;</span>
	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">colorspace</span>		<span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">colorspace</span><span class="p">;</span>
	<span class="n">icd</span><span class="o">-&gt;</span><span class="n">current_fmt</span>	<span class="o">=</span> <span class="n">xlate</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_camera_try_fmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">soc_camera_to_subdev</span><span class="p">(</span><span class="n">icd</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">soc_camera_format_xlate</span> <span class="o">*</span><span class="n">xlate</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_pix_format</span> <span class="o">*</span><span class="n">pix</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_mbus_framefmt</span> <span class="n">mf</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pixfmt</span> <span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">pixelformat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">xlate</span> <span class="o">=</span> <span class="n">soc_camera_xlate_by_fourcc</span><span class="p">(</span><span class="n">icd</span><span class="p">,</span> <span class="n">pixfmt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xlate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="s">&quot;Format %x not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pixfmt</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Limit to pxa hardware capabilities.  YUV422P planar format requires</span>
<span class="cm">	 * images size to be a multiple of 16 bytes.  If not, zeros will be</span>
<span class="cm">	 * inserted between Y and U planes, and U and V planes, which violates</span>
<span class="cm">	 * the YUV422P standard.</span>
<span class="cm">	 */</span>
	<span class="n">v4l_bound_align_image</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pix</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">pix</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="n">pixfmt</span> <span class="o">==</span> <span class="n">V4L2_PIX_FMT_YUV422P</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* limit to sensor capabilities */</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">width</span>	<span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">height</span>	<span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
	<span class="cm">/* Only progressive video supported so far */</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">field</span>	<span class="o">=</span> <span class="n">V4L2_FIELD_NONE</span><span class="p">;</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">colorspace</span>	<span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">colorspace</span><span class="p">;</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">code</span>		<span class="o">=</span> <span class="n">xlate</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">try_mbus_fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">width</span>	<span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">height</span>	<span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">colorspace</span>	<span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">colorspace</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mf</span><span class="p">.</span><span class="n">field</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">V4L2_FIELD_ANY</span>:
	<span class="k">case</span> <span class="n">V4L2_FIELD_NONE</span>:
		<span class="n">pix</span><span class="o">-&gt;</span><span class="n">field</span>	<span class="o">=</span> <span class="n">V4L2_FIELD_NONE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* TODO: support interlaced at least in pass-through mode */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="s">&quot;Field type %d unsupported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mf</span><span class="p">.</span><span class="n">field</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_camera_reqbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">v4l2_requestbuffers</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is for locking debugging only. I removed spinlocks and now I</span>
<span class="cm">	 * check whether .prepare is ever called on a linked buffer, or whether</span>
<span class="cm">	 * a dma IRQ can occur for an in-work or unlinked buffer. Until now</span>
<span class="cm">	 * it hadn&#39;t triggered</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pxa_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">vb_vidq</span><span class="p">.</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						      <span class="k">struct</span> <span class="n">pxa_buffer</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">inwork</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">queue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">pxa_camera_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pxa_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">vb_vidq</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pxa_buffer</span><span class="p">,</span>
			 <span class="n">vb</span><span class="p">.</span><span class="n">stream</span><span class="p">);</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">done</span><span class="p">,</span> <span class="n">pt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">VIDEOBUF_DONE</span> <span class="o">||</span>
	    <span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">POLLIN</span><span class="o">|</span><span class="n">POLLRDNORM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_camera_querycap</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">v4l2_capability</span> <span class="o">*</span><span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* cap-&gt;name is set by the firendly caller:-&gt; */</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">pxa_cam_driver_description</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">));</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">=</span> <span class="n">V4L2_CAP_VIDEO_CAPTURE</span> <span class="o">|</span> <span class="n">V4L2_CAP_STREAMING</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_camera_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">save_cicr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR0</span><span class="p">);</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">save_cicr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR1</span><span class="p">);</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">save_cicr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR2</span><span class="p">);</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">save_cicr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR3</span><span class="p">);</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">save_cicr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR4</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">icd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">soc_camera_to_subdev</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">icd</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">s_power</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pxa_camera_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">DRCMR</span><span class="p">(</span><span class="mi">68</span><span class="p">)</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="n">DRCMR_MAPVLD</span><span class="p">;</span>
	<span class="n">DRCMR</span><span class="p">(</span><span class="mi">69</span><span class="p">)</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">DRCMR_MAPVLD</span><span class="p">;</span>
	<span class="n">DRCMR</span><span class="p">(</span><span class="mi">70</span><span class="p">)</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|</span> <span class="n">DRCMR_MAPVLD</span><span class="p">;</span>

	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">save_cicr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CICR0_ENB</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR0</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">save_cicr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR1</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">save_cicr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR2</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">save_cicr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR3</span><span class="p">);</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">save_cicr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">CICR4</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">icd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">soc_camera_to_subdev</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">icd</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">s_power</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Restart frame capture if active buffer exists */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
		<span class="n">pxa_camera_start_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">soc_camera_host_ops</span> <span class="n">pxa_soc_camera_host_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">add</span>		<span class="o">=</span> <span class="n">pxa_camera_add_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">pxa_camera_remove_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_crop</span>	<span class="o">=</span> <span class="n">pxa_camera_set_crop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_formats</span>	<span class="o">=</span> <span class="n">pxa_camera_get_formats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_formats</span>	<span class="o">=</span> <span class="n">pxa_camera_put_formats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_fmt</span>	<span class="o">=</span> <span class="n">pxa_camera_set_fmt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">try_fmt</span>	<span class="o">=</span> <span class="n">pxa_camera_try_fmt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_videobuf</span>	<span class="o">=</span> <span class="n">pxa_camera_init_videobuf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reqbufs</span>	<span class="o">=</span> <span class="n">pxa_camera_reqbufs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">pxa_camera_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">querycap</span>	<span class="o">=</span> <span class="n">pxa_camera_querycap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_bus_param</span>	<span class="o">=</span> <span class="n">pxa_camera_set_bus_param</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">pxa_camera_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span> <span class="o">||</span> <span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pcdev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pcdev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not allocate pcdev</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit_kfree</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PXA_CAMERA_DATAWIDTH_8</span> <span class="o">|</span>
			<span class="n">PXA_CAMERA_DATAWIDTH_9</span> <span class="o">|</span> <span class="n">PXA_CAMERA_DATAWIDTH_10</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Platform hasn&#39;t set available data widths. This is bad.</span>
<span class="cm">		 * Warn and use a default.</span>
<span class="cm">		 */</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;WARNING! Platform hasn&#39;t set available &quot;</span>
			 <span class="s">&quot;data widths, using default 10 bit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">|=</span> <span class="n">PXA_CAMERA_DATAWIDTH_10</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_DATAWIDTH_8</span><span class="p">)</span>
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">width_flags</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_DATAWIDTH_9</span><span class="p">)</span>
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">width_flags</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">platform_flags</span> <span class="o">&amp;</span> <span class="n">PXA_CAMERA_DATAWIDTH_10</span><span class="p">)</span>
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">width_flags</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">;</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">mclk</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mclk_10khz</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">mclk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;mclk == 0! Please, fix your platform data. &quot;</span>
			 <span class="s">&quot;Using default 20MHz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">mclk</span> <span class="o">=</span> <span class="mi">20000000</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">mclk_divisor</span> <span class="o">=</span> <span class="n">mclk_get_divisor</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pcdev</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">capture</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Request the regions.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">),</span>
				<span class="n">PXA_CAM_DRV_NAME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit_clk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit_release</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>

	<span class="cm">/* request dma */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pxa_request_dma</span><span class="p">(</span><span class="s">&quot;CI_Y&quot;</span><span class="p">,</span> <span class="n">DMA_PRIO_HIGH</span><span class="p">,</span>
			      <span class="n">pxa_camera_dma_irq_y</span><span class="p">,</span> <span class="n">pcdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t request DMA for Y</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit_iounmap</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;got DMA channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pxa_request_dma</span><span class="p">(</span><span class="s">&quot;CI_U&quot;</span><span class="p">,</span> <span class="n">DMA_PRIO_HIGH</span><span class="p">,</span>
			      <span class="n">pxa_camera_dma_irq_u</span><span class="p">,</span> <span class="n">pcdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t request DMA for U</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit_free_dma_y</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;got DMA channel (U) %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pxa_request_dma</span><span class="p">(</span><span class="s">&quot;CI_V&quot;</span><span class="p">,</span> <span class="n">DMA_PRIO_HIGH</span><span class="p">,</span>
			      <span class="n">pxa_camera_dma_irq_v</span><span class="p">,</span> <span class="n">pcdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t request DMA for V</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit_free_dma_u</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;got DMA channel (V) %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="n">DRCMR</span><span class="p">(</span><span class="mi">68</span><span class="p">)</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="n">DRCMR_MAPVLD</span><span class="p">;</span>
	<span class="n">DRCMR</span><span class="p">(</span><span class="mi">69</span><span class="p">)</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">DRCMR_MAPVLD</span><span class="p">;</span>
	<span class="n">DRCMR</span><span class="p">(</span><span class="mi">70</span><span class="p">)</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|</span> <span class="n">DRCMR_MAPVLD</span><span class="p">;</span>

	<span class="cm">/* request irq */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">pxa_camera_irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PXA_CAM_DRV_NAME</span><span class="p">,</span>
			  <span class="n">pcdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Camera interrupt register failed </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit_free_dma</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">drv_name</span>	<span class="o">=</span> <span class="n">PXA_CAM_DRV_NAME</span><span class="p">;</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">pxa_soc_camera_host_ops</span><span class="p">;</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">priv</span>		<span class="o">=</span> <span class="n">pcdev</span><span class="p">;</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">v4l2_dev</span><span class="p">.</span><span class="n">dev</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">nr</span>		<span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">soc_camera_host_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_free_irq</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">exit_free_irq:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">pcdev</span><span class="p">);</span>
<span class="nl">exit_free_dma:</span>
	<span class="n">pxa_free_dma</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="nl">exit_free_dma_u:</span>
	<span class="n">pxa_free_dma</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="nl">exit_free_dma_y:</span>
	<span class="n">pxa_free_dma</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="nl">exit_iounmap:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
<span class="nl">exit_release:</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
<span class="nl">exit_clk:</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
<span class="nl">exit_kfree:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
<span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">pxa_camera_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">soc_host</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pxa_camera_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">soc_host</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">pxa_camera_dev</span><span class="p">,</span> <span class="n">soc_host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

	<span class="n">clk_put</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">pxa_free_dma</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">pxa_free_dma</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">pxa_free_dma</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">pcdev</span><span class="p">);</span>

	<span class="n">soc_camera_host_unregister</span><span class="p">(</span><span class="n">soc_host</span><span class="p">);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">;</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PXA Camera driver unloaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">pxa_camera_pm</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">pxa_camera_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">pxa_camera_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">pxa_camera_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> 	<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="n">PXA_CAM_DRV_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pm</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">pxa_camera_pm</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">pxa_camera_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">pxa_camera_remove</span><span class="p">),</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">pxa_camera_driver</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;PXA27x SoC Camera Host driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Guennadi Liakhovetski &lt;kernel@pengutronix.de&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">PXA_CAM_VERSION</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:&quot;</span> <span class="n">PXA_CAM_DRV_NAME</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
