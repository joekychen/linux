<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › marvell-ccic › cafe-driver.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>cafe-driver.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * A driver for the CMOS camera controller in the Marvell 88ALP01 &quot;cafe&quot;</span>
<span class="cm"> * multifunction chip.  Currently works with the Omnivision OV7670</span>
<span class="cm"> * sensor.</span>
<span class="cm"> *</span>
<span class="cm"> * The data sheet for this device can be found at:</span>
<span class="cm"> *    http://www.marvell.com/products/pc_connectivity/88alp01/</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2006-11 One Laptop Per Child Association, Inc.</span>
<span class="cm"> * Copyright 2006-11 Jonathan Corbet &lt;corbet@lwn.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Jonathan Corbet, corbet@lwn.net.</span>
<span class="cm"> *</span>
<span class="cm"> * v4l2_device/v4l2_subdev conversion by:</span>
<span class="cm"> * Copyright (C) 2009 Hans Verkuil &lt;hverkuil@xs4all.nl&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file may be distributed under the terms of the GNU General</span>
<span class="cm"> * Public License, version 2.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/videodev2.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-device.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-chip-ident.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>

<span class="cp">#include &quot;mcam-core.h&quot;</span>

<span class="cp">#define CAFE_VERSION 0x000002</span>


<span class="cm">/*</span>
<span class="cm"> * Parameters.</span>
<span class="cm"> */</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Jonathan Corbet &lt;corbet@lwn.net&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Marvell 88ALP01 CMOS Camera Controller driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_SUPPORTED_DEVICE</span><span class="p">(</span><span class="s">&quot;Video&quot;</span><span class="p">);</span>




<span class="k">struct</span> <span class="n">cafe_camera</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">registered</span><span class="p">;</span>			<span class="cm">/* Fully initialized? */</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="n">mcam</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">smbus_wait</span><span class="p">;</span>	<span class="cm">/* Waiting on i2c events */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Most of the camera controller registers are defined in mcam-core.h,</span>
<span class="cm"> * but the Cafe platform has some additional registers of its own;</span>
<span class="cm"> * they are described here.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * &quot;General purpose register&quot; has a couple of GPIOs used for sensor</span>
<span class="cm"> * power and reset on OLPC XO 1.0 systems.</span>
<span class="cm"> */</span>
<span class="cp">#define REG_GPR		0xb4</span>
<span class="cp">#define	  GPR_C1EN	  0x00000020	</span><span class="cm">/* Pad 1 (power down) enable */</span><span class="cp"></span>
<span class="cp">#define	  GPR_C0EN	  0x00000010	</span><span class="cm">/* Pad 0 (reset) enable */</span><span class="cp"></span>
<span class="cp">#define	  GPR_C1	  0x00000002	</span><span class="cm">/* Control 1 value */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * Control 0 is wired to reset on OLPC machines.  For ov7x sensors,</span>
<span class="cm"> * it is active low.</span>
<span class="cm"> */</span>
<span class="cp">#define	  GPR_C0	  0x00000001	</span><span class="cm">/* Control 0 value */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * These registers control the SMBUS module for communicating</span>
<span class="cm"> * with the sensor.</span>
<span class="cm"> */</span>
<span class="cp">#define REG_TWSIC0	0xb8	</span><span class="cm">/* TWSI (smbus) control 0 */</span><span class="cp"></span>
<span class="cp">#define	  TWSIC0_EN	  0x00000001	</span><span class="cm">/* TWSI enable */</span><span class="cp"></span>
<span class="cp">#define	  TWSIC0_MODE	  0x00000002	</span><span class="cm">/* 1 = 16-bit, 0 = 8-bit */</span><span class="cp"></span>
<span class="cp">#define	  TWSIC0_SID	  0x000003fc	</span><span class="cm">/* Slave ID */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * Subtle trickery: the slave ID field starts with bit 2.  But the</span>
<span class="cm"> * Linux i2c stack wants to treat the bottommost bit as a separate</span>
<span class="cm"> * read/write bit, which is why slave ID&#39;s are usually presented</span>
<span class="cm"> * &gt;&gt;1.  For consistency with that behavior, we shift over three</span>
<span class="cm"> * bits instead of two.</span>
<span class="cm"> */</span>
<span class="cp">#define	  TWSIC0_SID_SHIFT 3</span>
<span class="cp">#define	  TWSIC0_CLKDIV	  0x0007fc00	</span><span class="cm">/* Clock divider */</span><span class="cp"></span>
<span class="cp">#define	  TWSIC0_MASKACK  0x00400000	</span><span class="cm">/* Mask ack from sensor */</span><span class="cp"></span>
<span class="cp">#define	  TWSIC0_OVMAGIC  0x00800000	</span><span class="cm">/* Make it work on OV sensors */</span><span class="cp"></span>

<span class="cp">#define REG_TWSIC1	0xbc	</span><span class="cm">/* TWSI control 1 */</span><span class="cp"></span>
<span class="cp">#define	  TWSIC1_DATA	  0x0000ffff	</span><span class="cm">/* Data to/from camchip */</span><span class="cp"></span>
<span class="cp">#define	  TWSIC1_ADDR	  0x00ff0000	</span><span class="cm">/* Address (register) */</span><span class="cp"></span>
<span class="cp">#define	  TWSIC1_ADDR_SHIFT 16</span>
<span class="cp">#define	  TWSIC1_READ	  0x01000000	</span><span class="cm">/* Set for read op */</span><span class="cp"></span>
<span class="cp">#define	  TWSIC1_WSTAT	  0x02000000	</span><span class="cm">/* Write status */</span><span class="cp"></span>
<span class="cp">#define	  TWSIC1_RVALID	  0x04000000	</span><span class="cm">/* Read data valid */</span><span class="cp"></span>
<span class="cp">#define	  TWSIC1_ERROR	  0x08000000	</span><span class="cm">/* Something screwed up */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Here&#39;s the weird global control registers</span>
<span class="cm"> */</span>
<span class="cp">#define REG_GL_CSR     0x3004  </span><span class="cm">/* Control/status register */</span><span class="cp"></span>
<span class="cp">#define	  GCSR_SRS	 0x00000001	</span><span class="cm">/* SW Reset set */</span><span class="cp"></span>
<span class="cp">#define	  GCSR_SRC	 0x00000002	</span><span class="cm">/* SW Reset clear */</span><span class="cp"></span>
<span class="cp">#define	  GCSR_MRS	 0x00000004	</span><span class="cm">/* Master reset set */</span><span class="cp"></span>
<span class="cp">#define	  GCSR_MRC	 0x00000008	</span><span class="cm">/* HW Reset clear */</span><span class="cp"></span>
<span class="cp">#define	  GCSR_CCIC_EN	 0x00004000    </span><span class="cm">/* CCIC Clock enable */</span><span class="cp"></span>
<span class="cp">#define REG_GL_IMASK   0x300c  </span><span class="cm">/* Interrupt mask register */</span><span class="cp"></span>
<span class="cp">#define	  GIMSK_CCIC_EN		 0x00000004    </span><span class="cm">/* CCIC Interrupt enable */</span><span class="cp"></span>

<span class="cp">#define REG_GL_FCR	0x3038	</span><span class="cm">/* GPIO functional control register */</span><span class="cp"></span>
<span class="cp">#define	  GFCR_GPIO_ON	  0x08		</span><span class="cm">/* Camera GPIO enabled */</span><span class="cp"></span>
<span class="cp">#define REG_GL_GPIOR	0x315c	</span><span class="cm">/* GPIO register */</span><span class="cp"></span>
<span class="cp">#define	  GGPIO_OUT		0x80000	</span><span class="cm">/* GPIO output */</span><span class="cp"></span>
<span class="cp">#define	  GGPIO_VAL		0x00008	</span><span class="cm">/* Output pin value */</span><span class="cp"></span>

<span class="cp">#define REG_LEN		       (REG_GL_IMASK + 4)</span>


<span class="cm">/*</span>
<span class="cm"> * Debugging and related.</span>
<span class="cm"> */</span>
<span class="cp">#define cam_err(cam, fmt, arg...) \</span>
<span class="cp">	dev_err(&amp;(cam)-&gt;pdev-&gt;dev, fmt, ##arg);</span>
<span class="cp">#define cam_warn(cam, fmt, arg...) \</span>
<span class="cp">	dev_warn(&amp;(cam)-&gt;pdev-&gt;dev, fmt, ##arg);</span>

<span class="cm">/* -------------------------------------------------------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * The I2C/SMBUS interface to the camera itself starts here.  The</span>
<span class="cm"> * controller handles SMBUS itself, presenting a relatively simple register</span>
<span class="cm"> * interface; all we have to do is to tell it where to route the data.</span>
<span class="cm"> */</span>
<span class="cp">#define CAFE_SMBUS_TIMEOUT (HZ)  </span><span class="cm">/* generous */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cafe_camera</span> <span class="o">*</span><span class="nf">to_cam</span><span class="p">(</span><span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mcam_camera</span><span class="p">,</span> <span class="n">v4l2_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cafe_camera</span><span class="p">,</span> <span class="n">mcam</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">cafe_smbus_write_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">mcam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must delay after the interrupt, or the controller gets confused</span>
<span class="cm">	 * and never does give us good status.  Fortunately, we don&#39;t do this</span>
<span class="cm">	 * often.</span>
<span class="cm">	 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">c1</span> <span class="o">=</span> <span class="n">mcam_reg_read</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_TWSIC1</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TWSIC1_WSTAT</span><span class="o">|</span><span class="n">TWSIC1_ERROR</span><span class="p">))</span> <span class="o">!=</span> <span class="n">TWSIC1_WSTAT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cafe_smbus_write_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">cafe_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span>
		<span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">mcam</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mcam</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">TWSIC0_EN</span> <span class="o">|</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="n">TWSIC0_SID_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TWSIC0_SID</span><span class="p">);</span>
	<span class="n">rval</span> <span class="o">|=</span> <span class="n">TWSIC0_OVMAGIC</span><span class="p">;</span>  <span class="cm">/* Make OV sensors work */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Marvell sez set clkdiv to all 1&#39;s for now.</span>
<span class="cm">	 */</span>
	<span class="n">rval</span> <span class="o">|=</span> <span class="n">TWSIC0_CLKDIV</span><span class="p">;</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_TWSIC0</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">mcam_reg_read</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_TWSIC1</span><span class="p">);</span> <span class="cm">/* force write */</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">value</span> <span class="o">|</span> <span class="p">((</span><span class="n">command</span> <span class="o">&lt;&lt;</span> <span class="n">TWSIC1_ADDR_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TWSIC1_ADDR</span><span class="p">);</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_TWSIC1</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Unfortunately, reading TWSIC1 too soon after sending a command</span>
<span class="cm">	 * causes the device to die.</span>
<span class="cm">	 * Use a busy-wait because we often send a large quantity of small</span>
<span class="cm">	 * commands at-once; using msleep() would cause a lot of context</span>
<span class="cm">	 * switches which take longer than 2ms, resulting in a noticeable</span>
<span class="cm">	 * boot-time and capture-start delays.</span>
<span class="cm">	 */</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Another sad fact is that sometimes, commands silently complete but</span>
<span class="cm">	 * cafe_smbus_write_done() never becomes aware of this.</span>
<span class="cm">	 * This happens at random and appears to possible occur with any</span>
<span class="cm">	 * command.</span>
<span class="cm">	 * We don&#39;t understand why this is. We work around this issue</span>
<span class="cm">	 * with the timeout in the wait below, assuming that all commands</span>
<span class="cm">	 * complete within the timeout.</span>
<span class="cm">	 */</span>
	<span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">smbus_wait</span><span class="p">,</span> <span class="n">cafe_smbus_write_done</span><span class="p">(</span><span class="n">mcam</span><span class="p">),</span>
			<span class="n">CAFE_SMBUS_TIMEOUT</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">mcam_reg_read</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_TWSIC1</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">&amp;</span> <span class="n">TWSIC1_WSTAT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cam_err</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;SMBUS write (%02x/%02x/%02x) timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
				<span class="n">command</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">&amp;</span> <span class="n">TWSIC1_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cam_err</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;SMBUS write (%02x/%02x/%02x) error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
				<span class="n">command</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">int</span> <span class="nf">cafe_smbus_read_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">mcam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We must delay after the interrupt, or the controller gets confused</span>
<span class="cm">	 * and never does give us good status.  Fortunately, we don&#39;t do this</span>
<span class="cm">	 * often.</span>
<span class="cm">	 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">c1</span> <span class="o">=</span> <span class="n">mcam_reg_read</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_TWSIC1</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">c1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TWSIC1_RVALID</span><span class="o">|</span><span class="n">TWSIC1_ERROR</span><span class="p">);</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">int</span> <span class="nf">cafe_smbus_read_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">cafe_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span>
		<span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">mcam</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mcam</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">TWSIC0_EN</span> <span class="o">|</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="n">TWSIC0_SID_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TWSIC0_SID</span><span class="p">);</span>
	<span class="n">rval</span> <span class="o">|=</span> <span class="n">TWSIC0_OVMAGIC</span><span class="p">;</span> <span class="cm">/* Make OV sensors work */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Marvel sez set clkdiv to all 1&#39;s for now.</span>
<span class="cm">	 */</span>
	<span class="n">rval</span> <span class="o">|=</span> <span class="n">TWSIC0_CLKDIV</span><span class="p">;</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_TWSIC0</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">mcam_reg_read</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_TWSIC1</span><span class="p">);</span> <span class="cm">/* force write */</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">TWSIC1_READ</span> <span class="o">|</span> <span class="p">((</span><span class="n">command</span> <span class="o">&lt;&lt;</span> <span class="n">TWSIC1_ADDR_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TWSIC1_ADDR</span><span class="p">);</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_TWSIC1</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">smbus_wait</span><span class="p">,</span>
			<span class="n">cafe_smbus_read_done</span><span class="p">(</span><span class="n">mcam</span><span class="p">),</span> <span class="n">CAFE_SMBUS_TIMEOUT</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rval</span> <span class="o">=</span> <span class="n">mcam_reg_read</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_TWSIC1</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rval</span> <span class="o">&amp;</span> <span class="n">TWSIC1_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cam_err</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;SMBUS read (%02x/%02x) error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rval</span> <span class="o">&amp;</span> <span class="n">TWSIC1_RVALID</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cam_err</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;SMBUS read (%02x/%02x) timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
				<span class="n">command</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">rval</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform a transfer over SMBUS.  This thing is called under</span>
<span class="cm"> * the i2c bus lock, so we shouldn&#39;t race with ourselves...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cafe_smbus_xfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">char</span> <span class="n">rw</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cafe_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">i2c_get_adapdata</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This interface would appear to only do byte data ops.  OK</span>
<span class="cm">	 * it can do word too, but the cam chip has no use for that.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_BYTE_DATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cam_err</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;funky xfer size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">I2C_SMBUS_WRITE</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cafe_smbus_write_data</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">byte</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cafe_smbus_read_data</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">byte</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">cafe_smbus_enable_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cafe_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mcam</span><span class="p">.</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mcam_reg_set_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_IRQMASK</span><span class="p">,</span> <span class="n">TWSIIRQS</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mcam</span><span class="p">.</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">cafe_smbus_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">I2C_FUNC_SMBUS_READ_BYTE_DATA</span>  <span class="o">|</span>
	       <span class="n">I2C_FUNC_SMBUS_WRITE_BYTE_DATA</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">i2c_algorithm</span> <span class="n">cafe_smbus_algo</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">smbus_xfer</span> <span class="o">=</span> <span class="n">cafe_smbus_xfer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">functionality</span> <span class="o">=</span> <span class="n">cafe_smbus_func</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cafe_smbus_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cafe_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">adap</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">adap</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">mcam</span><span class="p">.</span><span class="n">i2c_adapter</span> <span class="o">=</span> <span class="n">adap</span><span class="p">;</span>
	<span class="n">cafe_smbus_enable_irq</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">adap</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
	<span class="n">adap</span><span class="o">-&gt;</span><span class="n">algo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cafe_smbus_algo</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;cafe_ccic&quot;</span><span class="p">);</span>
	<span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">i2c_set_adapdata</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">cam</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">i2c_add_adapter</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unable to register cafe i2c adapter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cafe_smbus_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">cafe_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i2c_del_adapter</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mcam</span><span class="p">.</span><span class="n">i2c_adapter</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mcam</span><span class="p">.</span><span class="n">i2c_adapter</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Controller-level stuff</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cafe_ctlr_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">mcam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Added magic to bring up the hardware on the B-Test board</span>
<span class="cm">	 */</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="mh">0x3038</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">);</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="mh">0x315c</span><span class="p">,</span> <span class="mh">0x80008</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Go through the dance needed to wake the device up.</span>
<span class="cm">	 * Note that these registers are global and shared</span>
<span class="cm">	 * with the NAND and SD devices.  Interaction between the</span>
<span class="cm">	 * three still needs to be examined.</span>
<span class="cm">	 */</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_GL_CSR</span><span class="p">,</span> <span class="n">GCSR_SRS</span><span class="o">|</span><span class="n">GCSR_MRS</span><span class="p">);</span> <span class="cm">/* Needed? */</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_GL_CSR</span><span class="p">,</span> <span class="n">GCSR_SRC</span><span class="o">|</span><span class="n">GCSR_MRC</span><span class="p">);</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_GL_CSR</span><span class="p">,</span> <span class="n">GCSR_SRC</span><span class="o">|</span><span class="n">GCSR_MRS</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Here we must wait a bit for the controller to come around.</span>
<span class="cm">	 */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_GL_CSR</span><span class="p">,</span> <span class="n">GCSR_CCIC_EN</span><span class="o">|</span><span class="n">GCSR_SRC</span><span class="o">|</span><span class="n">GCSR_MRC</span><span class="p">);</span>
	<span class="n">mcam_reg_set_bit</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_GL_IMASK</span><span class="p">,</span> <span class="n">GIMSK_CCIC_EN</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Mask all interrupts.</span>
<span class="cm">	 */</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_IRQMASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">cafe_ctlr_power_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">mcam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Part one of the sensor dance: turn the global</span>
<span class="cm">	 * GPIO signal on.</span>
<span class="cm">	 */</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_GL_FCR</span><span class="p">,</span> <span class="n">GFCR_GPIO_ON</span><span class="p">);</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_GL_GPIOR</span><span class="p">,</span> <span class="n">GGPIO_OUT</span><span class="o">|</span><span class="n">GGPIO_VAL</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Put the sensor into operational mode (assumes OLPC-style</span>
<span class="cm">	 * wiring).  Control 0 is reset - set to 1 to operate.</span>
<span class="cm">	 * Control 1 is power down, set to 0 to operate.</span>
<span class="cm">	 */</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_GPR</span><span class="p">,</span> <span class="n">GPR_C1EN</span><span class="o">|</span><span class="n">GPR_C0EN</span><span class="p">);</span> <span class="cm">/* pwr up, reset */</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_GPR</span><span class="p">,</span> <span class="n">GPR_C1EN</span><span class="o">|</span><span class="n">GPR_C0EN</span><span class="o">|</span><span class="n">GPR_C0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cafe_ctlr_power_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">mcam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_GPR</span><span class="p">,</span> <span class="n">GPR_C1EN</span><span class="o">|</span><span class="n">GPR_C0EN</span><span class="o">|</span><span class="n">GPR_C1</span><span class="p">);</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_GL_FCR</span><span class="p">,</span> <span class="n">GFCR_GPIO_ON</span><span class="p">);</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_GL_GPIOR</span><span class="p">,</span> <span class="n">GGPIO_OUT</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm"> * The platform interrupt handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">cafe_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cafe_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">mcam</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mcam</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irqs</span><span class="p">,</span> <span class="n">handled</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">);</span>
	<span class="n">irqs</span> <span class="o">=</span> <span class="n">mcam_reg_read</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_IRQSTAT</span><span class="p">);</span>
	<span class="n">handled</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">&amp;&amp;</span> <span class="n">mccic_irq</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">irqs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqs</span> <span class="o">&amp;</span> <span class="n">TWSIIRQS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">mcam</span><span class="p">,</span> <span class="n">REG_IRQSTAT</span><span class="p">,</span> <span class="n">TWSIIRQS</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">smbus_wait</span><span class="p">);</span>
		<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* -------------------------------------------------------------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * PCI interface stuff.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cafe_pci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cafe_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">mcam</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start putting together one of our big camera structures.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">cam</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cafe_camera</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">mcam</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mcam</span><span class="p">;</span>
	<span class="n">mcam</span><span class="o">-&gt;</span><span class="n">chip_id</span> <span class="o">=</span> <span class="n">V4L2_IDENT_CAFE</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">smbus_wait</span><span class="p">);</span>
	<span class="n">mcam</span><span class="o">-&gt;</span><span class="n">plat_power_up</span> <span class="o">=</span> <span class="n">cafe_ctlr_power_up</span><span class="p">;</span>
	<span class="n">mcam</span><span class="o">-&gt;</span><span class="n">plat_power_down</span> <span class="o">=</span> <span class="n">cafe_ctlr_power_down</span><span class="p">;</span>
	<span class="n">mcam</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set the clock speed for the XO 1; I don&#39;t believe this</span>
<span class="cm">	 * driver has ever run anywhere else.</span>
<span class="cm">	 */</span>
	<span class="n">mcam</span><span class="o">-&gt;</span><span class="n">clock_speed</span> <span class="o">=</span> <span class="mi">45</span><span class="p">;</span>
	<span class="n">mcam</span><span class="o">-&gt;</span><span class="n">use_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Vmalloc mode for buffers is traditional with this driver.</span>
<span class="cm">	 * We *might* be able to run DMA_contig, especially on a system</span>
<span class="cm">	 * with CMA in it.</span>
<span class="cm">	 */</span>
	<span class="n">mcam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span> <span class="o">=</span> <span class="n">B_vmalloc</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get set up on the PCI bus.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">mcam</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">pci_iomap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mcam</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unable to ioremap cafe-ccic regs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_disable</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">cafe_irq</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="s">&quot;cafe-ccic&quot;</span><span class="p">,</span> <span class="n">cam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_iounmap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the controller and leave it powered up.  It will</span>
<span class="cm">	 * stay that way until the sensor driver shows up.</span>
<span class="cm">	 */</span>
	<span class="n">cafe_ctlr_init</span><span class="p">(</span><span class="n">mcam</span><span class="p">);</span>
	<span class="n">cafe_ctlr_power_up</span><span class="p">(</span><span class="n">mcam</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set up I2C/SMBUS communications.  We have to drop the mutex here</span>
<span class="cm">	 * because the sensor could attach in this call chain, leading to</span>
<span class="cm">	 * unsightly deadlocks.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">cafe_smbus_setup</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_pdown</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mccic_register</span><span class="p">(</span><span class="n">mcam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cafe_smbus_shutdown</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
<span class="nl">out_pdown:</span>
	<span class="n">cafe_ctlr_power_down</span><span class="p">(</span><span class="n">mcam</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">cam</span><span class="p">);</span>
<span class="nl">out_iounmap:</span>
	<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">mcam</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
<span class="nl">out_disable:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Shut down an initialized device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cafe_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">cafe_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mccic_shutdown</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mcam</span><span class="p">);</span>
	<span class="n">cafe_smbus_shutdown</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">cam</span><span class="p">);</span>
	<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">mcam</span><span class="p">.</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">cafe_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cafe_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">to_cam</span><span class="p">(</span><span class="n">v4l2_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;pci_remove on unknown pdev %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cafe_shutdown</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/*</span>
<span class="cm"> * Basic power management.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cafe_pci_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cafe_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">to_cam</span><span class="p">(</span><span class="n">v4l2_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">mccic_suspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mcam</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">cafe_pci_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_device</span> <span class="o">*</span><span class="n">v4l2_dev</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cafe_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">to_cam</span><span class="p">(</span><span class="n">v4l2_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cam_warn</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;Unable to re-enable device on resume!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cafe_ctlr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mcam</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mccic_resume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">mcam</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif  </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">cafe_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_MARVELL</span><span class="p">,</span>
		     <span class="n">PCI_DEVICE_ID_MARVELL_88ALP01_CCIC</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">cafe_ids</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">cafe_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;cafe1000-ccic&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">cafe_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">cafe_pci_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">cafe_pci_remove</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">cafe_pci_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">cafe_pci_resume</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>




<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cafe_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Marvell M88ALP01 &#39;CAFE&#39; Camera Controller version %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">CAFE_VERSION</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cafe_pci_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unable to register cafe_ccic driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cafe_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cafe_pci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">cafe_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">cafe_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
