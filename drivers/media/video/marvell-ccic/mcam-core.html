<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › marvell-ccic › mcam-core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>mcam-core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * The Marvell camera core.  This device appears in a number of settings,</span>
<span class="cm"> * so it needs platform-specific support outside of the core.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2011 Jonathan Corbet corbet@lwn.net</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/videodev2.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-device.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-ioctl.h&gt;</span>
<span class="cp">#include &lt;media/v4l2-chip-ident.h&gt;</span>
<span class="cp">#include &lt;media/ov7670.h&gt;</span>
<span class="cp">#include &lt;media/videobuf2-vmalloc.h&gt;</span>
<span class="cp">#include &lt;media/videobuf2-dma-contig.h&gt;</span>
<span class="cp">#include &lt;media/videobuf2-dma-sg.h&gt;</span>

<span class="cp">#include &quot;mcam-core.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Basic frame stats - to be deleted shortly</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">frames</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">singles</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">delivered</span><span class="p">;</span>

<span class="cp">#ifdef MCAM_MODE_VMALLOC</span>
<span class="cm">/*</span>
<span class="cm"> * Internal DMA buffer management.  Since the controller cannot do S/G I/O,</span>
<span class="cm"> * we must have physically contiguous buffers to bring frames into.</span>
<span class="cm"> * These parameters control how many buffers we use, whether we</span>
<span class="cm"> * allocate them at load time (better chance of success, but nails down</span>
<span class="cm"> * memory) or when somebody tries to use the camera (riskier), and,</span>
<span class="cm"> * for load-time allocation, how big they should be.</span>
<span class="cm"> *</span>
<span class="cm"> * The controller can cycle through three buffers.  We could use</span>
<span class="cm"> * more by flipping pointers around, but it probably makes little</span>
<span class="cm"> * sense.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">alloc_bufs_at_read</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">alloc_bufs_at_read</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">alloc_bufs_at_read</span><span class="p">,</span>
		<span class="s">&quot;Non-zero value causes DMA buffers to be allocated when the &quot;</span>
		<span class="s">&quot;video capture device is read, rather than at module load &quot;</span>
		<span class="s">&quot;time.  This saves memory, but decreases the chances of &quot;</span>
		<span class="s">&quot;successfully getting those buffers.  This parameter is &quot;</span>
		<span class="s">&quot;only used in the vmalloc buffer mode&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">n_dma_bufs</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">n_dma_bufs</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">n_dma_bufs</span><span class="p">,</span>
		<span class="s">&quot;The number of DMA buffers to allocate.  Can be either two &quot;</span>
		<span class="s">&quot;(saves memory, makes timing tighter) or three.&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dma_buf_size</span> <span class="o">=</span> <span class="n">VGA_WIDTH</span> <span class="o">*</span> <span class="n">VGA_HEIGHT</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>  <span class="cm">/* Worst case */</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">dma_buf_size</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">dma_buf_size</span><span class="p">,</span>
		<span class="s">&quot;The size of the allocated DMA buffers.  If actual operating &quot;</span>
		<span class="s">&quot;parameters require larger buffers, an attempt to reallocate &quot;</span>
		<span class="s">&quot;will be made.&quot;</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* MCAM_MODE_VMALLOC */</span><span class="cp"></span>
<span class="k">static</span> <span class="k">const</span> <span class="n">bool</span> <span class="n">alloc_bufs_at_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">n_dma_bufs</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="cm">/* Used by S/G_PARM */</span>
<span class="cp">#endif </span><span class="cm">/* MCAM_MODE_VMALLOC */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">flip</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">flip</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">flip</span><span class="p">,</span>
		<span class="s">&quot;If set, the sensor will be instructed to flip the image &quot;</span>
		<span class="s">&quot;vertically.&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">buffer_mode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">buffer_mode</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">buffer_mode</span><span class="p">,</span>
		<span class="s">&quot;Set the buffer mode to be used; default is to go with what &quot;</span>
		<span class="s">&quot;the platform driver asks for.  Set to 0 for vmalloc, 1 for &quot;</span>
		<span class="s">&quot;DMA contiguous.&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Status flags.  Always manipulated with bit operations.</span>
<span class="cm"> */</span>
<span class="cp">#define CF_BUF0_VALID	 0	</span><span class="cm">/* Buffers valid - first three */</span><span class="cp"></span>
<span class="cp">#define CF_BUF1_VALID	 1</span>
<span class="cp">#define CF_BUF2_VALID	 2</span>
<span class="cp">#define CF_DMA_ACTIVE	 3	</span><span class="cm">/* A frame is incoming */</span><span class="cp"></span>
<span class="cp">#define CF_CONFIG_NEEDED 4	</span><span class="cm">/* Must configure hardware */</span><span class="cp"></span>
<span class="cp">#define CF_SINGLE_BUFFER 5	</span><span class="cm">/* Running with a single buffer */</span><span class="cp"></span>
<span class="cp">#define CF_SG_RESTART	 6	</span><span class="cm">/* SG restart needed */</span><span class="cp"></span>

<span class="cp">#define sensor_call(cam, o, f, args...) \</span>
<span class="cp">	v4l2_subdev_call(cam-&gt;sensor, o, f, ##args)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mcam_format_struct</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pixelformat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bpp</span><span class="p">;</span>   <span class="cm">/* Bytes per pixel */</span>
	<span class="k">enum</span> <span class="n">v4l2_mbus_pixelcode</span> <span class="n">mbus_code</span><span class="p">;</span>
<span class="p">}</span> <span class="n">mcam_formats</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">desc</span>		<span class="o">=</span> <span class="s">&quot;YUYV 4:2:2&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pixelformat</span>	<span class="o">=</span> <span class="n">V4L2_PIX_FMT_YUYV</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mbus_code</span>	<span class="o">=</span> <span class="n">V4L2_MBUS_FMT_YUYV8_2X8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bpp</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">desc</span>		<span class="o">=</span> <span class="s">&quot;RGB 444&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pixelformat</span>	<span class="o">=</span> <span class="n">V4L2_PIX_FMT_RGB444</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mbus_code</span>	<span class="o">=</span> <span class="n">V4L2_MBUS_FMT_RGB444_2X8_PADHI_LE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bpp</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">desc</span>		<span class="o">=</span> <span class="s">&quot;RGB 565&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pixelformat</span>	<span class="o">=</span> <span class="n">V4L2_PIX_FMT_RGB565</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mbus_code</span>	<span class="o">=</span> <span class="n">V4L2_MBUS_FMT_RGB565_2X8_LE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bpp</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">desc</span>		<span class="o">=</span> <span class="s">&quot;Raw RGB Bayer&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pixelformat</span>	<span class="o">=</span> <span class="n">V4L2_PIX_FMT_SBGGR8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mbus_code</span>	<span class="o">=</span> <span class="n">V4L2_MBUS_FMT_SBGGR8_1X8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bpp</span>		<span class="o">=</span> <span class="mi">1</span>
	<span class="p">},</span>
<span class="p">};</span>
<span class="cp">#define N_MCAM_FMTS ARRAY_SIZE(mcam_formats)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mcam_format_struct</span> <span class="o">*</span><span class="nf">mcam_find_format</span><span class="p">(</span><span class="n">u32</span> <span class="n">pixelformat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_MCAM_FMTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mcam_formats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pixelformat</span> <span class="o">==</span> <span class="n">pixelformat</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">mcam_formats</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
	<span class="cm">/* Not found? Then return the first format. */</span>
	<span class="k">return</span> <span class="n">mcam_formats</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The default format we use until somebody says otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_pix_format</span> <span class="n">mcam_def_pix_format</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">width</span>		<span class="o">=</span> <span class="n">VGA_WIDTH</span><span class="p">,</span>
	<span class="p">.</span><span class="n">height</span>		<span class="o">=</span> <span class="n">VGA_HEIGHT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pixelformat</span>	<span class="o">=</span> <span class="n">V4L2_PIX_FMT_YUYV</span><span class="p">,</span>
	<span class="p">.</span><span class="n">field</span>		<span class="o">=</span> <span class="n">V4L2_FIELD_NONE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bytesperline</span>	<span class="o">=</span> <span class="n">VGA_WIDTH</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sizeimage</span>	<span class="o">=</span> <span class="n">VGA_WIDTH</span><span class="o">*</span><span class="n">VGA_HEIGHT</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">enum</span> <span class="n">v4l2_mbus_pixelcode</span> <span class="n">mcam_def_mbus_code</span> <span class="o">=</span>
					<span class="n">V4L2_MBUS_FMT_YUYV8_2X8</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * The two-word DMA descriptor format used by the Armada 610 and like.  There</span>
<span class="cm"> * Is a three-word format as well (set C1_DESC_3WORD) where the third</span>
<span class="cm"> * word is a pointer to the next descriptor, but we don&#39;t use it.  Two-word</span>
<span class="cm"> * descriptors have to be contiguous in memory.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mcam_dma_desc</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">segment_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Our buffer type for working with videobuf2.  Note that the vb2</span>
<span class="cm"> * developers have decreed that struct vb2_buffer must be at the</span>
<span class="cm"> * beginning of this structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mcam_vb_buffer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="n">vb_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcam_dma_desc</span> <span class="o">*</span><span class="n">dma_desc</span><span class="p">;</span>	<span class="cm">/* Descriptor virtual address */</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_desc_pa</span><span class="p">;</span>		<span class="cm">/* Descriptor physical address */</span>
	<span class="kt">int</span> <span class="n">dma_desc_nent</span><span class="p">;</span>		<span class="cm">/* Number of mapped descriptors */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">mcam_vb_buffer</span> <span class="o">*</span><span class="nf">vb_to_mvb</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mcam_vb_buffer</span><span class="p">,</span> <span class="n">vb_buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hand a completed buffer back to user space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_buffer_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">frame</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vbuf</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">bytesused</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">pix_format</span><span class="p">.</span><span class="n">sizeimage</span><span class="p">;</span>
	<span class="n">vbuf</span><span class="o">-&gt;</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">buf_seq</span><span class="p">[</span><span class="n">frame</span><span class="p">];</span>
	<span class="n">vb2_set_plane_payload</span><span class="p">(</span><span class="n">vbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">pix_format</span><span class="p">.</span><span class="n">sizeimage</span><span class="p">);</span>
	<span class="n">vb2_buffer_done</span><span class="p">(</span><span class="n">vbuf</span><span class="p">,</span> <span class="n">VB2_BUF_STATE_DONE</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm"> * Debugging and related.</span>
<span class="cm"> */</span>
<span class="cp">#define cam_err(cam, fmt, arg...) \</span>
<span class="cp">	dev_err((cam)-&gt;dev, fmt, ##arg);</span>
<span class="cp">#define cam_warn(cam, fmt, arg...) \</span>
<span class="cp">	dev_warn((cam)-&gt;dev, fmt, ##arg);</span>
<span class="cp">#define cam_dbg(cam, fmt, arg...) \</span>
<span class="cp">	dev_dbg((cam)-&gt;dev, fmt, ##arg);</span>


<span class="cm">/*</span>
<span class="cm"> * Flag manipulation helpers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_reset_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">next_buf</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">nbufs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mcam_needs_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">CF_CONFIG_NEEDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_set_config_needed</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">needed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needed</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CF_CONFIG_NEEDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">CF_CONFIG_NEEDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * Make the controller start grabbing images.  Everything must</span>
<span class="cm"> * be set up before doing this.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_ctlr_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* set_bit performs a read, so no other barrier should be</span>
<span class="cm">	   needed here */</span>
	<span class="n">mcam_reg_set_bit</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CTRL0</span><span class="p">,</span> <span class="n">C0_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_ctlr_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mcam_reg_clear_bit</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CTRL0</span><span class="p">,</span> <span class="n">C0_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------------- */</span>

<span class="cp">#ifdef MCAM_MODE_VMALLOC</span>
<span class="cm">/*</span>
<span class="cm"> * Code specific to the vmalloc buffer mode.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate in-kernel DMA buffers for vmalloc mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_alloc_dma_bufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">loadtime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mcam_set_config_needed</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">loadtime</span><span class="p">)</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_buf_size</span> <span class="o">=</span> <span class="n">dma_buf_size</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_buf_size</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">pix_format</span><span class="p">.</span><span class="n">sizeimage</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_dma_bufs</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">n_dma_bufs</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">nbufs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_dma_bufs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_bufs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_buf_size</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_handles</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_bufs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cam_warn</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;Failed to allocate DMA buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">nbufs</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">nbufs</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_buf_size</span><span class="p">,</span>
				<span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_bufs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_handles</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">nbufs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">cam_err</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;Insufficient DMA buffers, cannot operate</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">2</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">n_dma_bufs</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">cam_warn</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;Will limp along with only 2 buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_free_dma_bufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">nbufs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_buf_size</span><span class="p">,</span>
				<span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_bufs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_handles</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_bufs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">nbufs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Set up DMA buffers when operating in vmalloc mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_ctlr_dma_vmalloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Store the first two Y buffers (we aren&#39;t supporting</span>
<span class="cm">	 * planar formats for now, so no UV bufs).  Then either</span>
<span class="cm">	 * set the third if it exists, or tell the controller</span>
<span class="cm">	 * to just use two.</span>
<span class="cm">	 */</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_Y0BAR</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_handles</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_Y1BAR</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_handles</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">nbufs</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_Y2BAR</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_handles</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">mcam_reg_clear_bit</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CTRL1</span><span class="p">,</span> <span class="n">C1_TWOBUFS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">mcam_reg_set_bit</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CTRL1</span><span class="p">,</span> <span class="n">C1_TWOBUFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">chip_id</span> <span class="o">==</span> <span class="n">V4L2_IDENT_CAFE</span><span class="p">)</span>
		<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_UBAR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* 32 bits only */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy data out to user space in the vmalloc case</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_frame_tasklet</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcam_vb_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">nbufs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">bufno</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">next_buf</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">S_STREAMING</span> <span class="o">||</span> <span class="n">bufno</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>  <span class="cm">/* I/O got stopped */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">next_buf</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">nbufs</span><span class="p">)</span>
			<span class="n">cam</span><span class="o">-&gt;</span><span class="n">next_buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">bufno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">singles</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>  <span class="cm">/* Leave it valid, hope for better later */</span>
		<span class="p">}</span>
		<span class="n">delivered</span><span class="o">++</span><span class="p">;</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">bufno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mcam_vb_buffer</span><span class="p">,</span>
				<span class="n">queue</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Drop the lock during the big copy.  This *should* be safe...</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">vb2_plane_vaddr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_bufs</span><span class="p">[</span><span class="n">bufno</span><span class="p">],</span>
				<span class="n">cam</span><span class="o">-&gt;</span><span class="n">pix_format</span><span class="p">.</span><span class="n">sizeimage</span><span class="p">);</span>
		<span class="n">mcam_buffer_done</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">bufno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb_buf</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Make sure our allocated buffers are up to the task.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_check_dma_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">nbufs</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_buf_size</span> <span class="o">&lt;</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">pix_format</span><span class="p">.</span><span class="n">sizeimage</span><span class="p">)</span>
			<span class="n">mcam_free_dma_bufs</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">nbufs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mcam_alloc_dma_bufs</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_vmalloc_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_tasklet</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* MCAM_MODE_VMALLOC */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mcam_alloc_dma_bufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">loadtime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mcam_free_dma_bufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mcam_check_dma_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="cp">#endif </span><span class="cm">/* MCAM_MODE_VMALLOC */</span><span class="cp"></span>


<span class="cp">#ifdef MCAM_MODE_DMA_CONTIG</span>
<span class="cm">/* ---------------------------------------------------------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * DMA-contiguous code.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * Set up a contiguous buffer for the given frame.  Here also is where</span>
<span class="cm"> * the underrun strategy is set: if there is no buffer available, reuse</span>
<span class="cm"> * the buffer from the other BAR and set the CF_SINGLE_BUFFER flag to</span>
<span class="cm"> * keep the interrupt handler from giving that buffer back to user</span>
<span class="cm"> * space.  In this way, we always have a buffer to DMA to and don&#39;t</span>
<span class="cm"> * have to try to play games stopping and restarting the controller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_set_contig_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_vb_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If there are no available buffers, go into single mode</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_bufs</span><span class="p">[</span><span class="n">frame</span> <span class="o">^</span> <span class="mh">0x1</span><span class="p">];</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_bufs</span><span class="p">[</span><span class="n">frame</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">frame</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">REG_Y0BAR</span> <span class="o">:</span> <span class="n">REG_Y1BAR</span><span class="p">,</span>
				<span class="n">vb2_dma_contig_plane_dma_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CF_SINGLE_BUFFER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">singles</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * OK, we have a buffer we can use.</span>
<span class="cm">	 */</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mcam_vb_buffer</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">frame</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">REG_Y0BAR</span> <span class="o">:</span> <span class="n">REG_Y1BAR</span><span class="p">,</span>
			<span class="n">vb2_dma_contig_plane_dma_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_bufs</span><span class="p">[</span><span class="n">frame</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">CF_SINGLE_BUFFER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initial B_DMA_contig setup.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_ctlr_dma_contig</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mcam_reg_set_bit</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CTRL1</span><span class="p">,</span> <span class="n">C1_TWOBUFS</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">nbufs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">mcam_set_contig_buffer</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mcam_set_contig_buffer</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Frame completion handling.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_dma_contig_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_vb_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_bufs</span><span class="p">[</span><span class="n">frame</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CF_SINGLE_BUFFER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">delivered</span><span class="o">++</span><span class="p">;</span>
		<span class="n">mcam_buffer_done</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb_buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mcam_set_contig_buffer</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* MCAM_MODE_DMA_CONTIG */</span><span class="cp"></span>

<span class="cp">#ifdef MCAM_MODE_DMA_SG</span>
<span class="cm">/* ---------------------------------------------------------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * Scatter/gather-specific code.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Set up the next buffer for S/G I/O; caller should be sure that</span>
<span class="cm"> * the controller is stopped and a buffer is available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_sg_next_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_vb_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mcam_vb_buffer</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Very Bad Not Good Things happen if you don&#39;t clear</span>
<span class="cm">	 * C1_DESC_ENA before making any descriptor changes.</span>
<span class="cm">	 */</span>
	<span class="n">mcam_reg_clear_bit</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CTRL1</span><span class="p">,</span> <span class="n">C1_DESC_ENA</span><span class="p">);</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_DMA_DESC_Y</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">dma_desc_pa</span><span class="p">);</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_DESC_LEN_Y</span><span class="p">,</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">dma_desc_nent</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_dma_desc</span><span class="p">));</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_DESC_LEN_U</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_DESC_LEN_V</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mcam_reg_set_bit</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CTRL1</span><span class="p">,</span> <span class="n">C1_DESC_ENA</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_bufs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initial B_DMA_sg setup</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_ctlr_dma_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The list-empty condition can hit us at resume time</span>
<span class="cm">	 * if the buffer list was empty when the system was suspended.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CF_SG_RESTART</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mcam_reg_clear_bit</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CTRL1</span><span class="p">,</span> <span class="n">C1_DESC_3WORD</span><span class="p">);</span>
	<span class="n">mcam_sg_next_buffer</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">nbufs</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Frame completion with S/G is trickier.  We can&#39;t muck with</span>
<span class="cm"> * a descriptor chain on the fly, since the controller buffers it</span>
<span class="cm"> * internally.  So we have to actually stop and restart; Marvell</span>
<span class="cm"> * says this is the way to do it.</span>
<span class="cm"> *</span>
<span class="cm"> * Of course, stopping is easier said than done; experience shows</span>
<span class="cm"> * that the controller can start a frame *after* C0_ENABLE has been</span>
<span class="cm"> * cleared.  So when running in S/G mode, the controller is &quot;stopped&quot;</span>
<span class="cm"> * on receipt of the start-of-frame interrupt.  That means we can</span>
<span class="cm"> * safely change the DMA descriptor array here and restart things</span>
<span class="cm"> * (assuming there&#39;s another buffer waiting to go).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_dma_sg_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_vb_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_bufs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re no longer supposed to be streaming, don&#39;t do anything.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">S_STREAMING</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we have another buffer available, put it in and</span>
<span class="cm">	 * restart the engine.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mcam_sg_next_buffer</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">mcam_ctlr_start</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Otherwise set CF_SG_RESTART and the controller will</span>
<span class="cm">	 * be restarted once another buffer shows up.</span>
<span class="cm">	 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CF_SG_RESTART</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">singles</span><span class="o">++</span><span class="p">;</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_bufs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now we can give the completed frame back to user space.</span>
<span class="cm">	 */</span>
	<span class="n">delivered</span><span class="o">++</span><span class="p">;</span>
	<span class="n">mcam_buffer_done</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb_buf</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Scatter/gather mode requires stopping the controller between</span>
<span class="cm"> * frames so we can put in a new DMA descriptor array.  If no new</span>
<span class="cm"> * buffer exists at frame completion, the controller is left stopped;</span>
<span class="cm"> * this function is charged with gettig things going again.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_sg_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mcam_ctlr_dma_sg</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">mcam_ctlr_start</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">CF_SG_RESTART</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* MCAM_MODE_DMA_SG */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mcam_sg_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* MCAM_MODE_DMA_SG */</span><span class="cp"></span>

<span class="cm">/* ---------------------------------------------------------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * Buffer-mode-independent controller code.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Image format setup</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_ctlr_image</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">imgsz</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_pix_format</span> <span class="o">*</span><span class="n">fmt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">pix_format</span><span class="p">;</span>

	<span class="n">imgsz</span> <span class="o">=</span> <span class="p">((</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">&lt;&lt;</span> <span class="n">IMGSZ_V_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IMGSZ_V_MASK</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bytesperline</span> <span class="o">&amp;</span> <span class="n">IMGSZ_H_MASK</span><span class="p">);</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_IMGSIZE</span><span class="p">,</span> <span class="n">imgsz</span><span class="p">);</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_IMGOFFSET</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* YPITCH just drops the last two bits */</span>
	<span class="n">mcam_reg_write_mask</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_IMGPITCH</span><span class="p">,</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bytesperline</span><span class="p">,</span>
			<span class="n">IMGP_YP_MASK</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Tell the controller about the image format we are using.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">pix_format</span><span class="p">.</span><span class="n">pixelformat</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">V4L2_PIX_FMT_YUYV</span>:
	    <span class="n">mcam_reg_write_mask</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CTRL0</span><span class="p">,</span>
			    <span class="n">C0_DF_YUV</span><span class="o">|</span><span class="n">C0_YUV_PACKED</span><span class="o">|</span><span class="n">C0_YUVE_YUYV</span><span class="p">,</span>
			    <span class="n">C0_DF_MASK</span><span class="p">);</span>
	    <span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">V4L2_PIX_FMT_RGB444</span>:
	    <span class="n">mcam_reg_write_mask</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CTRL0</span><span class="p">,</span>
			    <span class="n">C0_DF_RGB</span><span class="o">|</span><span class="n">C0_RGBF_444</span><span class="o">|</span><span class="n">C0_RGB4_XRGB</span><span class="p">,</span>
			    <span class="n">C0_DF_MASK</span><span class="p">);</span>
		<span class="cm">/* Alpha value? */</span>
	    <span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">V4L2_PIX_FMT_RGB565</span>:
	    <span class="n">mcam_reg_write_mask</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CTRL0</span><span class="p">,</span>
			    <span class="n">C0_DF_RGB</span><span class="o">|</span><span class="n">C0_RGBF_565</span><span class="o">|</span><span class="n">C0_RGB5_BGGR</span><span class="p">,</span>
			    <span class="n">C0_DF_MASK</span><span class="p">);</span>
	    <span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
	    <span class="n">cam_err</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;Unknown format %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">pix_format</span><span class="p">.</span><span class="n">pixelformat</span><span class="p">);</span>
	    <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure it knows we want to use hsync/vsync.</span>
<span class="cm">	 */</span>
	<span class="n">mcam_reg_write_mask</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CTRL0</span><span class="p">,</span> <span class="n">C0_SIF_HVSYNC</span><span class="p">,</span>
			<span class="n">C0_SIFM_MASK</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Configure the controller for operation; caller holds the</span>
<span class="cm"> * device mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_ctlr_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">CF_SG_RESTART</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_setup</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">mcam_ctlr_image</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">mcam_set_config_needed</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_ctlr_irq_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clear any pending interrupts, since we do not</span>
<span class="cm">	 * expect to have I/O active prior to enabling.</span>
<span class="cm">	 */</span>
	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_IRQSTAT</span><span class="p">,</span> <span class="n">FRAMEIRQS</span><span class="p">);</span>
	<span class="n">mcam_reg_set_bit</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_IRQMASK</span><span class="p">,</span> <span class="n">FRAMEIRQS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_ctlr_irq_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mcam_reg_clear_bit</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_IRQMASK</span><span class="p">,</span> <span class="n">FRAMEIRQS</span><span class="p">);</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_ctlr_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure it&#39;s not powered down.</span>
<span class="cm">	 */</span>
	<span class="n">mcam_reg_clear_bit</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CTRL1</span><span class="p">,</span> <span class="n">C1_PWRDWN</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Turn off the enable bit.  It sure should be off anyway,</span>
<span class="cm">	 * but it&#39;s good to be sure.</span>
<span class="cm">	 */</span>
	<span class="n">mcam_reg_clear_bit</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CTRL0</span><span class="p">,</span> <span class="n">C0_ENABLE</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clock the sensor appropriately.  Controller clock should</span>
<span class="cm">	 * be 48MHz, sensor &quot;typical&quot; value is half that.</span>
<span class="cm">	 */</span>
	<span class="n">mcam_reg_write_mask</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CLKCTRL</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">CLK_DIV_MASK</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Stop the controller, and don&#39;t return until we&#39;re really sure that no</span>
<span class="cm"> * further DMA is going on.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_ctlr_stop_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Theory: stop the camera controller (whether it is operating</span>
<span class="cm">	 * or not).  Delay briefly just in case we race with the SOF</span>
<span class="cm">	 * interrupt, then wait until no DMA is active.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">CF_SG_RESTART</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">mcam_ctlr_stop</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">S_IDLE</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This is a brutally long sleep, but experience shows that</span>
<span class="cm">	 * it can take the controller a while to get the message that</span>
<span class="cm">	 * it needs to stop grabbing frames.  In particular, we can</span>
<span class="cm">	 * sometimes (on mmp) get a frame at the end WITHOUT the</span>
<span class="cm">	 * start-of-frame indication.</span>
<span class="cm">	 */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">150</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CF_DMA_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">cam_err</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;Timeout waiting for DMA to end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* This would be bad news - what now? */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mcam_ctlr_irq_disable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Power up and down.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_ctlr_power_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">plat_power_up</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">mcam_reg_clear_bit</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CTRL1</span><span class="p">,</span> <span class="n">C1_PWRDWN</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="cm">/* Just to be sure */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_ctlr_power_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * School of hard knocks department: be sure we do any register</span>
<span class="cm">	 * twiddling on the controller *before* calling the platform</span>
<span class="cm">	 * power down routine.</span>
<span class="cm">	 */</span>
	<span class="n">mcam_reg_set_bit</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_CTRL1</span><span class="p">,</span> <span class="n">C1_PWRDWN</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">plat_power_down</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* -------------------------------------------------------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * Communications with the sensor.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__mcam_cam_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We have found the sensor on the i2c.  Let&#39;s try to have a</span>
<span class="cm"> * conversation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_cam_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_dbg_chip_ident</span> <span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">S_NOTREADY</span><span class="p">)</span>
		<span class="n">cam_warn</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;Cam init with device in funky state %d&quot;</span><span class="p">,</span>
				<span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__mcam_cam_reset</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">chip</span><span class="p">.</span><span class="n">ident</span> <span class="o">=</span> <span class="n">V4L2_IDENT_NONE</span><span class="p">;</span>
	<span class="n">chip</span><span class="p">.</span><span class="n">match</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">V4L2_CHIP_MATCH_I2C_ADDR</span><span class="p">;</span>
	<span class="n">chip</span><span class="p">.</span><span class="n">match</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_addr</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">g_chip_ident</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_type</span> <span class="o">=</span> <span class="n">chip</span><span class="p">.</span><span class="n">ident</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_type</span> <span class="o">!=</span> <span class="n">V4L2_IDENT_OV7670</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cam_err</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;Unsupported sensor type 0x%x&quot;</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_type</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cm">/* Get/set parameters? */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">S_IDLE</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mcam_ctlr_power_down</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Configure the sensor to match the parameters we have.  Caller should</span>
<span class="cm"> * hold s_mutex</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_cam_set_flip</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_control</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctrl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctrl</span><span class="p">));</span>
	<span class="n">ctrl</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">V4L2_CID_VFLIP</span><span class="p">;</span>
	<span class="n">ctrl</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">flip</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">s_ctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_cam_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_mbus_framefmt</span> <span class="n">mbus_fmt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">v4l2_fill_mbus_format</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbus_fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">pix_format</span><span class="p">,</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">mbus_code</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">s_mbus_fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbus_fmt</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * OV7670 does weird things if flip is set *before* format...</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="n">mcam_cam_set_flip</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get everything ready, and start grabbing frames.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_read_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Configuration.  If we still don&#39;t have DMA buffers,</span>
<span class="cm">	 * make one last, desperate attempt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span> <span class="o">==</span> <span class="n">B_vmalloc</span> <span class="o">&amp;&amp;</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">nbufs</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			<span class="n">mcam_alloc_dma_bufs</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcam_needs_config</span><span class="p">(</span><span class="n">cam</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mcam_cam_configure</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mcam_ctlr_configure</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Turn it loose.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">CF_DMA_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">mcam_reset_buffers</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">mcam_ctlr_irq_enable</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">S_STREAMING</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">CF_SG_RESTART</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">mcam_ctlr_start</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ----------------------------------------------------------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * Videobuf2 interface code.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vb_queue_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nbufs</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">num_planes</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sizes</span><span class="p">[],</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">alloc_ctxs</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">vb2_get_drv_priv</span><span class="p">(</span><span class="n">vq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">minbufs</span> <span class="o">=</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span> <span class="o">==</span> <span class="n">B_DMA_contig</span><span class="p">)</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">pix_format</span><span class="p">.</span><span class="n">sizeimage</span><span class="p">;</span>
	<span class="o">*</span><span class="n">num_planes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Someday we have to support planar formats... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">nbufs</span> <span class="o">&lt;</span> <span class="n">minbufs</span><span class="p">)</span>
		<span class="o">*</span><span class="n">nbufs</span> <span class="o">=</span> <span class="n">minbufs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span> <span class="o">==</span> <span class="n">B_DMA_contig</span><span class="p">)</span>
		<span class="n">alloc_ctxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_alloc_ctx</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_vb_buf_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_vb_buffer</span> <span class="o">*</span><span class="n">mvb</span> <span class="o">=</span> <span class="n">vb_to_mvb</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">vb2_get_drv_priv</span><span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">S_BUFWAIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mvb</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">S_STREAMING</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">CF_SG_RESTART</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">mcam_sg_restart</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="p">)</span>
		<span class="n">mcam_read_setup</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vb2 uses these to release the mutex when waiting in dqbuf.  I&#39;m</span>
<span class="cm"> * not actually sure we need to do this (I&#39;m not sure that vb2_dqbuf() needs</span>
<span class="cm"> * to be called with the mutex held), but better safe than sorry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_vb_wait_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">vb2_get_drv_priv</span><span class="p">(</span><span class="n">vq</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_vb_wait_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">vb2_get_drv_priv</span><span class="p">(</span><span class="n">vq</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These need to be called with the mutex held from vb2</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vb_start_streaming</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">vb2_get_drv_priv</span><span class="p">(</span><span class="n">vq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">S_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Videobuf2 sneakily hoards all the buffers and won&#39;t</span>
<span class="cm">	 * give them to us until *after* streaming starts.  But</span>
<span class="cm">	 * we can&#39;t actually start streaming until we have a</span>
<span class="cm">	 * destination.  So go into a wait state and hope they</span>
<span class="cm">	 * give us buffers soon.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span> <span class="o">!=</span> <span class="n">B_vmalloc</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">S_BUFWAIT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mcam_read_setup</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vb_stop_streaming</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">vb2_get_drv_priv</span><span class="p">(</span><span class="n">vq</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">S_BUFWAIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* They never gave us buffers */</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">S_IDLE</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">S_STREAMING</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">mcam_ctlr_stop_dma</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * VB2 reclaims the buffers, so we need to forget</span>
<span class="cm">	 * about them.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vb2_ops</span> <span class="n">mcam_vb2_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">queue_setup</span>		<span class="o">=</span> <span class="n">mcam_vb_queue_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_queue</span>		<span class="o">=</span> <span class="n">mcam_vb_buf_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start_streaming</span>	<span class="o">=</span> <span class="n">mcam_vb_start_streaming</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_streaming</span>		<span class="o">=</span> <span class="n">mcam_vb_stop_streaming</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wait_prepare</span>		<span class="o">=</span> <span class="n">mcam_vb_wait_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wait_finish</span>		<span class="o">=</span> <span class="n">mcam_vb_wait_finish</span><span class="p">,</span>
<span class="p">};</span>


<span class="cp">#ifdef MCAM_MODE_DMA_SG</span>
<span class="cm">/*</span>
<span class="cm"> * Scatter/gather mode uses all of the above functions plus a</span>
<span class="cm"> * few extras to deal with DMA mapping.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vb_sg_buf_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_vb_buffer</span> <span class="o">*</span><span class="n">mvb</span> <span class="o">=</span> <span class="n">vb_to_mvb</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">vb2_get_drv_priv</span><span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ndesc</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">pix_format</span><span class="p">.</span><span class="n">sizeimage</span><span class="o">/</span><span class="n">PAGE_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">mvb</span><span class="o">-&gt;</span><span class="n">dma_desc</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="n">ndesc</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_dma_desc</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">mvb</span><span class="o">-&gt;</span><span class="n">dma_desc_pa</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mvb</span><span class="o">-&gt;</span><span class="n">dma_desc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cam_err</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;Unable to get DMA descriptor array</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vb_sg_buf_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_vb_buffer</span> <span class="o">*</span><span class="n">mvb</span> <span class="o">=</span> <span class="n">vb_to_mvb</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">vb2_get_drv_priv</span><span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vb2_dma_sg_desc</span> <span class="o">*</span><span class="n">sgd</span> <span class="o">=</span> <span class="n">vb2_dma_sg_plane_desc</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mcam_dma_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">mvb</span><span class="o">-&gt;</span><span class="n">dma_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mvb</span><span class="o">-&gt;</span><span class="n">dma_desc_nent</span> <span class="o">=</span> <span class="n">dma_map_sg</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sgd</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">,</span> <span class="n">sgd</span><span class="o">-&gt;</span><span class="n">num_pages</span><span class="p">,</span>
			<span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mvb</span><span class="o">-&gt;</span><span class="n">dma_desc_nent</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>  <span class="cm">/* Not sure what&#39;s right here */</span>
	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sgd</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">mvb</span><span class="o">-&gt;</span><span class="n">dma_desc_nent</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">segment_len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">desc</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vb_sg_buf_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">vb2_get_drv_priv</span><span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vb2_dma_sg_desc</span> <span class="o">*</span><span class="n">sgd</span> <span class="o">=</span> <span class="n">vb2_dma_sg_plane_desc</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sgd</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">,</span> <span class="n">sgd</span><span class="o">-&gt;</span><span class="n">num_pages</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_vb_sg_buf_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">vb2_get_drv_priv</span><span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mcam_vb_buffer</span> <span class="o">*</span><span class="n">mvb</span> <span class="o">=</span> <span class="n">vb_to_mvb</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ndesc</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">pix_format</span><span class="p">.</span><span class="n">sizeimage</span><span class="o">/</span><span class="n">PAGE_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ndesc</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_dma_desc</span><span class="p">),</span>
			<span class="n">mvb</span><span class="o">-&gt;</span><span class="n">dma_desc</span><span class="p">,</span> <span class="n">mvb</span><span class="o">-&gt;</span><span class="n">dma_desc_pa</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vb2_ops</span> <span class="n">mcam_vb2_sg_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">queue_setup</span>		<span class="o">=</span> <span class="n">mcam_vb_queue_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_init</span>		<span class="o">=</span> <span class="n">mcam_vb_sg_buf_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_prepare</span>		<span class="o">=</span> <span class="n">mcam_vb_sg_buf_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_queue</span>		<span class="o">=</span> <span class="n">mcam_vb_buf_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_finish</span>		<span class="o">=</span> <span class="n">mcam_vb_sg_buf_finish</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_cleanup</span>		<span class="o">=</span> <span class="n">mcam_vb_sg_buf_cleanup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start_streaming</span>	<span class="o">=</span> <span class="n">mcam_vb_start_streaming</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_streaming</span>		<span class="o">=</span> <span class="n">mcam_vb_stop_streaming</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wait_prepare</span>		<span class="o">=</span> <span class="n">mcam_vb_wait_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wait_finish</span>		<span class="o">=</span> <span class="n">mcam_vb_wait_finish</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* MCAM_MODE_DMA_SG */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_setup_vb2</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">vq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vq</span><span class="p">));</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">;</span>
	<span class="n">vq</span><span class="o">-&gt;</span><span class="n">drv_priv</span> <span class="o">=</span> <span class="n">cam</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">B_DMA_contig</span>:
<span class="cp">#ifdef MCAM_MODE_DMA_CONTIG</span>
		<span class="n">vq</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcam_vb2_ops</span><span class="p">;</span>
		<span class="n">vq</span><span class="o">-&gt;</span><span class="n">mem_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vb2_dma_contig_memops</span><span class="p">;</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_alloc_ctx</span> <span class="o">=</span> <span class="n">vb2_dma_contig_init_ctx</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">vq</span><span class="o">-&gt;</span><span class="n">io_modes</span> <span class="o">=</span> <span class="n">VB2_MMAP</span> <span class="o">|</span> <span class="n">VB2_USERPTR</span><span class="p">;</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_setup</span> <span class="o">=</span> <span class="n">mcam_ctlr_dma_contig</span><span class="p">;</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">frame_complete</span> <span class="o">=</span> <span class="n">mcam_dma_contig_done</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">B_DMA_sg</span>:
<span class="cp">#ifdef MCAM_MODE_DMA_SG</span>
		<span class="n">vq</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcam_vb2_sg_ops</span><span class="p">;</span>
		<span class="n">vq</span><span class="o">-&gt;</span><span class="n">mem_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vb2_dma_sg_memops</span><span class="p">;</span>
		<span class="n">vq</span><span class="o">-&gt;</span><span class="n">io_modes</span> <span class="o">=</span> <span class="n">VB2_MMAP</span> <span class="o">|</span> <span class="n">VB2_USERPTR</span><span class="p">;</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_setup</span> <span class="o">=</span> <span class="n">mcam_ctlr_dma_sg</span><span class="p">;</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">frame_complete</span> <span class="o">=</span> <span class="n">mcam_dma_sg_done</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">B_vmalloc</span>:
<span class="cp">#ifdef MCAM_MODE_VMALLOC</span>
		<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_tasklet</span><span class="p">,</span> <span class="n">mcam_frame_tasklet</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">cam</span><span class="p">);</span>
		<span class="n">vq</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcam_vb2_ops</span><span class="p">;</span>
		<span class="n">vq</span><span class="o">-&gt;</span><span class="n">mem_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vb2_vmalloc_memops</span><span class="p">;</span>
		<span class="n">vq</span><span class="o">-&gt;</span><span class="n">buf_struct_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_vb_buffer</span><span class="p">);</span>
		<span class="n">vq</span><span class="o">-&gt;</span><span class="n">io_modes</span> <span class="o">=</span> <span class="n">VB2_MMAP</span><span class="p">;</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">dma_setup</span> <span class="o">=</span> <span class="n">mcam_ctlr_dma_vmalloc</span><span class="p">;</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">frame_complete</span> <span class="o">=</span> <span class="n">mcam_vmalloc_done</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">vb2_queue_init</span><span class="p">(</span><span class="n">vq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_cleanup_vb2</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vb2_queue_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">);</span>
<span class="cp">#ifdef MCAM_MODE_DMA_CONTIG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span> <span class="o">==</span> <span class="n">B_DMA_contig</span><span class="p">)</span>
		<span class="n">vb2_dma_contig_cleanup_ctx</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_alloc_ctx</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cm">/* ---------------------------------------------------------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * The long list of V4L2 ioctl() operations.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_streamon</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">v4l2_buf_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_streamon</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_streamoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">v4l2_buf_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_streamoff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_reqbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_requestbuffers</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_reqbufs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_querybuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_querybuf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_qbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_qbuf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_dqbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_dqbuf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_queryctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_queryctrl</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">queryctrl</span><span class="p">,</span> <span class="n">qc</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_g_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">g_ctrl</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_s_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">s_ctrl</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_querycap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_capability</span> <span class="o">*</span><span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="s">&quot;marvell_ccic&quot;</span><span class="p">);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="s">&quot;marvell_ccic&quot;</span><span class="p">);</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">=</span> <span class="n">V4L2_CAP_VIDEO_CAPTURE</span> <span class="o">|</span>
		<span class="n">V4L2_CAP_READWRITE</span> <span class="o">|</span> <span class="n">V4L2_CAP_STREAMING</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_enum_fmt_vid_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_fmtdesc</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">N_MCAM_FMTS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">,</span> <span class="n">mcam_formats</span><span class="p">[</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">desc</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">description</span><span class="p">));</span>
	<span class="n">fmt</span><span class="o">-&gt;</span><span class="n">pixelformat</span> <span class="o">=</span> <span class="n">mcam_formats</span><span class="p">[</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">].</span><span class="n">pixelformat</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_try_fmt_vid_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcam_format_struct</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_pix_format</span> <span class="o">*</span><span class="n">pix</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_mbus_framefmt</span> <span class="n">mbus_fmt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">f</span> <span class="o">=</span> <span class="n">mcam_find_format</span><span class="p">(</span><span class="n">pix</span><span class="o">-&gt;</span><span class="n">pixelformat</span><span class="p">);</span>
	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">pixelformat</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">pixelformat</span><span class="p">;</span>
	<span class="n">v4l2_fill_mbus_format</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbus_fmt</span><span class="p">,</span> <span class="n">pix</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">mbus_code</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">try_mbus_fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbus_fmt</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">v4l2_fill_pix_format</span><span class="p">(</span><span class="n">pix</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbus_fmt</span><span class="p">);</span>
	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">bytesperline</span> <span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">*</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">bpp</span><span class="p">;</span>
	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">sizeimage</span> <span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">*</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">bytesperline</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_s_fmt_vid_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcam_format_struct</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Can&#39;t do anything if the device is not idle</span>
<span class="cm">	 * Also can&#39;t if there are streaming buffers in place.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">S_IDLE</span> <span class="o">||</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">.</span><span class="n">num_buffers</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">f</span> <span class="o">=</span> <span class="n">mcam_find_format</span><span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="p">.</span><span class="n">pixelformat</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * See if the formatting works in principle.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcam_vidioc_try_fmt_vid_cap</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now we start to change things for real, so let&#39;s do it</span>
<span class="cm">	 * under lock.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">pix_format</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">mbus_code</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">mbus_code</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure we have appropriate DMA buffers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span> <span class="o">==</span> <span class="n">B_vmalloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mcam_check_dma_buffers</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mcam_set_config_needed</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return our stored notion of how the camera is/should be configured.</span>
<span class="cm"> * The V4l2 spec wants us to be smarter, and actually get this from</span>
<span class="cm"> * the camera (and not mess with it at open time).  Someday.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_g_fmt_vid_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="n">f</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">pix_format</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We only have one input - the sensor - so minimize the nonsense here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_enum_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_input</span> <span class="o">*</span><span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">input</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">V4L2_INPUT_TYPE_CAMERA</span><span class="p">;</span>
	<span class="n">input</span><span class="o">-&gt;</span><span class="n">std</span> <span class="o">=</span> <span class="n">V4L2_STD_ALL</span><span class="p">;</span> <span class="cm">/* Not sure what should go here */</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;Camera&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_g_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_s_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* from vivi.c */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_s_std</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">v4l2_std_id</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * G/S_PARM.  Most of this is done by the sensor, but we are</span>
<span class="cm"> * the level which controls the number of read buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_g_parm</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_streamparm</span> <span class="o">*</span><span class="n">parms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">g_parm</span><span class="p">,</span> <span class="n">parms</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">parms</span><span class="o">-&gt;</span><span class="n">parm</span><span class="p">.</span><span class="n">capture</span><span class="p">.</span><span class="n">readbuffers</span> <span class="o">=</span> <span class="n">n_dma_bufs</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_s_parm</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_streamparm</span> <span class="o">*</span><span class="n">parms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">s_parm</span><span class="p">,</span> <span class="n">parms</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">parms</span><span class="o">-&gt;</span><span class="n">parm</span><span class="p">.</span><span class="n">capture</span><span class="p">.</span><span class="n">readbuffers</span> <span class="o">=</span> <span class="n">n_dma_bufs</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_g_chip_ident</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_dbg_chip_ident</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ident</span> <span class="o">=</span> <span class="n">V4L2_IDENT_NONE</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v4l2_chip_match_host</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ident</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">chip_id</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">g_chip_ident</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_enum_framesizes</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_frmsizeenum</span> <span class="o">*</span><span class="n">sizes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">enum_framesizes</span><span class="p">,</span> <span class="n">sizes</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_enum_frameintervals</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_frmivalenum</span> <span class="o">*</span><span class="n">interval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">enum_frameintervals</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_VIDEO_ADV_DEBUG</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_g_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_dbg_register</span> <span class="o">*</span><span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v4l2_chip_match_host</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reg</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">mcam_reg_read</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">reg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">g_register</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_vidioc_s_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_dbg_register</span> <span class="o">*</span><span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v4l2_chip_match_host</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">,</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sensor_call</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">core</span><span class="p">,</span> <span class="n">s_register</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_ioctl_ops</span> <span class="n">mcam_v4l_ioctl_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">vidioc_querycap</span>	<span class="o">=</span> <span class="n">mcam_vidioc_querycap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_enum_fmt_vid_cap</span> <span class="o">=</span> <span class="n">mcam_vidioc_enum_fmt_vid_cap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_try_fmt_vid_cap</span>	<span class="o">=</span> <span class="n">mcam_vidioc_try_fmt_vid_cap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_s_fmt_vid_cap</span>	<span class="o">=</span> <span class="n">mcam_vidioc_s_fmt_vid_cap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_g_fmt_vid_cap</span>	<span class="o">=</span> <span class="n">mcam_vidioc_g_fmt_vid_cap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_enum_input</span>	<span class="o">=</span> <span class="n">mcam_vidioc_enum_input</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_g_input</span>		<span class="o">=</span> <span class="n">mcam_vidioc_g_input</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_s_input</span>		<span class="o">=</span> <span class="n">mcam_vidioc_s_input</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_s_std</span>		<span class="o">=</span> <span class="n">mcam_vidioc_s_std</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_reqbufs</span>		<span class="o">=</span> <span class="n">mcam_vidioc_reqbufs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_querybuf</span>	<span class="o">=</span> <span class="n">mcam_vidioc_querybuf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_qbuf</span>		<span class="o">=</span> <span class="n">mcam_vidioc_qbuf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_dqbuf</span>		<span class="o">=</span> <span class="n">mcam_vidioc_dqbuf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_streamon</span>	<span class="o">=</span> <span class="n">mcam_vidioc_streamon</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_streamoff</span>	<span class="o">=</span> <span class="n">mcam_vidioc_streamoff</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_queryctrl</span>	<span class="o">=</span> <span class="n">mcam_vidioc_queryctrl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_g_ctrl</span>		<span class="o">=</span> <span class="n">mcam_vidioc_g_ctrl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_s_ctrl</span>		<span class="o">=</span> <span class="n">mcam_vidioc_s_ctrl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_g_parm</span>		<span class="o">=</span> <span class="n">mcam_vidioc_g_parm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_s_parm</span>		<span class="o">=</span> <span class="n">mcam_vidioc_s_parm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_enum_framesizes</span> <span class="o">=</span> <span class="n">mcam_vidioc_enum_framesizes</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_enum_frameintervals</span> <span class="o">=</span> <span class="n">mcam_vidioc_enum_frameintervals</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_g_chip_ident</span>	<span class="o">=</span> <span class="n">mcam_vidioc_g_chip_ident</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_VIDEO_ADV_DEBUG</span>
	<span class="p">.</span><span class="n">vidioc_g_register</span>	<span class="o">=</span> <span class="n">mcam_vidioc_g_register</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vidioc_s_register</span>	<span class="o">=</span> <span class="n">mcam_vidioc_s_register</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* ---------------------------------------------------------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * Our various file operations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_v4l_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">video_drvdata</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">cam</span><span class="p">;</span>

	<span class="n">frames</span> <span class="o">=</span> <span class="n">singles</span> <span class="o">=</span> <span class="n">delivered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mcam_setup_vb2</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">mcam_ctlr_power_up</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">__mcam_cam_reset</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">mcam_set_config_needed</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_v4l_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">cam_dbg</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;Release, %d frames, %d singles, %d delivered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">frames</span><span class="p">,</span>
			<span class="n">singles</span><span class="p">,</span> <span class="n">delivered</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mcam_ctlr_stop_dma</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">mcam_cleanup_vb2</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">mcam_ctlr_power_down</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span> <span class="o">==</span> <span class="n">B_vmalloc</span> <span class="o">&amp;&amp;</span> <span class="n">alloc_bufs_at_read</span><span class="p">)</span>
			<span class="n">mcam_free_dma_bufs</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mcam_v4l_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
		<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mcam_v4l_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">pt</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcam_v4l_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_mmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_file_operations</span> <span class="n">mcam_v4l_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">mcam_v4l_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">mcam_v4l_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">mcam_v4l_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span> <span class="n">mcam_v4l_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">mcam_v4l_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">video_ioctl2</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * This template device holds all of those v4l2 methods; we</span>
<span class="cm"> * clone it for specific real devices.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">video_device</span> <span class="n">mcam_v4l_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;mcam&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tvnorms</span> <span class="o">=</span> <span class="n">V4L2_STD_NTSC_M</span><span class="p">,</span>
	<span class="p">.</span><span class="n">current_norm</span> <span class="o">=</span> <span class="n">V4L2_STD_NTSC_M</span><span class="p">,</span>  <span class="cm">/* make mplayer happy */</span>

	<span class="p">.</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcam_v4l_fops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcam_v4l_ioctl_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">video_device_release_empty</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* ---------------------------------------------------------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * Interrupt handler stuff</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcam_frame_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Basic frame housekeeping.</span>
<span class="cm">	 */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">CF_DMA_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">next_buf</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">buf_seq</span><span class="p">[</span><span class="n">frame</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">);</span>
	<span class="n">frames</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * &quot;This should never happen&quot;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">S_STREAMING</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Process the frame and set up the next one.</span>
<span class="cm">	 */</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">frame_complete</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * The interrupt handler; this needs to be called from the</span>
<span class="cm"> * platform irq handler with the lock held.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mccic_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irqs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frame</span><span class="p">,</span> <span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mcam_reg_write</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">REG_IRQSTAT</span><span class="p">,</span> <span class="n">FRAMEIRQS</span><span class="p">);</span> <span class="cm">/* Clear&#39;em all */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Handle any frame completions.  There really should</span>
<span class="cm">	 * not be more than one of these, or we have fallen</span>
<span class="cm">	 * far behind.</span>
<span class="cm">	 *</span>
<span class="cm">	 * When running in S/G mode, the frame number lacks any</span>
<span class="cm">	 * real meaning - there&#39;s only one descriptor array - but</span>
<span class="cm">	 * the controller still picks a different one to signal</span>
<span class="cm">	 * each time.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">frame</span> <span class="o">&lt;</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">nbufs</span><span class="p">;</span> <span class="n">frame</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irqs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IRQ_EOF0</span> <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mcam_frame_complete</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
			<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span> <span class="o">==</span> <span class="n">B_DMA_sg</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If a frame starts, note that we have DMA active.  This</span>
<span class="cm">	 * code assumes that we won&#39;t get multiple frame interrupts</span>
<span class="cm">	 * at once; may want to rethink that.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IRQ_SOF0</span> <span class="o">|</span> <span class="n">IRQ_SOF1</span> <span class="o">|</span> <span class="n">IRQ_SOF2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">CF_DMA_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span> <span class="o">==</span> <span class="n">B_DMA_sg</span><span class="p">)</span>
			<span class="n">mcam_ctlr_stop</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">handled</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ---------------------------------------------------------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * Registration and such.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ov7670_config</span> <span class="n">sensor_cfg</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Exclude QCIF mode, because it only captures a tiny portion</span>
<span class="cm">	 * of the sensor FOV</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">min_width</span> <span class="o">=</span> <span class="mi">320</span><span class="p">,</span>
	<span class="p">.</span><span class="n">min_height</span> <span class="o">=</span> <span class="mi">240</span><span class="p">,</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">mccic_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_board_info</span> <span class="n">ov7670_info</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&quot;ov7670&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x42</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">platform_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sensor_cfg</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Validate the requested buffer mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_mode</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span> <span class="o">=</span> <span class="n">buffer_mode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span> <span class="o">==</span> <span class="n">B_DMA_sg</span> <span class="o">&amp;&amp;</span>
			<span class="n">cam</span><span class="o">-&gt;</span><span class="n">chip_id</span> <span class="o">==</span> <span class="n">V4L2_IDENT_CAFE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;marvell-cam: Cafe can&#39;t do S/G I/O, &quot;</span>
			<span class="s">&quot;attempting vmalloc mode instead</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span> <span class="o">=</span> <span class="n">B_vmalloc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mcam_buffer_mode_supported</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;marvell-cam: buffer mode %d unsupported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Register with V4L</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_device_register</span><span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">S_NOTREADY</span><span class="p">;</span>
	<span class="n">mcam_set_config_needed</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">pix_format</span> <span class="o">=</span> <span class="n">mcam_def_pix_format</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">mbus_code</span> <span class="o">=</span> <span class="n">mcam_def_mbus_code</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">);</span>
	<span class="n">mcam_ctlr_init</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to find the sensor.</span>
<span class="cm">	 */</span>
	<span class="n">sensor_cfg</span><span class="p">.</span><span class="n">clock_speed</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">clock_speed</span><span class="p">;</span>
	<span class="n">sensor_cfg</span><span class="p">.</span><span class="n">use_smbus</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">use_smbus</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor_addr</span> <span class="o">=</span> <span class="n">ov7670_info</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor</span> <span class="o">=</span> <span class="n">v4l2_i2c_new_subdev_board</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">,</span>
			<span class="n">cam</span><span class="o">-&gt;</span><span class="n">i2c_adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ov7670_info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">sensor</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unregister</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcam_cam_init</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unregister</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Get the v4l2 setup done.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">vdev</span> <span class="o">=</span> <span class="n">mcam_v4l_template</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">.</span><span class="n">debug</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cam</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">.</span><span class="n">v4l2_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">video_register_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span> <span class="n">VFL_TYPE_GRABBER</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">video_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span> <span class="n">cam</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If so requested, try to get our DMA buffers now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span> <span class="o">==</span> <span class="n">B_vmalloc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">alloc_bufs_at_read</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mcam_alloc_dma_bufs</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">cam_warn</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;Unable to alloc DMA buffers at load&quot;</span>
					<span class="s">&quot; will try again later.&quot;</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">out_unregister:</span>
	<span class="n">v4l2_device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">mccic_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we have no users (and we really, really should have no</span>
<span class="cm">	 * users) the device will already be powered down.  Trying to</span>
<span class="cm">	 * take it down again will wedge the machine, which is frowned</span>
<span class="cm">	 * upon.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cam_warn</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="s">&quot;Removing a device with users!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mcam_ctlr_power_down</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vb2_queue_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span> <span class="o">==</span> <span class="n">B_vmalloc</span><span class="p">)</span>
		<span class="n">mcam_free_dma_bufs</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="n">video_unregister_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="n">v4l2_device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Power management</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PM</span>

<span class="kt">void</span> <span class="nf">mccic_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">mcam_state</span> <span class="n">cstate</span> <span class="o">=</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

		<span class="n">mcam_ctlr_stop_dma</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">mcam_ctlr_power_down</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">cstate</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">mccic_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcam_camera</span> <span class="o">*</span><span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mcam_ctlr_power_up</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
		<span class="n">__mcam_cam_reset</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mcam_ctlr_power_down</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">s_mutex</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">CF_CONFIG_NEEDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">S_STREAMING</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there was a buffer in the DMA engine at suspend</span>
<span class="cm">		 * time, put it back on the queue or we&#39;ll forget about it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffer_mode</span> <span class="o">==</span> <span class="n">B_DMA_sg</span> <span class="o">&amp;&amp;</span> <span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_bufs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">vb_bufs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cam</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mcam_read_setup</span><span class="p">(</span><span class="n">cam</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
