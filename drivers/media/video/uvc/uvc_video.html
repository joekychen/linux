<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › uvc › uvc_video.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>uvc_video.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *      uvc_video.c  --  USB Video Class driver - Video handling</span>
<span class="cm"> *</span>
<span class="cm"> *      Copyright (C) 2005-2010</span>
<span class="cm"> *          Laurent Pinchart (laurent.pinchart@ideasonboard.com)</span>
<span class="cm"> *</span>
<span class="cm"> *      This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *      it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *      the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *      (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/videodev2.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="cp">#include &lt;media/v4l2-common.h&gt;</span>

<span class="cp">#include &quot;uvcvideo.h&quot;</span>

<span class="cm">/* ------------------------------------------------------------------------</span>
<span class="cm"> * UVC Controls</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__uvc_query_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">query</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">unit</span><span class="p">,</span>
			<span class="n">__u8</span> <span class="n">intfnum</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">cs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">size</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u8</span> <span class="n">type</span> <span class="o">=</span> <span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">;</span>

	<span class="n">pipe</span> <span class="o">=</span> <span class="p">(</span><span class="n">query</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">?</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			      <span class="o">:</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">type</span> <span class="o">|=</span> <span class="p">(</span><span class="n">query</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">?</span> <span class="n">USB_DIR_IN</span> <span class="o">:</span> <span class="n">USB_DIR_OUT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">cs</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">,</span>
			<span class="n">unit</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">intfnum</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">uvc_query_name</span><span class="p">(</span><span class="n">__u8</span> <span class="n">query</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UVC_SET_CUR</span>:
		<span class="k">return</span> <span class="s">&quot;SET_CUR&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UVC_GET_CUR</span>:
		<span class="k">return</span> <span class="s">&quot;GET_CUR&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UVC_GET_MIN</span>:
		<span class="k">return</span> <span class="s">&quot;GET_MIN&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UVC_GET_MAX</span>:
		<span class="k">return</span> <span class="s">&quot;GET_MAX&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UVC_GET_RES</span>:
		<span class="k">return</span> <span class="s">&quot;GET_RES&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UVC_GET_LEN</span>:
		<span class="k">return</span> <span class="s">&quot;GET_LEN&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UVC_GET_INFO</span>:
		<span class="k">return</span> <span class="s">&quot;GET_INFO&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UVC_GET_DEF</span>:
		<span class="k">return</span> <span class="s">&quot;GET_DEF&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;&lt;invalid&gt;&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">uvc_query_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">query</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">unit</span><span class="p">,</span>
			<span class="n">__u8</span> <span class="n">intfnum</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">cs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__uvc_query_ctrl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">intfnum</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
				<span class="n">UVC_CTRL_CONTROL_TIMEOUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uvc_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;Failed to query (%s) UVC control %u on &quot;</span>
			<span class="s">&quot;unit %u: %d (exp. %u).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uvc_query_name</span><span class="p">(</span><span class="n">query</span><span class="p">),</span> <span class="n">cs</span><span class="p">,</span>
			<span class="n">unit</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uvc_fixup_video_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">uvc_streaming_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uvc_format</span> <span class="o">*</span><span class="n">format</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uvc_frame</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">nformats</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span> <span class="o">==</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bFormatIndex</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">format</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">format</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bFrameIndex</span> <span class="o">==</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bFrameIndex</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">frame</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">frame</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UVC_FMT_FLAG_COMPRESSED</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">dwMaxVideoFrameSize</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	      <span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">uvc_version</span> <span class="o">&lt;</span> <span class="mh">0x0110</span><span class="p">))</span>
		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">dwMaxVideoFrameSize</span> <span class="o">=</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">dwMaxVideoFrameBufferSize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UVC_FMT_FLAG_COMPRESSED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">UVC_QUIRK_FIX_BANDWIDTH</span> <span class="o">&amp;&amp;</span>
	    <span class="n">stream</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">num_altsetting</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">interval</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">bandwidth</span><span class="p">;</span>

		<span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">dwFrameInterval</span> <span class="o">&gt;</span> <span class="mi">100000</span><span class="p">)</span>
			 <span class="o">?</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">dwFrameInterval</span>
			 <span class="o">:</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">dwFrameInterval</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="cm">/* Compute a bandwidth estimation by multiplying the frame</span>
<span class="cm">		 * size by the number of video frames per second, divide the</span>
<span class="cm">		 * result by the number of USB frames (or micro-frames for</span>
<span class="cm">		 * high-speed devices) per second and add the UVC header size</span>
<span class="cm">		 * (assumed to be 12 bytes long).</span>
<span class="cm">		 */</span>
		<span class="n">bandwidth</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">wWidth</span> <span class="o">*</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">wHeight</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">format</span><span class="o">-&gt;</span><span class="n">bpp</span><span class="p">;</span>
		<span class="n">bandwidth</span> <span class="o">*=</span> <span class="mi">10000000</span> <span class="o">/</span> <span class="n">interval</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bandwidth</span> <span class="o">/=</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span><span class="p">)</span>
			<span class="n">bandwidth</span> <span class="o">/=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">bandwidth</span> <span class="o">+=</span> <span class="mi">12</span><span class="p">;</span>

		<span class="cm">/* The bandwidth estimate is too low for many cameras. Don&#39;t use</span>
<span class="cm">		 * maximum packet sizes lower than 1024 bytes to try and work</span>
<span class="cm">		 * around the problem. According to measurements done on two</span>
<span class="cm">		 * different camera models, the value is high enough to get most</span>
<span class="cm">		 * resolutions working while not preventing two simultaneous</span>
<span class="cm">		 * VGA streams at 15 fps.</span>
<span class="cm">		 */</span>
		<span class="n">bandwidth</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>

		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">dwMaxPayloadTransferSize</span> <span class="o">=</span> <span class="n">bandwidth</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uvc_get_video_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">uvc_streaming_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">probe</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">query</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">uvc_version</span> <span class="o">&gt;=</span> <span class="mh">0x0110</span> <span class="o">?</span> <span class="mi">34</span> <span class="o">:</span> <span class="mi">26</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">UVC_QUIRK_PROBE_DEF</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">query</span> <span class="o">==</span> <span class="n">UVC_GET_DEF</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__uvc_query_ctrl</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">intfnum</span><span class="p">,</span>
		<span class="n">probe</span> <span class="o">?</span> <span class="n">UVC_VS_PROBE_CONTROL</span> <span class="o">:</span> <span class="n">UVC_VS_COMMIT_CONTROL</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
		<span class="n">size</span><span class="p">,</span> <span class="n">uvc_timeout_param</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">query</span> <span class="o">==</span> <span class="n">UVC_GET_MIN</span> <span class="o">||</span> <span class="n">query</span> <span class="o">==</span> <span class="n">UVC_GET_MAX</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Some cameras, mostly based on Bison Electronics chipsets,</span>
<span class="cm">		 * answer a GET_MIN or GET_MAX request with the wCompQuality</span>
<span class="cm">		 * field only.</span>
<span class="cm">		 */</span>
		<span class="n">uvc_warn_once</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">UVC_WARN_MINMAX</span><span class="p">,</span> <span class="s">&quot;UVC non &quot;</span>
			<span class="s">&quot;compliance - GET_MIN/MAX(PROBE) incorrectly &quot;</span>
			<span class="s">&quot;supported. Enabling workaround.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ctrl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>
		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wCompQuality</span> <span class="o">=</span> <span class="n">le16_to_cpup</span><span class="p">((</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">query</span> <span class="o">==</span> <span class="n">UVC_GET_DEF</span> <span class="o">&amp;&amp;</span> <span class="n">probe</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Many cameras don&#39;t support the GET_DEF request on their</span>
<span class="cm">		 * video probe control. Warn once and return, the caller will</span>
<span class="cm">		 * fall back to GET_CUR.</span>
<span class="cm">		 */</span>
		<span class="n">uvc_warn_once</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">UVC_WARN_PROBE_DEF</span><span class="p">,</span> <span class="s">&quot;UVC non &quot;</span>
			<span class="s">&quot;compliance - GET_DEF(PROBE) not supported. &quot;</span>
			<span class="s">&quot;Enabling workaround.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uvc_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;Failed to query (%u) UVC %s control : &quot;</span>
			<span class="s">&quot;%d (exp. %u).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">probe</span> <span class="o">?</span> <span class="s">&quot;probe&quot;</span> <span class="o">:</span> <span class="s">&quot;commit&quot;</span><span class="p">,</span>
			<span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bmHint</span> <span class="o">=</span> <span class="n">le16_to_cpup</span><span class="p">((</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bFormatIndex</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bFrameIndex</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">dwFrameInterval</span> <span class="o">=</span> <span class="n">le32_to_cpup</span><span class="p">((</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wKeyFrameRate</span> <span class="o">=</span> <span class="n">le16_to_cpup</span><span class="p">((</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wPFrameRate</span> <span class="o">=</span> <span class="n">le16_to_cpup</span><span class="p">((</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wCompQuality</span> <span class="o">=</span> <span class="n">le16_to_cpup</span><span class="p">((</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">12</span><span class="p">]);</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wCompWindowSize</span> <span class="o">=</span> <span class="n">le16_to_cpup</span><span class="p">((</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">14</span><span class="p">]);</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wDelay</span> <span class="o">=</span> <span class="n">le16_to_cpup</span><span class="p">((</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">dwMaxVideoFrameSize</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">18</span><span class="p">]);</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">dwMaxPayloadTransferSize</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">22</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">34</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">dwClockFrequency</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">26</span><span class="p">]);</span>
		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bmFramingInfo</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bPreferedVersion</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>
		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bMinVersion</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bMaxVersion</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">33</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">dwClockFrequency</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">clock_frequency</span><span class="p">;</span>
		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bmFramingInfo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bPreferedVersion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bMinVersion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bMaxVersion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Some broken devices return null or wrong dwMaxVideoFrameSize and</span>
<span class="cm">	 * dwMaxPayloadTransferSize fields. Try to get the value from the</span>
<span class="cm">	 * format and frame descriptors.</span>
<span class="cm">	 */</span>
	<span class="n">uvc_fixup_video_ctrl</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uvc_set_video_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">uvc_streaming_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">probe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">uvc_version</span> <span class="o">&gt;=</span> <span class="mh">0x0110</span> <span class="o">?</span> <span class="mi">34</span> <span class="o">:</span> <span class="mi">26</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="o">*</span><span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bmHint</span><span class="p">);</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bFormatIndex</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bFrameIndex</span><span class="p">;</span>
	<span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">dwFrameInterval</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wKeyFrameRate</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wPFrameRate</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wCompQuality</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wCompWindowSize</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">wDelay</span><span class="p">);</span>
	<span class="n">put_unaligned_le32</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">dwMaxVideoFrameSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">18</span><span class="p">]);</span>
	<span class="n">put_unaligned_le32</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">dwMaxPayloadTransferSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">22</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">34</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_unaligned_le32</span><span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">dwClockFrequency</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">26</span><span class="p">]);</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bmFramingInfo</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bPreferedVersion</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bMinVersion</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">33</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">bMaxVersion</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__uvc_query_ctrl</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">UVC_SET_CUR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">intfnum</span><span class="p">,</span>
		<span class="n">probe</span> <span class="o">?</span> <span class="n">UVC_VS_PROBE_CONTROL</span> <span class="o">:</span> <span class="n">UVC_VS_COMMIT_CONTROL</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
		<span class="n">size</span><span class="p">,</span> <span class="n">uvc_timeout_param</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uvc_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;Failed to set UVC %s control : &quot;</span>
			<span class="s">&quot;%d (exp. %u).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">probe</span> <span class="o">?</span> <span class="s">&quot;probe&quot;</span> <span class="o">:</span> <span class="s">&quot;commit&quot;</span><span class="p">,</span>
			<span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">uvc_probe_video</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">uvc_streaming_control</span> <span class="o">*</span><span class="n">probe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uvc_streaming_control</span> <span class="n">probe_min</span><span class="p">,</span> <span class="n">probe_max</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">bandwidth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Perform probing. The device should adjust the requested values</span>
<span class="cm">	 * according to its capabilities. However, some devices, namely the</span>
<span class="cm">	 * first generation UVC Logitech webcams, don&#39;t implement the Video</span>
<span class="cm">	 * Probe control properly, and just return the needed bandwidth. For</span>
<span class="cm">	 * that reason, if the needed bandwidth exceeds the maximum available</span>
<span class="cm">	 * bandwidth, try to lower the quality.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_set_video_ctrl</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* Get the minimum and maximum values for compression settings. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">UVC_QUIRK_PROBE_MINMAX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_get_video_ctrl</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">probe_min</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">UVC_GET_MIN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_get_video_ctrl</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">probe_max</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">UVC_GET_MAX</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

		<span class="n">probe</span><span class="o">-&gt;</span><span class="n">wCompQuality</span> <span class="o">=</span> <span class="n">probe_max</span><span class="p">.</span><span class="n">wCompQuality</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_set_video_ctrl</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_get_video_ctrl</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">UVC_GET_CUR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">num_altsetting</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">bandwidth</span> <span class="o">=</span> <span class="n">probe</span><span class="o">-&gt;</span><span class="n">dwMaxPayloadTransferSize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bandwidth</span> <span class="o">&lt;=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">maxpsize</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">UVC_QUIRK_PROBE_MINMAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* TODO: negotiate compression parameters */</span>
		<span class="n">probe</span><span class="o">-&gt;</span><span class="n">wKeyFrameRate</span> <span class="o">=</span> <span class="n">probe_min</span><span class="p">.</span><span class="n">wKeyFrameRate</span><span class="p">;</span>
		<span class="n">probe</span><span class="o">-&gt;</span><span class="n">wPFrameRate</span> <span class="o">=</span> <span class="n">probe_min</span><span class="p">.</span><span class="n">wPFrameRate</span><span class="p">;</span>
		<span class="n">probe</span><span class="o">-&gt;</span><span class="n">wCompQuality</span> <span class="o">=</span> <span class="n">probe_max</span><span class="p">.</span><span class="n">wCompQuality</span><span class="p">;</span>
		<span class="n">probe</span><span class="o">-&gt;</span><span class="n">wCompWindowSize</span> <span class="o">=</span> <span class="n">probe_min</span><span class="p">.</span><span class="n">wCompWindowSize</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uvc_commit_video</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">uvc_streaming_control</span> <span class="o">*</span><span class="n">probe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uvc_set_video_ctrl</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* -----------------------------------------------------------------------------</span>
<span class="cm"> * Clocks and timestamps</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">uvc_video_clock_decode</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uvc_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		       <span class="k">const</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uvc_clock_sample</span> <span class="o">*</span><span class="n">sample</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">header_size</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">has_pts</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">has_scr</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">host_sof</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">dev_sof</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UVC_STREAM_PTS</span> <span class="o">|</span> <span class="n">UVC_STREAM_SCR</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UVC_STREAM_PTS</span> <span class="o">|</span> <span class="n">UVC_STREAM_SCR</span>:
		<span class="n">header_size</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
		<span class="n">has_pts</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">has_scr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UVC_STREAM_PTS</span>:
		<span class="n">header_size</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="n">has_pts</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UVC_STREAM_SCR</span>:
		<span class="n">header_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">has_scr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">header_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check for invalid headers. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">header_size</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Extract the timestamps:</span>
<span class="cm">	 *</span>
<span class="cm">	 * - store the frame PTS in the buffer structure</span>
<span class="cm">	 * - if the SCR field is present, retrieve the host SOF counter and</span>
<span class="cm">	 *   kernel timestamps and store them with the SCR STC and SOF fields</span>
<span class="cm">	 *   in the ring buffer</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_pts</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">pts</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_scr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* To limit the amount of data, drop SCRs with an SOF identical to the</span>
<span class="cm">	 * previous one.</span>
<span class="cm">	 */</span>
	<span class="n">dev_sof</span> <span class="o">=</span> <span class="n">get_unaligned_le16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">header_size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_sof</span> <span class="o">==</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">last_sof</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">last_sof</span> <span class="o">=</span> <span class="n">dev_sof</span><span class="p">;</span>

	<span class="n">host_sof</span> <span class="o">=</span> <span class="n">usb_get_current_frame_number</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">);</span>
	<span class="n">ktime_get_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>

	<span class="cm">/* The UVC specification allows device implementations that can&#39;t obtain</span>
<span class="cm">	 * the USB frame number to keep their own frame counters as long as they</span>
<span class="cm">	 * match the size and frequency of the frame number associated with USB</span>
<span class="cm">	 * SOF tokens. The SOF values sent by such devices differ from the USB</span>
<span class="cm">	 * SOF tokens by a fixed offset that needs to be estimated and accounted</span>
<span class="cm">	 * for to make timestamp recovery as accurate as possible.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The offset is estimated the first time a device SOF value is received</span>
<span class="cm">	 * as the difference between the host and device SOF values. As the two</span>
<span class="cm">	 * SOF values can differ slightly due to transmission delays, consider</span>
<span class="cm">	 * that the offset is null if the difference is not higher than 10 ms</span>
<span class="cm">	 * (negative differences can not happen and are thus considered as an</span>
<span class="cm">	 * offset). The video commit control wDelay field should be used to</span>
<span class="cm">	 * compute a dynamic threshold instead of using a fixed 10 ms value, but</span>
<span class="cm">	 * devices don&#39;t report reliable wDelay values.</span>
<span class="cm">	 *</span>
<span class="cm">	 * See uvc_video_clock_host_sof() for an explanation regarding why only</span>
<span class="cm">	 * the 8 LSBs of the delta are kept.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">sof_offset</span> <span class="o">==</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">delta_sof</span> <span class="o">=</span> <span class="p">(</span><span class="n">host_sof</span> <span class="o">-</span> <span class="n">dev_sof</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta_sof</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">sof_offset</span> <span class="o">=</span> <span class="n">delta_sof</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">sof_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_sof</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev_sof</span> <span class="o">+</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">sof_offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">2047</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">sample</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">samples</span><span class="p">[</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">head</span><span class="p">];</span>
	<span class="n">sample</span><span class="o">-&gt;</span><span class="n">dev_stc</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">header_size</span> <span class="o">-</span> <span class="mi">6</span><span class="p">]);</span>
	<span class="n">sample</span><span class="o">-&gt;</span><span class="n">dev_sof</span> <span class="o">=</span> <span class="n">dev_sof</span><span class="p">;</span>
	<span class="n">sample</span><span class="o">-&gt;</span><span class="n">host_sof</span> <span class="o">=</span> <span class="n">host_sof</span><span class="p">;</span>
	<span class="n">sample</span><span class="o">-&gt;</span><span class="n">host_ts</span> <span class="o">=</span> <span class="n">ts</span><span class="p">;</span>

	<span class="cm">/* Update the sliding window head and count. */</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uvc_video_clock_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uvc_clock</span> <span class="o">*</span><span class="n">clock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span>

	<span class="n">clock</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">clock</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">clock</span><span class="o">-&gt;</span><span class="n">last_sof</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">clock</span><span class="o">-&gt;</span><span class="n">sof_offset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uvc_video_clock_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uvc_clock</span> <span class="o">*</span><span class="n">clock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">clock</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

	<span class="n">clock</span><span class="o">-&gt;</span><span class="n">samples</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">samples</span><span class="p">),</span>
				 <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">samples</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">uvc_video_clock_reset</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uvc_video_clock_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">samples</span><span class="p">);</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">samples</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * uvc_video_clock_host_sof - Return the host SOF value for a clock sample</span>
<span class="cm"> *</span>
<span class="cm"> * Host SOF counters reported by usb_get_current_frame_number() usually don&#39;t</span>
<span class="cm"> * cover the whole 11-bits SOF range (0-2047) but are limited to the HCI frame</span>
<span class="cm"> * schedule window. They can be limited to 8, 9 or 10 bits depending on the host</span>
<span class="cm"> * controller and its configuration.</span>
<span class="cm"> *</span>
<span class="cm"> * We thus need to recover the SOF value corresponding to the host frame number.</span>
<span class="cm"> * As the device and host frame numbers are sampled in a short interval, the</span>
<span class="cm"> * difference between their values should be equal to a small delta plus an</span>
<span class="cm"> * integer multiple of 256 caused by the host frame number limited precision.</span>
<span class="cm"> *</span>
<span class="cm"> * To obtain the recovered host SOF value, compute the small delta by masking</span>
<span class="cm"> * the high bits of the host frame counter and device SOF difference and add it</span>
<span class="cm"> * to the device SOF value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">uvc_video_clock_host_sof</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uvc_clock_sample</span> <span class="o">*</span><span class="n">sample</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The delta value can be negative. */</span>
	<span class="n">s8</span> <span class="n">delta_sof</span><span class="p">;</span>

	<span class="n">delta_sof</span> <span class="o">=</span> <span class="p">(</span><span class="n">sample</span><span class="o">-&gt;</span><span class="n">host_sof</span> <span class="o">-</span> <span class="n">sample</span><span class="o">-&gt;</span><span class="n">dev_sof</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">sample</span><span class="o">-&gt;</span><span class="n">dev_sof</span> <span class="o">+</span> <span class="n">delta_sof</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">2047</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * uvc_video_clock_update - Update the buffer timestamp</span>
<span class="cm"> *</span>
<span class="cm"> * This function converts the buffer PTS timestamp to the host clock domain by</span>
<span class="cm"> * going through the USB SOF clock domain and stores the result in the V4L2</span>
<span class="cm"> * buffer timestamp field.</span>
<span class="cm"> *</span>
<span class="cm"> * The relationship between the device clock and the host clock isn&#39;t known.</span>
<span class="cm"> * However, the device and the host share the common USB SOF clock which can be</span>
<span class="cm"> * used to recover that relationship.</span>
<span class="cm"> *</span>
<span class="cm"> * The relationship between the device clock and the USB SOF clock is considered</span>
<span class="cm"> * to be linear over the clock samples sliding window and is given by</span>
<span class="cm"> *</span>
<span class="cm"> * SOF = m * PTS + p</span>
<span class="cm"> *</span>
<span class="cm"> * Several methods to compute the slope (m) and intercept (p) can be used. As</span>
<span class="cm"> * the clock drift should be small compared to the sliding window size, we</span>
<span class="cm"> * assume that the line that goes through the points at both ends of the window</span>
<span class="cm"> * is a good approximation. Naming those points P1 and P2, we get</span>
<span class="cm"> *</span>
<span class="cm"> * SOF = (SOF2 - SOF1) / (STC2 - STC1) * PTS</span>
<span class="cm"> *     + (SOF1 * STC2 - SOF2 * STC1) / (STC2 - STC1)</span>
<span class="cm"> *</span>
<span class="cm"> * or</span>
<span class="cm"> *</span>
<span class="cm"> * SOF = ((SOF2 - SOF1) * PTS + SOF1 * STC2 - SOF2 * STC1) / (STC2 - STC1)   (1)</span>
<span class="cm"> *</span>
<span class="cm"> * to avoid loosing precision in the division. Similarly, the host timestamp is</span>
<span class="cm"> * computed with</span>
<span class="cm"> *</span>
<span class="cm"> * TS = ((TS2 - TS1) * PTS + TS1 * SOF2 - TS2 * SOF1) / (SOF2 - SOF1)	     (2)</span>
<span class="cm"> *</span>
<span class="cm"> * SOF values are coded on 11 bits by USB. We extend their precision with 16</span>
<span class="cm"> * decimal bits, leading to a 11.16 coding.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: To avoid surprises with device clock values, PTS/STC timestamps should</span>
<span class="cm"> * be normalized using the nominal device clock frequency reported through the</span>
<span class="cm"> * UVC descriptors.</span>
<span class="cm"> *</span>
<span class="cm"> * Both the PTS/STC and SOF counters roll over, after a fixed but device</span>
<span class="cm"> * specific amount of time for PTS/STC and after 2048ms for SOF. As long as the</span>
<span class="cm"> * sliding window size is smaller than the rollover period, differences computed</span>
<span class="cm"> * on unsigned integers will produce the correct result. However, the p term in</span>
<span class="cm"> * the linear relations will be miscomputed.</span>
<span class="cm"> *</span>
<span class="cm"> * To fix the issue, we subtract a constant from the PTS and STC values to bring</span>
<span class="cm"> * PTS to half the 32 bit STC range. The sliding window STC values then fit into</span>
<span class="cm"> * the 32 bit range without any rollover.</span>
<span class="cm"> *</span>
<span class="cm"> * Similarly, we add 2048 to the device SOF values to make sure that the SOF</span>
<span class="cm"> * computed by (1) will never be smaller than 0. This offset is then compensated</span>
<span class="cm"> * by adding 2048 to the SOF values used in (2). However, this doesn&#39;t prevent</span>
<span class="cm"> * rollovers between (1) and (2): the SOF value computed by (1) can be slightly</span>
<span class="cm"> * lower than 4096, and the host SOF counters can have rolled over to 2048. This</span>
<span class="cm"> * case is handled by subtracting 2048 from the SOF value if it exceeds the host</span>
<span class="cm"> * SOF value at the end of the sliding window.</span>
<span class="cm"> *</span>
<span class="cm"> * Finally we subtract a constant from the host timestamps to bring the first</span>
<span class="cm"> * timestamp of the sliding window to 1s.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">uvc_video_clock_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="o">*</span><span class="n">v4l2_buf</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">uvc_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uvc_clock</span> <span class="o">*</span><span class="n">clock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uvc_clock_sample</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uvc_clock_sample</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">delta_stc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mean</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sof</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">div</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rem</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">y</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">first</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">samples</span><span class="p">[</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">];</span>
	<span class="n">last</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">samples</span><span class="p">[(</span><span class="n">clock</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">];</span>

	<span class="cm">/* First step, PTS to SOF conversion. */</span>
	<span class="n">delta_stc</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">pts</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">);</span>
	<span class="n">x1</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">dev_stc</span> <span class="o">-</span> <span class="n">delta_stc</span><span class="p">;</span>
	<span class="n">x2</span> <span class="o">=</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">dev_stc</span> <span class="o">-</span> <span class="n">delta_stc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x1</span> <span class="o">==</span> <span class="n">x2</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">y1</span> <span class="o">=</span> <span class="p">(</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">dev_sof</span> <span class="o">+</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">y2</span> <span class="o">=</span> <span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">dev_sof</span> <span class="o">+</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">y2</span> <span class="o">&lt;</span> <span class="n">y1</span><span class="p">)</span>
		<span class="n">y2</span> <span class="o">+=</span> <span class="mi">2048</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">y1</span> <span class="o">*</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">x2</span>
	  <span class="o">-</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">y2</span> <span class="o">*</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">x1</span><span class="p">;</span>
	<span class="n">y</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">);</span>

	<span class="n">sof</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>

	<span class="n">uvc_trace</span><span class="p">(</span><span class="n">UVC_TRACE_CLOCK</span><span class="p">,</span> <span class="s">&quot;%s: PTS %u y %llu.%06llu SOF %u.%06llu &quot;</span>
		  <span class="s">&quot;(x1 %u x2 %u y1 %u y2 %u SOF offset %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">pts</span><span class="p">,</span>
		  <span class="n">y</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">div_u64</span><span class="p">((</span><span class="n">y</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000</span><span class="p">,</span> <span class="mi">65536</span><span class="p">),</span>
		  <span class="n">sof</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">div_u64</span><span class="p">(((</span><span class="n">u64</span><span class="p">)</span><span class="n">sof</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000LLU</span><span class="p">,</span> <span class="mi">65536</span><span class="p">),</span>
		  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">clock</span><span class="o">-&gt;</span><span class="n">sof_offset</span><span class="p">);</span>

	<span class="cm">/* Second step, SOF to host clock conversion. */</span>
	<span class="n">x1</span> <span class="o">=</span> <span class="p">(</span><span class="n">uvc_video_clock_host_sof</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">x2</span> <span class="o">=</span> <span class="p">(</span><span class="n">uvc_video_clock_host_sof</span><span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x2</span> <span class="o">&lt;</span> <span class="n">x1</span><span class="p">)</span>
		<span class="n">x2</span> <span class="o">+=</span> <span class="mi">2048</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x1</span> <span class="o">==</span> <span class="n">x2</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">ts</span> <span class="o">=</span> <span class="n">timespec_sub</span><span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">host_ts</span><span class="p">,</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">host_ts</span><span class="p">);</span>
	<span class="n">y1</span> <span class="o">=</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>
	<span class="n">y2</span> <span class="o">=</span> <span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span> <span class="o">+</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>

	<span class="cm">/* Interpolated and host SOF timestamps can wrap around at slightly</span>
<span class="cm">	 * different times. Handle this by adding or removing 2048 to or from</span>
<span class="cm">	 * the computed SOF value to keep it close to the SOF samples mean</span>
<span class="cm">	 * value.</span>
<span class="cm">	 */</span>
	<span class="n">mean</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mean</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1024</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sof</span><span class="p">)</span>
		<span class="n">sof</span> <span class="o">+=</span> <span class="mi">2048</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sof</span> <span class="o">&gt;</span> <span class="n">mean</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1024</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">))</span>
		<span class="n">sof</span> <span class="o">-=</span> <span class="mi">2048</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">sof</span> <span class="o">+</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">y1</span> <span class="o">*</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">x2</span>
	  <span class="o">-</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">y2</span> <span class="o">*</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">x1</span><span class="p">;</span>
	<span class="n">y</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">);</span>

	<span class="n">div</span> <span class="o">=</span> <span class="n">div_u64_rem</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem</span><span class="p">);</span>
	<span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">host_ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">div</span><span class="p">;</span>
	<span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">host_ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">+</span> <span class="n">rem</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">&gt;=</span> <span class="n">NSEC_PER_SEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-=</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">uvc_trace</span><span class="p">(</span><span class="n">UVC_TRACE_CLOCK</span><span class="p">,</span> <span class="s">&quot;%s: SOF %u.%06llu y %llu ts %lu.%06lu &quot;</span>
		  <span class="s">&quot;buf ts %lu.%06lu (x1 %u/%u/%u x2 %u/%u/%u y1 %u y2 %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		  <span class="n">sof</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">div_u64</span><span class="p">(((</span><span class="n">u64</span><span class="p">)</span><span class="n">sof</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000LLU</span><span class="p">,</span> <span class="mi">65536</span><span class="p">),</span>
		  <span class="n">y</span><span class="p">,</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">/</span> <span class="n">NSEC_PER_USEC</span><span class="p">,</span>
		  <span class="n">v4l2_buf</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">v4l2_buf</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">,</span>
		  <span class="n">x1</span><span class="p">,</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">host_sof</span><span class="p">,</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">dev_sof</span><span class="p">,</span>
		  <span class="n">x2</span><span class="p">,</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">host_sof</span><span class="p">,</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">dev_sof</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">);</span>

	<span class="cm">/* Update the V4L2 buffer. */</span>
	<span class="n">v4l2_buf</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">v4l2_buf</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">/</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------------------</span>
<span class="cm"> * Stream statistics</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uvc_video_stats_decode</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">header_size</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">has_pts</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">has_scr</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">scr_sof</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">scr_stc</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">pts</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_frames</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_packets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ktime_get_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">start_ts</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UVC_STREAM_PTS</span> <span class="o">|</span> <span class="n">UVC_STREAM_SCR</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UVC_STREAM_PTS</span> <span class="o">|</span> <span class="n">UVC_STREAM_SCR</span>:
		<span class="n">header_size</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
		<span class="n">has_pts</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">has_scr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UVC_STREAM_PTS</span>:
		<span class="n">header_size</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="n">has_pts</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UVC_STREAM_SCR</span>:
		<span class="n">header_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">has_scr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">header_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check for invalid headers. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">header_size</span> <span class="o">||</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">header_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_invalid</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Extract the timestamps. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_pts</span><span class="p">)</span>
		<span class="n">pts</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">has_scr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scr_stc</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">header_size</span> <span class="o">-</span> <span class="mi">6</span><span class="p">]);</span>
		<span class="n">scr_sof</span> <span class="o">=</span> <span class="n">get_unaligned_le16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">header_size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* Is PTS constant through the whole frame ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_pts</span> <span class="o">&amp;&amp;</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_pts</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">pts</span> <span class="o">!=</span> <span class="n">pts</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_pts_diffs</span><span class="o">++</span><span class="p">;</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">last_pts_diff</span> <span class="o">=</span>
				<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_packets</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">has_pts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_pts</span><span class="o">++</span><span class="p">;</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">pts</span> <span class="o">=</span> <span class="n">pts</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do all frames have a PTS in their first non-empty packet, or before</span>
<span class="cm">	 * their first empty packet ?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">header_size</span><span class="p">)</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">has_initial_pts</span> <span class="o">=</span> <span class="n">has_pts</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">header_size</span> <span class="o">&amp;&amp;</span> <span class="n">has_pts</span><span class="p">)</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">has_early_pts</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do the SCR.STC and SCR.SOF fields vary through the frame ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_scr</span> <span class="o">&amp;&amp;</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_scr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">scr_stc</span> <span class="o">!=</span> <span class="n">scr_stc</span><span class="p">)</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_scr_diffs</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">has_scr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Expand the SOF counter to 32 bits and store its value. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_frames</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_scr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">scr_sof_count</span> <span class="o">+=</span>
				<span class="p">(</span><span class="n">scr_sof</span> <span class="o">-</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">scr_sof</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2048</span><span class="p">;</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">scr_sof</span> <span class="o">=</span> <span class="n">scr_sof</span><span class="p">;</span>

		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_scr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">scr_stc</span> <span class="o">=</span> <span class="n">scr_stc</span><span class="p">;</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">scr_sof</span> <span class="o">=</span> <span class="n">scr_sof</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">scr_sof</span> <span class="o">&lt;</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">min_sof</span><span class="p">)</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">min_sof</span> <span class="o">=</span> <span class="n">scr_sof</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scr_sof</span> <span class="o">&gt;</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">max_sof</span><span class="p">)</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">max_sof</span> <span class="o">=</span> <span class="n">scr_sof</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Record the first non-empty packet number. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">header_size</span><span class="p">)</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">first_data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_packets</span><span class="p">;</span>

	<span class="cm">/* Update the frame size. */</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">header_size</span><span class="p">;</span>

	<span class="cm">/* Update the packets counters. */</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">header_size</span><span class="p">)</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_empty</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">UVC_STREAM_ERR</span><span class="p">)</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_errors</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uvc_video_stats_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uvc_stats_frame</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>

	<span class="n">uvc_trace</span><span class="p">(</span><span class="n">UVC_TRACE_STATS</span><span class="p">,</span> <span class="s">&quot;frame %u stats: %u/%u/%u packets, &quot;</span>
		  <span class="s">&quot;%u/%u/%u pts (%searly %sinitial), %u/%u scr, &quot;</span>
		  <span class="s">&quot;last pts/stc/sof %u/%u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">stream</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">first_data</span><span class="p">,</span>
		  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_packets</span> <span class="o">-</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_empty</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_packets</span><span class="p">,</span>
		  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_pts_diffs</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_pts_diff</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_pts</span><span class="p">,</span>
		  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">has_early_pts</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;!&quot;</span><span class="p">,</span>
		  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">has_initial_pts</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;!&quot;</span><span class="p">,</span>
		  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_scr_diffs</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_scr</span><span class="p">,</span>
		  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">pts</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">scr_stc</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">scr_sof</span><span class="p">);</span>

	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_frames</span><span class="o">++</span><span class="p">;</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_packets</span> <span class="o">+=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_packets</span><span class="p">;</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_empty</span> <span class="o">+=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_empty</span><span class="p">;</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_errors</span> <span class="o">+=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_errors</span><span class="p">;</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_invalid</span> <span class="o">+=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_invalid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">has_early_pts</span><span class="p">)</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_pts_early</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">has_initial_pts</span><span class="p">)</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_pts_initial</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_pts_diff</span> <span class="o">&lt;=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">first_data</span><span class="p">)</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_pts_constant</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_scr</span> <span class="o">&gt;=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_packets</span> <span class="o">-</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_empty</span><span class="p">)</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_scr_count_ok</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_scr_diffs</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_scr</span><span class="p">)</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_scr_diffs_ok</span><span class="o">++</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">uvc_video_stats_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scr_sof_freq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">duration</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">stop_ts</span><span class="p">.</span><span class="n">tv_sec</span>
		  <span class="o">-</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">start_ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">stop_ts</span><span class="p">.</span><span class="n">tv_nsec</span>
		   <span class="o">-</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">start_ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="o">--</span><span class="p">;</span>
		<span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">+=</span> <span class="mi">1000000000</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Compute the SCR.SOF frequency estimate. At the nominal 1kHz SOF</span>
<span class="cm">	 * frequency this will not overflow before more than 1h.</span>
<span class="cm">	 */</span>
	<span class="n">duration</span> <span class="o">=</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">+</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">duration</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">scr_sof_freq</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">scr_sof_count</span> <span class="o">*</span> <span class="mi">1000</span>
			     <span class="o">/</span> <span class="n">duration</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">scr_sof_freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">count</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="n">count</span><span class="p">,</span>
			   <span class="s">&quot;frames:  %u</span><span class="se">\n</span><span class="s">packets: %u</span><span class="se">\n</span><span class="s">empty:   %u</span><span class="se">\n</span><span class="s">&quot;</span>
			   <span class="s">&quot;errors:  %u</span><span class="se">\n</span><span class="s">invalid: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_frames</span><span class="p">,</span>
			   <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_packets</span><span class="p">,</span>
			   <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_empty</span><span class="p">,</span>
			   <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_errors</span><span class="p">,</span>
			   <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_invalid</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">count</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="n">count</span><span class="p">,</span>
			   <span class="s">&quot;pts: %u early, %u initial, %u ok</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_pts_early</span><span class="p">,</span>
			   <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_pts_initial</span><span class="p">,</span>
			   <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_pts_constant</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">count</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="n">count</span><span class="p">,</span>
			   <span class="s">&quot;scr: %u count ok, %u diff ok</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_scr_count_ok</span><span class="p">,</span>
			   <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">nb_scr_diffs_ok</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">count</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="n">count</span><span class="p">,</span>
			   <span class="s">&quot;sof: %u &lt;= sof &lt;= %u, freq %u.%03u kHz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">min_sof</span><span class="p">,</span>
			   <span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">max_sof</span><span class="p">,</span>
			   <span class="n">scr_sof_freq</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">scr_sof_freq</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uvc_video_stats_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">));</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">min_sof</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uvc_video_stats_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_get_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">stop_ts</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------------------</span>
<span class="cm"> * Video codecs</span>
<span class="cm"> */</span>

<span class="cm">/* Video payload decoding is handled by uvc_video_decode_start(),</span>
<span class="cm"> * uvc_video_decode_data() and uvc_video_decode_end().</span>
<span class="cm"> *</span>
<span class="cm"> * uvc_video_decode_start is called with URB data at the start of a bulk or</span>
<span class="cm"> * isochronous payload. It processes header data and returns the header size</span>
<span class="cm"> * in bytes if successful. If an error occurs, it returns a negative error</span>
<span class="cm"> * code. The following error codes have special meanings.</span>
<span class="cm"> *</span>
<span class="cm"> * - EAGAIN informs the caller that the current video buffer should be marked</span>
<span class="cm"> *   as done, and that the function should be called again with the same data</span>
<span class="cm"> *   and a new video buffer. This is used when end of frame conditions can be</span>
<span class="cm"> *   reliably detected at the beginning of the next frame only.</span>
<span class="cm"> *</span>
<span class="cm"> * If an error other than -EAGAIN is returned, the caller will drop the current</span>
<span class="cm"> * payload. No call to uvc_video_decode_data and uvc_video_decode_end will be</span>
<span class="cm"> * made until the next payload. -ENODATA can be used to drop the current</span>
<span class="cm"> * payload if no other error code is appropriate.</span>
<span class="cm"> *</span>
<span class="cm"> * uvc_video_decode_data is called for every URB with URB data. It copies the</span>
<span class="cm"> * data to the video buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * uvc_video_decode_end is called with header data at the end of a bulk or</span>
<span class="cm"> * isochronous payload. It performs any additional header data processing and</span>
<span class="cm"> * returns 0 or a negative error code if an error occurred. As header data have</span>
<span class="cm"> * already been processed by uvc_video_decode_start, this functions isn&#39;t</span>
<span class="cm"> * required to perform sanity checks a second time.</span>
<span class="cm"> *</span>
<span class="cm"> * For isochronous transfers where a payload is always transferred in a single</span>
<span class="cm"> * URB, the three functions will be called in a row.</span>
<span class="cm"> *</span>
<span class="cm"> * To let the decoder process header data and update its internal state even</span>
<span class="cm"> * when no video buffer is available, uvc_video_decode_start must be prepared</span>
<span class="cm"> * to be called with a NULL buf parameter. uvc_video_decode_data and</span>
<span class="cm"> * uvc_video_decode_end will never be called with a NULL buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uvc_video_decode_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">uvc_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u8</span> <span class="n">fid</span><span class="p">;</span>

	<span class="cm">/* Sanity checks:</span>
<span class="cm">	 * - packet must be at least 2 bytes long</span>
<span class="cm">	 * - bHeaderLength value must be at least 2 bytes (see above)</span>
<span class="cm">	 * - bHeaderLength value can&#39;t be larger than the packet size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">nb_invalid</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fid</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">UVC_STREAM_FID</span><span class="p">;</span>

	<span class="cm">/* Increase the sequence number regardless of any buffer states, so</span>
<span class="cm">	 * that discontinuous sequence numbers always indicate lost frames.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">last_fid</span> <span class="o">!=</span> <span class="n">fid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">)</span>
			<span class="n">uvc_video_stats_update</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">uvc_video_clock_decode</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">uvc_video_stats_decode</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Store the payload FID bit and return immediately when the buffer is</span>
<span class="cm">	 * NULL.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">last_fid</span> <span class="o">=</span> <span class="n">fid</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Mark the buffer as bad if the error bit is set. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">UVC_STREAM_ERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uvc_trace</span><span class="p">(</span><span class="n">UVC_TRACE_FRAME</span><span class="p">,</span> <span class="s">&quot;Marking buffer as bad (error bit &quot;</span>
			  <span class="s">&quot;set).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Synchronize to the input stream by waiting for the FID bit to be</span>
<span class="cm">	 * toggled when the the buffer state is not UVC_BUF_STATE_ACTIVE.</span>
<span class="cm">	 * stream-&gt;last_fid is initialized to -1, so the first isochronous</span>
<span class="cm">	 * frame will always be in sync.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the device doesn&#39;t toggle the FID bit, invert stream-&gt;last_fid</span>
<span class="cm">	 * when the EOF bit is set to force synchronisation on the next packet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">UVC_BUF_STATE_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fid</span> <span class="o">==</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">last_fid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uvc_trace</span><span class="p">(</span><span class="n">UVC_TRACE_FRAME</span><span class="p">,</span> <span class="s">&quot;Dropping payload (out of &quot;</span>
				<span class="s">&quot;sync).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">UVC_QUIRK_STREAM_NO_FID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">UVC_STREAM_EOF</span><span class="p">))</span>
				<span class="n">stream</span><span class="o">-&gt;</span><span class="n">last_fid</span> <span class="o">^=</span> <span class="n">UVC_STREAM_FID</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">uvc_clock_param</span> <span class="o">==</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">)</span>
			<span class="n">ktime_get_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ktime_get_real_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>

		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">;</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">timestamp</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">timestamp</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span>
			<span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">/</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>

		<span class="cm">/* TODO: Handle PTS and SCR. */</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UVC_BUF_STATE_ACTIVE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Mark the buffer as done if we&#39;re at the beginning of a new frame.</span>
<span class="cm">	 * End of frame detection is better implemented by checking the EOF</span>
<span class="cm">	 * bit (FID bit toggling is delayed by one frame compared to the EOF</span>
<span class="cm">	 * bit), but some devices don&#39;t set the bit at end of frame (and the</span>
<span class="cm">	 * last payload can be lost anyway). We thus must check if the FID has</span>
<span class="cm">	 * been toggled.</span>
<span class="cm">	 *</span>
<span class="cm">	 * stream-&gt;last_fid is initialized to -1, so the first isochronous</span>
<span class="cm">	 * frame will never trigger an end of frame detection.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Empty buffers (bytesused == 0) don&#39;t trigger end of frame detection</span>
<span class="cm">	 * as it doesn&#39;t make sense to return an empty buffer. This also</span>
<span class="cm">	 * avoids detecting end of frame conditions at FID toggling if the</span>
<span class="cm">	 * previous payload had the EOF bit set.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fid</span> <span class="o">!=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">last_fid</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytesused</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uvc_trace</span><span class="p">(</span><span class="n">UVC_TRACE_FRAME</span><span class="p">,</span> <span class="s">&quot;Frame complete (FID bit &quot;</span>
				<span class="s">&quot;toggled).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UVC_BUF_STATE_READY</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">last_fid</span> <span class="o">=</span> <span class="n">fid</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uvc_video_decode_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">uvc_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxlen</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Copy the video data to the buffer. */</span>
	<span class="n">maxlen</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytesused</span><span class="p">;</span>
	<span class="n">mem</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">mem</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytesused</span><span class="p">;</span>
	<span class="n">nbytes</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">len</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytesused</span> <span class="o">+=</span> <span class="n">nbytes</span><span class="p">;</span>

	<span class="cm">/* Complete the current frame if the buffer size was exceeded. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">maxlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uvc_trace</span><span class="p">(</span><span class="n">UVC_TRACE_FRAME</span><span class="p">,</span> <span class="s">&quot;Frame complete (overflow).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UVC_BUF_STATE_READY</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uvc_video_decode_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">uvc_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Mark the buffer as done if the EOF marker is set. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">UVC_STREAM_EOF</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytesused</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uvc_trace</span><span class="p">(</span><span class="n">UVC_TRACE_FRAME</span><span class="p">,</span> <span class="s">&quot;Frame complete (EOF found).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">uvc_trace</span><span class="p">(</span><span class="n">UVC_TRACE_FRAME</span><span class="p">,</span> <span class="s">&quot;EOF in empty payload.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UVC_BUF_STATE_READY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">UVC_QUIRK_STREAM_NO_FID</span><span class="p">)</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">last_fid</span> <span class="o">^=</span> <span class="n">UVC_STREAM_FID</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Video payload encoding is handled by uvc_video_encode_header() and</span>
<span class="cm"> * uvc_video_encode_data(). Only bulk transfers are currently supported.</span>
<span class="cm"> *</span>
<span class="cm"> * uvc_video_encode_header is called at the start of a payload. It adds header</span>
<span class="cm"> * data to the transfer buffer and returns the header size. As the only known</span>
<span class="cm"> * UVC output device transfers a whole frame in a single payload, the EOF bit</span>
<span class="cm"> * is always set in the header.</span>
<span class="cm"> *</span>
<span class="cm"> * uvc_video_encode_data is called for every URB and copies the data from the</span>
<span class="cm"> * video buffer to the transfer buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uvc_video_encode_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">uvc_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* Header length */</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">UVC_STREAM_EOH</span> <span class="o">|</span> <span class="n">UVC_STREAM_EOF</span>
		<span class="o">|</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">last_fid</span> <span class="o">&amp;</span> <span class="n">UVC_STREAM_FID</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uvc_video_encode_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">uvc_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uvc_video_queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nbytes</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>

	<span class="cm">/* Copy video data to the URB buffer. */</span>
	<span class="n">mem</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">mem</span> <span class="o">+</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">buf_used</span><span class="p">;</span>
	<span class="n">nbytes</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">len</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytesused</span> <span class="o">-</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">buf_used</span><span class="p">);</span>
	<span class="n">nbytes</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">max_payload_size</span> <span class="o">-</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">payload_size</span><span class="p">,</span>
			<span class="n">nbytes</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>

	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">buf_used</span> <span class="o">+=</span> <span class="n">nbytes</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nbytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------------------</span>
<span class="cm"> * URB handling</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Completion handler for video URBs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uvc_video_decode_isoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">uvc_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uvc_trace</span><span class="p">(</span><span class="n">UVC_TRACE_FRAME</span><span class="p">,</span> <span class="s">&quot;USB isochronous frame &quot;</span>
				<span class="s">&quot;lost (%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span><span class="p">);</span>
			<span class="cm">/* Mark the buffer as faulty. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">buf</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Decode the payload header. */</span>
		<span class="n">mem</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">+</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_video_decode_start</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">actual_length</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
				<span class="n">buf</span> <span class="o">=</span> <span class="n">uvc_queue_next_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span>
							    <span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Decode the payload data. */</span>
		<span class="n">uvc_video_decode_data</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">mem</span> <span class="o">+</span> <span class="n">ret</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">actual_length</span> <span class="o">-</span> <span class="n">ret</span><span class="p">);</span>

		<span class="cm">/* Process the header again. */</span>
		<span class="n">uvc_video_decode_end</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">actual_length</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">UVC_BUF_STATE_READY</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">!=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytesused</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">cur_format</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span>
			      <span class="n">UVC_FMT_FLAG_COMPRESSED</span><span class="p">))</span>
				<span class="n">buf</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">buf</span> <span class="o">=</span> <span class="n">uvc_queue_next_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uvc_video_decode_bulk</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">uvc_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mem</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">payload_size</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* If the URB is the first of its payload, decode and save the</span>
<span class="cm">	 * header.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">header_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">skip_payload</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_video_decode_start</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
				<span class="n">buf</span> <span class="o">=</span> <span class="n">uvc_queue_next_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span>
							    <span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>

		<span class="cm">/* If an error occurred skip the rest of the payload. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">skip_payload</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">header</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">header_size</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>

			<span class="n">mem</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* The buffer queue might have been cancelled while a bulk transfer</span>
<span class="cm">	 * was in progress, so we can reach here with buf equal to NULL. Make</span>
<span class="cm">	 * sure buf is never dereferenced if NULL.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Process video data. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">skip_payload</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">uvc_video_decode_data</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Detect the payload end by a URB smaller than the maximum size (or</span>
<span class="cm">	 * a payload size equal to the maximum) and process the header again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">||</span>
	    <span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">payload_size</span> <span class="o">&gt;=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">max_payload_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">skip_payload</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uvc_video_decode_end</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">header</span><span class="p">,</span>
				<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">payload_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">UVC_BUF_STATE_READY</span><span class="p">)</span>
				<span class="n">buf</span> <span class="o">=</span> <span class="n">uvc_queue_next_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span>
							    <span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">header_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">skip_payload</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">payload_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uvc_video_encode_bulk</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">uvc_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_size</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If the URB is the first of its payload, add the header. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">header_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_video_encode_header</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">header_size</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">payload_size</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">mem</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Process video data. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_video_encode_data</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">payload_size</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytesused</span> <span class="o">==</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">buf_used</span> <span class="o">||</span>
	    <span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">payload_size</span> <span class="o">==</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">max_payload_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytesused</span> <span class="o">==</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">buf_used</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">.</span><span class="n">buf_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UVC_BUF_STATE_READY</span><span class="p">;</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">v4l2_buf</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="o">++</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">;</span>
			<span class="n">uvc_queue_next_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">last_fid</span> <span class="o">^=</span> <span class="n">UVC_STREAM_FID</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">header_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">payload_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_size</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uvc_video_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uvc_video_queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uvc_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">uvc_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="s">&quot;Non-zero status (%d) in video &quot;</span>
			<span class="s">&quot;completion handler.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:		<span class="cm">/* usb_kill_urb() called. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">frozen</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:	<span class="cm">/* usb_unlink_urb() called. */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:	<span class="cm">/* The endpoint is being disabled. */</span>
		<span class="n">uvc_queue_cancel</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">irqlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">irqqueue</span><span class="p">))</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">irqqueue</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uvc_buffer</span><span class="p">,</span>
				       <span class="n">queue</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">irqlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">decode</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uvc_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;Failed to resubmit video URB (%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free transfer buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uvc_free_urb_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UVC_URBS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
<span class="cp">#ifndef CONFIG_DMA_NONCOHERENT</span>
			<span class="n">usb_free_coherent</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_size</span><span class="p">,</span>
				<span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_dma</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="cp">#else</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="cp">#endif</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate transfer buffers. This function can be called with buffers</span>
<span class="cm"> * already allocated when resuming from suspend, in which case it will</span>
<span class="cm"> * return without touching the buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * Limit the buffer size to UVC_MAX_PACKETS bulk/isochronous packets. If the</span>
<span class="cm"> * system is too low on memory try successively smaller numbers of packets</span>
<span class="cm"> * until allocation succeeds.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of allocated packets on success or 0 when out of memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uvc_alloc_urb_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">psize</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">npackets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Buffers are already allocated, bail out. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_size</span> <span class="o">/</span> <span class="n">psize</span><span class="p">;</span>

	<span class="cm">/* Compute the number of packets. Bulk endpoints might transfer UVC</span>
<span class="cm">	 * payloads across multiple URBs.</span>
<span class="cm">	 */</span>
	<span class="n">npackets</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">psize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">npackets</span> <span class="o">&gt;</span> <span class="n">UVC_MAX_PACKETS</span><span class="p">)</span>
		<span class="n">npackets</span> <span class="o">=</span> <span class="n">UVC_MAX_PACKETS</span><span class="p">;</span>

	<span class="cm">/* Retry allocations until one succeed. */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">npackets</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="n">npackets</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UVC_URBS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_size</span> <span class="o">=</span> <span class="n">psize</span> <span class="o">*</span> <span class="n">npackets</span><span class="p">;</span>
<span class="cp">#ifndef CONFIG_DMA_NONCOHERENT</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">usb_alloc_coherent</span><span class="p">(</span>
				<span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_size</span><span class="p">,</span>
				<span class="n">gfp_flags</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_dma</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="cp">#else</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			    <span class="n">kmalloc</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_size</span><span class="p">,</span> <span class="n">gfp_flags</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">uvc_free_urb_buffers</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">UVC_URBS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uvc_trace</span><span class="p">(</span><span class="n">UVC_TRACE_VIDEO</span><span class="p">,</span> <span class="s">&quot;Allocated %u URB buffers &quot;</span>
				<span class="s">&quot;of %ux%u bytes each.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">UVC_URBS</span><span class="p">,</span> <span class="n">npackets</span><span class="p">,</span>
				<span class="n">psize</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">npackets</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">uvc_trace</span><span class="p">(</span><span class="n">UVC_TRACE_VIDEO</span><span class="p">,</span> <span class="s">&quot;Failed to allocate URB buffers (%u bytes &quot;</span>
		<span class="s">&quot;per packet).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">psize</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Uninitialize isochronous/bulk URBs and free transfer buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uvc_uninit_video</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">free_buffers</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">uvc_video_stats_stop</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UVC_URBS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">free_buffers</span><span class="p">)</span>
		<span class="n">uvc_free_urb_buffers</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize isochronous URBs and allocate transfer buffers. The packet size</span>
<span class="cm"> * is given by the endpoint.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uvc_init_video_isoc</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">npackets</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">psize</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">psize</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">wMaxPacketSize</span><span class="p">);</span>
	<span class="n">psize</span> <span class="o">=</span> <span class="p">(</span><span class="n">psize</span> <span class="o">&amp;</span> <span class="mh">0x07ff</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">psize</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">));</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">dwMaxVideoFrameSize</span><span class="p">;</span>

	<span class="n">npackets</span> <span class="o">=</span> <span class="n">uvc_alloc_urb_buffers</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">npackets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">npackets</span> <span class="o">*</span> <span class="n">psize</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UVC_URBS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="n">npackets</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uvc_uninit_video</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">stream</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">usb_rcvisocpipe</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
				<span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_DMA_NONCOHERENT</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">=</span> <span class="n">URB_ISO_ASAP</span> <span class="o">|</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_dma</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cp">#else</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">=</span> <span class="n">URB_ISO_ASAP</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterval</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">uvc_video_complete</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span> <span class="o">=</span> <span class="n">npackets</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">npackets</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">psize</span><span class="p">;</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">psize</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize bulk URBs and allocate transfer buffers. The packet size is</span>
<span class="cm"> * given by the endpoint.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uvc_init_video_bulk</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">npackets</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">psize</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">psize</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">wMaxPacketSize</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x07ff</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">dwMaxPayloadTransferSize</span><span class="p">;</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">max_payload_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">npackets</span> <span class="o">=</span> <span class="n">uvc_alloc_urb_buffers</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">npackets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">npackets</span> <span class="o">*</span> <span class="n">psize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usb_endpoint_dir_in</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">))</span>
		<span class="n">pipe</span> <span class="o">=</span> <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
				       <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pipe</span> <span class="o">=</span> <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
				       <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">V4L2_BUF_TYPE_VIDEO_OUTPUT</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UVC_URBS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uvc_uninit_video</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">size</span><span class="p">,</span> <span class="n">uvc_video_complete</span><span class="p">,</span>
			<span class="n">stream</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_DMA_NONCOHERENT</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">=</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb_dma</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cp">#endif</span>

		<span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize isochronous/bulk URBs and allocate transfer buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uvc_init_video</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">intf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">last_fid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">header_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">skip_payload</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">bulk</span><span class="p">.</span><span class="n">payload_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">uvc_video_stats_start</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">num_altsetting</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">best_ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">best_psize</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bandwidth</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">altsetting</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">intfnum</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">intfnum</span><span class="p">;</span>

		<span class="cm">/* Isochronous endpoint, select the alternate setting. */</span>
		<span class="n">bandwidth</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">dwMaxPayloadTransferSize</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bandwidth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uvc_trace</span><span class="p">(</span><span class="n">UVC_TRACE_VIDEO</span><span class="p">,</span> <span class="s">&quot;Device requested null &quot;</span>
				<span class="s">&quot;bandwidth, defaulting to lowest.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">bandwidth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">uvc_trace</span><span class="p">(</span><span class="n">UVC_TRACE_VIDEO</span><span class="p">,</span> <span class="s">&quot;Device requested %u &quot;</span>
				<span class="s">&quot;B/frame bandwidth.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">num_altsetting</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alts</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">psize</span><span class="p">;</span>

			<span class="n">alts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="n">uvc_find_endpoint</span><span class="p">(</span><span class="n">alts</span><span class="p">,</span>
				<span class="n">stream</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* Check if the bandwidth is high enough. */</span>
			<span class="n">psize</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">wMaxPacketSize</span><span class="p">);</span>
			<span class="n">psize</span> <span class="o">=</span> <span class="p">(</span><span class="n">psize</span> <span class="o">&amp;</span> <span class="mh">0x07ff</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">psize</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">psize</span> <span class="o">&gt;=</span> <span class="n">bandwidth</span> <span class="o">&amp;&amp;</span> <span class="n">psize</span> <span class="o">&lt;=</span> <span class="n">best_psize</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">altsetting</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">best_psize</span> <span class="o">=</span> <span class="n">psize</span><span class="p">;</span>
				<span class="n">best_ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">best_ep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uvc_trace</span><span class="p">(</span><span class="n">UVC_TRACE_VIDEO</span><span class="p">,</span> <span class="s">&quot;No fast enough alt setting &quot;</span>
				<span class="s">&quot;for requested bandwidth.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">uvc_trace</span><span class="p">(</span><span class="n">UVC_TRACE_VIDEO</span><span class="p">,</span> <span class="s">&quot;Selecting alternate setting %u &quot;</span>
			<span class="s">&quot;(%u B/frame bandwidth).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">altsetting</span><span class="p">,</span> <span class="n">best_psize</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_set_interface</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">intfnum</span><span class="p">,</span> <span class="n">altsetting</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_init_video_isoc</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">best_ep</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Bulk endpoint, proceed to URB initialization. */</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">uvc_find_endpoint</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				<span class="n">stream</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_init_video_bulk</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Submit the URBs. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UVC_URBS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">gfp_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uvc_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;Failed to submit URB %u &quot;</span>
					<span class="s">&quot;(%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">uvc_uninit_video</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* --------------------------------------------------------------------------</span>
<span class="cm"> * Suspend/resume</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Stop streaming without disabling the video queue.</span>
<span class="cm"> *</span>
<span class="cm"> * To let userspace applications resume without trouble, we must not touch the</span>
<span class="cm"> * video buffers in any way. We mark the device as frozen to make sure the URB</span>
<span class="cm"> * completion handler won&#39;t try to cancel the queue when we kill the URBs.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">uvc_video_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uvc_queue_streaming</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">uvc_uninit_video</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">usb_set_interface</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">intfnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reconfigure the video interface and restart streaming if it was enabled</span>
<span class="cm"> * before suspend.</span>
<span class="cm"> *</span>
<span class="cm"> * If an error occurs, disable the video queue. This will wake all pending</span>
<span class="cm"> * buffers, making sure userspace applications are notified of the problem</span>
<span class="cm"> * instead of waiting forever.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">uvc_video_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* If the bus has been reset on resume, set the alternate setting to 0.</span>
<span class="cm">	 * This should be the default value, but some devices crash or otherwise</span>
<span class="cm">	 * misbehave if they don&#39;t receive a SET_INTERFACE request before any</span>
<span class="cm">	 * other video control request.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span>
		<span class="n">usb_set_interface</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">intfnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">uvc_video_clock_reset</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_commit_video</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uvc_queue_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uvc_queue_streaming</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_init_video</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">uvc_queue_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ------------------------------------------------------------------------</span>
<span class="cm"> * Video device</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the UVC video device by switching to alternate setting 0 and</span>
<span class="cm"> * retrieve the default format.</span>
<span class="cm"> *</span>
<span class="cm"> * Some cameras (namely the Fuji Finepix) set the format and frame</span>
<span class="cm"> * indexes to zero. The UVC standard doesn&#39;t clearly make this a spec</span>
<span class="cm"> * violation, so try to silently fix the values if possible.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called before registering the device with V4L.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">uvc_video_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uvc_streaming_control</span> <span class="o">*</span><span class="n">probe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uvc_format</span> <span class="o">*</span><span class="n">format</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uvc_frame</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">nformats</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uvc_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;No supported video formats found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Initialize the video buffers queue. */</span>
	<span class="n">uvc_queue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="o">!</span><span class="n">uvc_no_drop_param</span><span class="p">);</span>

	<span class="cm">/* Alternate setting 0 should be the default, yet the XBox Live Vision</span>
<span class="cm">	 * Cam (and possibly other devices) crash or otherwise misbehave if</span>
<span class="cm">	 * they don&#39;t receive a SET_INTERFACE request before any other video</span>
<span class="cm">	 * control request.</span>
<span class="cm">	 */</span>
	<span class="n">usb_set_interface</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">intfnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Set the streaming probe control with default streaming parameters</span>
<span class="cm">	 * retrieved from the device. Webcams that don&#39;t suport GET_DEF</span>
<span class="cm">	 * requests on the probe control will just keep their current streaming</span>
<span class="cm">	 * parameters.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uvc_get_video_ctrl</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">UVC_GET_DEF</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">uvc_set_video_ctrl</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Initialize the streaming parameters with the probe control current</span>
<span class="cm">	 * value. This makes sure SET_CUR requests on the streaming commit</span>
<span class="cm">	 * control will always use values retrieved from a successful GET_CUR</span>
<span class="cm">	 * request on the probe control, as required by the UVC specification.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_get_video_ctrl</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">UVC_GET_CUR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Check if the default format descriptor exists. Use the first</span>
<span class="cm">	 * available format otherwise.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">nformats</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">format</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">probe</span><span class="o">-&gt;</span><span class="n">bFormatIndex</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">nframes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uvc_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;No frame descriptor found for the &quot;</span>
			<span class="s">&quot;default format.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Zero bFrameIndex might be correct. Stream-based formats (including</span>
<span class="cm">	 * MPEG-2 TS and DV) do not support frames but have a dummy frame</span>
<span class="cm">	 * descriptor with bFrameIndex set to zero. If the default frame</span>
<span class="cm">	 * descriptor is not found, use the first available frame.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">format</span><span class="o">-&gt;</span><span class="n">nframes</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">frame</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">bFrameIndex</span> <span class="o">==</span> <span class="n">probe</span><span class="o">-&gt;</span><span class="n">bFrameIndex</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">probe</span><span class="o">-&gt;</span><span class="n">bFormatIndex</span> <span class="o">=</span> <span class="n">format</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="n">probe</span><span class="o">-&gt;</span><span class="n">bFrameIndex</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">bFrameIndex</span><span class="p">;</span>

	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">cur_format</span> <span class="o">=</span> <span class="n">format</span><span class="p">;</span>
	<span class="n">stream</span><span class="o">-&gt;</span><span class="n">cur_frame</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>

	<span class="cm">/* Select the video decoding function */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">quirks</span> <span class="o">&amp;</span> <span class="n">UVC_QUIRK_BUILTIN_ISIGHT</span><span class="p">)</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">decode</span> <span class="o">=</span> <span class="n">uvc_video_decode_isight</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">num_altsetting</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">decode</span> <span class="o">=</span> <span class="n">uvc_video_decode_isoc</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">decode</span> <span class="o">=</span> <span class="n">uvc_video_decode_bulk</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">num_altsetting</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">stream</span><span class="o">-&gt;</span><span class="n">decode</span> <span class="o">=</span> <span class="n">uvc_video_encode_bulk</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">uvc_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;Isochronous endpoints are not &quot;</span>
				<span class="s">&quot;supported for video output devices.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable or disable the video stream.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">uvc_video_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">uvc_streaming</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uvc_uninit_video</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">usb_set_interface</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">intfnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">uvc_queue_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">uvc_video_clock_cleanup</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_video_clock_init</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_queue_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_queue</span><span class="p">;</span>

	<span class="cm">/* Commit the streaming parameters. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_commit_video</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_commit</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">uvc_init_video</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_video</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_video:</span>
	<span class="n">usb_set_interface</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">intfnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">error_commit:</span>
	<span class="n">uvc_queue_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">error_queue:</span>
	<span class="n">uvc_video_clock_cleanup</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
