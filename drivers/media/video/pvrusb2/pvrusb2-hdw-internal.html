<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › pvrusb2 › pvrusb2-hdw-internal.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>pvrusb2-hdw-internal.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2005 Mike Isely &lt;isely@pobox.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __PVRUSB2_HDW_INTERNAL_H</span>
<span class="cp">#define __PVRUSB2_HDW_INTERNAL_H</span>

<span class="cm">/*</span>

<span class="cm">  This header sets up all the internal structures and definitions needed to</span>
<span class="cm">  track and coordinate the driver&#39;s interaction with the hardware.  ONLY</span>
<span class="cm">  source files which actually implement part of that whole circus should be</span>
<span class="cm">  including this header.  Higher levels, like the external layers to the</span>
<span class="cm">  various public APIs (V4L, sysfs, etc) should NOT ever include this</span>
<span class="cm">  private, internal header.  This means that pvrusb2-hdw, pvrusb2-encoder,</span>
<span class="cm">  etc will include this, but pvrusb2-v4l should not.</span>

<span class="cm">*/</span>

<span class="cp">#include &lt;linux/videodev2.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &quot;pvrusb2-hdw.h&quot;</span>
<span class="cp">#include &quot;pvrusb2-io.h&quot;</span>
<span class="cp">#include &lt;media/v4l2-device.h&gt;</span>
<span class="cp">#include &lt;media/cx2341x.h&gt;</span>
<span class="cp">#include &lt;media/ir-kbd-i2c.h&gt;</span>
<span class="cp">#include &quot;pvrusb2-devattr.h&quot;</span>

<span class="cm">/* Legal values for PVR2_CID_HSM */</span>
<span class="cp">#define PVR2_CVAL_HSM_FAIL 0</span>
<span class="cp">#define PVR2_CVAL_HSM_FULL 1</span>
<span class="cp">#define PVR2_CVAL_HSM_HIGH 2</span>

<span class="cp">#define PVR2_VID_ENDPOINT        0x84</span>
<span class="cp">#define PVR2_UNK_ENDPOINT        0x86    </span><span class="cm">/* maybe raw yuv ? */</span><span class="cp"></span>
<span class="cp">#define PVR2_VBI_ENDPOINT        0x88</span>

<span class="cp">#define PVR2_CTL_BUFFSIZE        64</span>

<span class="cp">#define FREQTABLE_SIZE 500</span>

<span class="cp">#define LOCK_TAKE(x) do { mutex_lock(&amp;x##_mutex); x##_held = !0; } while (0)</span>
<span class="cp">#define LOCK_GIVE(x) do { x##_held = 0; mutex_unlock(&amp;x##_mutex); } while (0)</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pvr2_ctlf_is_dirty</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pvr2_ctrl</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pvr2_ctlf_clear_dirty</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pvr2_ctrl</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pvr2_ctlf_check_value</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pvr2_ctrl</span> <span class="o">*</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pvr2_ctlf_get_value</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pvr2_ctrl</span> <span class="o">*</span><span class="p">,</span><span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pvr2_ctlf_set_value</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pvr2_ctrl</span> <span class="o">*</span><span class="p">,</span><span class="kt">int</span> <span class="n">msk</span><span class="p">,</span><span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pvr2_ctlf_val_to_sym</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pvr2_ctrl</span> <span class="o">*</span><span class="p">,</span><span class="kt">int</span> <span class="n">msk</span><span class="p">,</span><span class="kt">int</span> <span class="n">val</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="o">*</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pvr2_ctlf_sym_to_val</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pvr2_ctrl</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="o">*</span><span class="n">mskp</span><span class="p">,</span><span class="kt">int</span> <span class="o">*</span><span class="n">valp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pvr2_ctlf_get_v4lflags</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pvr2_ctrl</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* This structure describes a specific control.  A table of these is set up</span>
<span class="cm">   in pvrusb2-hdw.c. */</span>
<span class="k">struct</span> <span class="n">pvr2_ctl_info</span> <span class="p">{</span>
	<span class="cm">/* Control&#39;s name suitable for use as an identifier */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/* Short description of control */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>

	<span class="cm">/* Control&#39;s implementation */</span>
	<span class="n">pvr2_ctlf_get_value</span> <span class="n">get_value</span><span class="p">;</span>      <span class="cm">/* Get its value */</span>
	<span class="n">pvr2_ctlf_get_value</span> <span class="n">get_def_value</span><span class="p">;</span>  <span class="cm">/* Get its default value */</span>
	<span class="n">pvr2_ctlf_get_value</span> <span class="n">get_min_value</span><span class="p">;</span>  <span class="cm">/* Get minimum allowed value */</span>
	<span class="n">pvr2_ctlf_get_value</span> <span class="n">get_max_value</span><span class="p">;</span>  <span class="cm">/* Get maximum allowed value */</span>
	<span class="n">pvr2_ctlf_set_value</span> <span class="n">set_value</span><span class="p">;</span>      <span class="cm">/* Set its value */</span>
	<span class="n">pvr2_ctlf_check_value</span> <span class="n">check_value</span><span class="p">;</span>  <span class="cm">/* Check that value is valid */</span>
	<span class="n">pvr2_ctlf_val_to_sym</span> <span class="n">val_to_sym</span><span class="p">;</span>    <span class="cm">/* Custom convert value-&gt;symbol */</span>
	<span class="n">pvr2_ctlf_sym_to_val</span> <span class="n">sym_to_val</span><span class="p">;</span>    <span class="cm">/* Custom convert symbol-&gt;value */</span>
	<span class="n">pvr2_ctlf_is_dirty</span> <span class="n">is_dirty</span><span class="p">;</span>        <span class="cm">/* Return true if dirty */</span>
	<span class="n">pvr2_ctlf_clear_dirty</span> <span class="n">clear_dirty</span><span class="p">;</span>  <span class="cm">/* Clear dirty state */</span>
	<span class="n">pvr2_ctlf_get_v4lflags</span> <span class="n">get_v4lflags</span><span class="p">;</span><span class="cm">/* Retrieve v4l flags */</span>

	<span class="cm">/* Control&#39;s type (int, enum, bitmask) */</span>
	<span class="k">enum</span> <span class="n">pvr2_ctl_type</span> <span class="n">type</span><span class="p">;</span>

	<span class="cm">/* Associated V4L control ID, if any */</span>
	<span class="kt">int</span> <span class="n">v4l_id</span><span class="p">;</span>

	<span class="cm">/* Associated driver internal ID, if any */</span>
	<span class="kt">int</span> <span class="n">internal_id</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t implicitly initialize this control&#39;s value */</span>
	<span class="kt">int</span> <span class="n">skip_init</span><span class="p">;</span>

	<span class="cm">/* Starting value for this control */</span>
	<span class="kt">int</span> <span class="n">default_value</span><span class="p">;</span>

	<span class="cm">/* Type-specific control information */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span> <span class="cm">/* Integer control */</span>
			<span class="kt">long</span> <span class="n">min_value</span><span class="p">;</span> <span class="cm">/* lower limit */</span>
			<span class="kt">long</span> <span class="n">max_value</span><span class="p">;</span> <span class="cm">/* upper limit */</span>
		<span class="p">}</span> <span class="n">type_int</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span> <span class="cm">/* enumerated control */</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>       <span class="cm">/* enum value count */</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">value_names</span><span class="p">;</span> <span class="cm">/* symbol names */</span>
		<span class="p">}</span> <span class="n">type_enum</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span> <span class="cm">/* bitmask control */</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">valid_bits</span><span class="p">;</span> <span class="cm">/* bits in use */</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">bit_names</span><span class="p">;</span>  <span class="cm">/* symbol name/bit */</span>
		<span class="p">}</span> <span class="n">type_bitmask</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">def</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* Same as pvr2_ctl_info, but includes storage for the control description */</span>
<span class="cp">#define PVR2_CTLD_INFO_DESC_SIZE 32</span>
<span class="k">struct</span> <span class="n">pvr2_ctld_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pvr2_ctl_info</span> <span class="n">info</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">desc</span><span class="p">[</span><span class="n">PVR2_CTLD_INFO_DESC_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pvr2_ctrl</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pvr2_ctl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pvr2_hdw</span> <span class="o">*</span><span class="n">hdw</span><span class="p">;</span>
<span class="p">};</span>



<span class="cm">/* Disposition of firmware1 loading situation */</span>
<span class="cp">#define FW1_STATE_UNKNOWN 0</span>
<span class="cp">#define FW1_STATE_MISSING 1</span>
<span class="cp">#define FW1_STATE_FAILED 2</span>
<span class="cp">#define FW1_STATE_RELOAD 3</span>
<span class="cp">#define FW1_STATE_OK 4</span>

<span class="cm">/* What state the device is in if it is a hybrid */</span>
<span class="cp">#define PVR2_PATHWAY_UNKNOWN 0</span>
<span class="cp">#define PVR2_PATHWAY_ANALOG 1</span>
<span class="cp">#define PVR2_PATHWAY_DIGITAL 2</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pvr2_i2c_func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pvr2_hdw</span> <span class="o">*</span><span class="p">,</span><span class="n">u8</span><span class="p">,</span><span class="n">u8</span> <span class="o">*</span><span class="p">,</span><span class="n">u16</span><span class="p">,</span><span class="n">u8</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
<span class="cp">#define PVR2_I2C_FUNC_CNT 128</span>

<span class="cm">/* This structure contains all state data directly needed to</span>
<span class="cm">   manipulate the hardware (as opposed to complying with a kernel</span>
<span class="cm">   interface) */</span>
<span class="k">struct</span> <span class="n">pvr2_hdw</span> <span class="p">{</span>
	<span class="cm">/* Underlying USB device handle */</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">usb_intf</span><span class="p">;</span>

	<span class="cm">/* Our handle into the v4l2 sub-device architecture */</span>
	<span class="k">struct</span> <span class="n">v4l2_device</span> <span class="n">v4l2_dev</span><span class="p">;</span>
	<span class="cm">/* Device description, anything that must adjust behavior based on</span>
<span class="cm">	   device specific info will use information held here. */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pvr2_device_desc</span> <span class="o">*</span><span class="n">hdw_desc</span><span class="p">;</span>

	<span class="cm">/* Kernel worker thread handling */</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">workqueue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">workpoll</span><span class="p">;</span>     <span class="cm">/* Update driver state */</span>

	<span class="cm">/* Video spigot */</span>
	<span class="k">struct</span> <span class="n">pvr2_stream</span> <span class="o">*</span><span class="n">vid_stream</span><span class="p">;</span>

	<span class="cm">/* Mutex for all hardware state control */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">big_lock_mutex</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">big_lock_held</span><span class="p">;</span>  <span class="cm">/* For debugging */</span>

	<span class="cm">/* This is a simple string which identifies the instance of this</span>
<span class="cm">	   driver.  It is unique within the set of existing devices, but</span>
<span class="cm">	   there is no attempt to keep the name consistent with the same</span>
<span class="cm">	   physical device each time. */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

	<span class="cm">/* This is a simple string which identifies the physical device</span>
<span class="cm">	   instance itself - if possible.  (If not possible, then it is</span>
<span class="cm">	   based on the specific driver instance, similar to name above.)</span>
<span class="cm">	   The idea here is that userspace might hopefully be able to use</span>
<span class="cm">	   this recognize specific tuners.  It will encode a serial number,</span>
<span class="cm">	   if available. */</span>
	<span class="kt">char</span> <span class="n">identifier</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

	<span class="cm">/* I2C stuff */</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="n">i2c_adap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_algorithm</span> <span class="n">i2c_algo</span><span class="p">;</span>
	<span class="n">pvr2_i2c_func</span> <span class="n">i2c_func</span><span class="p">[</span><span class="n">PVR2_I2C_FUNC_CNT</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i2c_cx25840_hack_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i2c_linked</span><span class="p">;</span>

	<span class="cm">/* IR related */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ir_scheme_active</span><span class="p">;</span> <span class="cm">/* IR scheme as seen from the outside */</span>
	<span class="k">struct</span> <span class="n">IR_i2c_init_data</span> <span class="n">ir_init_data</span><span class="p">;</span> <span class="cm">/* params passed to IR modules */</span>

	<span class="cm">/* Frequency table */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freqTable</span><span class="p">[</span><span class="n">FREQTABLE_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freqProgSlot</span><span class="p">;</span>

	<span class="cm">/* Stuff for handling low level control interaction with device */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">ctl_lock_mutex</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctl_lock_held</span><span class="p">;</span>  <span class="cm">/* For debugging */</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">ctl_write_urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">ctl_read_urb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ctl_write_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ctl_read_buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctl_write_pend_flag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctl_read_pend_flag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctl_timeout_flag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">ctl_done</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd_buffer</span><span class="p">[</span><span class="n">PVR2_CTL_BUFFSIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">cmd_debug_state</span><span class="p">;</span>               <span class="c1">// Low level command debugging info</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd_debug_code</span><span class="p">;</span>      <span class="c1">//</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd_debug_write_len</span><span class="p">;</span>  <span class="c1">//</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd_debug_read_len</span><span class="p">;</span>   <span class="c1">//</span>

	<span class="cm">/* Bits of state that describe what is going on with various parts</span>
<span class="cm">	   of the driver. */</span>
	<span class="kt">int</span> <span class="n">state_pathway_ok</span><span class="p">;</span>         <span class="cm">/* Pathway config is ok */</span>
	<span class="kt">int</span> <span class="n">state_encoder_ok</span><span class="p">;</span>         <span class="cm">/* Encoder is operational */</span>
	<span class="kt">int</span> <span class="n">state_encoder_run</span><span class="p">;</span>        <span class="cm">/* Encoder is running */</span>
	<span class="kt">int</span> <span class="n">state_encoder_config</span><span class="p">;</span>     <span class="cm">/* Encoder is configured */</span>
	<span class="kt">int</span> <span class="n">state_encoder_waitok</span><span class="p">;</span>     <span class="cm">/* Encoder pre-wait done */</span>
	<span class="kt">int</span> <span class="n">state_encoder_runok</span><span class="p">;</span>      <span class="cm">/* Encoder has run for &gt;= .25 sec */</span>
	<span class="kt">int</span> <span class="n">state_decoder_run</span><span class="p">;</span>        <span class="cm">/* Decoder is running */</span>
	<span class="kt">int</span> <span class="n">state_decoder_ready</span><span class="p">;</span>      <span class="cm">/* Decoder is stabilized &amp; streamable */</span>
	<span class="kt">int</span> <span class="n">state_usbstream_run</span><span class="p">;</span>      <span class="cm">/* FX2 is streaming */</span>
	<span class="kt">int</span> <span class="n">state_decoder_quiescent</span><span class="p">;</span>  <span class="cm">/* Decoder idle for minimal interval */</span>
	<span class="kt">int</span> <span class="n">state_pipeline_config</span><span class="p">;</span>    <span class="cm">/* Pipeline is configured */</span>
	<span class="kt">int</span> <span class="n">state_pipeline_req</span><span class="p">;</span>       <span class="cm">/* Somebody wants to stream */</span>
	<span class="kt">int</span> <span class="n">state_pipeline_pause</span><span class="p">;</span>     <span class="cm">/* Pipeline must be paused */</span>
	<span class="kt">int</span> <span class="n">state_pipeline_idle</span><span class="p">;</span>      <span class="cm">/* Pipeline not running */</span>

	<span class="cm">/* This is the master state of the driver.  It is the combined</span>
<span class="cm">	   result of other bits of state.  Examining this will indicate the</span>
<span class="cm">	   overall state of the driver.  Values here are one of</span>
<span class="cm">	   PVR2_STATE_xxxx */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">master_state</span><span class="p">;</span>

	<span class="cm">/* True if device led is currently on */</span>
	<span class="kt">int</span> <span class="n">led_on</span><span class="p">;</span>

	<span class="cm">/* True if states must be re-evaluated */</span>
	<span class="kt">int</span> <span class="n">state_stale</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">state_func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">state_data</span><span class="p">;</span>

	<span class="cm">/* Timer for measuring required decoder settling time before we&#39;re</span>
<span class="cm">	   allowed to fire it up again. */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">quiescent_timer</span><span class="p">;</span>

	<span class="cm">/* Timer for measuring decoder stabilization time, which is the</span>
<span class="cm">	   amount of time we need to let the decoder run before we can</span>
<span class="cm">	   trust its output (otherwise the encoder might see garbage and</span>
<span class="cm">	   then fail to start correctly). */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">decoder_stabilization_timer</span><span class="p">;</span>

	<span class="cm">/* Timer for measuring encoder pre-wait time */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">encoder_wait_timer</span><span class="p">;</span>

	<span class="cm">/* Timer for measuring encoder minimum run time */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">encoder_run_timer</span><span class="p">;</span>

	<span class="cm">/* Place to block while waiting for state changes */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">state_wait_data</span><span class="p">;</span>


	<span class="kt">int</span> <span class="n">force_dirty</span><span class="p">;</span>        <span class="cm">/* consider all controls dirty if true */</span>
	<span class="kt">int</span> <span class="n">flag_ok</span><span class="p">;</span>            <span class="cm">/* device in known good state */</span>
	<span class="kt">int</span> <span class="n">flag_modulefail</span><span class="p">;</span>    <span class="cm">/* true if at least one module failed to load */</span>
	<span class="kt">int</span> <span class="n">flag_disconnected</span><span class="p">;</span>  <span class="cm">/* flag_ok == 0 due to disconnect */</span>
	<span class="kt">int</span> <span class="n">flag_init_ok</span><span class="p">;</span>       <span class="cm">/* true if structure is fully initialized */</span>
	<span class="kt">int</span> <span class="n">fw1_state</span><span class="p">;</span>          <span class="cm">/* current situation with fw1 */</span>
	<span class="kt">int</span> <span class="n">pathway_state</span><span class="p">;</span>      <span class="cm">/* one of PVR2_PATHWAY_xxx */</span>
	<span class="kt">int</span> <span class="n">flag_decoder_missed</span><span class="p">;</span><span class="cm">/* We&#39;ve noticed missing decoder */</span>
	<span class="kt">int</span> <span class="n">flag_tripped</span><span class="p">;</span>       <span class="cm">/* Indicates overall failure to start */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">decoder_client_id</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>CPU firmware info (used to help find / save firmware data)</p></td><td class="code"><div class="highlight"><pre>	<span class="kt">char</span> <span class="o">*</span><span class="n">fw_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fw_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fw_cpu_flag</span><span class="p">;</span> <span class="cm">/* True if we are dealing with the CPU */</span>

	<span class="cm">/* Tuner / frequency control stuff */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tuner_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tuner_updated</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freqValTelevision</span><span class="p">;</span>  <span class="cm">/* Current freq for tv mode */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freqValRadio</span><span class="p">;</span>       <span class="cm">/* Current freq for radio mode */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freqSlotTelevision</span><span class="p">;</span> <span class="cm">/* Current slot for tv mode */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freqSlotRadio</span><span class="p">;</span>      <span class="cm">/* Current slot for radio mode */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freqSelector</span><span class="p">;</span>       <span class="cm">/* 0=radio 1=television */</span>
	<span class="kt">int</span> <span class="n">freqDirty</span><span class="p">;</span>

	<span class="cm">/* Current tuner info - this information is polled from the I2C bus */</span>
	<span class="k">struct</span> <span class="n">v4l2_tuner</span> <span class="n">tuner_signal_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tuner_signal_stale</span><span class="p">;</span>

	<span class="cm">/* Cropping capability info */</span>
	<span class="k">struct</span> <span class="n">v4l2_cropcap</span> <span class="n">cropcap_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cropcap_stale</span><span class="p">;</span>

	<span class="cm">/* Video standard handling */</span>
	<span class="n">v4l2_std_id</span> <span class="n">std_mask_eeprom</span><span class="p">;</span> <span class="c1">// Hardware supported selections</span>
	<span class="n">v4l2_std_id</span> <span class="n">std_mask_avail</span><span class="p">;</span>  <span class="c1">// Which standards we may select from</span>
	<span class="n">v4l2_std_id</span> <span class="n">std_mask_cur</span><span class="p">;</span>    <span class="c1">// Currently selected standard(s)</span>
	<span class="kt">int</span> <span class="n">std_enum_cur</span><span class="p">;</span>            <span class="c1">// selected standard enumeration value</span>
	<span class="kt">int</span> <span class="n">std_dirty</span><span class="p">;</span>               <span class="c1">// True if std_mask_cur has changed</span>
	<span class="k">struct</span> <span class="n">pvr2_ctl_info</span> <span class="n">std_info_enum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pvr2_ctl_info</span> <span class="n">std_info_avail</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pvr2_ctl_info</span> <span class="n">std_info_cur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pvr2_ctl_info</span> <span class="n">std_info_detect</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>Generated string names, one per actual V4L2 standard</p></td><td class="code"><div class="highlight"><pre>	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">std_mask_ptrs</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">std_mask_names</span><span class="p">[</span><span class="mi">32</span><span class="p">][</span><span class="mi">16</span><span class="p">];</span>

	<span class="kt">int</span> <span class="n">unit_number</span><span class="p">;</span>             <span class="cm">/* ID for driver instance */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">serial_number</span><span class="p">;</span> <span class="cm">/* ID for hardware itself */</span>

	<span class="kt">char</span> <span class="n">bus_info</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span> <span class="cm">/* Bus location info */</span>

	<span class="cm">/* Minor numbers used by v4l logic (yes, this is a hack, as there</span>
<span class="cm">	   should be no v4l junk here).  Probably a better way to do this. */</span>
	<span class="kt">int</span> <span class="n">v4l_minor_number_video</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">v4l_minor_number_vbi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">v4l_minor_number_radio</span><span class="p">;</span>

	<span class="cm">/* Bit mask of PVR2_CVAL_INPUT choices which are valid for the hardware */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">input_avail_mask</span><span class="p">;</span>
	<span class="cm">/* Bit mask of PVR2_CVAL_INPUT choices which are currently allowed */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">input_allowed_mask</span><span class="p">;</span>

	<span class="cm">/* Location of eeprom or a negative number if none */</span>
	<span class="kt">int</span> <span class="n">eeprom_addr</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">pvr2_config</span> <span class="n">active_stream_type</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">pvr2_config</span> <span class="n">desired_stream_type</span><span class="p">;</span>

	<span class="cm">/* Control state needed for cx2341x module */</span>
	<span class="k">struct</span> <span class="n">cx2341x_mpeg_params</span> <span class="n">enc_cur_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cx2341x_mpeg_params</span> <span class="n">enc_ctl_state</span><span class="p">;</span>
	<span class="cm">/* True if an encoder attribute has changed */</span>
	<span class="kt">int</span> <span class="n">enc_stale</span><span class="p">;</span>
	<span class="cm">/* True if an unsafe encoder attribute has changed */</span>
	<span class="kt">int</span> <span class="n">enc_unsafe_stale</span><span class="p">;</span>
	<span class="cm">/* True if enc_cur_state is valid */</span>
	<span class="kt">int</span> <span class="n">enc_cur_valid</span><span class="p">;</span>

	<span class="cm">/* Control state */</span>
<span class="cp">#define VCREATE_DATA(lab) int lab##_val; int lab##_dirty</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">brightness</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">contrast</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">saturation</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">hue</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">volume</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">balance</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">bass</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">treble</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">mute</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">cropl</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">cropt</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">cropw</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">croph</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">audiomode</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">res_hor</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">res_ver</span><span class="p">);</span>
	<span class="n">VCREATE_DATA</span><span class="p">(</span><span class="n">srate</span><span class="p">);</span>
<span class="cp">#undef VCREATE_DATA</span>

	<span class="k">struct</span> <span class="n">pvr2_ctld_info</span> <span class="o">*</span><span class="n">mpeg_ctrl_info</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">pvr2_ctrl</span> <span class="o">*</span><span class="n">controls</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">control_cnt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* This function gets the current frequency */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pvr2_hdw_get_cur_freq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvr2_hdw</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">pvr2_hdw_status_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvr2_hdw</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __PVRUSB2_HDW_INTERNAL_H */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm">  Stuff for Emacs to see, in order to encourage consistent editing style:</span>
<span class="cm">  *** Local Variables: ***</span>
<span class="cm">  *** mode: c ***</span>
<span class="cm">  *** fill-column: 75 ***</span>
<span class="cm">  *** tab-width: 8 ***</span>
<span class="cm">  *** c-basic-offset: 8 ***</span>
<span class="cm">  *** End: ***</span>
<span class="cm">  */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
