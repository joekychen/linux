<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › media › video › omap1_camera.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>omap1_camera.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * V4L2 SoC Camera driver for OMAP1 Camera Interface</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2010, Janusz Krzysztofik &lt;jkrzyszt@tis.icnet.pl&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Based on V4L2 Driver for i.MXL/i.MXL camera (CSI) host</span>
<span class="cm"> * Copyright (C) 2008, Paulius Zaleckas &lt;paulius.zaleckas@teltonika.lt&gt;</span>
<span class="cm"> * Copyright (C) 2009, Darius Augulis &lt;augulis.darius@gmail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Based on PXA SoC camera driver</span>
<span class="cm"> * Copyright (C) 2006, Sascha Hauer, Pengutronix</span>
<span class="cm"> * Copyright (C) 2008, Guennadi Liakhovetski &lt;kernel@pengutronix.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Hardware specific bits initialy based on former work by Matt Callow</span>
<span class="cm"> * drivers/media/video/omap/omap1510cam.c</span>
<span class="cm"> * Copyright (C) 2006 Matt Callow</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>


<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;media/omap1_camera.h&gt;</span>
<span class="cp">#include &lt;media/soc_camera.h&gt;</span>
<span class="cp">#include &lt;media/soc_mediabus.h&gt;</span>
<span class="cp">#include &lt;media/videobuf-dma-contig.h&gt;</span>
<span class="cp">#include &lt;media/videobuf-dma-sg.h&gt;</span>

<span class="cp">#include &lt;plat/dma.h&gt;</span>


<span class="cp">#define DRIVER_NAME		&quot;omap1-camera&quot;</span>
<span class="cp">#define DRIVER_VERSION		&quot;0.0.2&quot;</span>


<span class="cm">/*</span>
<span class="cm"> * ---------------------------------------------------------------------------</span>
<span class="cm"> *  OMAP1 Camera Interface registers</span>
<span class="cm"> * ---------------------------------------------------------------------------</span>
<span class="cm"> */</span>

<span class="cp">#define REG_CTRLCLOCK		0x00</span>
<span class="cp">#define REG_IT_STATUS		0x04</span>
<span class="cp">#define REG_MODE		0x08</span>
<span class="cp">#define REG_STATUS		0x0C</span>
<span class="cp">#define REG_CAMDATA		0x10</span>
<span class="cp">#define REG_GPIO		0x14</span>
<span class="cp">#define REG_PEAK_COUNTER	0x18</span>

<span class="cm">/* CTRLCLOCK bit shifts */</span>
<span class="cp">#define LCLK_EN			BIT(7)</span>
<span class="cp">#define DPLL_EN			BIT(6)</span>
<span class="cp">#define MCLK_EN			BIT(5)</span>
<span class="cp">#define CAMEXCLK_EN		BIT(4)</span>
<span class="cp">#define POLCLK			BIT(3)</span>
<span class="cp">#define FOSCMOD_SHIFT		0</span>
<span class="cp">#define FOSCMOD_MASK		(0x7 &lt;&lt; FOSCMOD_SHIFT)</span>
<span class="cp">#define FOSCMOD_12MHz		0x0</span>
<span class="cp">#define FOSCMOD_6MHz		0x2</span>
<span class="cp">#define FOSCMOD_9_6MHz		0x4</span>
<span class="cp">#define FOSCMOD_24MHz		0x5</span>
<span class="cp">#define FOSCMOD_8MHz		0x6</span>

<span class="cm">/* IT_STATUS bit shifts */</span>
<span class="cp">#define DATA_TRANSFER		BIT(5)</span>
<span class="cp">#define FIFO_FULL		BIT(4)</span>
<span class="cp">#define H_DOWN			BIT(3)</span>
<span class="cp">#define H_UP			BIT(2)</span>
<span class="cp">#define V_DOWN			BIT(1)</span>
<span class="cp">#define V_UP			BIT(0)</span>

<span class="cm">/* MODE bit shifts */</span>
<span class="cp">#define RAZ_FIFO		BIT(18)</span>
<span class="cp">#define EN_FIFO_FULL		BIT(17)</span>
<span class="cp">#define EN_NIRQ			BIT(16)</span>
<span class="cp">#define THRESHOLD_SHIFT		9</span>
<span class="cp">#define THRESHOLD_MASK		(0x7f &lt;&lt; THRESHOLD_SHIFT)</span>
<span class="cp">#define DMA			BIT(8)</span>
<span class="cp">#define EN_H_DOWN		BIT(7)</span>
<span class="cp">#define EN_H_UP			BIT(6)</span>
<span class="cp">#define EN_V_DOWN		BIT(5)</span>
<span class="cp">#define EN_V_UP			BIT(4)</span>
<span class="cp">#define ORDERCAMD		BIT(3)</span>

<span class="cp">#define IRQ_MASK		(EN_V_UP | EN_V_DOWN | EN_H_UP | EN_H_DOWN | \</span>
<span class="cp">				 EN_NIRQ | EN_FIFO_FULL)</span>

<span class="cm">/* STATUS bit shifts */</span>
<span class="cp">#define HSTATUS			BIT(1)</span>
<span class="cp">#define VSTATUS			BIT(0)</span>

<span class="cm">/* GPIO bit shifts */</span>
<span class="cp">#define CAM_RST			BIT(0)</span>

<span class="cm">/* end of OMAP1 Camera Interface registers */</span>


<span class="cp">#define SOCAM_BUS_FLAGS	(V4L2_MBUS_MASTER | \</span>
<span class="cp">			V4L2_MBUS_HSYNC_ACTIVE_HIGH | V4L2_MBUS_VSYNC_ACTIVE_HIGH | \</span>
<span class="cp">			V4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_PCLK_SAMPLE_FALLING | \</span>
<span class="cp">			V4L2_MBUS_DATA_ACTIVE_HIGH)</span>


<span class="cp">#define FIFO_SIZE		((THRESHOLD_MASK &gt;&gt; THRESHOLD_SHIFT) + 1)</span>
<span class="cp">#define FIFO_SHIFT		__fls(FIFO_SIZE)</span>

<span class="cp">#define DMA_BURST_SHIFT		(1 + OMAP_DMA_DATA_BURST_4)</span>
<span class="cp">#define DMA_BURST_SIZE		(1 &lt;&lt; DMA_BURST_SHIFT)</span>

<span class="cp">#define DMA_ELEMENT_SHIFT	OMAP_DMA_DATA_TYPE_S32</span>
<span class="cp">#define DMA_ELEMENT_SIZE	(1 &lt;&lt; DMA_ELEMENT_SHIFT)</span>

<span class="cp">#define DMA_FRAME_SHIFT_CONTIG	(FIFO_SHIFT - 1)</span>
<span class="cp">#define DMA_FRAME_SHIFT_SG	DMA_BURST_SHIFT</span>

<span class="cp">#define DMA_FRAME_SHIFT(x)	((x) == OMAP1_CAM_DMA_CONTIG ? \</span>
<span class="cp">						DMA_FRAME_SHIFT_CONTIG : \</span>
<span class="cp">						DMA_FRAME_SHIFT_SG)</span>
<span class="cp">#define DMA_FRAME_SIZE(x)	(1 &lt;&lt; DMA_FRAME_SHIFT(x))</span>
<span class="cp">#define DMA_SYNC		OMAP_DMA_SYNC_FRAME</span>
<span class="cp">#define THRESHOLD_LEVEL		DMA_FRAME_SIZE</span>


<span class="cp">#define MAX_VIDEO_MEM		4	</span><span class="cm">/* arbitrary video memory limit in MB */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * Structures</span>
<span class="cm"> */</span>

<span class="cm">/* buffer for one video frame */</span>
<span class="k">struct</span> <span class="n">omap1_cam_buf</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">videobuf_buffer</span>		<span class="n">vb</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">v4l2_mbus_pixelcode</span>	<span class="n">code</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">inwork</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span>		<span class="o">*</span><span class="n">sgbuf</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">sgcount</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">bytes_left</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">videobuf_state</span>		<span class="n">result</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span>		<span class="n">soc_host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">soc_camera_device</span>	<span class="o">*</span><span class="n">icd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span>			<span class="o">*</span><span class="n">clk</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">irq</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>			<span class="o">*</span><span class="n">base</span><span class="p">;</span>

	<span class="kt">int</span>				<span class="n">dma_ch</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">omap1_cam_platform_data</span>	<span class="o">*</span><span class="n">pdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span>			<span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">pflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">camexclk</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">capture</span><span class="p">;</span>

	<span class="cm">/* lock used to protect videobuf */</span>
	<span class="n">spinlock_t</span>			<span class="n">lock</span><span class="p">;</span>

	<span class="cm">/* Pointers to DMA buffers */</span>
	<span class="k">struct</span> <span class="n">omap1_cam_buf</span>		<span class="o">*</span><span class="n">active</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap1_cam_buf</span>		<span class="o">*</span><span class="n">ready</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">omap1_cam_vb_mode</span>		<span class="n">vb_mode</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="p">(</span><span class="o">*</span><span class="n">mmap_mapper</span><span class="p">)(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>

	<span class="n">u32</span>				<span class="n">reg_cache</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">cam_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">reg_cache</span><span class="p">[</span><span class="n">reg</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">cam_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">,</span> <span class="n">bool</span> <span class="n">from_cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">from_cache</span> <span class="o">?</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">reg_cache</span><span class="p">[</span><span class="n">reg</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)];</span>
<span class="p">}</span>

<span class="cp">#define CAM_READ(pcdev, reg) \</span>
<span class="cp">		cam_read(pcdev, REG_##reg, false)</span>
<span class="cp">#define CAM_WRITE(pcdev, reg, val) \</span>
<span class="cp">		cam_write(pcdev, REG_##reg, val)</span>
<span class="cp">#define CAM_READ_CACHE(pcdev, reg) \</span>
<span class="cp">		cam_read(pcdev, REG_##reg, true)</span>

<span class="cm">/*</span>
<span class="cm"> *  Videobuf operations</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap1_videobuf_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">sizeimage</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">count</span> <span class="o">||</span> <span class="o">*</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">OMAP1_CAMERA_MIN_BUF_COUNT</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span><span class="p">))</span>
		<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">OMAP1_CAMERA_MIN_BUF_COUNT</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">size</span> <span class="o">*</span> <span class="o">*</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">MAX_VIDEO_MEM</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
		<span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">MAX_VIDEO_MEM</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">/</span> <span class="o">*</span><span class="n">size</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span>
			<span class="s">&quot;%s: count=%d, size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="o">*</span><span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap1_cam_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">omap1_cam_vb_mode</span> <span class="n">vb_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">());</span>

	<span class="n">videobuf_waiton</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vb_mode</span> <span class="o">==</span> <span class="n">OMAP1_CAM_DMA_CONTIG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">videobuf_dma_contig_free</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">videobuf_dmabuf</span> <span class="o">*</span><span class="n">dma</span> <span class="o">=</span> <span class="n">videobuf_to_dma</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>

		<span class="n">videobuf_dma_unmap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma</span><span class="p">);</span>
		<span class="n">videobuf_dma_free</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_NEEDS_INIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap1_videobuf_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span> <span class="k">enum</span> <span class="n">v4l2_field</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap1_cam_buf</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap1_cam_buf</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">));</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">current_fmt</span><span class="p">);</span>

	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">inwork</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">!=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">current_fmt</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">||</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">field</span> <span class="o">!=</span> <span class="n">field</span> <span class="o">||</span>
			<span class="n">vb</span><span class="o">-&gt;</span><span class="n">width</span>  <span class="o">!=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">user_width</span> <span class="o">||</span>
			<span class="n">vb</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">!=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">user_height</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">code</span>  <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">current_fmt</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">width</span>  <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">user_width</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">user_height</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">field</span>  <span class="o">=</span> <span class="n">field</span><span class="p">;</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span>  <span class="o">=</span> <span class="n">VIDEOBUF_NEEDS_INIT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">sizeimage</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">baddr</span> <span class="o">&amp;&amp;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">bsize</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">VIDEOBUF_NEEDS_INIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">videobuf_iolock</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_PREPARED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">inwork</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">free_buffer</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">inwork</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_dma_dest_params</span><span class="p">(</span><span class="kt">int</span> <span class="n">dma_ch</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap1_cam_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">omap1_cam_vb_mode</span> <span class="n">vb_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vb_mode</span> <span class="o">==</span> <span class="n">OMAP1_CAM_DMA_CONTIG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">videobuf_to_dma_contig</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">);</span>
		<span class="n">block_size</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgbuf</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgbuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dma_addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">block_size</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgbuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">block_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">&lt;</span> <span class="n">block_size</span><span class="p">))</span>
			<span class="n">block_size</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytes_left</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">dma_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DMA_FRAME_SIZE</span><span class="p">(</span><span class="n">vb_mode</span><span class="p">)</span> <span class="o">*</span>
				<span class="n">DMA_ELEMENT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">dma_addr</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">dma_addr</span><span class="p">,</span> <span class="n">DMA_FRAME_SIZE</span><span class="p">(</span><span class="n">vb_mode</span><span class="p">)</span> <span class="o">*</span>
					<span class="n">DMA_ELEMENT_SIZE</span><span class="p">);</span>
			<span class="n">block_size</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">DMA_FRAME_SIZE</span><span class="p">(</span><span class="n">vb_mode</span><span class="p">)</span> <span class="o">*</span>
					<span class="n">DMA_ELEMENT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">-=</span> <span class="n">block_size</span><span class="p">;</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgcount</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">omap_set_dma_dest_params</span><span class="p">(</span><span class="n">dma_ch</span><span class="p">,</span>
		<span class="n">OMAP_DMA_PORT_EMIFF</span><span class="p">,</span> <span class="n">OMAP_DMA_AMODE_POST_INC</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">omap_set_dma_transfer_params</span><span class="p">(</span><span class="n">dma_ch</span><span class="p">,</span>
		<span class="n">OMAP_DMA_DATA_TYPE_S32</span><span class="p">,</span> <span class="n">DMA_FRAME_SIZE</span><span class="p">(</span><span class="n">vb_mode</span><span class="p">),</span>
		<span class="n">block_size</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">DMA_FRAME_SHIFT</span><span class="p">(</span><span class="n">vb_mode</span><span class="p">)</span> <span class="o">+</span> <span class="n">DMA_ELEMENT_SHIFT</span><span class="p">),</span>
		<span class="n">DMA_SYNC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">omap1_cam_buf</span> <span class="o">*</span><span class="nf">prepare_next_vb</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap1_cam_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is already a buffer pointed out by the pcdev-&gt;ready,</span>
<span class="cm">	 * (re)use it, otherwise try to fetch and configure a new one.</span>
<span class="cm">	 */</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">ready</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">capture</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">capture</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">omap1_cam_buf</span><span class="p">,</span> <span class="n">vb</span><span class="p">.</span><span class="n">queue</span><span class="p">);</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_ACTIVE</span><span class="p">;</span>
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">ready</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">queue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span> <span class="o">==</span> <span class="n">OMAP1_CAM_DMA_CONTIG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In CONTIG mode, we can safely enter next buffer parameters</span>
<span class="cm">		 * into the DMA programming register set after the DMA</span>
<span class="cm">		 * has already been activated on the previous buffer</span>
<span class="cm">		 */</span>
		<span class="n">set_dma_dest_params</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_ch</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In SG mode, the above is not safe since there are probably</span>
<span class="cm">		 * a bunch of sgbufs from previous sglist still pending.</span>
<span class="cm">		 * Instead, mark the sglist fresh for the upcoming</span>
<span class="cm">		 * try_next_sgbuf().</span>
<span class="cm">		 */</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="nf">try_next_sgbuf</span><span class="p">(</span><span class="kt">int</span> <span class="n">dma_ch</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap1_cam_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgbuf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgbuf</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* current sglist is active */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytes_left</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* indicate sglist complete */</span>
			<span class="n">sgbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* process next sgbuf */</span>
			<span class="n">sgbuf</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgbuf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sgbuf</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">buf</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sgbuf</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">sgbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">buf</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgbuf</span> <span class="o">=</span> <span class="n">sgbuf</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* sglist is fresh, initialize it before using */</span>
		<span class="k">struct</span> <span class="n">videobuf_dmabuf</span> <span class="o">*</span><span class="n">dma</span> <span class="o">=</span> <span class="n">videobuf_to_dma</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">);</span>

		<span class="n">sgbuf</span> <span class="o">=</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">sglist</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sgbuf</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgbuf</span> <span class="o">=</span> <span class="n">sgbuf</span><span class="p">;</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">VIDEOBUF_DONE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sgbuf</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Put our next sgbuf parameters (address, size)</span>
<span class="cm">		 * into the DMA programming register set.</span>
<span class="cm">		 */</span>
		<span class="n">set_dma_dest_params</span><span class="p">(</span><span class="n">dma_ch</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">OMAP1_CAM_DMA_SG</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sgbuf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_capture</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap1_cam_buf</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrlclock</span> <span class="o">=</span> <span class="n">CAM_READ_CACHE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">CAM_READ_CACHE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">MODE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EN_V_DOWN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable start of frame interrupt, which we will use for activating</span>
<span class="cm">	 * our end of frame watchdog when capture actually starts.</span>
<span class="cm">	 */</span>
	<span class="n">mode</span> <span class="o">|=</span> <span class="n">EN_V_UP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ctrlclock</span> <span class="o">&amp;</span> <span class="n">LCLK_EN</span><span class="p">))</span>
		<span class="cm">/* stop pixel clock before FIFO reset */</span>
		<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">,</span> <span class="n">ctrlclock</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">LCLK_EN</span><span class="p">);</span>
	<span class="cm">/* reset FIFO */</span>
	<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">MODE</span><span class="p">,</span> <span class="n">mode</span> <span class="o">|</span> <span class="n">RAZ_FIFO</span><span class="p">);</span>

	<span class="n">omap_start_dma</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_ch</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span> <span class="o">==</span> <span class="n">OMAP1_CAM_DMA_SG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In SG mode, it&#39;s a good moment for fetching next sgbuf</span>
<span class="cm">		 * from the current sglist and, if available, already putting</span>
<span class="cm">		 * its parameters into the DMA programming register set.</span>
<span class="cm">		 */</span>
		<span class="n">try_next_sgbuf</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_ch</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* (re)enable pixel clock */</span>
	<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">,</span> <span class="n">ctrlclock</span> <span class="o">|</span> <span class="n">LCLK_EN</span><span class="p">);</span>
	<span class="cm">/* release FIFO reset */</span>
	<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">MODE</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">suspend_capture</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrlclock</span> <span class="o">=</span> <span class="n">CAM_READ_CACHE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">);</span>

	<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">,</span> <span class="n">ctrlclock</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">LCLK_EN</span><span class="p">);</span>
	<span class="n">omap_stop_dma</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_ch</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">disable_capture</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">CAM_READ_CACHE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">MODE</span><span class="p">);</span>

	<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">MODE</span><span class="p">,</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">IRQ_MASK</span> <span class="o">|</span> <span class="n">DMA</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap1_videobuf_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap1_cam_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mode</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">capture</span><span class="p">);</span>
	<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VIDEOBUF_QUEUED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Capture in progress, so don&#39;t touch pcdev-&gt;ready even if</span>
<span class="cm">		 * empty. Since the transfer of the DMA programming register set</span>
<span class="cm">		 * content to the DMA working register set is done automatically</span>
<span class="cm">		 * by the DMA hardware, this can pretty well happen while we</span>
<span class="cm">		 * are keeping the lock here. Leave fetching it from the queue</span>
<span class="cm">		 * to be done when a next DMA interrupt occures instead.</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">ready</span><span class="p">);</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">prepare_next_vb</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">ready</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span>
		<span class="s">&quot;%s: capture not active, setup FIFO, start DMA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">mode</span> <span class="o">=</span> <span class="n">CAM_READ_CACHE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">MODE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">THRESHOLD_MASK</span><span class="p">;</span>
	<span class="n">mode</span> <span class="o">|=</span> <span class="n">THRESHOLD_LEVEL</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">THRESHOLD_SHIFT</span><span class="p">;</span>
	<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">MODE</span><span class="p">,</span> <span class="n">mode</span> <span class="o">|</span> <span class="n">EN_FIFO_FULL</span> <span class="o">|</span> <span class="n">DMA</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span> <span class="o">==</span> <span class="n">OMAP1_CAM_DMA_SG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In SG mode, the above prepare_next_vb() didn&#39;t actually</span>
<span class="cm">		 * put anything into the DMA programming register set,</span>
<span class="cm">		 * so we have to do it now, before activating DMA.</span>
<span class="cm">		 */</span>
		<span class="n">try_next_sgbuf</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_ch</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">start_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap1_videobuf_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap1_cam_buf</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span>
			<span class="n">container_of</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap1_cam_buf</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span> <span class="o">=</span> <span class="n">vq</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VIDEOBUF_DONE</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (done)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VIDEOBUF_ACTIVE</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (active)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VIDEOBUF_QUEUED</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (queued)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VIDEOBUF_PREPARED</span>:
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (prepared)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s (unknown %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">free_buffer</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">videobuf_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">videobuf_state</span> <span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap1_cam_buf</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">suspend_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
		<span class="n">disable_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">)</span>
		<span class="n">suspend_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>

	<span class="n">vb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">ready</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">!=</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * No next buffer has been entered into the DMA</span>
<span class="cm">			 * programming register set on time (could be done only</span>
<span class="cm">			 * while the previous DMA interurpt was processed, not</span>
<span class="cm">			 * later), so the last DMA block, be it a whole buffer</span>
<span class="cm">			 * if in CONTIG or its last sgbuf if in SG mode, is</span>
<span class="cm">			 * about to be reused by the just autoreinitialized DMA</span>
<span class="cm">			 * engine, and overwritten with next frame data. Best we</span>
<span class="cm">			 * can do is stopping the capture as soon as possible,</span>
<span class="cm">			 * hopefully before the next frame start.</span>
<span class="cm">			 */</span>
			<span class="n">suspend_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
		<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">ts</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">)</span>
			<span class="n">vb</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>

		<span class="cm">/* shift in next buffer */</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">ready</span><span class="p">;</span>
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">ready</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * No next buffer was ready on time (see above), so</span>
<span class="cm">			 * indicate error condition to force capture restart or</span>
<span class="cm">			 * stop, depending on next buffer already queued or not.</span>
<span class="cm">			 */</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">;</span>
			<span class="n">prepare_next_vb</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>

			<span class="n">buf</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">ready</span><span class="p">;</span>
			<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
			<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">ready</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">ready</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In both CONTIG and SG mode, the DMA engine has possibly</span>
<span class="cm">		 * been already autoreinitialized with the preprogrammed</span>
<span class="cm">		 * pcdev-&gt;ready buffer.  We can either accept this fact</span>
<span class="cm">		 * and just swap the buffers, or provoke an error condition</span>
<span class="cm">		 * and restart capture.  The former seems less intrusive.</span>
<span class="cm">		 */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: nobody waiting on videobuf, swap with next</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">ready</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span> <span class="o">==</span> <span class="n">OMAP1_CAM_DMA_SG</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * In SG mode, we have to make sure that the buffer we</span>
<span class="cm">			 * are putting back into the pcdev-&gt;ready is marked</span>
<span class="cm">			 * fresh.</span>
<span class="cm">			 */</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">ready</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

		<span class="n">buf</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * No next buffer has been entered into</span>
<span class="cm">		 * the DMA programming register set on time.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span> <span class="o">==</span> <span class="n">OMAP1_CAM_DMA_CONTIG</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * In CONTIG mode, the DMA engine has already been</span>
<span class="cm">			 * reinitialized with the current buffer. Best we can do</span>
<span class="cm">			 * is not touching it.</span>
<span class="cm">			 */</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s: nobody waiting on videobuf, reuse it</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * In SG mode, the DMA engine has just been</span>
<span class="cm">			 * autoreinitialized with the last sgbuf from the</span>
<span class="cm">			 * current list. Restart capture in order to transfer</span>
<span class="cm">			 * next frame start into the first sgbuf, not the last</span>
<span class="cm">			 * one.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">suspend_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
				<span class="n">result</span> <span class="o">=</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: no more videobufs, stop capture</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">disable_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span> <span class="o">==</span> <span class="n">OMAP1_CAM_DMA_CONTIG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In CONTIG mode, the current buffer parameters had already</span>
<span class="cm">		 * been entered into the DMA programming register set while the</span>
<span class="cm">		 * buffer was fetched with prepare_next_vb(), they may have also</span>
<span class="cm">		 * been transferred into the runtime set and already active if</span>
<span class="cm">		 * the DMA still running.</span>
<span class="cm">		 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* In SG mode, extra steps are required */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">)</span>
			<span class="cm">/* make sure we (re)use sglist from start on error */</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * In any case, enter the next sgbuf parameters into the DMA</span>
<span class="cm">		 * programming register set.  They will be used either during</span>
<span class="cm">		 * nearest DMA autoreinitialization or, in case of an error,</span>
<span class="cm">		 * on DMA startup below.</span>
<span class="cm">		 */</span>
		<span class="n">try_next_sgbuf</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_ch</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: videobuf error; reset FIFO, restart DMA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
		<span class="n">start_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * In SG mode, the above also resulted in the next sgbuf</span>
<span class="cm">		 * parameters being entered into the DMA programming register</span>
<span class="cm">		 * set, making them ready for next DMA autoreinitialization.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finally, try fetching next buffer.</span>
<span class="cm">	 * In CONTIG mode, it will also enter it into the DMA programming</span>
<span class="cm">	 * register set, making it ready for next DMA autoreinitialization.</span>
<span class="cm">	 */</span>
	<span class="n">prepare_next_vb</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">status</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap1_cam_buf</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">suspend_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
		<span class="n">disable_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span> <span class="o">==</span> <span class="n">OMAP1_CAM_DMA_CONTIG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In CONTIG mode, assume we have just managed to collect the</span>
<span class="cm">		 * whole frame, hopefully before our end of frame watchdog is</span>
<span class="cm">		 * triggered. Then, all we have to do is disabling the watchdog</span>
<span class="cm">		 * for this frame, and calling videobuf_done() with success</span>
<span class="cm">		 * indicated.</span>
<span class="cm">		 */</span>
		<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">MODE</span><span class="p">,</span>
				<span class="n">CAM_READ_CACHE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">MODE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EN_V_DOWN</span><span class="p">);</span>
		<span class="n">videobuf_done</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">VIDEOBUF_DONE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In SG mode, we have to process every sgbuf from the current</span>
<span class="cm">		 * sglist, one after another.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgbuf</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Current sglist not completed yet, try fetching next</span>
<span class="cm">			 * sgbuf, hopefully putting it into the DMA programming</span>
<span class="cm">			 * register set, making it ready for next DMA</span>
<span class="cm">			 * autoreinitialization.</span>
<span class="cm">			 */</span>
			<span class="n">try_next_sgbuf</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_ch</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgbuf</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * No more sgbufs left in the current sglist. This</span>
<span class="cm">			 * doesn&#39;t mean that the whole videobuffer is already</span>
<span class="cm">			 * complete, but only that the last sgbuf from the</span>
<span class="cm">			 * current sglist is about to be filled. It will be</span>
<span class="cm">			 * ready on next DMA interrupt, signalled with the</span>
<span class="cm">			 * buf-&gt;sgbuf set back to NULL.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">!=</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Video frame collected without errors so far,</span>
<span class="cm">				 * we can prepare for collecting a next one</span>
<span class="cm">				 * as soon as DMA gets autoreinitialized</span>
<span class="cm">				 * after the current (last) sgbuf is completed.</span>
<span class="cm">				 */</span>
				<span class="n">buf</span> <span class="o">=</span> <span class="n">prepare_next_vb</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

				<span class="n">try_next_sgbuf</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_ch</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* end of videobuf */</span>
		<span class="n">videobuf_done</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">cam_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap1_cam_buf</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">it_status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">it_status</span> <span class="o">=</span> <span class="n">CAM_READ</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">IT_STATUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">it_status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: unhandled camera interrupt, status == %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">it_status</span><span class="p">);</span>
		<span class="n">suspend_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
		<span class="n">disable_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">it_status</span> <span class="o">&amp;</span> <span class="n">FIFO_FULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: FIFO overflow</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">it_status</span> <span class="o">&amp;</span> <span class="n">V_DOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* end of video frame watchdog */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span> <span class="o">==</span> <span class="n">OMAP1_CAM_DMA_CONTIG</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * In CONTIG mode, the watchdog is disabled with</span>
<span class="cm">			 * successful DMA end of block interrupt, and reenabled</span>
<span class="cm">			 * on next frame start. If we get here, there is nothing</span>
<span class="cm">			 * to check, we must be out of sync.</span>
<span class="cm">			 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">sgcount</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * If exactly 2 sgbufs from the next sglist have</span>
<span class="cm">				 * been programmed into the DMA engine (the</span>
<span class="cm">				 * first one already transferred into the DMA</span>
<span class="cm">				 * runtime register set, the second one still</span>
<span class="cm">				 * in the programming set), then we are in sync.</span>
<span class="cm">				 */</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">dev_notice</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: unexpected end of video frame</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">it_status</span> <span class="o">&amp;</span> <span class="n">V_UP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">mode</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span> <span class="o">==</span> <span class="n">OMAP1_CAM_DMA_CONTIG</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * In CONTIG mode, we need this interrupt every frame</span>
<span class="cm">			 * in oredr to reenable our end of frame watchdog.</span>
<span class="cm">			 */</span>
			<span class="n">mode</span> <span class="o">=</span> <span class="n">CAM_READ_CACHE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">MODE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * In SG mode, the below enabled end of frame watchdog</span>
<span class="cm">			 * is kept on permanently, so we can turn this one shot</span>
<span class="cm">			 * setup off.</span>
<span class="cm">			 */</span>
			<span class="n">mode</span> <span class="o">=</span> <span class="n">CAM_READ_CACHE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">MODE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EN_V_UP</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">EN_V_DOWN</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* (re)enable end of frame watchdog interrupt */</span>
			<span class="n">mode</span> <span class="o">|=</span> <span class="n">EN_V_DOWN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">MODE</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: unhandled camera interrupt, status == %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">it_status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">videobuf_done</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">videobuf_queue_ops</span> <span class="n">omap1_videobuf_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">buf_setup</span>	<span class="o">=</span> <span class="n">omap1_videobuf_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_prepare</span>	<span class="o">=</span> <span class="n">omap1_videobuf_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_queue</span>	<span class="o">=</span> <span class="n">omap1_videobuf_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buf_release</span>	<span class="o">=</span> <span class="n">omap1_videobuf_release</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * SOC Camera host operations</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sensor_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* apply/release camera sensor reset if requested by platform data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">OMAP1_CAMERA_RST_HIGH</span><span class="p">)</span>
		<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">GPIO</span><span class="p">,</span> <span class="n">reset</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">OMAP1_CAMERA_RST_LOW</span><span class="p">)</span>
		<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">GPIO</span><span class="p">,</span> <span class="o">!</span><span class="n">reset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The following two functions absolutely depend on the fact, that</span>
<span class="cm"> * there can be only one camera on OMAP1 camera sensor interface</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap1_cam_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrlclock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">icd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="cm">/* setup sensor clock */</span>
	<span class="n">ctrlclock</span> <span class="o">=</span> <span class="n">CAM_READ</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">);</span>
	<span class="n">ctrlclock</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CAMEXCLK_EN</span> <span class="o">|</span> <span class="n">MCLK_EN</span> <span class="o">|</span> <span class="n">DPLL_EN</span><span class="p">);</span>
	<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">,</span> <span class="n">ctrlclock</span><span class="p">);</span>

	<span class="n">ctrlclock</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FOSCMOD_MASK</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">camexclk</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">6000000</span>:
		<span class="n">ctrlclock</span> <span class="o">|=</span> <span class="n">CAMEXCLK_EN</span> <span class="o">|</span> <span class="n">FOSCMOD_6MHz</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8000000</span>:
		<span class="n">ctrlclock</span> <span class="o">|=</span> <span class="n">CAMEXCLK_EN</span> <span class="o">|</span> <span class="n">FOSCMOD_8MHz</span> <span class="o">|</span> <span class="n">DPLL_EN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">9600000</span>:
		<span class="n">ctrlclock</span> <span class="o">|=</span> <span class="n">CAMEXCLK_EN</span> <span class="o">|</span> <span class="n">FOSCMOD_9_6MHz</span> <span class="o">|</span> <span class="n">DPLL_EN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">12000000</span>:
		<span class="n">ctrlclock</span> <span class="o">|=</span> <span class="n">CAMEXCLK_EN</span> <span class="o">|</span> <span class="n">FOSCMOD_12MHz</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">24000000</span>:
		<span class="n">ctrlclock</span> <span class="o">|=</span> <span class="n">CAMEXCLK_EN</span> <span class="o">|</span> <span class="n">FOSCMOD_24MHz</span> <span class="o">|</span> <span class="n">DPLL_EN</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">,</span> <span class="n">ctrlclock</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DPLL_EN</span><span class="p">);</span>

	<span class="cm">/* enable internal clock */</span>
	<span class="n">ctrlclock</span> <span class="o">|=</span> <span class="n">MCLK_EN</span><span class="p">;</span>
	<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">,</span> <span class="n">ctrlclock</span><span class="p">);</span>

	<span class="n">sensor_reset</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">icd</span> <span class="o">=</span> <span class="n">icd</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="s">&quot;OMAP1 Camera driver attached to camera %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">icd</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap1_cam_remove_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrlclock</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">icd</span> <span class="o">!=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">icd</span><span class="p">);</span>

	<span class="n">suspend_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
	<span class="n">disable_capture</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>

	<span class="n">sensor_reset</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="cm">/* disable and release system clocks */</span>
	<span class="n">ctrlclock</span> <span class="o">=</span> <span class="n">CAM_READ_CACHE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">);</span>
	<span class="n">ctrlclock</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MCLK_EN</span> <span class="o">|</span> <span class="n">DPLL_EN</span> <span class="o">|</span> <span class="n">CAMEXCLK_EN</span><span class="p">);</span>
	<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">,</span> <span class="n">ctrlclock</span><span class="p">);</span>

	<span class="n">ctrlclock</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctrlclock</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FOSCMOD_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">FOSCMOD_12MHz</span><span class="p">;</span>
	<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">,</span> <span class="n">ctrlclock</span><span class="p">);</span>
	<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">,</span> <span class="n">ctrlclock</span> <span class="o">|</span> <span class="n">MCLK_EN</span><span class="p">);</span>

	<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">,</span> <span class="n">ctrlclock</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MCLK_EN</span><span class="p">);</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">icd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span>
		<span class="s">&quot;OMAP1 Camera driver detached from camera %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Duplicate standard formats based on host capability of byte swapping */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">soc_mbus_lookup</span> <span class="n">omap1_cam_formats</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">V4L2_MBUS_FMT_UYVY8_2X8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">fourcc</span>			<span class="o">=</span> <span class="n">V4L2_PIX_FMT_YUYV</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;YUYV&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bits_per_sample</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">packing</span>		<span class="o">=</span> <span class="n">SOC_MBUS_PACKING_2X8_PADHI</span><span class="p">,</span>
		<span class="p">.</span><span class="n">order</span>			<span class="o">=</span> <span class="n">SOC_MBUS_ORDER_BE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">layout</span>			<span class="o">=</span> <span class="n">SOC_MBUS_LAYOUT_PACKED</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">},</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">V4L2_MBUS_FMT_VYUY8_2X8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">fourcc</span>			<span class="o">=</span> <span class="n">V4L2_PIX_FMT_YVYU</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;YVYU&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bits_per_sample</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">packing</span>		<span class="o">=</span> <span class="n">SOC_MBUS_PACKING_2X8_PADHI</span><span class="p">,</span>
		<span class="p">.</span><span class="n">order</span>			<span class="o">=</span> <span class="n">SOC_MBUS_ORDER_BE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">layout</span>			<span class="o">=</span> <span class="n">SOC_MBUS_LAYOUT_PACKED</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">},</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">V4L2_MBUS_FMT_YUYV8_2X8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">fourcc</span>			<span class="o">=</span> <span class="n">V4L2_PIX_FMT_UYVY</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;UYVY&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bits_per_sample</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">packing</span>		<span class="o">=</span> <span class="n">SOC_MBUS_PACKING_2X8_PADHI</span><span class="p">,</span>
		<span class="p">.</span><span class="n">order</span>			<span class="o">=</span> <span class="n">SOC_MBUS_ORDER_BE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">layout</span>			<span class="o">=</span> <span class="n">SOC_MBUS_LAYOUT_PACKED</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">},</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">V4L2_MBUS_FMT_YVYU8_2X8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">fourcc</span>			<span class="o">=</span> <span class="n">V4L2_PIX_FMT_VYUY</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;VYUY&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bits_per_sample</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">packing</span>		<span class="o">=</span> <span class="n">SOC_MBUS_PACKING_2X8_PADHI</span><span class="p">,</span>
		<span class="p">.</span><span class="n">order</span>			<span class="o">=</span> <span class="n">SOC_MBUS_ORDER_BE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">layout</span>			<span class="o">=</span> <span class="n">SOC_MBUS_LAYOUT_PACKED</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">},</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">V4L2_MBUS_FMT_RGB555_2X8_PADHI_BE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">fourcc</span>			<span class="o">=</span> <span class="n">V4L2_PIX_FMT_RGB555</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;RGB555&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bits_per_sample</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">packing</span>		<span class="o">=</span> <span class="n">SOC_MBUS_PACKING_2X8_PADHI</span><span class="p">,</span>
		<span class="p">.</span><span class="n">order</span>			<span class="o">=</span> <span class="n">SOC_MBUS_ORDER_BE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">layout</span>			<span class="o">=</span> <span class="n">SOC_MBUS_LAYOUT_PACKED</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">},</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">V4L2_MBUS_FMT_RGB555_2X8_PADHI_LE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">fourcc</span>			<span class="o">=</span> <span class="n">V4L2_PIX_FMT_RGB555X</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;RGB555X&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bits_per_sample</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">packing</span>		<span class="o">=</span> <span class="n">SOC_MBUS_PACKING_2X8_PADHI</span><span class="p">,</span>
		<span class="p">.</span><span class="n">order</span>			<span class="o">=</span> <span class="n">SOC_MBUS_ORDER_BE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">layout</span>			<span class="o">=</span> <span class="n">SOC_MBUS_LAYOUT_PACKED</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">},</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">V4L2_MBUS_FMT_RGB565_2X8_BE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">fourcc</span>			<span class="o">=</span> <span class="n">V4L2_PIX_FMT_RGB565</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;RGB565&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bits_per_sample</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">packing</span>		<span class="o">=</span> <span class="n">SOC_MBUS_PACKING_2X8_PADHI</span><span class="p">,</span>
		<span class="p">.</span><span class="n">order</span>			<span class="o">=</span> <span class="n">SOC_MBUS_ORDER_BE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">layout</span>			<span class="o">=</span> <span class="n">SOC_MBUS_LAYOUT_PACKED</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">},</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">V4L2_MBUS_FMT_RGB565_2X8_LE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">fourcc</span>			<span class="o">=</span> <span class="n">V4L2_PIX_FMT_RGB565X</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;RGB565X&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bits_per_sample</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">packing</span>		<span class="o">=</span> <span class="n">SOC_MBUS_PACKING_2X8_PADHI</span><span class="p">,</span>
		<span class="p">.</span><span class="n">order</span>			<span class="o">=</span> <span class="n">SOC_MBUS_ORDER_BE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">layout</span>			<span class="o">=</span> <span class="n">SOC_MBUS_LAYOUT_PACKED</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap1_cam_get_formats</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">soc_camera_format_xlate</span> <span class="o">*</span><span class="n">xlate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">soc_camera_to_subdev</span><span class="p">(</span><span class="n">icd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">formats</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">v4l2_mbus_pixelcode</span> <span class="n">code</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">soc_mbus_pixelfmt</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">enum_mbus_fmt</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">code</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* No more formats */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fmt</span> <span class="o">=</span> <span class="n">soc_mbus_get_fmtdesc</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fmt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: unsupported format code #%d: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">idx</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check support for the requested bits-per-sample */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bits_per_sample</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">V4L2_MBUS_FMT_YUYV8_2X8</span>:
	<span class="k">case</span> <span class="n">V4L2_MBUS_FMT_YVYU8_2X8</span>:
	<span class="k">case</span> <span class="n">V4L2_MBUS_FMT_UYVY8_2X8</span>:
	<span class="k">case</span> <span class="n">V4L2_MBUS_FMT_VYUY8_2X8</span>:
	<span class="k">case</span> <span class="n">V4L2_MBUS_FMT_RGB555_2X8_PADHI_BE</span>:
	<span class="k">case</span> <span class="n">V4L2_MBUS_FMT_RGB555_2X8_PADHI_LE</span>:
	<span class="k">case</span> <span class="n">V4L2_MBUS_FMT_RGB565_2X8_BE</span>:
	<span class="k">case</span> <span class="n">V4L2_MBUS_FMT_RGB565_2X8_LE</span>:
		<span class="n">formats</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xlate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xlate</span><span class="o">-&gt;</span><span class="n">host_fmt</span>	<span class="o">=</span> <span class="n">soc_mbus_find_fmtdesc</span><span class="p">(</span><span class="n">code</span><span class="p">,</span>
						<span class="n">omap1_cam_formats</span><span class="p">,</span>
						<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">omap1_cam_formats</span><span class="p">));</span>
			<span class="n">xlate</span><span class="o">-&gt;</span><span class="n">code</span>	<span class="o">=</span> <span class="n">code</span><span class="p">;</span>
			<span class="n">xlate</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s: providing format %s as byte swapped code #%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">xlate</span><span class="o">-&gt;</span><span class="n">host_fmt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xlate</span><span class="p">)</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%s: providing format %s in pass-through mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">formats</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xlate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xlate</span><span class="o">-&gt;</span><span class="n">host_fmt</span>	<span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
		<span class="n">xlate</span><span class="o">-&gt;</span><span class="n">code</span>	<span class="o">=</span> <span class="n">code</span><span class="p">;</span>
		<span class="n">xlate</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">formats</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">is_dma_aligned</span><span class="p">(</span><span class="n">s32</span> <span class="n">bytes_per_line</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">omap1_cam_vb_mode</span> <span class="n">vb_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">bytes_per_line</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">bytes_per_line</span><span class="p">,</span> <span class="n">DMA_ELEMENT_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">DMA_FRAME_SIZE</span><span class="p">(</span><span class="n">vb_mode</span><span class="p">)</span> <span class="o">*</span> <span class="n">DMA_ELEMENT_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dma_align</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">height</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">soc_mbus_pixelfmt</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">omap1_cam_vb_mode</span> <span class="n">vb_mode</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enlarge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">bytes_per_line</span> <span class="o">=</span> <span class="n">soc_mbus_bytes_per_line</span><span class="p">(</span><span class="o">*</span><span class="n">width</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bytes_per_line</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bytes_per_line</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_dma_aligned</span><span class="p">(</span><span class="n">bytes_per_line</span><span class="p">,</span> <span class="o">*</span><span class="n">height</span><span class="p">,</span> <span class="n">vb_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pxalign</span> <span class="o">=</span> <span class="n">__fls</span><span class="p">(</span><span class="n">bytes_per_line</span> <span class="o">/</span> <span class="o">*</span><span class="n">width</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">salign</span>  <span class="o">=</span> <span class="n">DMA_FRAME_SHIFT</span><span class="p">(</span><span class="n">vb_mode</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">DMA_ELEMENT_SHIFT</span> <span class="o">-</span> <span class="n">pxalign</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">incr</span>    <span class="o">=</span> <span class="n">enlarge</span> <span class="o">&lt;&lt;</span> <span class="n">salign</span><span class="p">;</span>

		<span class="n">v4l_bound_align_image</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">width</span> <span class="o">+</span> <span class="n">incr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">height</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">height</span> <span class="o">+</span> <span class="n">incr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">salign</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define subdev_call_with_sense(pcdev, dev, icd, sd, function, args...)		     \</span>
<span class="cp">({										     \</span>
<span class="cp">	struct soc_camera_sense sense = {					     \</span>
<span class="cp">		.master_clock		= pcdev-&gt;camexclk,			     \</span>
<span class="cp">		.pixel_clock_max	= 0,					     \</span>
<span class="cp">	};									     \</span>
<span class="cp">	int __ret;								     \</span>
<span class="cp">										     \</span>
<span class="cp">	if (pcdev-&gt;pdata)							     \</span>
<span class="cp">		sense.pixel_clock_max = pcdev-&gt;pdata-&gt;lclk_khz_max * 1000;	     \</span>
<span class="cp">	icd-&gt;sense = &amp;sense;							     \</span>
<span class="cp">	__ret = v4l2_subdev_call(sd, video, function, ##args);			     \</span>
<span class="cp">	icd-&gt;sense = NULL;							     \</span>
<span class="cp">										     \</span>
<span class="cp">	if (sense.flags &amp; SOCAM_SENSE_PCLK_CHANGED) {				     \</span>
<span class="cp">		if (sense.pixel_clock &gt; sense.pixel_clock_max) {		     \</span>
<span class="cp">			dev_err(dev,						     \</span>
<span class="cp">				&quot;%s: pixel clock %lu set by the camera too high!\n&quot;, \</span>
<span class="cp">				__func__, sense.pixel_clock);			     \</span>
<span class="cp">			__ret = -EINVAL;					     \</span>
<span class="cp">		}								     \</span>
<span class="cp">	}									     \</span>
<span class="cp">	__ret;									     \</span>
<span class="cp">})</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_mbus_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">v4l2_mbus_framefmt</span> <span class="o">*</span><span class="n">mf</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">soc_camera_format_xlate</span> <span class="o">*</span><span class="n">xlate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">bytes_per_line</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">subdev_call_with_sense</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">icd</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">s_mbus_fmt</span><span class="p">,</span> <span class="n">mf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: s_mbus_fmt failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">!=</span> <span class="n">xlate</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: unexpected pixel code change</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bytes_per_line</span> <span class="o">=</span> <span class="n">soc_mbus_bytes_per_line</span><span class="p">(</span><span class="n">mf</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">xlate</span><span class="o">-&gt;</span><span class="n">host_fmt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes_per_line</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: soc_mbus_bytes_per_line() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">bytes_per_line</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_dma_aligned</span><span class="p">(</span><span class="n">bytes_per_line</span><span class="p">,</span> <span class="n">mf</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: resulting geometry %ux%u not DMA aligned</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">mf</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">mf</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap1_cam_set_crop</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">v4l2_crop</span> <span class="o">*</span><span class="n">crop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_rect</span> <span class="o">*</span><span class="n">rect</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">crop</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">soc_camera_format_xlate</span> <span class="o">*</span><span class="n">xlate</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">current_fmt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">soc_camera_to_subdev</span><span class="p">(</span><span class="n">icd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_mbus_framefmt</span> <span class="n">mf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">subdev_call_with_sense</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">icd</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">s_crop</span><span class="p">,</span> <span class="n">crop</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: failed to crop to %ux%u@%u:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			 <span class="n">rect</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">rect</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span> <span class="n">rect</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">rect</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">g_mbus_fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: failed to fetch current format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dma_align</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mf</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">xlate</span><span class="o">-&gt;</span><span class="n">host_fmt</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span><span class="p">,</span>
			<span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: failed to align %ux%u %s with DMA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">mf</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">mf</span><span class="p">.</span><span class="n">height</span><span class="p">,</span>
				<span class="n">xlate</span><span class="o">-&gt;</span><span class="n">host_fmt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* sensor returned geometry not DMA aligned, trying to fix */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">set_mbus_format</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">icd</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">,</span> <span class="n">xlate</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: failed to set format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">icd</span><span class="o">-&gt;</span><span class="n">user_width</span>	 <span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
	<span class="n">icd</span><span class="o">-&gt;</span><span class="n">user_height</span> <span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap1_cam_set_fmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">soc_camera_to_subdev</span><span class="p">(</span><span class="n">icd</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">soc_camera_format_xlate</span> <span class="o">*</span><span class="n">xlate</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_pix_format</span> <span class="o">*</span><span class="n">pix</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_mbus_framefmt</span> <span class="n">mf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">xlate</span> <span class="o">=</span> <span class="n">soc_camera_xlate_by_fourcc</span><span class="p">(</span><span class="n">icd</span><span class="p">,</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">pixelformat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xlate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: format %#x not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">pix</span><span class="o">-&gt;</span><span class="n">pixelformat</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mf</span><span class="p">.</span><span class="n">width</span>	<span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">height</span>	<span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">field</span>	<span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">;</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">colorspace</span>	<span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">colorspace</span><span class="p">;</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">code</span>		<span class="o">=</span> <span class="n">xlate</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dma_align</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mf</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">xlate</span><span class="o">-&gt;</span><span class="n">host_fmt</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span><span class="p">,</span>
			<span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: failed to align %ux%u %s with DMA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span>
				<span class="n">xlate</span><span class="o">-&gt;</span><span class="n">host_fmt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">set_mbus_format</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">icd</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">,</span> <span class="n">xlate</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: failed to set format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">width</span>	 <span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">height</span>	 <span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">field</span>	 <span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">field</span><span class="p">;</span>
	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">colorspace</span>  <span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">colorspace</span><span class="p">;</span>
	<span class="n">icd</span><span class="o">-&gt;</span><span class="n">current_fmt</span> <span class="o">=</span> <span class="n">xlate</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap1_cam_try_fmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">v4l2_format</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">soc_camera_to_subdev</span><span class="p">(</span><span class="n">icd</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">soc_camera_format_xlate</span> <span class="o">*</span><span class="n">xlate</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_pix_format</span> <span class="o">*</span><span class="n">pix</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_mbus_framefmt</span> <span class="n">mf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* TODO: limit to mx1 hardware capabilities */</span>

	<span class="n">xlate</span> <span class="o">=</span> <span class="n">soc_camera_xlate_by_fourcc</span><span class="p">(</span><span class="n">icd</span><span class="p">,</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">pixelformat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xlate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="s">&quot;Format %#x not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">pix</span><span class="o">-&gt;</span><span class="n">pixelformat</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mf</span><span class="p">.</span><span class="n">width</span>	<span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">height</span>	<span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">field</span>	<span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">;</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">colorspace</span>	<span class="o">=</span> <span class="n">pix</span><span class="o">-&gt;</span><span class="n">colorspace</span><span class="p">;</span>
	<span class="n">mf</span><span class="p">.</span><span class="n">code</span>		<span class="o">=</span> <span class="n">xlate</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">;</span>

	<span class="cm">/* limit to sensor capabilities */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">try_mbus_fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">width</span>	<span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">height</span>	<span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">field</span>	<span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">field</span><span class="p">;</span>
	<span class="n">pix</span><span class="o">-&gt;</span><span class="n">colorspace</span>	<span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">colorspace</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">sg_mode</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Local mmap_mapper wrapper,</span>
<span class="cm"> * used for detecting videobuf-dma-contig buffer allocation failures</span>
<span class="cm"> * and switching to videobuf-dma-sg automatically for future attempts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap1_cam_mmap_mapper</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">videobuf_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">mmap_mapper</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
		<span class="n">sg_mode</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap1_cam_init_videobuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">videobuf_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg_mode</span><span class="p">)</span>
		<span class="n">videobuf_queue_dma_contig_init</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">omap1_videobuf_ops</span><span class="p">,</span>
				<span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span>
				<span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">,</span> <span class="n">V4L2_FIELD_NONE</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap1_cam_buf</span><span class="p">),</span> <span class="n">icd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">video_lock</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">videobuf_queue_sg_init</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">omap1_videobuf_ops</span><span class="p">,</span>
				<span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span>
				<span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">,</span> <span class="n">V4L2_FIELD_NONE</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap1_cam_buf</span><span class="p">),</span> <span class="n">icd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">video_lock</span><span class="p">);</span>

	<span class="cm">/* use videobuf mode (auto)selected with the module parameter */</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">vb_mode</span> <span class="o">=</span> <span class="n">sg_mode</span> <span class="o">?</span> <span class="n">OMAP1_CAM_DMA_SG</span> <span class="o">:</span> <span class="n">OMAP1_CAM_DMA_CONTIG</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure we substitute the videobuf-dma-contig version of the</span>
<span class="cm">	 * mmap_mapper() callback with our own wrapper, used for switching</span>
<span class="cm">	 * automatically to videobuf-dma-sg on buffer allocation failure.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg_mode</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">int_ops</span><span class="o">-&gt;</span><span class="n">mmap_mapper</span> <span class="o">!=</span> <span class="n">omap1_cam_mmap_mapper</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">mmap_mapper</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">int_ops</span><span class="o">-&gt;</span><span class="n">mmap_mapper</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">int_ops</span><span class="o">-&gt;</span><span class="n">mmap_mapper</span> <span class="o">=</span> <span class="n">omap1_cam_mmap_mapper</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap1_cam_reqbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">v4l2_requestbuffers</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is for locking debugging only. I removed spinlocks and now I</span>
<span class="cm">	 * check whether .prepare is ever called on a linked buffer, or whether</span>
<span class="cm">	 * a dma IRQ can occur for an in-work or unlinked buffer. Until now</span>
<span class="cm">	 * it hadn&#39;t triggered</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">omap1_cam_buf</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">vb_vidq</span><span class="p">.</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						      <span class="k">struct</span> <span class="n">omap1_cam_buf</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">inwork</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">queue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap1_cam_querycap</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">v4l2_capability</span> <span class="o">*</span><span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* cap-&gt;name is set by the friendly caller:-&gt; */</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="s">&quot;OMAP1 Camera&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cap</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">));</span>
	<span class="n">cap</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">=</span> <span class="n">V4L2_CAP_VIDEO_CAPTURE</span> <span class="o">|</span> <span class="n">V4L2_CAP_STREAMING</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap1_cam_set_bus_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">v4l2_subdev</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">soc_camera_to_subdev</span><span class="p">(</span><span class="n">icd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">ici</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">ici</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pixfmt</span> <span class="o">=</span> <span class="n">icd</span><span class="o">-&gt;</span><span class="n">current_fmt</span><span class="o">-&gt;</span><span class="n">host_fmt</span><span class="o">-&gt;</span><span class="n">fourcc</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">soc_camera_format_xlate</span> <span class="o">*</span><span class="n">xlate</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">soc_mbus_pixelfmt</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">v4l2_mbus_config</span> <span class="n">cfg</span> <span class="o">=</span> <span class="p">{.</span><span class="n">type</span> <span class="o">=</span> <span class="n">V4L2_MBUS_PARALLEL</span><span class="p">,};</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">common_flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrlclock</span><span class="p">,</span> <span class="n">mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">g_mbus_config</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">common_flags</span> <span class="o">=</span> <span class="n">soc_mbus_config_compatible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg</span><span class="p">,</span> <span class="n">SOCAM_BUS_FLAGS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">common_flags</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;Flags incompatible: camera 0x%x, host 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">cfg</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span> <span class="n">SOCAM_BUS_FLAGS</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">common_flags</span> <span class="o">=</span> <span class="n">SOCAM_BUS_FLAGS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make choices, possibly based on platform configuration */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">common_flags</span> <span class="o">&amp;</span> <span class="n">V4L2_MBUS_PCLK_SAMPLE_RISING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">common_flags</span> <span class="o">&amp;</span> <span class="n">V4L2_MBUS_PCLK_SAMPLE_FALLING</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">||</span>
				<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">OMAP1_CAMERA_LCLK_RISING</span><span class="p">)</span>
			<span class="n">common_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">V4L2_MBUS_PCLK_SAMPLE_FALLING</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">common_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">V4L2_MBUS_PCLK_SAMPLE_RISING</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cfg</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">common_flags</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">video</span><span class="p">,</span> <span class="n">s_mbus_config</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;camera s_mbus_config(0x%lx) returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">common_flags</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctrlclock</span> <span class="o">=</span> <span class="n">CAM_READ_CACHE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctrlclock</span> <span class="o">&amp;</span> <span class="n">LCLK_EN</span><span class="p">)</span>
		<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">,</span> <span class="n">ctrlclock</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">LCLK_EN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">common_flags</span> <span class="o">&amp;</span> <span class="n">V4L2_MBUS_PCLK_SAMPLE_RISING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;CTRLCLOCK_REG |= POLCLK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ctrlclock</span> <span class="o">|=</span> <span class="n">POLCLK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;CTRLCLOCK_REG &amp;= ~POLCLK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ctrlclock</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">POLCLK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">,</span> <span class="n">ctrlclock</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">LCLK_EN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctrlclock</span> <span class="o">&amp;</span> <span class="n">LCLK_EN</span><span class="p">)</span>
		<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">CTRLCLOCK</span><span class="p">,</span> <span class="n">ctrlclock</span><span class="p">);</span>

	<span class="cm">/* select bus endianess */</span>
	<span class="n">xlate</span> <span class="o">=</span> <span class="n">soc_camera_xlate_by_fourcc</span><span class="p">(</span><span class="n">icd</span><span class="p">,</span> <span class="n">pixfmt</span><span class="p">);</span>
	<span class="n">fmt</span> <span class="o">=</span> <span class="n">xlate</span><span class="o">-&gt;</span><span class="n">host_fmt</span><span class="p">;</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="n">CAM_READ</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">MODE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">RAZ_FIFO</span> <span class="o">|</span> <span class="n">IRQ_MASK</span> <span class="o">|</span> <span class="n">DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">==</span> <span class="n">SOC_MBUS_ORDER_LE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MODE_REG &amp;= ~ORDERCAMD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">MODE</span><span class="p">,</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ORDERCAMD</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MODE_REG |= ORDERCAMD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">CAM_WRITE</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="n">MODE</span><span class="p">,</span> <span class="n">mode</span> <span class="o">|</span> <span class="n">ORDERCAMD</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">omap1_cam_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_device</span> <span class="o">*</span><span class="n">icd</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap1_cam_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">icd</span><span class="o">-&gt;</span><span class="n">vb_vidq</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">omap1_cam_buf</span><span class="p">,</span>
			 <span class="n">vb</span><span class="p">.</span><span class="n">stream</span><span class="p">);</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">done</span><span class="p">,</span> <span class="n">pt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">VIDEOBUF_DONE</span> <span class="o">||</span>
	    <span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">VIDEOBUF_ERROR</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">soc_camera_host_ops</span> <span class="n">omap1_host_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">add</span>		<span class="o">=</span> <span class="n">omap1_cam_add_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">omap1_cam_remove_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_formats</span>	<span class="o">=</span> <span class="n">omap1_cam_get_formats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_crop</span>	<span class="o">=</span> <span class="n">omap1_cam_set_crop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_fmt</span>	<span class="o">=</span> <span class="n">omap1_cam_set_fmt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">try_fmt</span>	<span class="o">=</span> <span class="n">omap1_cam_try_fmt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_videobuf</span>	<span class="o">=</span> <span class="n">omap1_cam_init_videobuf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reqbufs</span>	<span class="o">=</span> <span class="n">omap1_cam_reqbufs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">querycap</span>	<span class="o">=</span> <span class="n">omap1_cam_querycap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_bus_param</span>	<span class="o">=</span> <span class="n">omap1_cam_set_bus_param</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">omap1_cam_poll</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">omap1_cam_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span> <span class="o">||</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">irq</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;armper_ck&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">clk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pcdev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pcdev</span><span class="p">)</span> <span class="o">+</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not allocate pcdev</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit_put_clk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="n">clk</span><span class="p">;</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">camexclk</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">camexclk_khz</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">camexclk</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">6000000</span>:
	<span class="k">case</span> <span class="mi">8000000</span>:
	<span class="k">case</span> <span class="mi">9600000</span>:
	<span class="k">case</span> <span class="mi">12000000</span>:
	<span class="k">case</span> <span class="mi">24000000</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* pcdev-&gt;camexclk != 0 =&gt; pcdev-&gt;pdata != NULL */</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Incorrect sensor clock frequency %ld kHz, &quot;</span>
				<span class="s">&quot;should be one of 0, 6, 8, 9.6, 12 or 24 MHz, &quot;</span>
				<span class="s">&quot;please correct your platform data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">camexclk_khz</span><span class="p">);</span>
		<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">camexclk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Not providing sensor clock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">capture</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Request the region.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">),</span> <span class="n">DRIVER_NAME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit_kfree</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit_release</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>

	<span class="n">sensor_reset</span><span class="p">(</span><span class="n">pcdev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">omap_request_dma</span><span class="p">(</span><span class="n">OMAP_DMA_CAMERA_IF_RX</span><span class="p">,</span> <span class="n">DRIVER_NAME</span><span class="p">,</span>
			<span class="n">dma_isr</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pcdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_ch</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t request DMA for OMAP1 Camera</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit_iounmap</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;got DMA channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_ch</span><span class="p">);</span>

	<span class="cm">/* preconfigure DMA */</span>
	<span class="n">omap_set_dma_src_params</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_ch</span><span class="p">,</span> <span class="n">OMAP_DMA_PORT_TIPB</span><span class="p">,</span>
			<span class="n">OMAP_DMA_AMODE_CONSTANT</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">REG_CAMDATA</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">omap_set_dma_dest_burst_mode</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_ch</span><span class="p">,</span> <span class="n">OMAP_DMA_DATA_BURST_4</span><span class="p">);</span>
	<span class="cm">/* setup DMA autoinitialization */</span>
	<span class="n">omap_dma_link_lch</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_ch</span><span class="p">,</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_ch</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">cam_isr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DRIVER_NAME</span><span class="p">,</span> <span class="n">pcdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Camera interrupt register failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit_free_dma</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">drv_name</span>	<span class="o">=</span> <span class="n">DRIVER_NAME</span><span class="p">;</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">omap1_host_ops</span><span class="p">;</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">priv</span>		<span class="o">=</span> <span class="n">pcdev</span><span class="p">;</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">v4l2_dev</span><span class="p">.</span><span class="n">dev</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">.</span><span class="n">nr</span>		<span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">soc_camera_host_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">soc_host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_free_irq</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;OMAP1 Camera Interface driver loaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">exit_free_irq:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">pcdev</span><span class="p">);</span>
<span class="nl">exit_free_dma:</span>
	<span class="n">omap_free_dma</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_ch</span><span class="p">);</span>
<span class="nl">exit_iounmap:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
<span class="nl">exit_release:</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
<span class="nl">exit_kfree:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>
<span class="nl">exit_put_clk:</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span>
<span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__exit</span> <span class="nf">omap1_cam_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_camera_host</span> <span class="o">*</span><span class="n">soc_host</span> <span class="o">=</span> <span class="n">to_soc_camera_host</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap1_cam_dev</span> <span class="o">*</span><span class="n">pcdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">soc_host</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">omap1_cam_dev</span><span class="p">,</span> <span class="n">soc_host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">pcdev</span><span class="p">);</span>

	<span class="n">omap_free_dma</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">dma_ch</span><span class="p">);</span>

	<span class="n">soc_camera_host_unregister</span><span class="p">(</span><span class="n">soc_host</span><span class="p">);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">;</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>

	<span class="n">clk_put</span><span class="p">(</span><span class="n">pcdev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pcdev</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;OMAP1 Camera Interface driver unloaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">omap1_cam_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="n">DRIVER_NAME</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">omap1_cam_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__exit_p</span><span class="p">(</span><span class="n">omap1_cam_remove</span><span class="p">),</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">omap1_cam_driver</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">sg_mode</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">sg_mode</span><span class="p">,</span> <span class="s">&quot;videobuf mode, 0: dma-contig (default), 1: dma-sg&quot;</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;OMAP1 Camera Interface driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Janusz Krzysztofik &lt;jkrzyszt@tis.icnet.pl&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRIVER_VERSION</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:&quot;</span> <span class="n">DRIVER_NAME</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
